00000000                            ; =========================================================================================================================================================
00000000                            ; Hedgebrew Engine (Clean, Overhauled, Enhanced S3&K Engine)
00000000                            ; =========================================================================================================================================================
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Configuration
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		include	"Config/Configuration.asm"	; Configuration
00000000                            ; =========================================================================================================================================================
00000000                            ; Configuration
00000000                            ; =========================================================================================================================================================
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; ASM68K Options
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		opt	l.				; Use "." for local labels
00000000                            		opt	ws+				; allow white spaces in operand parsing
00000000                            		opt	op+				; Optimize to PC relative addressing
00000000                            		opt	os+				; Optimize short branches
00000000                            		opt	ow+				; Optimize absolute long addressing
00000000                            		opt	oz+				; Optimize zero displacements
00000000                            		opt	oaq+				; Optimize to addq
00000000                            		opt	osq+				; Optimize to subq
00000000                            		opt	omq+				; Optimize to moveq
00000000                            		opt	ae-				; Disable automatic evens
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Required
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            GAME_NAME	equs	"Hedgebrew Engine Project                        "; International name
00000000                            IO_SUPPORT	equs	"J"				; I/O support
00000000 =20202020                  SRAM_SUPPORT	equ	$20202020			; SRAM support
00000000 =20202020                  SRAM_START	equ	$20202020			; SRAM start address
00000000 =20202020                  SRAM_END	equ	$20202020			; SRAM end address
00000000                            NOTES		equs	""; Notes
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; User defined
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =00000001                  DEBUG_BUILD	equ	1				; Debug build flag (0 = Disabled)
00000000                            ENABLE_HANDLER	equ	0|DEBUG				; Vladikcomper's error handler enable flag (0 = Disabled)
00000000 =00000000                  ENABLE_LAGMETER	equ	0				; Lag meter enable flag (0 = Disabled)
00000000 =00000001                  DEBUG		equ	DEBUG_BUILD			; Hack
00000000                            ; =========================================================================================================================================================
00000000                            
00000000                            		include	"Sound/langZ80.asm"		; Z80 Language macros
00000000                            ; MADE BY NATSUMI 2017
00000000                            
00000000                            ; DEFINE HELPERS
00000000 =00000000                  z80prg =	0		; 0 IN 68K MODE, 1 IN Z80 MODE
00000000 =00000000                  ztemp =		0		; TEMPORARY REGISTER
00000000 =00000000                  zundoc =	0		; SET TO 0 TO USE UNDOCUMENTED OPCODES
00000000 =00000001                  zchkoffs =	1		; SET TO 0 TO NOT CHECK IX/IY AND JR OFFSETS
00000000                            z80regstr	EQUS "a b c d e h l bc de hl sp af ix iy i r ixh ixl iyh iyl (bc) (de) (hl) (sp) af' (ix) (iy)"
00000000                            
00000000                            ; EASILY MAKE SECTIONS
00000000                            z80prog	macro obj
00000000                            	if narg=0
00000000                            		OBJEND
00000000                            	; magic function that fixes all the jr and djnz opcodes, along with offsets.
00000000                            	; Used for detecting illegal forward jumps
00000000                            		local lastpos
00000000                            lastpos =	*
00000000                            			local off, byte
00000000                            		rept zfuturec
00000000                            			popp off
00000000                            			popp byte
00000000                            			org zfuturepos-zfutureobj+off
00000000                            			dc.b byte
00000000                            		endr
00000000                            		org lastpos
00000000                            		POPO		; restore options
00000000                            z80prg =	0
00000000                            		MEXIT		; exit macro here
00000000                            	endif
00000000                            	PUSHO			; push options
00000000                            	OPT AE-			; automatic evens off
00000000                            	OPT AN+			; allow use of 100H instead of $100
00000000                            	OPT M-			; do not print better macro info. Comment out for large text dump.
00000000                            	OPT D-			; make sure EQU/SET do not descope local lables
00000000                            zfutureobj =	\obj
00000000                            zfuturepos =	*
00000000                            zfuturec =	0
00000000                            	if narg=1
00000000                            		OBJ \obj
00000000                            z80prg =	1
00000000                            	else
00000000                            		inform 0,"Invalid num of args!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; CREATE A LITTLE-ENDIAN Z80 ABSOLUTE ADDRESS
00000000                            z80word	macro word
00000000                            	dc.b ((\word)&$FF), ((\word)>>8&$FF)
00000000                                endm
00000000                            
00000000                            ; SAVES THE RÃˆGISTER ID TO ZTEMP
00000000                            zgetreg	macro reg, err
00000000                            	if strlen("\reg")=0
00000000                            		inform \err,"The register must not be empty!"
00000000                            		mexit
00000000                            	endif
00000000                            ztemp = instr("\z80regstr", "\reg")
00000000                            	if (ztemp<>0)&(ztemp<55)
00000000                            ztemp =		(z\reg)
00000000                            	elseif ztemp=56
00000000                            ztemp =		zbcr
00000000                            	elseif ztemp=61
00000000                            ztemp =		zder
00000000                            	elseif ztemp=66
00000000                            ztemp =		zhlr
00000000                            	elseif ztemp=71
00000000                            ztemp =		zspr
00000000                            	elseif ztemp=76
00000000                            ztemp =		zaf2
00000000                            	elseif ztemp=79
00000000                            ztemp =		zixr
00000000                            	elseif ztemp=85
00000000                            ztemp =		ziyr
00000000                            	else
00000000                            		if instr("\reg", "(ix+")<>0|instr("\reg", "(ix-")<>0
00000000                            ztemp =		zixp
00000000                            		elseif instr("\reg", "(iy+")<>0|instr("\reg", "(iy-")<>0
00000000                            ztemp =		ziyp
00000000                            		else
00000000                            ztemp =			-1
00000000                            			local a, cc, p
00000000                            a =			0
00000000                            p =			1
00000000                            d =			0
00000000                            			while a=0
00000000                            				if p>strlen("\reg")
00000000                            ztemp =					-2
00000000                            a =					1
00000000                            				else
00000000                            cc					substr p,p,"\reg"
00000000                            					if '\cc'='('
00000000                            d =						d+1
00000000                            					elseif '\cc'=')'
00000000                            d =						d-1
00000000                            					elseif ('\cc'<>' ')&('\cc'<>'	')
00000000                            						if d<1
00000000                            a =							1
00000000                            						endif
00000000                            					endif
00000000                            				endif
00000000                            p =				p+1
00000000                            			endw
00000000                            		endif
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; PLACES THE SIGNED OFFSET INTO ROM, AND QUEUES A CHECK
00000000                            zindoff	macro reg, byte
00000000                            	local off
00000000                            off	substr 4, strlen("\reg")-1, "\reg"
00000000                            	if zchkoffs
00000000                            		dc.b -(off)-1, off
00000000                            		zfuture \byte
00000000                            	else
00000000                            		dc.b \byte, off
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zjrfuture macro off, byte
00000000                            	if zchkoffs
00000000                            		dc.b -(off)-1, off
00000000                            		zfuture \byte
00000000                            	else
00000000                            		dc.b \byte, off
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; QUEUES SIGNED VALUES TO BE FIXED
00000000                            zfuture	macro byte
00000000                            zfuturec =	zfuturec+1
00000000                            		local p,v
00000000                            p =		*-2
00000000                            v =		\byte
00000000                            		pushp "\#v"
00000000                            		pushp "\#p"
00000000                                endm
00000000                            
00000000                            ; Define equates for registers
00000000 =00000000                  zb = 	0
00000000 =00000001                  zc =	1
00000000 =00000002                  zd =	2
00000000 =00000003                  ze =	3
00000000 =00000004                  zh =	4
00000000 =00000005                  zl =	5
00000000 =00000007                  za =	7
00000000 =00000008                  zbc =	8
00000000 =00000009                  zde =	9
00000000 =0000000A                  zhl =	$A
00000000 =0000000B                  zsp =	$B
00000000 =00000018                  zbcr =	$18
00000000 =00000019                  zder =	$19
00000000 =0000001A                  zhlr =	$1A
00000000 =0000001B                  zspr =	$1B
00000000 =00000020                  zix =	$20
00000000 =00000021                  ziy =	$21
00000000 =00000022                  zixr =	$22
00000000 =00000023                  ziyr =	$23
00000000 =00000024                  zixp =	$24
00000000 =00000025                  ziyp =	$25
00000000 =00000028                  zixh =	$28
00000000 =00000029                  zixl =	$29
00000000 =0000002A                  ziyh =	$2A
00000000 =0000002B                  ziyl =	$2B
00000000 =00000030                  zaf =	$30
00000000 =00000031                  zaf2 =	$31
00000000 =00000038                  zi =	$38
00000000 =00000039                  zr =	$39
00000000                            
00000000                            
00000000                            ; Define instructions
00000000                            
00000000                            db	macro val
00000000                            	dc.b \_
00000000                                endm
00000000                            
00000000                            dsb	macro num, val
00000000                            	dcb.b \_
00000000                                endm
00000000                            
00000000                            dw	macro val
00000000                            	rept narg
00000000                            		dc.b ((\val)&$FF), ((\val)>>8&$FF)
00000000                            		shift
00000000                            	endr
00000000                                endm
00000000                            
00000000                            bw	macro val
00000000                            	rept narg
00000000                            		dc.b ((\val)>>8&$FF), ((\val)&$FF)
00000000                            		shift
00000000                            	endr
00000000                                endm
00000000                            
00000000                            dsw	macro num, val
00000000                            	rept \num
00000000                            		dc.b ((\val)&$FF), ((\val)>>8&$FF)
00000000                            		shift
00000000                            	endr
00000000                                endm
00000000                            
00000000                            bsw	macro num, val
00000000                            	rept \num
00000000                            		dc.b ((\val)>>8&$FF), ((\val)&$FF)
00000000                            		shift
00000000                            	endr
00000000                                endm
00000000                            
00000000                            rlc	macro reg, reg2
00000000                            	zgetreg \reg, 0
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	if narg=2
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $00+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $00+ztemp		; rlc a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $06			; rlc (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; rlc (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $06
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; rlc (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $06
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            rrc	macro reg
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if narg=2
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $08+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $08+ztemp		; rrc a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $0E			; rrc (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; rrc (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $0E
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; rrc (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $0E
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            rl	macro reg
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if narg=2
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $10+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $10+ztemp		; rl a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $16			; rl (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; rl (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $16
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; rl (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $16
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            rr	macro reg
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if narg=2
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $18+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $18+ztemp		; rr a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $1E			; rr (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; rr (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $1E
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; rr (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $1E
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            sla	macro reg
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if narg=2
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $20+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $20+ztemp		; sla a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $26			; sla (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; sla (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $26
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; sla (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $26
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            sra	macro reg
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if narg=2
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $28+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $28+ztemp		; sra a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $2E			; sra (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; sra (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $2E
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; sra (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $2E
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            sll	macro reg
00000000                            	if zundoc
00000000                            		inform 2,"Undocumented opcodes are not enabled."
00000000                            	endif
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if narg=2
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $30+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $30+ztemp		; sll a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $36			; sll (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; sll (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $36
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; sll (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $36
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            srl	macro reg
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if narg=2
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $38+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $38+ztemp		; sra a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $3E			; sra (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; sra (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $3E
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; sra (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $3E
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            bit	macro bit, reg
00000000                            	if narg<>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	if (\bit<0)|(\bit>7)
00000000                            		inform 2,"Invalid bit '\bit'!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $40+ztemp+(\bit*$08)	; bit 0-7,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $46+(\bit*$08)	; bit 0-7,(hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; bit 0-7,(ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $46+(\bit*$08)
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; bit 0-7,(iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $46+(\bit*$08)
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            res	macro bit, reg, reg2
00000000                            	if narg>3
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	if (\bit<0)|(\bit>7)
00000000                            		inform 2,"Invalid bit '\bit'!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $80+ztemp+(\bit*$08)	; res 0-7,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $86+(\bit*$08)	; res 0-7,(hl)
00000000                            	elseif (ztemp=zixp)|(ztemp=ziyp)
00000000                            		dc.b $DD+((ztemp-zixp)*$20)	; res 0-7,(ix/iy+*),  , a, b, c, d, e, h, l
00000000                            		zindoff \reg, $CB
00000000                            		if narg=3
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			zgetreg \reg2, 0
00000000                            			if (ztemp<0)|(ztemp>za)
00000000                            				inform 2,"Invalid or unsupported register '\reg2'!"
00000000                            			endif
00000000                            		else
00000000                            ztemp =			6
00000000                            		endif
00000000                            		dc.b $80+(\bit*$08)+ztemp
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zset	macro bit, reg
00000000                            	if narg>3
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	if (\bit<0)|(\bit>7)
00000000                            		inform 2,"Invalid bit '\bit'!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $C0+ztemp+(\bit*$08)	; set 0-7,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $C6+(\bit*$08)	; set 0-7,(hl)
00000000                            	elseif (ztemp=zixp)|(ztemp=ziyp)
00000000                            		dc.b $DD+((ztemp-zixp)*$20)	; set 0-7,(ix/iy+*),  , a, b, c, d, e, h, l
00000000                            		zindoff \reg, $CB
00000000                            		if narg=3
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			zgetreg \reg2, 0
00000000                            			if (ztemp<0)|(ztemp>za)
00000000                            				inform 2,"Invalid or unsupported register '\reg2'!"
00000000                            			endif
00000000                            		else
00000000                            ztemp =			6
00000000                            		endif
00000000                            		dc.b $C0+(\bit*$08)+ztemp
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            im	macro im
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	if "\im"="0/1"
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $ED, $4E		; im 0/1
00000000                            	elseif (\im<0)|(\im>2)
00000000                            		inform 2,"Interrupt mode must only be 0, 1 or 2!"
00000000                            	elseif \im=2
00000000                            		dc.b $ED, $5E		; im 2
00000000                            	else
00000000                            		dc.b $ED, $46+(\im*$10); im 0 or 1
00000000                            	endif
00000000                                endm
00000000                            
00000000                            rst	macro addr
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	if type(\addr)&1
00000000                            		if (\addr&7)=0
00000000                            			if \addr>$48|\addr<0
00000000                            				inform 2,"Invalid address! Must be at least 0 and at most $38!"
00000000                            			endif
00000000                            		else
00000000                            			inform 2,"Address must be aligned by $8!"
00000000                            		endif
00000000                            	endif
00000000                            		dc.b $C7+\addr	; RST *
00000000                                endm
00000000                            
00000000                            inc	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 2
00000000                            	if ztemp<=za
00000000                            		dc.b $04+(ztemp*$08)		; inc a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $34			; inc (hl)
00000000                            	elseif (ztemp>=zbc)&(ztemp<=zsp)
00000000                            		dc.b $03+((ztemp-zbc)*$10)	; inc bc, de, hl or sp
00000000                            	elseif ztemp=zix
00000000                            		dc.b $DD, $23			; inc ix
00000000                            	elseif ztemp=ziy
00000000                            		dc.b $FD, $23			; inc iy
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; inc ix+
00000000                            		zindoff \reg, $34
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; inc iy+
00000000                            		zindoff \reg, $34
00000000                            	elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((ztemp&$02)*$10), $24+((ztemp&$01)*$08); inc ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            dec	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 2
00000000                            	if ztemp<=za
00000000                            		dc.b $05+(ztemp*$08)		; dec a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $35			; dec (hl)
00000000                            	elseif (ztemp>=zbc)&(ztemp<=zsp)
00000000                            		dc.b $0B+((ztemp-zbc)*$10)	; dec bc, de, hl or sp
00000000                            	elseif ztemp=zix
00000000                            		dc.b $DD, $2B			; dec ix
00000000                            	elseif ztemp=ziy
00000000                            		dc.b $FD, $2B			; dec iy
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; dec ix+
00000000                            		zindoff \reg, $35
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; dec iy+
00000000                            		zindoff \reg, $35
00000000                            	elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((ztemp&$02)*$10), $25+((ztemp&$01)*$08); dec ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zsub	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if ztemp=-1
00000000                            		dc.b $D6			; sub a,*
00000000                            		dc.b \reg
00000000                            	elseif ztemp<=za
00000000                            		dc.b $90+ztemp			; sub a,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $96			; sub a,(hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; sub a,(ix+*)
00000000                            		zindoff \reg, $96
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; sub a,(iy+*)
00000000                            		zindoff \reg, $96
00000000                            	elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((ztemp&$02)*$10), $94+(ztemp&$01); sub a,ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zand	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if ztemp=-1
00000000                            		dc.b $E6			; and a,*
00000000                            		dc.b \reg
00000000                            	elseif ztemp<=za
00000000                            		dc.b $A0+ztemp			; and a,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $A6			; and a,(hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; and a,(ix+*)
00000000                            		zindoff \reg, $A6
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; and a,(iy+*)
00000000                            		zindoff \reg, $A6
00000000                            	elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((ztemp&$02)*$10), $A4+(ztemp&$01); and a,ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zor	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if ztemp=-1
00000000                            		dc.b $F6			; or a,*
00000000                            		dc.b \reg
00000000                            	elseif ztemp<=za
00000000                            		dc.b $B0+ztemp			; or a,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $B6			; or a,(hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; or a,(ix+*)
00000000                            		zindoff \reg, $B6
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; or a,(iy+*)
00000000                            		zindoff \reg, $B6
00000000                            	elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((ztemp&$02)*$10), $B4+(ztemp&$01); or a,ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            xor	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if ztemp=-1
00000000                            		dc.b $EE			; xor a,*
00000000                            		dc.b \reg
00000000                            	elseif ztemp<=za
00000000                            		dc.b $A8+ztemp			; xor a,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $B6			; xor a,(hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; xor a,(ix+*)
00000000                            		zindoff \reg, $AE
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; xor a,(iy+*)
00000000                            		zindoff \reg, $AE
00000000                            	elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((ztemp&$02)*$10), $AC+(ztemp&$01); xor a,ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            cp	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if ztemp=-1
00000000                            		dc.b $FE			; cp a,*
00000000                            		dc.b \reg
00000000                            	elseif ztemp<=za
00000000                            		dc.b $B8+ztemp			; cp a,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $BE			; cp a,(hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; cp a,(ix+*)
00000000                            		zindoff \reg, $BE
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; cp a,(iy+*)
00000000                            		zindoff \reg, $BE
00000000                            	elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((ztemp&$02)*$10), $BC+(ztemp&$01); cp a,ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zadd	macro reg1, reg2
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg1, 0
00000000                            ztemp1 =	ztemp
00000000                            	if narg>1
00000000                            		zgetreg \reg2, 0
00000000                            	endif
00000000                            	if ((narg=1)&((ztemp<=za)|(ztemp=zhlr)|(ztemp=zixp)|(ztemp=ziyp)))|(ztemp1=za)|(ztemp1=zixp)|(ztemp1=ziyp); this complex piece of shit just checks if we omitted the a param
00000000                            		if (ztemp1=zixp)|(ztemp=zixp)
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $DD		; add a,(ix+*)
00000000                            			zindoff \reg1, $86
00000000                            		elseif (ztemp1=ziyp)|(ztemp=ziyp)
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $FD		; add a,(iy+*)
00000000                            			zindoff \reg1, $86
00000000                            		elseif ztemp=zhlr
00000000                            			dc.b $86		; add a,(hl)
00000000                            		elseif ztemp=-1
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $C6		; add a,*
00000000                            			dc.b \reg1
00000000                            		elseif ztemp<=za
00000000                            			dc.b $80+ztemp		; add a,a, b, c, d, e, h or l
00000000                            		elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			dc.b $DD+((ztemp&$02)*$10), $84+(ztemp&$01); add a,ixh, ixl, iyh, iyl
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination: a, \reg2!"
00000000                            		endif
00000000                            	elseif ((narg=1)&(ztemp>=zbc)&(ztemp<=zsp))|(ztemp1=zhl)	; this piece of shit just checks if we omitted the hl param
00000000                            		dc.b $09+((ztemp-zbc)*$10)	; add hl,bc, de, hl or sp
00000000                            	elseif ztemp1=zix
00000000                            		dc.b $DD
00000000                            		if ztemp=zbc
00000000                            			dc.b $09		; add ix,bc
00000000                            		elseif ztemp=zde
00000000                            			dc.b $19		; add ix,de
00000000                            		elseif ztemp=zix
00000000                            			dc.b $29		; add ix,ix
00000000                            		elseif ztemp=zsp
00000000                            			dc.b $39		; add ix,sp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination: ix, \reg2!"
00000000                            		endif
00000000                            	elseif ztemp1=ziy
00000000                            		dc.b $FD
00000000                            		if ztemp=zbc
00000000                            			dc.b $09		; add iy,bc
00000000                            		elseif ztemp=zde
00000000                            			dc.b $19		; add iy,de
00000000                            		elseif ztemp=ziy
00000000                            			dc.b $29		; add iy,iy
00000000                            		elseif ztemp=zsp
00000000                            			dc.b $39		; add iy,sp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination: iy, \reg2!"
00000000                            		endif
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg1'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            adc	macro reg1, reg2
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg1, 0
00000000                            ztemp1 =	ztemp
00000000                            	if narg>1
00000000                            		zgetreg \reg2, 0
00000000                            	endif
00000000                            	if ((narg=1)&((ztemp<=za)|(ztemp=zhlr)|(ztemp=zixp)|(ztemp=ziyp)))|(ztemp1=za)|(ztemp1=zixp)|(ztemp1=ziyp); this complex piece of shit just checks if we omitted the a param
00000000                            		if (ztemp1=zixp)|(ztemp=zixp)
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $DD		; adc a,(ix+*)
00000000                            			zindoff \reg1, $8E
00000000                            		elseif (ztemp1=ziyp)|(ztemp=ziyp)
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $FD		; adc a,(iy+*)
00000000                            			zindoff \reg1, $8E
00000000                            		elseif ztemp=zhlr
00000000                            			dc.b $8E		; adc a,(hl)
00000000                            		elseif ztemp=-1
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $CE		; adc a,*
00000000                            			dc.b \reg1
00000000                            		elseif ztemp<=za
00000000                            			dc.b $88+ztemp		; adc a,a, b, c, d, e, h or l
00000000                            		elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			dc.b $DD+((ztemp&$02)*$10), $8C+(ztemp&$01); adc a,ixh, ixl, iyh, iyl
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination: a, \reg2!"
00000000                            		endif
00000000                            	elseif ((narg=1)&(ztemp>=zbc)&(ztemp<=zsp))|(ztemp1=zhl)	; this piece of shit just checks if we omitted the hl param
00000000                            		dc.b $ED, $4A+((ztemp-zbc)*$10)	; adc hl,bc, de, hl or sp
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg1'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            sbc	macro reg1, reg2
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg1, 0
00000000                            ztemp1 =	ztemp
00000000                            	if narg>1
00000000                            		zgetreg \reg2, 0
00000000                            	endif
00000000                            	if ((narg=1)&((ztemp<=za)|(ztemp=zhlr)|(ztemp=zixp)|(ztemp=ziyp)))|(ztemp1=za)|(ztemp1=zixp)|(ztemp1=ziyp); this complex piece of shit just checks if we omitted the a param
00000000                            		if (ztemp1=zixp)|(ztemp=zixp)
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $DD		; sbc a,(ix+*)
00000000                            			zindoff \reg1, $9E
00000000                            		elseif (ztemp1=ziyp)|(ztemp=ziyp)
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $FD		; sbc a,(iy+*)
00000000                            			zindoff \reg1, $9E
00000000                            		elseif ztemp=zhlr
00000000                            			dc.b $9E		; sbc a,(hl)
00000000                            		elseif ztemp=-1
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $DE		; sbc a,*
00000000                            			dc.b \reg1
00000000                            		elseif ztemp<=za
00000000                            			dc.b $98+ztemp		; sbc a,a, b, c, d, e, h or l
00000000                            		elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			dc.b $DD+((ztemp&$02)*$10), $9C+(ztemp&$01); sbc a,ixh, ixl, iyh, iyl
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination: a, \reg2!"
00000000                            		endif
00000000                            	elseif ((narg=1)&(ztemp>=zbc)&(ztemp<=zsp))|(ztemp1=zhl)	; this piece of shit just checks if we omitted the hl param
00000000                            		dc.b $ED, $42+((ztemp-zbc)*$10)	; sbc hl,bc, de, hl or sp
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg1'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zpop	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 2
00000000                            	if (ztemp>=zbc)&(ztemp<=zhl)
00000000                            		dc.b $C1+((ztemp-zbc)*$10); pop bc, de or hl
00000000                            	elseif ztemp=zaf
00000000                            		dc.b $F1		; pop af
00000000                            	elseif ztemp=zix
00000000                            		dc.b $DD, $E1		; pop ix
00000000                            	elseif ztemp=ziy
00000000                            		dc.b $FD, $E1		; pop iy
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zpush	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 2
00000000                            	if (ztemp>=zbc)&(ztemp<=zhl)
00000000                            		dc.b $C5+((ztemp-zbc)*$10); pop bc, de or hl
00000000                            	elseif ztemp=zaf
00000000                            		dc.b $F5		; pop af
00000000                            	elseif ztemp=zix
00000000                            		dc.b $DD, $E5		; pop ix
00000000                            	elseif ztemp=ziy
00000000                            		dc.b $FD, $E5		; pop iy
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ex	macro reg1, reg2
00000000                            	if narg<>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg1, 0
00000000                            zreg1 =	ztemp
00000000                            	zgetreg \reg2, 0
00000000                            	if ((zreg1=zaf)|(zreg1=zaf2))&((ztemp=zaf)|(ztemp=zaf2))
00000000                            		dc.b $08			; ex af,af' & ex af',af & ex af,af
00000000                            	elseif ((zreg1=zde)|(zreg1=zhl))&((ztemp=zde)|(ztemp=zhl))
00000000                            		dc.b $EB			; ex de,hl & ex hl,de
00000000                            	elseif ((zreg1=zspr)|(zreg1=zhl))&((ztemp=zspr)|(ztemp=zhl))
00000000                            		dc.b $E3			; ex (sp),hl & ex hl,(sp)
00000000                            	elseif ((zreg1=zix)|(zreg1=zspr))&((ztemp=zix)|(ztemp=zspr))
00000000                            		dc.b $DD,$E3			; ex (sp),ix & ex ix,(sp)
00000000                            	elseif ((zreg1=ziy)|(zreg1=zspr))&((ztemp=ziy)|(ztemp=zspr))
00000000                            		dc.b $FD,$E3			; ex (sp),iy & ex iy,(sp)
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register combination '\reg1' and '\reg2'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            out	macro port, reg
00000000                            	if narg<>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if instr("\port", "(c)")<>0
00000000                            		if (ztemp=-1)&(instr("\port", "0")<>0)
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			dc.b $ED, $71		; out (c),0
00000000                            		elseif ztemp<=za
00000000                            			dc.b $ED, $41+(ztemp*$08)		; out (c),a, b, c, d, e, h or l
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register '\reg'!"
00000000                            		endif
00000000                            	elseif ztemp=za
00000000                            		dc.b $D3, \port		; out (*),a
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported port '\port'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            in	macro reg, port
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if instr("\port", "(c)")<>0
00000000                            		if narg=1
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			dc.b $ED, $70		; in (c)
00000000                            		elseif ztemp<=za
00000000                            			dc.b $ED, $40+(ztemp*$08)		; in a, b, c, d, e, h or l,(c)
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register '\reg'!"
00000000                            		endif
00000000                            	elseif ztemp=za
00000000                            		dc.b $D3, \port		; in a,(*)
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported port '\port'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ld	macro reg1, reg2
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg1, 0
00000000                            zreg1 =	ztemp
00000000                            	zgetreg \reg2, 0
00000000                            zreg2 =	ztemp
00000000                            	if zreg1=-2
00000000                            		if zreg2=za
00000000                            			dc.b $32			; ld (**),a
00000000                            			z80word \reg1
00000000                            		elseif zreg2=zhl
00000000                            			dc.b $22			; ld (**),hl
00000000                            			z80word \reg1
00000000                            		elseif (zreg2>=zbc)&(zreg2<=zsp)
00000000                            			dc.b $ED, $43+((zreg2-zbc)*$10)	; ld (**),bc, de, sp
00000000                            			z80word \reg1
00000000                            		elseif zreg2=zix
00000000                            			dc.b $DD, $22			; ld (**),ix
00000000                            			z80word \reg1
00000000                            		elseif zreg2=ziy
00000000                            			dc.b $FD, $22			; ld (**),iy
00000000                            			z80word \reg1
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg1' and '\reg2'!"
00000000                            		endif
00000000                            	elseif zreg2=-1
00000000                            		if (zreg1<=za)
00000000                            			dc.b $06+(zreg1*$08), \reg2	; ld a, b, c, d, e, h or l,*
00000000                            		elseif zreg1=zhlr
00000000                            			dc.b $36, \reg2			; ld (hl),*
00000000                            		elseif (zreg1>=zbc)&(zreg1<=zsp)
00000000                            			dc.b $01+((zreg1-zbc)*$10)	; ld bc, de, hl, sp,**
00000000                            			z80word \reg2
00000000                            		elseif zreg1=zix
00000000                            			dc.b $DD, $21			; ld ix,**
00000000                            			z80word \reg2
00000000                            		elseif zreg1=ziy
00000000                            			dc.b $FD, $21			; ld iy,**
00000000                            			z80word \reg2
00000000                            		elseif zreg1=zixp
00000000                            			dc.b $DD			; ld (ix+*),*
00000000                            			zindoff \reg1, $36
00000000                            			dc.b \reg2
00000000                            		elseif zreg1=ziyp
00000000                            			dc.b $FD			; ld (iy+*),*
00000000                            			zindoff \reg1, $36
00000000                            			dc.b \reg2
00000000                            		elseif (zreg1>=zixh)&(zreg1<=ziyl)
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			dc.b $DD+((zreg1&$02)*$10), $26+((zreg1&$01)*$08), \reg2; ld ixh, ixl, iyh, iyl,*
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg1' and '\reg2'!"
00000000                            		endif
00000000                            	elseif zreg2=-2
00000000                            		if (zreg1=za)
00000000                            			dc.b $3A			; ld a,(**)
00000000                            			z80word \reg2
00000000                            		elseif zreg1=zhl
00000000                            			dc.b $2A			; ld hl,(**)
00000000                            			z80word \reg2
00000000                            		elseif (zreg1>=zbc)&(zreg1<=zsp)
00000000                            			dc.b $ED, $4B+((zreg1-zbc)*$10)	; ld bc, de, hl, sp,(**)
00000000                            			z80word \reg2
00000000                            		elseif zreg1=zix
00000000                            			dc.b $DD, $2A			; ld ix,(**)
00000000                            			z80word \reg2
00000000                            		elseif zreg1=ziy
00000000                            			dc.b $FD, $2A			; ld iy,(**)
00000000                            			z80word \reg2
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg1' and '\reg2'!"
00000000                            		endif
00000000                            	elseif (zreg1<=za)&(zreg2<=za)
00000000                            		dc.b $40+(zreg1*$08)+zreg2		; ld a, b, c, d, e, h or l,a, b, c, d, e, h or l
00000000                            	elseif (zreg1=za)&(zreg2=zbcr)
00000000                            		dc.b $0A				; ld a,(bc)
00000000                            	elseif (zreg1=za)&(zreg2=zder)
00000000                            		dc.b $1A				; ld a,(de)
00000000                            	elseif (zreg1<=za)&(zreg2=zhlr)
00000000                            		dc.b $46+(zreg1*$08)			; ld a, b, c, d, e, h or l,(hl)
00000000                            	elseif (zreg1=zhlr)&(zreg2<=za)
00000000                            		dc.b $70+zreg2				; ld (hl),a, b, c, d, e, h or l
00000000                            	elseif (zreg1<=za)&(zreg2=zixp)
00000000                            		dc.b $DD				; ld a, b, c, d, e, h or l,(ix+*)
00000000                            		zindoff \reg2, $46+(zreg1*$08)
00000000                            	elseif (zreg1<=za)&(zreg2=ziyp)
00000000                            		dc.b $FD				; ld a, b, c, d, e, h or l,(iy+*)
00000000                            		zindoff \reg2, $46+(zreg1*$08)
00000000                            	elseif (zreg2<=za)&(zreg1=zixp)
00000000                            		dc.b $DD				; ld (ix+*),a, b, c, d, e, h or l
00000000                            		zindoff \reg1, $70+zreg2
00000000                            	elseif (zreg2<=za)&(zreg1=ziyp)
00000000                            		dc.b $FD				; ld (iy+*),a, b, c, d, e, h or l
00000000                            		zindoff \reg1, $70+zreg2
00000000                            	elseif (zreg1=zbcr)&(zreg2=za)
00000000                            		dc.b $02				; ld (bc),a
00000000                            	elseif (zreg1=zder)&(zreg2=za)
00000000                            		dc.b $12				; ld (de),a
00000000                            	elseif (zreg1=zsp)&(zreg2=zhl)
00000000                            		dc.b $F9				; ld sp,hl
00000000                            	elseif (zreg1=zi)&(zreg2=za)
00000000                            		dc.b $ED, $47				; ld i,a
00000000                            	elseif (zreg2=zi)&(zreg1=za)
00000000                            		dc.b $ED, $57				; ld a,i
00000000                            	elseif (zreg1=zr)&(zreg2=za)
00000000                            		dc.b $ED, $4F				; ld r,a
00000000                            	elseif (zreg2=zr)&(zreg1=za)
00000000                            		dc.b $ED, $5F				; ld a,r
00000000                            	elseif (zreg1=zsp)&(zreg2=zix)
00000000                            		dc.b $DD, $F9				; ld sp, ix
00000000                            	elseif (zreg1=zsp)&(zreg2=ziy)
00000000                            		dc.b $FD, $F9				; ld sp, iy
00000000                            	elseif (zreg1>=zixh)&(zreg1<=ziyl)&((zreg2<=za)&(zreg2<>zh)&(zreg2<>zl))
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((zreg1&$02)*$10), $60+((zreg1&$01)*$08)+zreg2; ld ixh, ixl, iyh, iyl,a, b, c, d, e
00000000                            	elseif (zreg2>=zixh)&(zreg2<=ziyl)&((zreg1<=za)&(zreg1<>zh)&(zreg1<>zl))
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((zreg2&$02)*$10), $44+(zreg2&$01)+(zreg1*$08); ld a, b, c, d, e,ixh, ixl, iyh, iyl
00000000                            	elseif (zreg1>=zixh)&(zreg1<=ziyl)&(zreg2>=zixh)&(zreg2>=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if ((zreg1&$02)<>(zreg2&$02))
00000000                            			inform 2,"Invalid or unsupported register combination '\reg1' and '\reg2'!"
00000000                            			mexit
00000000                            		endif
00000000                            		dc.b $DD+((zreg1&$02)*$10), $60+((zreg1&$01)*$08)+(zreg2&$01); ld ixh, ixl, iyh, iyl,ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register combination '\reg1' and '\reg2'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            djnz	macro addr
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	zjrfuture \addr-*-2, $10
00000000                                endm
00000000                            
00000000                            jr	macro cond, off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	if narg=1
00000000                            		zjrfuture \cond-*-2, $18
00000000                            	else
00000000                            		jr\cond \off
00000000                            	endif
00000000                                endm
00000000                            
00000000                            jrnz	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	zjrfuture \off-*-2, $20
00000000                                endm
00000000                            
00000000                            jrnc	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	zjrfuture \off-*-2, $30
00000000                                endm
00000000                            
00000000                            jrz	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	zjrfuture \off-*-2, $28
00000000                                endm
00000000                            
00000000                            jrc	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	zjrfuture \off-*-2, $38
00000000                                endm
00000000                            
00000000                            jp	macro cond, off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	if narg=1
00000000                            		zgetreg \cond, 0
00000000                            		if ztemp=zhlr
00000000                            			dc.b $E9		; jp (hl)
00000000                            		elseif ztemp=zixr
00000000                            			dc.b $DD, $E9		; jp (ix)
00000000                            		elseif ztemp=ziyr
00000000                            			dc.b $FD, $E9		; jp (iy)
00000000                            		else
00000000                            			dc.b $C3		; jp **
00000000                            			z80word \cond
00000000                            		endif
00000000                            	else
00000000                            		jp\cond \off
00000000                            	endif
00000000                                endm
00000000                            
00000000                            jpnz	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $C2
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            jpnc	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $D2
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            jpz	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $CA
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            jpc	macro off
00000000                            	dc.b $DA
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            jppo	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $E2
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            jpp	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $F2
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            jppe	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $EA
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            jpm	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $FA
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            call	macro cond, off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	if narg=1
00000000                            		dc.b $CD
00000000                            		z80word \cond
00000000                            	else
00000000                            		call\cond \off
00000000                            	endif
00000000                                endm
00000000                            
00000000                            callnz	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $C4
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            callz	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $CC
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            callnc	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $D4
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            callc	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $DC
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            callpo	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $E4
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            callpe	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $EC
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            callp	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $F4
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            callm	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $FC
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            ret	macro cond
00000000                            	if narg=0
00000000                            		dc.b $C9
00000000                            	else
00000000                            		ret\cond
00000000                            	endif
00000000                                endm
00000000                            
00000000                            retnz	macro
00000000                            	dc.b $C0
00000000                                endm
00000000                            
00000000                            retz	macro
00000000                            	dc.b $C8
00000000                                endm
00000000                            
00000000                            retnc	macro
00000000                            	dc.b $D0
00000000                                endm
00000000                            
00000000                            retc	macro
00000000                            	dc.b $D8
00000000                                endm
00000000                            
00000000                            retpo	macro
00000000                            	dc.b $E0
00000000                                endm
00000000                            
00000000                            retpe	macro
00000000                            	dc.b $E8
00000000                                endm
00000000                            
00000000                            retp	macro
00000000                            	dc.b $F0
00000000                                endm
00000000                            
00000000                            retm	macro
00000000                            	dc.b $F8
00000000                                endm
00000000                            
00000000                            di	macro
00000000                            	if z80prg=0
00000000                            		move	#$2700,sr	; THIS IS HERE, IF YOU WANNA USE DI IN 68K CODE ;)
00000000                            	else
00000000                            		dc.b $F3
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ei	macro
00000000                            	if z80prg=0
00000000                            		move	#$2300,sr	; THIS IS HERE, IF YOU WANNA USE EI IN 68K CODE ;)
00000000                            	else
00000000                            		dc.b $FB
00000000                            	endif
00000000                                endm
00000000                            
00000000                            halt	macro
00000000                            	if z80prg=0
00000000                            		stop	#$2700		; THIS IS HERE, IF YOU WANNA USE HALT IN 68K CODE ;)
00000000                            	else
00000000                            		dc.b $76
00000000                            	endif
00000000                                endm
00000000                            
00000000                            znop	macro
00000000                            	dc.b $00
00000000                                endm
00000000                            
00000000                            rlca	macro
00000000                            	dc.b $07
00000000                                endm
00000000                            
00000000                            rla	macro
00000000                            	dc.b $17
00000000                                endm
00000000                            
00000000                            daa	macro
00000000                            	dc.b $27
00000000                                endm
00000000                            
00000000                            scf	macro
00000000                            	dc.b $37
00000000                                endm
00000000                            
00000000                            rrca	macro
00000000                            	dc.b $0F
00000000                                endm
00000000                            
00000000                            rra	macro
00000000                            	dc.b $1F
00000000                                endm
00000000                            
00000000                            cpl	macro
00000000                            	dc.b $2F
00000000                                endm
00000000                            
00000000                            ccf	macro
00000000                            	dc.b $3F
00000000                                endm
00000000                            
00000000                            exx	macro
00000000                            	dc.b $D9
00000000                                endm
00000000                            
00000000                            zneg	macro
00000000                            	dc.b $ED, $44
00000000                                endm
00000000                            
00000000                            retn	macro
00000000                            	dc.b $ED, $45
00000000                                endm
00000000                            
00000000                            reti	macro
00000000                            	dc.b $ED, $4D
00000000                                endm
00000000                            
00000000                            rrd	macro
00000000                            	dc.b $ED, $67
00000000                                endm
00000000                            
00000000                            rld	macro
00000000                            	dc.b $ED, $6F
00000000                                endm
00000000                            
00000000                            ldi	macro
00000000                            	dc.b $ED, $A0
00000000                                endm
00000000                            
00000000                            cpi	macro
00000000                            	dc.b $ED, $A1
00000000                                endm
00000000                            
00000000                            ini	macro
00000000                            	dc.b $ED, $A2
00000000                                endm
00000000                            
00000000                            outi	macro
00000000                            	dc.b $ED, $A3
00000000                                endm
00000000                            
00000000                            ldd	macro
00000000                            	dc.b $ED, $A8
00000000                                endm
00000000                            
00000000                            cpd	macro
00000000                            	dc.b $ED, $A9
00000000                                endm
00000000                            
00000000                            ind	macro
00000000                            	dc.b $ED, $AA
00000000                                endm
00000000                            
00000000                            outd	macro
00000000                            	dc.b $ED, $AB
00000000                                endm
00000000                            
00000000                            ldir	macro
00000000                            	dc.b $ED, $B0
00000000                                endm
00000000                            
00000000                            cpir	macro
00000000                            	dc.b $ED, $B1
00000000                                endm
00000000                            
00000000                            inir	macro
00000000                            	dc.b $ED, $B2
00000000                                endm
00000000                            
00000000                            otir	macro
00000000                            	dc.b $ED, $B3
00000000                                endm
00000000                            
00000000                            lddr	macro
00000000                            	dc.b $ED, $B8
00000000                                endm
00000000                            
00000000                            cpdr	macro
00000000                            	dc.b $ED, $B9
00000000                                endm
00000000                            
00000000                            indr	macro
00000000                            	dc.b $ED, $BA
00000000                                endm
00000000                            
00000000                            otdr	macro
00000000                            	dc.b $ED, $BB
00000000                                endm
00000000                            		include	"Sound/amps/code/macro.asm"	; AMPS macros
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Various assembly flags
00000000                            ; ---------------------------------------------------------------------------
00000000                            	opt ae+
00000000                            
00000000                            ; if safe mode is enabled (1), then the driver will attempt to find any issues.
00000000                            ; if Vladik's error debugger is installed, then the error will be displayed.
00000000                            ; else, the CPU is trapped.
00000000                            
00000000 =00000001                  safe =	DEBUG
00000000                            
00000000                            ; Select the tempo algorith.
00000000                            ; 0 = Overflow method.
00000000                            ; 1 = Counter method.
00000000                            
00000000 =00000000                  tempo =	0
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Channel configuration
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset 0
00000000 =00000000                  cFlags		rs.b 1		; various channel flags, see below
00000000 =00000001                  cType		rs.b 1		; hardware type for the channel
00000000 =00000002                  cData		rs.l 1		; 68k tracker address for the channel
00000000 =00000006                  cPanning	rs.b 0		; channel panning and LFO. FM and DAC only
00000000 =00000006                  cEnvPos		rs.b 1		; volume envelope position. PSG only
00000000 =00000007                  cDetune		rs.b 1		; frequency detune (offset)
00000000 =00000008                  cPitch		rs.b 1		; pitch (transposition) offset
00000000 =00000009                  cVolume		rs.b 1		; channel volume
00000000 =0000000A                  cTick		rs.b 1		; channel tick multiplier
00000000 =0000000B                  cSample		rs.b 0		; channel sample ID, DAC only
00000000 =0000000B                  cVolEnv		rs.b 0		; volume envelope ID. PSG only
00000000 =0000000B                  cVoice		rs.b 1		; YM2612 voice ID. FM only
00000000 =0000000C                  cDuration	rs.b 1		; current note duration
00000000 =0000000D                  cLastDur	rs.b 1		; last note duration
00000000 =0000000E                  cFreq		rs.w 1		; channel base frequency
00000000 =00000010                  cModDelay	rs.b 0		; delay before modulation starts
00000000 =00000010                  cMod		rs.l 1		; modulation data address
00000000 =00000014                  cModFreq	rs.w 1		; modulation frequency offset
00000000 =00000016                  cModSpeed	rs.b 1		; number of frames til next modulation step
00000000 =00000017                  cModStep	rs.b 1		; modulation frequency offset per step
00000000 =00000018                  cModCount	rs.b 1		; number of modulation steps until reversal
00000000 =00000019                  cLoop		rs.b 3		; loop counter values
00000000 =0000001B                  cStatPSG4 =	__rs-1		; PSG4 type value. PSG3 only
00000000 =0000001A                  cPrio =		__rs-2		; sound effect channel priority. SFX only
00000000 =0000001C                  cSizeSFX	rs.w 0		; size of each SFX track
00000000                            
00000000 =0000001C                  cNoteTimeCur	rs.b 1		; frame counter to note off. Music only
00000000 =0000001D                  cNoteTimeMain	rs.b 1		; copy of frame counter to note off. Music only
00000000 =0000001E                  cStack		rs.b 1		; channel stack pointer. Music only
00000000                            		rs.b 1		; unused. Music only
00000000                            		rs.l 3		; channel stack data. Music only
00000000 =0000002C                  cSize		rs.w 0		; size of each music track
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Bits for cFlags
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset 0
00000000 =00000000                  cfbMode		rs.b 0		; set if in pitch mode, clear if in sample mode. DAC only
00000000 =00000000                  cfbRest		rs.b 1		; set if channel is resting. FM and PSG only
00000000 =00000001                  cfbInt		rs.b 1		; set if interrupted by SFX. Music only
00000000 =00000002                  cfbHold		rs.b 1		; set if playing notes does not trigger note-on's
00000000 =00000003                  cfbMod		rs.b 1		; set if modulation is enabled
00000000 =00000004                  cfbCond		rs.b 1		; set if ignoring many tracker commands
00000000 =00000005                  cfbVol		rs.b 1		; set if channel should update volume
00000000 =00000007                  cfbRun =	$07		; set if channel is running a tracker
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Misc variables for channel modes
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000 =00000002                  ctbPt2 =	$02		; bit part 2 - FM 4-6
00000000 =00000000                  ctFM1 =		$00		; FM 1
00000000 =00000001                  ctFM2 =		$01		; FM 2
00000000 =00000002                  ctFM3 =		$02		; FM 3	- Valid for SFX
00000000 =00000004                  ctFM4 =		$04		; FM 4	- Valid for SFX
00000000 =00000005                  ctFM5 =		$05		; FM 5	- Valid for SFX
00000000                            
00000000 =00000003                  ctbDAC =	$03		; DAC bit
00000000 =0000000B                  ctDAC1 =	(1<<ctbDAC)|$03	; DAC 1	- Valid for SFX
00000000 =0000000E                  ctDAC2 =	(1<<ctbDAC)|$06	; DAC 2
00000000                            
00000000 =00000080                  ctPSG1 =	$80		; PSG 1	- Valid for SFX
00000000 =000000A0                  ctPSG2 =	$A0		; PSG 2	- Valid for SFX
00000000 =000000C0                  ctPSG3 =	$C0		; PSG 3	- Valid for SFX
00000000 =000000E0                  ctPSG4 =	$E0		; PSG 4
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Misc flags
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000 =00000002                  Mus_DAC =	2		; number of DAC channels
00000000 =00000005                  Mus_FM =	5		; number of FM channels
00000000 =00000003                  Mus_PSG =	3		; number of PSG channels
00000000 =0000000A                  Mus_Ch =	Mus_DAC+Mus_FM+Mus_PSG; total number of music channels
00000000 =00000001                  SFX_DAC =	1		; number of DAC SFX channels
00000000 =00000003                  SFX_FM =	3		; number of FM SFX channels
00000000 =00000003                  SFX_PSG =	3		; number of PSG SFX channels
00000000 =00000007                  SFX_Ch =	SFX_DAC+SFX_FM+SFX_PSG; total number of SFX channels
00000000                            
00000000 =0000001D                  VoiceRegs =	29		; total number of registers inside of a voice
00000000 =00000019                  VoiceTL =	VoiceRegs-4	; location of voice TL levels
00000000                            
00000000 =00001000                  MaxPitch =	$1000		; this is the maximum pitch Dual PCM is capable of processing
00000000 =00000018                  Z80E_Read =	$00018		; this is used by Dual PCM internally but we need this for macros
00000000                            
00000000                            ; NOTE: There is no magic trick to making Dual PCM play samples at higher rates.
00000000                            ; These values are only here to allow you to give lower pitch samples higher
00000000                            ; quality, and playing samples at higher rates than Dual PCM can process them
00000000                            ; may decrease the perceived quality by the end user. Use these equates only
00000000                            ; if you know what you are doing.
00000000                            
00000000 =00000140                  sr17 =		$0140		; 5 Quarter sample rate	17500 Hz
00000000 =00000120                  sr15 =		$0120		; 9 Eights sample rate	15750 Hz
00000000 =00000100                  sr14 =		$0100		; Default sample rate	14000 Hz
00000000 =000000E0                  sr12 =		$00E0		; 7 Eights sample rate	12250 Hz
00000000 =000000C0                  sr10 =		$00C0		; 3 Quarter sample rate	10500 Hz
00000000 =000000A0                  sr8 =		$00A0		; 5 Eights sample rate	8750 Hz
00000000 =00000080                  sr7 =		$0080		; Half sample rate	7000 HZ
00000000 =00000060                  sr5 =		$0060		; 3 Eights sample rate	5250 Hz
00000000 =00000040                  sr3 =		$0040		; 1 Quarter sample rate	3500 Hz
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Sound driver RAM configuration
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000 =00A00000                  dZ80 =		$A00000		; quick reference to Z80 RAM
00000000 =00C00011                  dPSG =		$C00011		; quick reference to PSG port
00000000                            
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Bits for mFlags
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset 0
00000000 =00000000                  mfbRing		rs.b 1		; if set, change speaker (play different sfx)
00000000 =00000001                  mfbSpeed	rs.b 1		; if set, speed shoes are active
00000000 =00000002                  mfbWater	rs.b 1		; if set, underwater mode is active
00000000 =00000003                  mfbNoPAL	rs.b 1		; if set, play songs slowly in PAL region
00000000 =00000007                  mfbPaused =	$07		; if set, sound driver is paused
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Sound ID equates
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset 1
00000000 =00000001                  Mus_Reset	rs.b 1		; reset underwater and speed shoes flags, update volume
00000000 =00000002                  Mus_FadeOut	rs.b 1		; initialize a music fade out
00000000 =00000003                  Mus_Stop	rs.b 1		; stop all music
00000000 =00000004                  Mus_ShoesOn	rs.b 1		; enable speed shoes mode
00000000 =00000005                  Mus_ShoesOff	rs.b 1		; disable speed shoes mode
00000000 =00000006                  Mus_ToWater	rs.b 1		; enable underwater mode
00000000 =00000007                  Mus_OutWater	rs.b 1		; disable underwater mode
00000000 =00000008                  Mus_Pause	rs.b 1		; pause the music
00000000 =00000009                  Mus_Unpause	rs.b 1		; unpause the music
00000000 =0000000A                  MusOff		rs.b 0		; first music ID
00000000                            
00000000 =00000078                  MusCount =	$78		; number of installed music tracks
00000000 =00000082                  SFXoff =	MusCount+MusOff	; first SFX ID
00000000 =00000078                  SFXcount =	$78		; number of intalled sound effects
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Condition modes
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset 0
00000000 =00000000                  dcoT		rs.b 1		; condition T	; True
00000000 =00000001                  dcoF		rs.b 1		; condition F	; False
00000000 =00000002                  dcoHI		rs.b 1		; condition HI	; HIgher (unsigned)
00000000 =00000003                  dcoLS		rs.b 1		; condition LS	; Less or Same (unsigned)
00000000 =00000004                  dcoHS		rs.b 0		; condition HS	; Higher or Sane (unsigned)
00000000 =00000004                  dcoCC		rs.b 1		; condition CC	; Carry Clear (unsigned)
00000000 =00000005                  dcoLO		rs.b 0		; condition LO	; LOwer (unsigned)
00000000 =00000005                  dcoCS		rs.b 1		; condition CS	; Carry Set (unsigned)
00000000 =00000006                  dcoNE		rs.b 1		; condition NE	; Not Equal
00000000 =00000007                  dcoEQ		rs.b 1		; condition EQ	; EQual
00000000 =00000008                  dcoVC		rs.b 1		; condition VC	; oVerflow Clear (signed)
00000000 =00000009                  dcoVS		rs.b 1		; condition VS	; oVerflow Set (signed)
00000000 =0000000A                  dcoPL		rs.b 1		; condition PL	; Positive (PLus)
00000000 =0000000B                  dcoMI		rs.b 1		; condition MI	; Negamite (MInus)
00000000 =0000000C                  dcoGE		rs.b 1		; condition GE	; Greater or Equal (signed)
00000000 =0000000D                  dcoLT		rs.b 1		; condition LT	; Less Than (signed)
00000000 =0000000E                  dcoGT		rs.b 1		; condition GT	; GreaTer (signed)
00000000 =0000000F                  dcoLE		rs.b 1		; condition LE	; Less or Equal (signed)
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Emvelope commands equates
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset $80
00000000 =00000080                  eReset		rs.w 1		; 80 - Restart from position 0
00000000 =00000082                  eHold		rs.w 1		; 82 - Hold volume at current level
00000000 =00000084                  eLoop		rs.w 1		; 84 - Jump back/forwards according to next byte
00000000 =00000086                  eStop		rs.w 1		; 86 - Stop current note and envelope
00000000 =00000088                  eLast		rs.w 0		; safe mode equate
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Fade out end commands
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset $80
00000000 =00000080                  fEnd		rs.l 1		; 80 - Do nothing
00000000 =00000084                  fStop		rs.l 1		; 84 - Stop all music
00000000 =00000088                  fResVol		rs.l 1		; 88 - Reset volume and update
00000000 =0000008C                  fReset		rs.l 1		; 8C - Stop music playing and reset volume
00000000 =00000090                  fLast		rs.l 0		; safe mode equate
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Quickly read a word from odd address. 28 cycles
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            dREAD_WORD	macro areg, dreg
00000000                            	move.b	(\areg)+,(sp)		; read the next byte into stack
00000000                            	move.w	(sp),\dreg		; get word back from stack (shift byte by 8 bits)
00000000                            	move.b	(\areg),\dreg		; get the next byte into register
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; used to calculate the address of the right FM voice
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            dCALC_VOICE	macro off
00000000                            	lsl.w	#5,d0			; multiply voice ID by $20
00000000                            	if narg>0
00000000                            		add.w	#\off,d0	; if have had extra argument, add it to offset
00000000                            	endif
00000000                            	add.w	d0,a1			; add offset to voice table address
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Tells the Z80 to stop, and waits for it to finish stopping (acquire bus)
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            ;stopZ80 	macro
00000000                            ;	move.w	#$100,$A11100		; stop the Z80
00000000                            ;.loop\@
00000000                            ;	btst	#0,$A11100
00000000                            ;	bne.s	.loop\@			; loop until it says it's stopped
00000000                            ;    endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Tells the Z80 to start again
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            ;startZ80 	macro
00000000                            ;	move.w	#0,$A11100		; start the Z80
00000000                            ;    endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Macro for pausing music
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            AMPS_MUSPAUSE	macro	; enable request pause and paused flags
00000000                            	move.b	#Mus_Pause,mQueue+2.w
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Macro for unpausing music
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            AMPS_MUSUNPAUSE	macro	; enable request unpause flag
00000000                            	move.b	#Mus_Unpause,mQueue+2.w
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Macro for queueing sound
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            playSnd	macro id, queue	; queue sound
00000000                            	move.b	\id,(mQueue+((\queue\)-1)).w
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Create volume envelope table, and SMPS2ASM equates
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            volenv		macro name
00000000                            	rept narg			; repeate for all arguments
00000000                            v\name =	__venv			; create SMPS2ASM equate
00000000                            		dc.l vd\name		; create pointer
00000000                            __venv =	__venv+1		; increase ID
00000000                            	shift				; shift next argument into view
00000000                            	endr
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Creates SFX pointers table, and creates necessary equates
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            ptrSFX		macro type, name
00000000                            .type =		\type<<24		; create equate for the type mask
00000000                            	rept narg-1			; repeat for all arguments
00000000                            		dc.l \name\|.type	; create pointer with specified type
00000000                            __sfx =		__sfx+1			; increase SFX ID
00000000                            	shift				; shift next argument into view
00000000                            	endr
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Creates music pointers table, and creates necessary equates
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            ptrMusic	macro name, sptempo
00000000                            	rept narg/2			; repeat for half of the arguments
00000000                            		dc.l ((\sptempo)<<24)|\name\; create pointer with tempo
00000000                            __mus =		__mus+1			; increase music ID
00000000                            	shift				; shift next argument into view
00000000                            	shift				; ''
00000000                            	endr
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Include PCM data
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            incSWF		macro name, file
00000000                            SWF_\name\	incbin	\file		; include PCM data
00000000                            SWFR_\name\ 	dcb.b Z80E_Read*(MaxPitch/$100),$00; add end markers (for Dual PCM)
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Create data for a sample
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            sample		macro freq, start, loop, name
00000000                            	if narg=4		; if we have 4 arguments, we'd like a custom name
00000000                            d\name =	__samp		; use the extra argument to create SMPS2ASM equate
00000000                            	else
00000000                            d\start =	__samp		; else, use the first one!
00000000                            	endif
00000000                            __samp =	__samp+1	; increase sample ID
00000000                            ; create offsets for the sample normal, reverse, loop normal, loop reverse.
00000000                            	dc.b SWF_\start&$FF,((SWF_\start>>$08)&$7F)|$80,(SWF_\start>>$0F)&$FF
00000000                            	dc.b (SWFR_\start-1)&$FF,(((SWFR_\start-1)>>$08)&$7F)|$80,((SWFR_\start-1)>>$0F)&$FF
00000000                            	dc.b SWF_\loop&$FF,((SWF_\loop>>$08)&$7F)|$80, (SWF_\loop>>$0F)&$FF
00000000                            	dc.b (SWFR_\loop-1)&$FF,(((SWFR_\loop-1)>>$08)&$7F)|$80,((SWFR_\loop-1)>>$0F)&$FF
00000000                            	dc.w \freq-$100		; sample frequency (actually offset, so we remove $100)
00000000                            	dc.w 0			; unused!
00000000                                endm
00000000                            ; ===========================================================================
00000000                            	opt ae-
00000000                            		include	"Sound/amps/code/smps2asm.asm"	; AMPS SMPS2ASM
00000000                            ; ===============================================
00000000                            ; Based on Flamewing's SMPS2ASM, and S1SMPS2ASM by Marc (AKA Cinossu)
00000000                            ; Reworked and improved by Natsumi
00000000                            ; ===============================================
00000000                            ; this macro is created to emulate enum in AS
00000000                            enum	macro	num, lable
00000000                            ; copy initial number for referencing later
00000000                            .num	= num
00000000                            	rept narg-1
00000000                            \lable		set .num
00000000                            .num =	.num+1
00000000                            	shift
00000000                            	endr
00000000                                endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------------------------
00000000                            ; Note Equates
00000000                            	enum $80+0, nRst
00000000 =00000080                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =00000080                M nrst	set	.num
00000000 =00000081                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nRst+1,nC0,nCs0,nD0,nEb0,nE0,nF0,nFs0,nG0,nAb0,nA0,nBb0,nB0
00000000 =00000081                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =00000081                M nc0	set	.num
00000000 =00000082                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000082                M ncs0	set	.num
00000000 =00000083                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000083                M nd0	set	.num
00000000 =00000084                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000084                M neb0	set	.num
00000000 =00000085                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000085                M ne0	set	.num
00000000 =00000086                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000086                M nf0	set	.num
00000000 =00000087                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000087                M nfs0	set	.num
00000000 =00000088                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000088                M ng0	set	.num
00000000 =00000089                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000089                M nab0	set	.num
00000000 =0000008A                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000008A                M na0	set	.num
00000000 =0000008B                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000008B                M nbb0	set	.num
00000000 =0000008C                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000008C                M nb0	set	.num
00000000 =0000008D                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nB0+1, nC1,nCs1,nD1,nEb1,nE1,nF1,nFs1,nG1,nAb1,nA1,nBb1,nB1
00000000 =0000008D                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =0000008D                M nc1	set	.num
00000000 =0000008E                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000008E                M ncs1	set	.num
00000000 =0000008F                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000008F                M nd1	set	.num
00000000 =00000090                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000090                M neb1	set	.num
00000000 =00000091                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000091                M ne1	set	.num
00000000 =00000092                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000092                M nf1	set	.num
00000000 =00000093                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000093                M nfs1	set	.num
00000000 =00000094                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000094                M ng1	set	.num
00000000 =00000095                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000095                M nab1	set	.num
00000000 =00000096                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000096                M na1	set	.num
00000000 =00000097                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000097                M nbb1	set	.num
00000000 =00000098                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000098                M nb1	set	.num
00000000 =00000099                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nB1+1, nC2,nCs2,nD2,nEb2,nE2,nF2,nFs2,nG2,nAb2,nA2,nBb2,nB2
00000000 =00000099                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =00000099                M nc2	set	.num
00000000 =0000009A                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000009A                M ncs2	set	.num
00000000 =0000009B                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000009B                M nd2	set	.num
00000000 =0000009C                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000009C                M neb2	set	.num
00000000 =0000009D                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000009D                M ne2	set	.num
00000000 =0000009E                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000009E                M nf2	set	.num
00000000 =0000009F                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000009F                M nfs2	set	.num
00000000 =000000A0                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A0                M ng2	set	.num
00000000 =000000A1                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A1                M nab2	set	.num
00000000 =000000A2                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A2                M na2	set	.num
00000000 =000000A3                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A3                M nbb2	set	.num
00000000 =000000A4                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A4                M nb2	set	.num
00000000 =000000A5                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nB2+1, nC3,nCs3,nD3,nEb3,nE3,nF3,nFs3,nG3,nAb3,nA3,nBb3,nB3
00000000 =000000A5                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =000000A5                M nc3	set	.num
00000000 =000000A6                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A6                M ncs3	set	.num
00000000 =000000A7                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A7                M nd3	set	.num
00000000 =000000A8                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A8                M neb3	set	.num
00000000 =000000A9                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A9                M ne3	set	.num
00000000 =000000AA                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000AA                M nf3	set	.num
00000000 =000000AB                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000AB                M nfs3	set	.num
00000000 =000000AC                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000AC                M ng3	set	.num
00000000 =000000AD                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000AD                M nab3	set	.num
00000000 =000000AE                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000AE                M na3	set	.num
00000000 =000000AF                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000AF                M nbb3	set	.num
00000000 =000000B0                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B0                M nb3	set	.num
00000000 =000000B1                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nB3+1, nC4,nCs4,nD4,nEb4,nE4,nF4,nFs4,nG4,nAb4,nA4,nBb4,nB4
00000000 =000000B1                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =000000B1                M nc4	set	.num
00000000 =000000B2                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B2                M ncs4	set	.num
00000000 =000000B3                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B3                M nd4	set	.num
00000000 =000000B4                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B4                M neb4	set	.num
00000000 =000000B5                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B5                M ne4	set	.num
00000000 =000000B6                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B6                M nf4	set	.num
00000000 =000000B7                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B7                M nfs4	set	.num
00000000 =000000B8                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B8                M ng4	set	.num
00000000 =000000B9                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B9                M nab4	set	.num
00000000 =000000BA                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000BA                M na4	set	.num
00000000 =000000BB                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000BB                M nbb4	set	.num
00000000 =000000BC                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000BC                M nb4	set	.num
00000000 =000000BD                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nB4+1, nC5,nCs5,nD5,nEb5,nE5,nF5,nFs5,nG5,nAb5,nA5,nBb5,nB5
00000000 =000000BD                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =000000BD                M nc5	set	.num
00000000 =000000BE                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000BE                M ncs5	set	.num
00000000 =000000BF                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000BF                M nd5	set	.num
00000000 =000000C0                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C0                M neb5	set	.num
00000000 =000000C1                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C1                M ne5	set	.num
00000000 =000000C2                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C2                M nf5	set	.num
00000000 =000000C3                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C3                M nfs5	set	.num
00000000 =000000C4                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C4                M ng5	set	.num
00000000 =000000C5                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C5                M nab5	set	.num
00000000 =000000C6                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C6                M na5	set	.num
00000000 =000000C7                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C7                M nbb5	set	.num
00000000 =000000C8                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C8                M nb5	set	.num
00000000 =000000C9                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nB5+1, nC6,nCs6,nD6,nEb6,nE6,nF6,nFs6,nG6,nAb6,nA6,nBb6,nB6
00000000 =000000C9                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =000000C9                M nc6	set	.num
00000000 =000000CA                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000CA                M ncs6	set	.num
00000000 =000000CB                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000CB                M nd6	set	.num
00000000 =000000CC                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000CC                M neb6	set	.num
00000000 =000000CD                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000CD                M ne6	set	.num
00000000 =000000CE                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000CE                M nf6	set	.num
00000000 =000000CF                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000CF                M nfs6	set	.num
00000000 =000000D0                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D0                M ng6	set	.num
00000000 =000000D1                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D1                M nab6	set	.num
00000000 =000000D2                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D2                M na6	set	.num
00000000 =000000D3                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D3                M nbb6	set	.num
00000000 =000000D4                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D4                M nb6	set	.num
00000000 =000000D5                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nB6+1, nC7,nCs7,nD7,nEb7,nE7,nF7,nFs7,nG7,nAb7,nA7,nBb7
00000000 =000000D5                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =000000D5                M nc7	set	.num
00000000 =000000D6                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D6                M ncs7	set	.num
00000000 =000000D7                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D7                M nd7	set	.num
00000000 =000000D8                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D8                M neb7	set	.num
00000000 =000000D9                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D9                M ne7	set	.num
00000000 =000000DA                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000DA                M nf7	set	.num
00000000 =000000DB                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000DB                M nfs7	set	.num
00000000 =000000DC                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000DC                M ng7	set	.num
00000000 =000000DD                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000DD                M nab7	set	.num
00000000 =000000DE                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000DE                M na7	set	.num
00000000 =000000DF                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000DF                M nbb7	set	.num
00000000 =000000E0                M .num	=	.num+1
00000000                          M 	shift
00000000                            
00000000                            ; ---------------------------------------------------------------------------------------------
00000000                            ; PSG volume envelope equates
00000000 =00000000                  v00 =	$00
00000000                            
00000000                            ; ---------------------------------------------------------------------------------------------
00000000                            ; Header Macros
00000000                            sHeaderInit	macro
00000000                            sPointZero =	*
00000000                            sPatNum =	0
00000000                                endm
00000000                            
00000000                            ; Header - Set up Channel Usage
00000000                            sHeaderCh	macro fm,psg
00000000                            	dc.b \fm-1
00000000                            	if narg=2
00000000                            		if \fm>5
00000000                            			inform 2,"You sure there are \fm FM channels?"
00000000                            		endif
00000000                            		dc.b \psg-1
00000000                            		if \psg>3
00000000                            			inform 2,"You sure there are \psg PSG channels?"
00000000                            		endif
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; Convert S1 tempo to S3 tempo
00000000                            sConvS1Tempo	macro tempo
00000000                            s2tempo = ((((((((tempo=0)&1)<<8)|tempo)-1)<<8)+(((((tempo=0)&1)<<8)|tempo)>>1))/((((tempo=0)&1)<<8)|tempo))&$FF
00000000                            s3tempo = ($100-(((s2tempo=0)&1)|s2tempo))&$FF
00000000                                endm
00000000                            
00000000                            ; Header - Set up Tempo and Tick Multiplier
00000000                            sHeaderTempo	macro tmul,tempo
00000000                            	dc.b \tmul-1,\tempo
00000000                                endm
00000000                            
00000000                            sHeaderTempoS1	macro tmul,tempo
00000000                            	sConvS1Tempo \tempo
00000000                            	dc.b \tmul-1,s3tempo
00000000                                endm
00000000                            
00000000                            ; Header - Set priority leve
00000000                            sHeaderPrio	macro prio
00000000                            	dc.b \prio
00000000                                endm
00000000                            
00000000                            ; Header - Set up DAC Channel
00000000                            sHeaderDAC	macro loc,vol,samp
00000000                            	dc.w \loc-sPointZero
00000000                            	if narg>=2
00000000                            		dc.b \vol
00000000                            		if narg>=3
00000000                            			dc.b \samp
00000000                            		else
00000000                            			dc.b $00
00000000                            		endif
00000000                            	else
00000000                            		dc.w $00
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; Header - Set up FM Channel
00000000                            sHeaderFM	macro loc,pitch,vol
00000000                            	dc.w \loc-sPointZero
00000000                            	dc.b \pitch,\vol
00000000                                endm
00000000                            
00000000                            ; Header - Set up PSG Channel
00000000                            sHeaderPSG	macro loc,pitch,vol,detune,volenv
00000000                            	dc.w \loc-sPointZero
00000000                            	dc.b \pitch,\vol,\detune,\volenv
00000000                                endm
00000000                            
00000000                            ; Header - Set up SFX Channel
00000000                            sHeaderSFX	macro flags,type,loc,pitch,vol
00000000                            	dc.b \flags,\type
00000000                            	dc.w \loc-sPointZero
00000000                            	dc.b \pitch,\vol
00000000                                endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------------------------
00000000                            ; Command Flag Macros and Equates. Based on the original s1smps2asm, and Flamewing's smps2asm
00000000 =00000000                  spNone set $00
00000000 =00000040                  spRight set $40
00000000 =00000080                  spLeft set $80
00000000 =000000C0                  spCentre set $C0
00000000 =000000C0                  spCenter set $C0
00000000                            
00000000                            ; ---------------------------------------------------------------------------------------------
00000000                            ; Macros for FM instruments
00000000                            ; Patches - Feedback
00000000                            
00000000                            ; Patches - Algorithm
00000000                            spAlgorithm macro val, name
00000000                            	if (sPatNum<>0)&(safe=0)
00000000                            		; align the patch
00000000                            		dc.b (*^(sPatNum*spTL4))&$FF
00000000                            		dc.b ((*>>8)+(spDe3*spDR3))&$FF
00000000                            		dc.b ((*>>16)-(spTL1*spRR3))&$FF
00000000                            	endif
00000000                            	if narg>1
00000000                            p\name =	sPatNum
00000000                            	endif
00000000                            sPatNum =	sPatNum+1
00000000                            spAl	= val
00000000                                endm
00000000                            
00000000                            spFeedback macro val
00000000                            spFe	= val
00000000                                endm
00000000                            
00000000                            ; Patches - Detune
00000000                            spDetune macro op1,op2,op3,op4
00000000                            spDe1	= op1
00000000                            spDe2	= op2
00000000                            spDe3	= op3
00000000                            spDe4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Multiple
00000000                            spMultiple macro op1,op2,op3,op4
00000000                            spMu1	= op1
00000000                            spMu2	= op2
00000000                            spMu3	= op3
00000000                            spMu4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Rate Scale
00000000                            spRateScale macro op1,op2,op3,op4
00000000                            spRS1	= op1
00000000                            spRS2	= op2
00000000                            spRS3	= op3
00000000                            spRS4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Attack Rate
00000000                            spAttackRt macro op1,op2,op3,op4
00000000                            spAR1	= op1
00000000                            spAR2	= op2
00000000                            spAR3	= op3
00000000                            spAR4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Amplitude Modulation
00000000                            spAmpMod macro op1,op2,op3,op4
00000000                            spAM1	= op1
00000000                            spAM2	= op2
00000000                            spAM3	= op3
00000000                            spAM4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Sustain Rate
00000000                            spSustainRt macro op1,op2,op3,op4
00000000                            spSR1	= op1		; Also known as decay 1 rate
00000000                            spSR2	= op2
00000000                            spSR3	= op3
00000000                            spSR4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Sustain Level
00000000                            spSustainLv macro op1,op2,op3,op4
00000000                            spSL1	= op1		; also known as decay 1 level
00000000                            spSL2	= op2
00000000                            spSL3	= op3
00000000                            spSL4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Decay Rate
00000000                            spDecayRt macro op1,op2,op3,op4
00000000                            spDR1	= op1		; Also known as decay 2 rate
00000000                            spDR2	= op2
00000000                            spDR3	= op3
00000000                            spDR4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Release Rate
00000000                            spReleaseRt macro op1,op2,op3,op4
00000000                            spRR1	= op1
00000000                            spRR2	= op2
00000000                            spRR3	= op3
00000000                            spRR4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - SSG-EG
00000000                            spSSGEG macro op1,op2,op3,op4
00000000                            spSS1	= op1
00000000                            spSS2	= op2
00000000                            spSS3	= op3
00000000                            spSS4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Total Level
00000000                            spTotalLv macro op1,op2,op3,op4
00000000                            spTL1	= op1
00000000                            spTL2	= op2
00000000                            spTL3	= op3
00000000                            spTL4	= op4
00000000                            ; Construct the patch finally.
00000000                            	dc.b	(spFe<<3)+spAl
00000000                            ;   0     1     2     3     4     5     6     7
00000000                            ;%1000,%1000,%1000,%1000,%1010,%1110,%1110,%1111
00000000                            spTLMask4 set $80
00000000                            spTLMask2 set ((spAl>=5)<<7)
00000000                            spTLMask3 set ((spAl>=4)<<7)
00000000                            spTLMask1 set ((spAl=7)<<7)
00000000                            	dc.b (spDe1<<4)+spMu1, (spDe3<<4)+spMu3, (spDe2<<4)+spMu2, (spDe4<<4)+spMu4
00000000                            	dc.b (spRS1<<6)+spAR1, (spRS3<<6)+spAR3, (spRS2<<6)+spAR2, (spRS4<<6)+spAR4
00000000                            	dc.b (spAM1<<7)+spSR1, (spAM3<<7)+spsR3, (spAM2<<7)+spSR2, (spAM4<<7)+spSR4
00000000                            	dc.b spDR1,            spDR3,            spDR2,            spDR4
00000000                            	dc.b (spSL1<<4)+spRR1, (spSL3<<4)+spRR3, (spSL2<<4)+spRR2, (spSL4<<4)+spRR4
00000000                            	dc.b spSS1,            spSS3,            spSS2,            spSS4
00000000                            	dc.b spTL1|spTLMask1,  spTL3|spTLMask3,  spTL2|spTLMask2,  spTL4|spTLMask4
00000000                            	if safe=1
00000000                            		dc.b 'NAT'	; align the patch
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; Patches - Total Level (for broken total level masks)
00000000                            spTotalLv2 macro op1,op2,op3,op4
00000000                            spTL1	= op1
00000000                            spTL2	= op2
00000000                            spTL3	= op3
00000000                            spTL4	= op4
00000000                            	dc.b (spFe<<3)+spAl
00000000                            	dc.b (spDe1<<4)+spMu1, (spDe3<<4)+spMu3, (spDe2<<4)+spMu2, (spDe4<<4)+spMu4
00000000                            	dc.b (spRS1<<6)+spAR1, (spRS3<<6)+spAR3, (spRS2<<6)+spAR2, (spRS4<<6)+spAR4
00000000                            	dc.b (spAM1<<7)+spSR1, (spAM3<<7)+spsR3, (spAM2<<7)+spSR2, (spAM4<<7)+spSR4
00000000                            	dc.b spDR1,            spDR3,            spDR2,            spDR4
00000000                            	dc.b (spSL1<<4)+spRR1, (spSL3<<4)+spRR3, (spSL2<<4)+spRR2, (spSL4<<4)+spRR4
00000000                            	dc.b spSS1,            spSS3,            spSS2,            spSS4
00000000                            	dc.b spTL1,	       spTL3,		 spTL2,		   spTL4
00000000                            	if safe=1
00000000                            		dc.b 'NAT'	; align the patch
00000000                            	endif
00000000                                endm
00000000                            ; ---------------------------------------------------------------------------------------------
00000000                            ; SMPS commands
00000000                            
00000000                            ; E0xx - Panning, AMS, FMS (PANAFMS - PAFMS_PAN)
00000000                            sPan		macro pan, ams, fms
00000000                            	if narg=1
00000000                            		dc.b $E0, \pan
00000000                            	elseif narg=2
00000000                            		dc.b $E0, \pan|\ams
00000000                            	else
00000000                            		dc.b $E0, \pan|(\ams<<4)|\fms
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; E1xx - Set channel frequency displacement to xx (DETUNE_SET)
00000000                            ssDetune	macro val
00000000                            	dc.b $E1, \val
00000000                                endm
00000000                            
00000000                            ; E2xx - Add xx to channel frequency displacement (DETUNE)
00000000                            saDetune	macro val
00000000                            	dc.b $E2, \val
00000000                                endm
00000000                            
00000000                            ; E3xx - Set channel pitch to xx (TRANSPOSE - TRNSP_SET)
00000000                            ssTranspose	macro val
00000000                            	dc.b $E3, \val
00000000                                endm
00000000                            
00000000                            ; E4xx - Add xx to channel pitch (TRANSPOSE - TRNSP_ADD)
00000000                            saTranspose	macro val
00000000                            	dc.b $E4, \val
00000000                                endm
00000000                            
00000000                            ; E5xx - Set channel tick multiplier to xx (TICK_MULT - TMULT_CUR)
00000000                            ssTickMulCh	macro val
00000000                            	dc.b $E5, \val-1
00000000                                endm
00000000                            
00000000                            ; E6xx - Set global tick multiplier to xx (TICK_MULT - TMULT_ALL)
00000000                            ssTickMul	macro val
00000000                            	dc.b $E6, \val-1
00000000                                endm
00000000                            
00000000                            ; E7 - Do not attack of next note (HOLD)
00000000 =000000E7                  sHold =		$E7
00000000                            
00000000                            ; E8xx - Set patch/voice/sample to xx (INSTRUMENT - INS_C_FM / INS_C_PSG / INS_C_DAC)
00000000                            sVoice		macro val
00000000                            	dc.b $E8, \val
00000000                                endm
00000000                            
00000000                            ; E9xx - Set music speed shoes tempo to xx (TEMPO - TEMPO_SET_SPEED)
00000000                            ssTempoShoes	macro val
00000000                            	dc.b $E9, \val
00000000                                endm
00000000                            
00000000                            ; EAxx - Set music tempo to xx (TEMPO - TEMPO_SET)
00000000                            ssTempo		macro val
00000000                            	dc.b $EA, \val
00000000                                endm
00000000                            ssTempoS1	macro val
00000000                            	sConvS1Tempo \val
00000000                            	dc.b $EA, s3tempo
00000000                                endm
00000000                            
00000000                            ; EB - Turn on Modulation (MOD_SET - MODS_ON)
00000000                            sModOn		macro
00000000                            	dc.b $EB
00000000                                endm
00000000                            
00000000                            ; EC - Turn off Modulation (MOD_SET - MODS_OFF)
00000000                            sModOff		macro
00000000                            	dc.b $EC
00000000                                endm
00000000                            
00000000                            ; EDxx - Add xx to channel volume (VOLUME - VOL_CN_FM / VOL_CN_PSG / VOL_CN_DAC)
00000000                            saVol		macro vol
00000000                            	dc.b $ED, \vol
00000000                                endm
00000000                            
00000000                            ; EExx - Set channel volume to xx (VOLUME - VOL_CN_ABS)
00000000                            ssVol		macro vol
00000000                            	dc.b $EE, \vol
00000000                                endm
00000000                            
00000000                            ; EFxxyy - Enable/Disable LFO (SET_LFO - LFO_AMSEN)
00000000                            ssLFO		macro reg, ams, fms, pan
00000000                            	if narg=2
00000000                            		dc.b $EF, \reg,\ams
00000000                            	elseif narg=3
00000000                            		dc.b $EF, \reg,(\ams<<4)|\fms
00000000                            	else
00000000                            		dc.b $EF, \reg,(\ams<<4)|\fms|\pan
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; F0wwxxyyzz - Modulation
00000000                            ;  ww: wait time
00000000                            ;  xx: modulation speed
00000000                            ;  yy: change per step
00000000                            ;  zz: number of steps
00000000                            ; (MOD_SETUP)
00000000                            ssMod68k	macro wait, speed, step, count
00000000                            	dc.b $F0, \wait,\speed,\step,\count
00000000                                endm
00000000                            
00000000                            ; F1 - Use sample DAC mode (DAC_MODE - DACM_SAMP)
00000000                            sModeSampDAC	macro
00000000                            	dc.b $F1
00000000                                endm
00000000                            
00000000                            ; F2 - Use pitch DAC mode (DAC_MODE - DACM_NOTE)
00000000                            sModePitchDAC	macro
00000000                            	dc.b $F2
00000000                                endm
00000000                            
00000000                            ; F3xx - PSG4 noise mode xx (PSG_NOISE - PNOIS_AMPS)
00000000                            sNoisePSG	macro val
00000000                            	dc.b $F3, \val
00000000                                endm
00000000                            
00000000                            ; F4xxxx - Keep looping back to xxxx each time the SFX is being played (CONT_SFX)
00000000                            sCont		macro loc
00000000                            	dc.b $F4
00000000                            	dc.w \loc-*-1
00000000                                endm
00000000                            
00000000                            ; F5 - End of channel (TRK_END - TEND_STD)
00000000                            sStop		macro
00000000                            	dc.b $F5
00000000                                endm
00000000                            
00000000                            ; F6xxxx - Jump to xxxx (GOTO)
00000000                            ssJump		macro loc
00000000                            	dc.b $F6
00000000                            	dc.w \loc-*-1
00000000                                endm
00000000                            
00000000                            ; F7xxyyzzzz - Loop back to zzzz yy times, xx being the loop index for loop recursion fixing (LOOP)
00000000                            sLoop		macro index,loops,loc
00000000                            	dc.b $F7, \index
00000000                            	dc.w \loc-*-1
00000000                            	dc.b \loops
00000000                                endm
00000000                            
00000000                            ; F8xxxx - Call pattern at xxxx, saving return point (GOSUB)
00000000                            sCall		macro loc
00000000                            	dc.b $F8
00000000                            	dc.w \loc-*-1
00000000                                endm
00000000                            
00000000                            ; F9 - Return (RETURN)
00000000                            sRet		macro
00000000                            	dc.b $F9
00000000                                endm
00000000                            
00000000                            ; FAyyxx - Set communications byte yy to xx (SET_COMM - SPECIAL)
00000000                            sComm		macro num, val
00000000                            	dc.b $FA, \num,\val
00000000                                endm
00000000                            
00000000                            ; FBxyzz - Get communications byte y, and compare zz with it using condition x (COMM_CONDITION)
00000000                            sCond		macro num, cond, val
00000000                            	dc.b $FB, \num|(\cond<<4),\val
00000000                                endm
00000000                            
00000000                            ; FC - Reset condition (COMM_RESET)
00000000                            sCondOff	macro
00000000                            	dc.b $FC
00000000                                endm
00000000                            
00000000                            ; FDxx - Stop note after xx frames (NOTE_STOP - NSTOP_NORMAL)
00000000                            sNoteTimeOut	macro val
00000000                            	dc.b $FD, \val
00000000                                endm
00000000                            
00000000                            ; FExxyy - YM command yy on register xx (YMCMD)
00000000                            sCmdYM		macro reg, val
00000000                            	dc.b $FE, \reg,\val
00000000                                endm
00000000                            
00000000                            ; FF00xx - Play sample xx on DAC1 (PLAY_DAC - PLAY_DAC1)
00000000                            sPlaySamp1	macro id
00000000                            	dc.b $FF,$00, \id
00000000                                endm
00000000                            
00000000                            ; FF01xx - Play sample xx on DAC1 (PLAY_DAC - PLAY_DAC2)
00000000                            sPlaySamp2	macro id
00000000                            	dc.b $FF,$01, \id
00000000                                endm
00000000                            
00000000                            ; FF02xxxx - Set channel frequency to xxxx (CHFREQ_SET)
00000000                            ssFreq		macro freq
00000000                            	dc.b $FF,$02
00000000                            	dc.w \freq
00000000                                endm
00000000                            
00000000                            ; FF03xx - Set channel frequency to note xx (CHFREQ_SET - CHFREQ_NOTE)
00000000                            ssFreqNote	macro note
00000000                            	dc.b $FF,$03, \note^$80
00000000                                endm
00000000                            
00000000                            ; FF04 - Increment spindash rev counter (SPINDASH_REV - SDREV_INC)
00000000                            sSpinRev	macro
00000000                            	dc.b $FF,$04
00000000                                endm
00000000                            
00000000                            ; FF05 - Reset spindash rev counter (SPINDASH_REV - SDREV_RESET)
00000000                            sSpinReset	macro
00000000                            	dc.b $FF,$05
00000000                                endm
00000000                            
00000000                            ; FF06xx - Add xx to music speed tempo (TEMPO - TEMPO_ADD_SPEED)
00000000                            saTempoSpeed	macro tempo
00000000                            	dc.b $FF,$06, \tempo
00000000                                endm
00000000                            
00000000                            ; FF07xx - Add xx to music tempo (TEMPO - TEMPO_ADD)
00000000                            saTempo		macro tempo
00000000                            	dc.b $FF,$07, \tempo
00000000                                endm
00000000                            
00000000                            ; FF08xyzz - Get RAM address pointer offset by y, compare zz with it using condition x (COMM_CONDITION - COMM_SPEC)
00000000                            sCondReg	macro off, cond, val
00000000                            	dc.b $FF,$08, \off|(\cond<<4),\val
00000000                                endm
00000000                            
00000000                            ; FF09xx - Play another music/sfx (SND_CMD)
00000000                            sPlayMus	macro id
00000000                            	dc.b $FF,$09, \id
00000000                                endm
00000000                            
00000000                            ; FF0A - Enable raw frequency mode (RAW_FREQ)
00000000                            sFreqOn		macro freq
00000000                            	dc.b $FF,$0A
00000000                            	inform 3,"Flag is currently not implemented! Please remove."
00000000                                endm
00000000                            
00000000                            ; FF0B - Disable raw frequency mode (RAW_FREQ - RAW_FREQ_OFF)
00000000                            sFreqOff	macro freq
00000000                            	dc.b $FF,$0B
00000000                            	inform 3,"Flag is currently not implemented! Please remove."
00000000                                endm
00000000                            
00000000                            ; FF0C - Enable FM3 special mode (SPC_FM3)
00000000                            sSpecFM3	macro freq
00000000                            	dc.b $FF,$0C
00000000                            	inform 3,"Flag is currently not implemented! Please remove."
00000000                                endm
00000000                            
00000000                            ; FF0Dxx - Set DAC filter bank address (DAC_FILTER)
00000000                            ssFilter	macro bank
00000000                            	dc.b $FF,$0D, \bank
00000000                                endm
00000000                            
00000000                            ; FF0E - Freeze 68k. Debug flag (DEBUG_STOP_CPU)
00000000                            sFreeze		macro
00000000                            	if safe=1
00000000                            		dc.b $FF,$0E
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; FF0F - Bring up tracker debugger at end of frame. Debug flag (DEBUG_PRINT_TRACKER)
00000000                            sCheck		macro
00000000                            	if safe=1
00000000                            		dc.b $FF,$0F
00000000                            	endif
00000000                                endm
00000000                            
00000000                            		include	"Config/Constants.asm"		; Constants
00000000                            ; =========================================================================================================================================================
00000000                            ; MegaDrive constants
00000000                            ; =========================================================================================================================================================
00000000 =00000000                  ROM_START		equ	$000000				; ROM area start address
00000000 =00400000                  ROM_END			equ	$3FFFFF+1			; ROM area end address
00000000                            
00000000 =00A00000                  Z80_RAM			equ	$A00000				; Z80 RAM start address
00000000 =00A02000                  Z80_RAM_END		equ	$A02000				; Z80 RAM end address
00000000 =00A11100                  Z80_BUS_REQ		equ	$A11100				; Z80 bus request
00000000 =00A11200                  Z80_RESET		equ	$A11200				; Z80 reset
00000000                            
00000000 =00A04000                  YM2612_A0		equ	$A04000				; M68K YM2612 register port 0
00000000 =00A04001                  YM2612_D0		equ	$A04001				; M68K YM2612 data port 0
00000000 =00A04002                  YM2612_A1		equ	$A04002				; M68K YM2612 register port 1
00000000 =00A04003                  YM2612_D1		equ	$A04003				; M68K YM2612 data port 1
00000000 =00C00011                  PSG_INPUT		equ	$C00011				; M68K PSG input
00000000                            
00000000 =00A10001                  HW_VERSION		equ	$A10001				; Hardware version
00000000 =00A14000                  TMSS_PORT		equ	$A14000				; TMSS port
00000000                            
00000000 =00A10003                  PORT_A_DATA		equ	$A10003				; Port A data
00000000 =00A10005                  PORT_B_DATA		equ	$A10005				; Port B data
00000000 =00A10007                  PORT_C_DATA		equ	$A10007				; Port C data
00000000 =00A10009                  PORT_A_CTRL		equ	$A10009				; Port A control
00000000 =00A1000B                  PORT_B_CTRL		equ	$A1000B				; Port B control
00000000 =00A1000D                  PORT_C_CTRL		equ	$A1000D				; Port C control
00000000 =00A1000F                  PORT_A_TX		equ	$A1000F				; Port A Tx data
00000000 =00A10011                  PORT_A_RX		equ	$A10011				; Port A Rx data
00000000 =00A10013                  PORT_A_SCTRL		equ	$A10013				; Port A S control
00000000 =00A10015                  PORT_B_TX		equ	$A10015				; Port B Tx data
00000000 =00A10017                  PORT_B_RX		equ	$A10017				; Port B Rx data
00000000 =00A10019                  PORT_B_SCTRL		equ	$A10019				; Port B S control
00000000 =00A1001B                  PORT_C_TX		equ	$A1001B				; Port C Tx data
00000000 =00A1001D                  PORT_C_RX		equ	$A1001D				; Port C Rx data
00000000 =00A1001F                  PORT_C_SCTRL		equ	$A1001F				; Port C S control
00000000                            
00000000 =00A130F1                  SRAM_ACCESS		equ	$A130F1				; SRAM access register ($200000 - $3FFFFF)
00000000                            
00000000 =00A130F3                  MAPPER_BANK_1		equ	$A130F3				; Mapper bank 1 register ($080000 - $0FFFFF)
00000000 =00A130F5                  MAPPER_BANK_2		equ	$A130F5				; Mapper bank 2 register ($100000 - $17FFFF)
00000000 =00A130F7                  MAPPER_BANK_3		equ	$A130F7				; Mapper bank 3 register ($180000 - $1FFFFF)
00000000 =00A130F9                  MAPPER_BANK_4		equ	$A130F9				; Mapper bank 4 register ($200000 - $27FFFF)
00000000 =00A130FB                  MAPPER_BANK_5		equ	$A130FB				; Mapper bank 5 register ($280000 - $2FFFFF)
00000000 =00A130FD                  MAPPER_BANK_6		equ	$A130FD				; Mapper bank 6 register ($300000 - $37FFFF)
00000000 =00A130FF                  MAPPER_BANK_7		equ	$A130FF				; Mapper bank 7 register ($380000 - $3FFFFF)
00000000                            
00000000 =00C00000                  VDP_DATA		equ	$C00000				; VDP data port
00000000 =00C00004                  VDP_CTRL		equ	$C00004				; VDP control port
00000000 =00C00008                  VDP_HVCOUNT		equ	$C00008				; VDP H/V counter
00000000 =00C0001C                  VDP_DEBUG		equ	$C0001C				; VDP debug register
00000000                            
00000000 =00FF0000                  RAM_START		equ	$FF0000				; M68K RAM start address
00000000 =01000000                  RAM_END			equ	$FFFFFF+1			; M68K RAM end address
00000000                            
00000000 =FFFF8000                  RAM_WORD_START		equ	$FFFF8000			; Starting address of absolute word addressable M68K RAM
00000000 =00000000                  RAM_WORD_END		equ	$FFFFFFFF+1			; Ending address of absolute word addressable M68K RAM
00000000                            ; =========================================================================================================================================================
00000000                            		include	"Config/Macros.asm"		; Macros
00000000                            ; =========================================================================================================================================================
00000000                            ; MegaDrive macros
00000000                            ; =========================================================================================================================================================
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Align
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	bound	- Size boundary
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            align		macros	bound
00000000                            		cnop	0,\bound
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Pad RS to even address
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------
00000000                            rseven		macros
00000000                            		rs.b	__rs&1
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Push registers to stack (works on either processor)
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	regs	- Registers to push
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            push		macro	regs
00000000                            		if z80prg=0
00000000                            			if instr("\regs","/")|instr("\regs","-")
00000000                            				movem.\0 \regs,-(sp)
00000000                            			else
00000000                            				move.\0	\regs,-(sp)
00000000                            			endif
00000000                            		else
00000000                            			zpush	\regs
00000000                            		endif
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Pop registers from stack (works on either processor)
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	regs	- Registers to pop
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            pop		macro	regs
00000000                            		if z80prg=0
00000000                            			if instr("\regs","/")|instr("\regs","-")
00000000                            				movem.\0 (sp)+,\regs
00000000                            			else
00000000                            				move.\0	(sp)+,\regs
00000000                            			endif
00000000                            		else
00000000                            			zpop	\regs
00000000                            		endif
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Clear memory
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	starta	- Address to start clearing memory at
00000000                            ;	enda	- Address to finish clearing memory at
00000000                            ;		  (not rEQUired if there exists a label that is the same as the starting label, but with "_End" at the end of it)
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            clrRAM		macro	starta, enda
00000000                            		local	endaddr
00000000                            		if narg<2
00000000                            endaddr			EQUS	"\starta\_End"
00000000                            		else
00000000                            endaddr			EQUS	"\enda"
00000000                            		endif
00000000                            		moveq	#0,d0
00000000                            		if ((\starta)&$8000)=0
00000000                            			lea	\starta,a1
00000000                            		else
00000000                            			lea	(\starta).w,a1
00000000                            		endif
00000000                            		if (\starta)&1
00000000                            			move.b	d0,(a1)+
00000000                            		endif
00000000                            		move.w	#(((\endaddr)-(\starta))-((\starta)&1))>>2-1,d1
00000000                            .Clear\@:	move.l	d0,(a1)+
00000000                            		dbf	d1,.Clear\@
00000000                            		if (((\endaddr)-(\starta))-((\starta)&1))&2
00000000                            			move.w	d0,(a1)+
00000000                            		endif
00000000                            		if (((\endaddr)-(\starta))-((\starta)&1))&1
00000000                            			move.b	d0,(a1)+
00000000                            		endif
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Disable SRAM access
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            sramOff		macros
00000000                            		move.b	#0,SRAM_ACCESS
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Enable SRAM access
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            sramOn		macros
00000000                            		move.b	#1,SRAM_ACCESS
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Disable interrupts
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            intsOff		macros
00000000                            		ori	#$700,sr
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Enable interrupts
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            intsOn		macros
00000000                            		andi	#$F8FF,sr
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Stop the Z80
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            doZ80Stop	macros
00000000                            		move.w	#$100,Z80_BUS_REQ
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Wait for the Z80 to stop
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            waitZ80Stop	macro
00000000                            .Wait\@:	btst	#0,Z80_BUS_REQ
00000000                            		bne.s	.Wait\@
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Stop the Z80 and wait for it to
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            stopZ80		macro
00000000                            		doZ80Stop
00000000                          M 	move.w	#$100,z80_bus_req
00000000                            		waitZ80Stop
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Start the Z80
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            startZ80	macros
00000000                            		move.w	#0,Z80_BUS_REQ
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Wait for the Z80 to start
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            waitZ80Start	macro
00000000                            .Wait\@:	btst	#0,Z80_BUS_REQ
00000000                            		beq.s	.Wait\@
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Cancel Z80 reset
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            resetZ80Off	macros
00000000                            		move.w	#$100,Z80_RESET
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Reset the Z80
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            resetZ80	macros
00000000                            		move.w	#0,Z80_RESET
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Wait for the YM2612 to not be busy
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            waitYM		macro
00000000                            		nop
00000000                            		nop
00000000                            		nop
00000000                            @Wait\@:	tst.b	(a0)
00000000                            		bmi.s	@Wait\@
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Wait for DMA finish
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	port	- Something to represent the VDP control port (default is VDP_CTRL_PORT)
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------	
00000000                            waitDMA		macro	port
00000000                            .Wait\@:
00000000                            		if narg>0
00000000                            			move.w	\port,d1
00000000                            		else
00000000                            			move.w	VDP_CTRL,d1
00000000                            		endif
00000000                            		btst	#1,d1
00000000                            		bne.s	.Wait\@
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; VDP command instruction
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	addr	- Address in VDP memory
00000000                            ;	type	- Type of VDP memory
00000000                            ;	rwd	- VDP command
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =00000021                  VRAM		EQU	%100001		; VRAM
00000000 =0000002B                  CRAM		EQU	%101011		; CRAM
00000000 =00000025                  VSRAM		EQU	%100101		; VSRAM
00000000 =0000000C                  READ		EQU	%001100		; VDP read
00000000 =00000007                  WRITE		EQU	%000111		; VDP write
00000000 =00000027                  DMA		EQU	%100111		; VDP DMA
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            vdpCmd		macro	ins, addr, type, rwd, end, end2
00000000                            		if narg=5
00000000                            			\ins	#((((\type&\rwd)&3)<<30)|((\addr&$3FFF)<<16)|(((\type&\rwd)&$FC)<<2)|((\addr&$C000)>>14)), \end
00000000                            		elseif narg>=6
00000000                            			\ins	#((((\type&\rwd)&3)<<30)|((\addr&$3FFF)<<16)|(((\type&\rwd)&$FC)<<2)|((\addr&$C000)>>14))\end, \end2
00000000                            		else
00000000                            			\ins	((((\type&\rwd)&3)<<30)|((\addr&$3FFF)<<16)|(((\type&\rwd)&$FC)<<2)|((\addr&$C000)>>14))
00000000                            		endif
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; VDP DMA from 68000 memory to VDP memory
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	src	- Source address in 68000 memory
00000000                            ;	dest	- Destination address in VDP memory
00000000                            ;	len	- Length of data in bytes
00000000                            ;	type	- Type of VDP memory
00000000                            ;	a6.l	- VDP control port
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            dma68k		macro	src, dest, len, type, port
00000000                            		move.l	#$94009300|((((\len)/2)&$FF00)<<8)|(((\len)/2)&$FF),(a6)
00000000                            		move.l	#$96009500|((((\src)/2)&$FF00)<<8)|(((\src)/2)&$FF),(a6)
00000000                            		move.w	#$9700|(((\src)>>17)&$7F),(a6)
00000000                            		vdpCmd	move.w, \dest, \type, DMA, >>16, (a6)
00000000                            		vdpCmd	move.w, \dest, \type, DMA, &$FFFF, -(sp)
00000000                            		move.w	(sp)+,(a6)
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Fill VRAM with byte
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	byte	- Byte to fill VRAM with
00000000                            ;	addr	- Address in VRAM
00000000                            ;	len	- Length of fill in bytes
00000000                            ;	a6.l	- VDP control port
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            dmaFill		macro	byte, addr, len
00000000                            		move.w	#$8F01,(a6)
00000000                            		move.l	#$94009300|((((\len)-1)&$FF00)<<8)|(((\len)-1)&$FF),(a6)
00000000                            		move.w	#$9780,(a6)
00000000                            		move.l	#$40000080|(((\addr)&$3FFF)<<16)|(((\addr)&$C000)>>14),(a6)
00000000                            		move.w	#(\byte)<<8,-4(a6)
00000000                            		waitDMA	(a6)
00000000                            		move.w	#$8F02,(a6)
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Copy a region of VRAM to a location in VRAM
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	src	- Source address in VRAM
00000000                            ;	dest	- Destination address in VRAM
00000000                            ;	len	- Length of copy in bytes
00000000                            ;	a6.l	- VDP control port
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            dmaCopy		macro	src, dest, len
00000000                            		move.w	#$8F01,(a6)
00000000                            		move.l	#$94009300|((((\len)-1)&$FF00)<<8)|(((\len)-1)&$FF),(a6)
00000000                            		move.l	#$96009500|(((\src)&$FF00)<<8)|((\src)&$FF),(a6)
00000000                            		move.w	#$97C0,(a6)
00000000                            		move.l	#$000000C0|(((\dest)&$3FFF)<<16)|(((\dest)&$C000)>>14),(a6)
00000000                            		waitDMA	(a6)
00000000                            		move.w	#$8F02,(a6)
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Start the lag-o-meter
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            lagOn		macro
00000000                            		if ENABLE_LAGMETER
00000000                            			move.w	#$9193,VDP_CTRL
00000000                            		endif
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Stop the lag-o-meter
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            lagOff		macro
00000000                            		if ENABLE_LAGMETER
00000000                            			move.w	#$9100,VDP_CTRL
00000000                            		endif
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Disable display
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            displayOff	macro
00000000                            		move.w	vdpReg1.w,d0
00000000                            		andi.b	#%10111111,d0
00000000                            		move.w	d0,VDP_CTRL
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Enable display
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            displayOn	macro
00000000                            		move.w	vdpReg1.w,d0
00000000                            		ori.b	#%01000000,d0
00000000                            		move.w	d0,VDP_CTRL
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Move the HUD down
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            moveHUDDown	macros
00000000                            		move.l	#-$80000,rHUD_Accel.w		; Set to move HUD down
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Move the HUD up
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            moveHUDUp	macros
00000000                            		move.l	#$8000,rHUD_Accel.w		; Set to move HUD up
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Convert a string to the textbox's format and store as a line
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	str	- The string
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            txtLine		macro	str
00000000                            c		= 1
00000000                            		rept	strlen(\str)
00000000                            ochar			substr c, c, \str
00000000                            char			substr "\ochar"-$1F, "\ochar"-$1F, "skojh`aledisfsg\0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_ABCDEFGHIJKLMNOPQRSTUVWXYZncmb"
00000000                            			dc.w	"\char"+$588
00000000                            c			= c+1
00000000                            		endr
00000000                            		dc.w	$FFFF
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add a line break character to the textbox
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            txtLineBreak	macros
00000000                            		dc.w	$FFFF
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add a message terminator character to the textbox
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            txtLineEnd	macros
00000000                            		dc.w	0
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add an animation change flag to the textbox
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	ani	- New animation script pointer
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            txtNewAni	macro	ani
00000000                            		dc.w	$FFFE
00000000                            		dc.l	\ani
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add an icon change flag to the textbox
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	icon	- New icon art pointer
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            txtNewIcon	macro	icon
00000000                            		dc.w	$FFFD
00000000                            		dc.l	\icon
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add a finished flag to the textbox
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            txtEnd		macros
00000000                            		dc.w	$FFFC
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add an entry to the level art animation script
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	duration	- Global duration
00000000                            ;	artaddr		- Source art
00000000                            ;	tileid		- Destination tile ID
00000000                            ;	numentries	- Number of entries
00000000                            ;	numvramtiles	- Number of tiles per entry
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            lvlAniDat	macro	duration, artaddr, tileid, numentries, numvramtiles
00000000                            		dc.l	(\duration&$FF)<<24|\artaddr
00000000                            		dc.w	((\tileid&$7FF)<<5)
00000000                            		dc.b	\numentries, \numvramtiles
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Get a unique character set from a string
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	string		- String to go throuhg
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	unique_chars	- A string of unique characters found
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            getUniqueChars	macro	string
00000000                            unique_chars	substr 1,1,\string
00000000                            strpos		= 1
00000000                            		while strpos<strlen(\string)
00000000                            found			= 0
00000000                            pos			= 0
00000000                            char			substr strpos+1,strpos+1,\string
00000000                            			while (pos<strlen("\unique_chars"))&(found=0)
00000000                            uchar				substr pos+1,pos+1,"\unique_chars"
00000000                            				if strcmp("\uchar","\char")|strcmp("\char", " ")
00000000                            found					= 1
00000000                            				endif
00000000                            pos				= pos+1
00000000                            			endw
00000000                            			if found=0
00000000                            unique_chars			equs "\unique_chars\\char"
00000000                            			endif
00000000                            strpos			= strpos+1
00000000                            			endw
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Run objects macro
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            runObjects		macro
00000000                            		movea.w	objExecFirst.w,a0				; load first object slot into a0
00000000                            		move.l	_objAddress(a0),a1				; load its pointer to a1
00000000                            		jsr	(a1)					; jump to its code
00000000                            	endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Next object macro
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            nextObject		macro
00000000                            		movea.w	_objNext(a0),a0				; load the next object address to a0
00000000                            		move.l	_objAddress(a0),a1				; load its pointer to a1
00000000                            		jmp	(a1)					; jump to its code
00000000                            	endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add sprite to a display list
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	layer	- The destination display layer
00000000                            ;	obj 	- The address register for the source object
00000000                            ;	fre 	- A free-to-user address register
00000000                            ;	chk	- If 1, the code also checks if the object is displayed already
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            displaySprite		macro	layer, obj, fre, chk
00000000                            ;	if layer >= 8
00000000                            ;		inform 2,"Invalid display layer!"
00000000                            ;	endif
00000000                            	if \chk
00000000                            		tst.w	_objDrawNext(\obj)					; check if displayed already
00000000                            		bne.s	.no\@						; if yes, skip
00000000                            	endif
00000000                            		move.w	#objDisplay+(\layer*dSize),_objDrawNext(\obj)	; put end marker as the next pointer
00000000                            		move.w	objDisplay+dPrev+(\layer*dSize).w,\fre		; copy the pointer from the end marker to dst register
00000000                            		move.w	\fre,_objDrawPrev(\obj)				; copy that to prev pointer
00000000                            		move.w	\obj,_objDrawNext(\fre)				;
00000000                            		move.w	\obj,objDisplay+dPrev+(\layer*dSize).w		; copy the pointer from the end marker to dst register
00000000                            ;		cmp.w	#objDisplay+(\layer*dSize),objDisplay+dPrev+(\layer*dSize).w	; special case: points to itself
00000000                            ;		bne.s	.no\@								; if no, skip
00000000                            ;		move.w	\obj,objDisplay+dPrev+(\layer*dSize).w				; else, copy over
00000000                            .no\@
00000000                            	endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add sprite to a display list using an address register
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	reg	- The address regsister containing target
00000000                            ;	obj 	- The address register for the source object
00000000                            ;	fre 	- A free-to-user address register
00000000                            ;	chk	- If 1, the code also checks if the object is displayed already
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            displaySpriteReg		macro	reg, obj, fre, chk
00000000                            	local layer
00000000                            layer EQUR	\reg							; convert register
00000000                            	if \chk
00000000                            		tst.w	_objDrawNext(\reg)					; check if displayed already
00000000                            		bne.s	.no\@						; if yes, skip
00000000                            	endif
00000000                            		move.w	layer,_objDrawNext(\obj)				; put end marker as the next pointer
00000000                            		move.w	_objDrawPrev(layer),\fre				; copy the pointer from the end marker to dst register
00000000                            		move.w	\fre,_objDrawPrev(\obj)				; copy that to prev pointer
00000000                            		move.w	\obj,_objDrawNext(\fre)				;
00000000                            		move.w	\obj,_objDrawPrev(layer)				; copy the pointer from the end marker to dst register
00000000                            ;		cmp.w	_objDrawPrev(layer),layer				; special case: points to itself
00000000                            ;		bne.s	.no\@						; if no, skip
00000000                            ;		move.w	\obj,_objDrawPrev(layer)				; else, copy over
00000000                            .no\@
00000000                            	endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Remove a sprite from a display list
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	obj 	- The address register for the source object
00000000                            ;	fre 	- A free-to-user address register
00000000                            ;	chk	- If 1, the code also checks if the object is displayed already
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            removeSprite		macro	obj, fre, chk
00000000                            	if \chk
00000000                            		tst.w	_objDrawNext(\obj)					; check if displayed already
00000000                            		beq.s	.yes\@						; if not, skip
00000000                            	endif
00000000                            		move.w	_objDrawPrev(\obj),\fre				; load the prev pointer to dst
00000000                            		move.w	_objDrawNext(\obj),_objDrawNext(\fre)			; copy the next object pointer from src to dst
00000000                            		move.w	_objDrawNext(\obj),\fre				; load the next pointer to dst
00000000                            		move.w	_objDrawPrev(\obj),_objDrawPrev(\fre)			; copy the prev object pointer from src to dst
00000000                            ;		cmp.w	_objDrawPrev(\obj),\fre				; special case: last object
00000000                            ;		bne.s	.no\@						; if no, skip
00000000                            ;		move.w	\fre,_objDrawNext(\fre)				; else, change to point to same address
00000000                            .no\@
00000000                            		clr.l	_objDrawNext(\obj)
00000000                            .yes\@
00000000                            	endm
00000000                            ; =========================================================================================================================================================
00000000                            		include	"Config/Offsets.asm"		; Offsets
00000000                            ; =========================================================================================================================================================
00000000                            ; User defined constants
00000000                            ; =========================================================================================================================================================
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Game mode IDs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsreset
00000000 =00000000                  gTitle		rs.l	1				; Title screen game mode
00000000 =00000004                  gLevel		rs.l	1				; Level game mode
00000000 =00000008                  gEnd		rs.l	1				; Ending game mode
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; V-INT routine IDs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsreset
00000000 =00000000                  vLag		rs.w	1				; Lag updates
00000000 =00000002                  vGeneral	rs.w	1				; General updates
00000000 =00000004                  vLevel		rs.w	1				; Level updates
00000000 =00000006                  vLvlLoad	rs.w	1				; Level load updates
00000000 =00000008                  vTitle		rs.w	1				; Title screen updates
00000000 =0000000A                  vFade		rs.w	1				; Fade updates
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Level IDs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsreset
00000000 =00000000                  zWWZ		rs.b	1				; Wacky Workbench
00000000                            
00000000 =00000001                  ZONE_COUNT	equ	__rs				; Number of zones
00000000                            
00000000 =00000000                  lWWZ		equ	zWWZ<<8				; Wacky Workbench
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Music definitions
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset	MusOff
00000000 =0000000A                  mFirst		rs.b	0
00000000 =0000000A                  mSega		rs.b	1				; SEGA jingle
00000000 =0000000B                  mWWZ		rs.b	1				; Wacky Workbench music
00000000 =0000000C                  mBoss		rs.b	1				; Boss music
00000000 =0000000D                  mInvincible	rs.b	1				; Invincibility music
00000000 =0000000E                  mEnd		rs.b	0
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; SFX definitions
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset	SFXoff
00000000 =00000082                  sFirst		rs.b	0
00000000 =00000082                  sLeap		rs.b	1				; Jump sound
00000000 =00000083                  sSkid		rs.b	1				; Skid sound
00000000 =00000084                  sHurt		rs.b	0				; Hurt sound
00000000 =00000084                  sDeath		rs.b	1				; Death sound
00000000 =00000085                  sPush		rs.b	1				; Push sound
00000000 =00000086                  sBubble		rs.b	1				; Bubble sound
00000000 =00000087                  sDrown		rs.b	1				; Drowning sound
00000000 =00000088                  sDrownWarn	rs.b	1				; Drown warning sound
00000000 =00000089                  sDrownCount	rs.b	1				; Drown countdown sound
00000000 =0000008A                  sCheckpoint	rs.b	1				; Checkpoint sound
00000000 =0000008B                  sSpikeMove	rs.b	1				; Spike movement sound
00000000 =0000008C                  sRing		rs.b	1				; Ring sound
00000000 =0000008D                  sRingLoss	rs.b	1				; Ring loss sound
00000000 =0000008E                  sSpring		rs.b	1				; Spring sound
00000000 =0000008F                  sShield		rs.b	1				; Shield sound
00000000 =00000090                  sSplash		rs.b	1				; Water splash sound
00000000 =00000091                  sBumper		rs.b	1				; Bumper sound
00000000 =00000092                  sSwitch		rs.b	1				; Switch sound
00000000 =00000093                  sSignpost	rs.b	1				; Signpost sound
00000000 =00000094                  sCollapse	rs.b	1				; Collapse sound
00000000 =00000095                  sWallSmash	rs.b	1				; Wall smash sound
00000000 =00000096                  sRumble		rs.b	1				; Rumble sound
00000000 =00000097                  sWarp		rs.b	1				; Warp sound
00000000 =00000098                  sBossHit	rs.b	1				; Boss hit sound
00000000 =00000099                  sBomb		rs.b	1				; Bomb sound
00000000 =0000009A                  sBreakItem	rs.b	1				; Break item sound
00000000 =0000009B                  sFloorBounce	rs.b	1				; Floor bounce sound
00000000 =0000009C                  sCharge		rs.b	1				; Charge sound
00000000 =0000009D                  sChargeStop	rs.b	1				; Charge stop sound
00000000 =0000009E                  sChargeRelease	rs.b	1				; Charge release sound
00000000 =0000009F                  sDiamBreak	rs.b	1				; Diamond break sound
00000000 =000000A0                  sEnd		rs.b	0
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Object SSTs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsreset
00000000 =00000000                  _objPrevDPLC	rs.b	0				; Previous DPLC ID (only used by a few objects)
00000000 =00000000                  _objAddress	rs.l	1				; Pointer to object code
00000000 =00000004                  _objNext	rs.w	1				; Pointer to next object in the linked list
00000000 =00000006                  _objPrev	rs.w	1				; Pointer to previous object in the linked list
00000000 =00000008                  _objDrawNext	rs.w	1				; Pointer to next object to display
00000000 =0000000A                  _objDrawPrev	rs.w	1				; Pointer to previous object to display
00000000                            
00000000 =0000000C                  _objFlags	rs.b	1				; Object flags
00000000 =0000000D                  _objRender	rs.b	1				; Render flags
00000000 =0000000E                  _objVRAM	rs.w	1				; Sprite tile properties
00000000 =00000010                  _objFrame	rs.b	0				; Mapping frame ID (top byte of the following long)
00000000 =00000010                  _objMapping	rs.l	1				; Sprite mappings
00000000                            
00000000 =00000014                  _objXPos	rs.l	1				; X position
00000000 =00000017                  _objDrawW	equ	__rs-1				; Sprite width
00000000 =00000018                  _objYPos	rs.l	1				; Y position
00000000 =0000001B                  _objDrawH	equ	__rs-1				; Sprite height
00000000 =0000001C                  _objXVel	rs.w	1				; X velocity
00000000 =0000001E                  _objYVel	rs.w	1				; Y velocity
00000000                            
00000000 =00000020                  _objAnim	rs.b	1				; Animation ID
00000000 =00000021                  _objPrevAnim	rs.b	1				; Saved animation ID
00000000 =00000022                  _objAnimFrame	rs.b	1				; Animation script frame ID
00000000 =00000023                  _objAnimTimer	rs.b	1				; Animation timer
00000000                            
00000000 =00000024                  _objSubtype	rs.b	1				; Subtype ID (top byte of the following long)
00000000 =00000025                  _objRoutine	rs.b	1				; Routine ID
00000000 =00000026                  _objRespawn	rs.w	1				; Respawn table entry pointer
00000000 =00000028                  _objStatus	rs.b	1				; Status flags
00000000 =00000029                  _objShield	rs.b	1				; Shield flags
00000000                            
00000000 =0000002A                  _objDynSSTs	rs.b	$60-__rs			; Dynamic SSTs
00000000 =00000060                  _objSize	rs.b	0				; Size of the SSTs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Dynamic SSTs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset	_objDynSSTs
00000000 =0000002A                  _objColType	rs.b	1				; Collision type
00000000 =0000002B                  _objColStat	rs.b	1				; Collision status
00000000 =0000002B                  _objHitCnt	equ	_objColStat			; Boss hit count
00000000 =0000002C                  _objColW	rs.b	1				; Collision width
00000000 =0000002D                  _objColH	rs.b	1				; Collision height
00000000 =0000002E                  _objNextTilt	rs.b	1				; Next tilt value
00000000 =0000002F                  _objTilt	rs.b	1				; Tilt value
00000000 =00000030                  _objLvlSSTs	rs.b	0				; Beginning of dynamic level SSTs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Sub sprite SSTs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset	_objNextTilt			; Allow some reserved SSTs
00000000 =0000002E                  _objSubSSTs	rs.b	0				; Start of sub sprite SSTs
00000000 =0000002E                  _objSubCnt	rs.w	1				; Main sprite sub sprite count
00000000 =00000030                  _objSubStart	rs.b	0				; Actual sub sprite SSTs start
00000000 =00000000                  ct		=	0
00000000                            
00000000                            	rept	8					; Allow 8 sub sprites per object
00000000                            _objSub\$ct\XPos	rs.w	1			; Sub sprite X position
00000000                            _objSub\$ct\YPos	rs.w	1			; Sub sprite Y position
00000000                            _objSub\$ct\Free	rs.b	1			; Sub sprite free byte
00000000                            _objSub\$ct\Frame	rs.b	1			; Sub sprite mapping frame
00000000                            ct		=	ct+1
00000000                            	endr
00000000 =00000030                M _objsub0xpos	rs.w	1
00000000 =00000032                M _objsub0ypos	rs.w	1
00000000 =00000034                M _objsub0free	rs.b	1
00000000 =00000035                M _objsub0frame	rs.b	1
00000000 =00000001                M ct	=	ct+1
00000000 =00000036                M _objsub1xpos	rs.w	1
00000000 =00000038                M _objsub1ypos	rs.w	1
00000000 =0000003A                M _objsub1free	rs.b	1
00000000 =0000003B                M _objsub1frame	rs.b	1
00000000 =00000002                M ct	=	ct+1
00000000 =0000003C                M _objsub2xpos	rs.w	1
00000000 =0000003E                M _objsub2ypos	rs.w	1
00000000 =00000040                M _objsub2free	rs.b	1
00000000 =00000041                M _objsub2frame	rs.b	1
00000000 =00000003                M ct	=	ct+1
00000000 =00000042                M _objsub3xpos	rs.w	1
00000000 =00000044                M _objsub3ypos	rs.w	1
00000000 =00000046                M _objsub3free	rs.b	1
00000000 =00000047                M _objsub3frame	rs.b	1
00000000 =00000004                M ct	=	ct+1
00000000 =00000048                M _objsub4xpos	rs.w	1
00000000 =0000004A                M _objsub4ypos	rs.w	1
00000000 =0000004C                M _objsub4free	rs.b	1
00000000 =0000004D                M _objsub4frame	rs.b	1
00000000 =00000005                M ct	=	ct+1
00000000 =0000004E                M _objsub5xpos	rs.w	1
00000000 =00000050                M _objsub5ypos	rs.w	1
00000000 =00000052                M _objsub5free	rs.b	1
00000000 =00000053                M _objsub5frame	rs.b	1
00000000 =00000006                M ct	=	ct+1
00000000 =00000054                M _objsub6xpos	rs.w	1
00000000 =00000056                M _objsub6ypos	rs.w	1
00000000 =00000058                M _objsub6free	rs.b	1
00000000 =00000059                M _objsub6frame	rs.b	1
00000000 =00000007                M ct	=	ct+1
00000000 =0000005A                M _objsub7xpos	rs.w	1
00000000 =0000005C                M _objsub7ypos	rs.w	1
00000000 =0000005E                M _objsub7free	rs.b	1
00000000 =0000005F                M _objsub7frame	rs.b	1
00000000 =00000008                M ct	=	ct+1
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Sprite drawing input list definitions
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset _objDrawPrev-6			; this awkward thing will make dPrev == _objDrawPrev
00000000 =00000004                  dNext		rs.w 1					; pointer to first display object in linked list
00000000 =00000006                  dN2		rs.w 1					; must be 0
00000000 =00000008                  dN1		rs.w 1					; must be 0
00000000 =0000000A                  dPrev		rs.w 1					; pointer to last display object in linked list
00000000 =00000008                  dSize =		__rs-dNext				; size of display layer
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Solid object collision bits
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =00000003                  cStandBit	equ	3
00000000 =00000008                  cStand		equ	1<<cStandBit
00000000                            
00000000 =00000002                  cPushDelta	equ	2
00000000                            
00000000 =00000005                  cPushBit	equ	cStandBit+cPushDelta
00000000 =00000020                  cPush		equ	1<<cPushBit
00000000                            
00000000 =00000000                  cTouchSideBit	equ	0
00000000 =00000001                  cTouchSide	equ	1<<cTouchSideBit
00000000                            
00000000 =00000002                  cTouchBtmBit	equ	cTouchSideBit+cPushDelta
00000000 =00000004                  cTouchBtm	equ	1<<cTouchBtmBit
00000000                            
00000000 =00000004                  cTouchTopBit	equ	cTouchBtmBit+cPushDelta
00000000 =00000010                  cTouchTop	equ	1<<cTouchTopBit
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Macro to calculate the RAM space used by objects without going over the given max size
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	size	- Max size for this object SST space
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =00000000                  curobj		=	0
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            maxObjRAM	macro	size
00000000                            curobj_size	=	0
00000000                            		while curobj_size<(\size)
00000000                            rObj_\$curobj		rs.b	_objSize
00000000                            curobj_size		=	curobj_size+_objSize
00000000                            curobj			=	curobj+1
00000000                            		endw
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Level drawing variables
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsreset
00000000 =00000000                  cXPos		rs.l	1				; Plane X position
00000000 =00000004                  cXPrev		rs.w	1				; Plane previous X position
00000000 =00000006                  cXPrevR		rs.w	1				; Plane previous X position (rounded)
00000000 =00000008                  cYPos		rs.l	1				; Plane Y position
00000000 =0000000C                  cYPrev		rs.w	1				; Plane previous Y position
00000000 =0000000E                  cYPrevR		rs.w	1				; Plane previous Y position (rounded)
00000000 =00000010                  cRBlks		rs.b	1				; Number of blocks in the first set of tiles in a row
00000000 =00000011                  cCBlks		rs.b	1				; Number of blocks in the first set of tiles in a column
00000000 =00000012                  cVDP		rs.l	1				; VDP command
00000000 =00000016                  cLayout		rs.w	1				; Layout offset
00000000 =00000018                  cUpdate		rs.l	1				; Update routine
00000000 =0000001C                  cRedraw		rs.w	1				; Redraw flag
00000000 =0000001E                  cSize2		rs.b	0				; Variable list size
00000000                            ; =========================================================================================================================================================
00000000                            		include	"Config/Variables.asm"		; Variables
00000000                            ; =========================================================================================================================================================
00000000                            ; User defined RAM addresses
00000000                            ; =========================================================================================================================================================
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Standard variables
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset	RAM_START
00000000                            
00000000                            		; --- BUFFERS ---
00000000                            
00000000 =00FF0000                  miscBuff	rs.b	0				; General buffer
00000000 =00FF0000                  chunkData	rs.b	$8000				; Chunk table (uses same space as general buffer)
00000000 =00FF8000                  miscBuff_End	rs.b	0
00000000                            
00000000                            		rsset	RAM_WORD_START
00000000                            
00000000 =FFFF8000                  kosMBuff	rs.b	$1000				; Kosinski decompression buffer
00000000                            
00000000 =FFFF9000                  dmaQueue	rs.b	$FC				; DMA queue buffer
00000000 =FFFF90FC                  dmaSlot		rs.w	1				; DMA queue buffer slot
00000000                            
00000000 =FFFF90FE                  hScrollBuff	rs.b	$380				; HScroll table
00000000 =FFFF947E                  hScrollBuff_End	rs.b	0				; ''
00000000                            
00000000 =FFFF947E                  vScrollBuff	rs.b	$50				; VScroll table
00000000 =FFFF94CE                  vScrollBuff_End	rs.b	0				; ''
00000000 =FFFF947E                  vScrollBuffFG	EQU	vScrollBuff			; VScroll foreground value
00000000 =FFFF9480                  vScrollBuffBG	EQU	vScrollBuff+2			; VScroll background value
00000000                            
00000000 =FFFF94CE                  spriteBuff	rs.b	$280				; Sprite table
00000000 =FFFF974E                  spriteBuff_End	rs.b	0				; ''
00000000                            
00000000                            ; NTP: we won't be able to save ram like this until we switch to SWAP mappings (and we'll need per-piece limit checks on lest we overwrite the water palette)
00000000                            ;palFadeBuffAlt	equ	spriteBuff_End-$100		; Target water palette buffer
00000000                            ;palFadeBuff	equ	spriteBuff_End-$80		; Target palette buffer
00000000                            
00000000 =FFFF974E                  palFadeBuffAlt	rs.b	$80				; Target water palette buffer
00000000 =FFFF97CE                  palFadeBuff	rs.b	$80				; Target palette buffer
00000000 =FFFF984E                  paletteBuffAlt	rs.b	$80				; Water palette buffer
00000000 =FFFF98CE                  paletteBuff	rs.b	$80				; Palette buffer
00000000                            
00000000 =FFFF994E                  kosVars		rs.b	0				; Kosinski decompression queue variables
00000000 =FFFF994E                  kosCount	rs.w	1				; Kosinski decompression queue count
00000000 =FFFF9950                  kosRegisters	rs.b	$1A				; Kosinski decompression stored registers
00000000 =FFFF996A                  kosStatusReg	rs.w	1				; Kosinski decompression stored SR
00000000 =FFFF996C                  kosBookmark	rs.l	1				; Kosinski decompression bookmark
00000000 =FFFF9970                  kosList		rs.b	$20				; Kosinski decompression queue
00000000 =FFFF9970                  kosSource	equ	kosList				; ''
00000000 =FFFF9974                  kosDestination	equ	kosList+4			; ''
00000000 =FFFF9990                  kosList_End	rs.b	0				; ''
00000000 =FFFF9990                  kosMModules	rs.w	1				; Kosinski moduled decompression modules left
00000000 =FFFF9992                  kosMLastSize	rs.w	1				; Kosinski moduled decompression last module size
00000000 =FFFF9994                  kosMList	rs.b	$20*6				; Kosinski moduled decompression queue
00000000 =FFFF9994                  kosMSource	equ	kosMList			; ''
00000000 =FFFF9998                  kosMDestination	equ	kosMList+4			; ''
00000000 =FFFF9A54                  kosMList_End	rs.b	0				; ''
00000000 =FFFF9A54                  kosVars_End	rs.b	0				; End of Kosinski decompression queue variables
00000000                            
00000000 =FFFF9A54                  objRespawn	rs.b	$300				; Object respawn table
00000000 =FFFF9D54                  objRespawn_End	rs.b	0				; ''
00000000                            
00000000 =FFFF9D54                  objMemory	rs.b	0				; Object SSTs
00000000                            		maxObjRAM $2400				; ''
00000000 =00000000                M curobj_size	=	0
00000000                          M 	while	curobj_size<($2400)
00000000 =FFFF9D54                M robj_0	rs.b	_objsize
00000000 =00000060                M curobj_size	=	curobj_size+_objsize
00000000 =00000001                M curobj	=	curobj+1
00000000 =FFFF9DB4                M robj_1	rs.b	_objsize
00000000 =000000C0                M curobj_size	=	curobj_size+_objsize
00000000 =00000002                M curobj	=	curobj+1
00000000 =FFFF9E14                M robj_2	rs.b	_objsize
00000000 =00000120                M curobj_size	=	curobj_size+_objsize
00000000 =00000003                M curobj	=	curobj+1
00000000 =FFFF9E74                M robj_3	rs.b	_objsize
00000000 =00000180                M curobj_size	=	curobj_size+_objsize
00000000 =00000004                M curobj	=	curobj+1
00000000 =FFFF9ED4                M robj_4	rs.b	_objsize
00000000 =000001E0                M curobj_size	=	curobj_size+_objsize
00000000 =00000005                M curobj	=	curobj+1
00000000 =FFFF9F34                M robj_5	rs.b	_objsize
00000000 =00000240                M curobj_size	=	curobj_size+_objsize
00000000 =00000006                M curobj	=	curobj+1
00000000 =FFFF9F94                M robj_6	rs.b	_objsize
00000000 =000002A0                M curobj_size	=	curobj_size+_objsize
00000000 =00000007                M curobj	=	curobj+1
00000000 =FFFF9FF4                M robj_7	rs.b	_objsize
00000000 =00000300                M curobj_size	=	curobj_size+_objsize
00000000 =00000008                M curobj	=	curobj+1
00000000 =FFFFA054                M robj_8	rs.b	_objsize
00000000 =00000360                M curobj_size	=	curobj_size+_objsize
00000000 =00000009                M curobj	=	curobj+1
00000000 =FFFFA0B4                M robj_9	rs.b	_objsize
00000000 =000003C0                M curobj_size	=	curobj_size+_objsize
00000000 =0000000A                M curobj	=	curobj+1
00000000 =FFFFA114                M robj_a	rs.b	_objsize
00000000 =00000420                M curobj_size	=	curobj_size+_objsize
00000000 =0000000B                M curobj	=	curobj+1
00000000 =FFFFA174                M robj_b	rs.b	_objsize
00000000 =00000480                M curobj_size	=	curobj_size+_objsize
00000000 =0000000C                M curobj	=	curobj+1
00000000 =FFFFA1D4                M robj_c	rs.b	_objsize
00000000 =000004E0                M curobj_size	=	curobj_size+_objsize
00000000 =0000000D                M curobj	=	curobj+1
00000000 =FFFFA234                M robj_d	rs.b	_objsize
00000000 =00000540                M curobj_size	=	curobj_size+_objsize
00000000 =0000000E                M curobj	=	curobj+1
00000000 =FFFFA294                M robj_e	rs.b	_objsize
00000000 =000005A0                M curobj_size	=	curobj_size+_objsize
00000000 =0000000F                M curobj	=	curobj+1
00000000 =FFFFA2F4                M robj_f	rs.b	_objsize
00000000 =00000600                M curobj_size	=	curobj_size+_objsize
00000000 =00000010                M curobj	=	curobj+1
00000000 =FFFFA354                M robj_10	rs.b	_objsize
00000000 =00000660                M curobj_size	=	curobj_size+_objsize
00000000 =00000011                M curobj	=	curobj+1
00000000 =FFFFA3B4                M robj_11	rs.b	_objsize
00000000 =000006C0                M curobj_size	=	curobj_size+_objsize
00000000 =00000012                M curobj	=	curobj+1
00000000 =FFFFA414                M robj_12	rs.b	_objsize
00000000 =00000720                M curobj_size	=	curobj_size+_objsize
00000000 =00000013                M curobj	=	curobj+1
00000000 =FFFFA474                M robj_13	rs.b	_objsize
00000000 =00000780                M curobj_size	=	curobj_size+_objsize
00000000 =00000014                M curobj	=	curobj+1
00000000 =FFFFA4D4                M robj_14	rs.b	_objsize
00000000 =000007E0                M curobj_size	=	curobj_size+_objsize
00000000 =00000015                M curobj	=	curobj+1
00000000 =FFFFA534                M robj_15	rs.b	_objsize
00000000 =00000840                M curobj_size	=	curobj_size+_objsize
00000000 =00000016                M curobj	=	curobj+1
00000000 =FFFFA594                M robj_16	rs.b	_objsize
00000000 =000008A0                M curobj_size	=	curobj_size+_objsize
00000000 =00000017                M curobj	=	curobj+1
00000000 =FFFFA5F4                M robj_17	rs.b	_objsize
00000000 =00000900                M curobj_size	=	curobj_size+_objsize
00000000 =00000018                M curobj	=	curobj+1
00000000 =FFFFA654                M robj_18	rs.b	_objsize
00000000 =00000960                M curobj_size	=	curobj_size+_objsize
00000000 =00000019                M curobj	=	curobj+1
00000000 =FFFFA6B4                M robj_19	rs.b	_objsize
00000000 =000009C0                M curobj_size	=	curobj_size+_objsize
00000000 =0000001A                M curobj	=	curobj+1
00000000 =FFFFA714                M robj_1a	rs.b	_objsize
00000000 =00000A20                M curobj_size	=	curobj_size+_objsize
00000000 =0000001B                M curobj	=	curobj+1
00000000 =FFFFA774                M robj_1b	rs.b	_objsize
00000000 =00000A80                M curobj_size	=	curobj_size+_objsize
00000000 =0000001C                M curobj	=	curobj+1
00000000 =FFFFA7D4                M robj_1c	rs.b	_objsize
00000000 =00000AE0                M curobj_size	=	curobj_size+_objsize
00000000 =0000001D                M curobj	=	curobj+1
00000000 =FFFFA834                M robj_1d	rs.b	_objsize
00000000 =00000B40                M curobj_size	=	curobj_size+_objsize
00000000 =0000001E                M curobj	=	curobj+1
00000000 =FFFFA894                M robj_1e	rs.b	_objsize
00000000 =00000BA0                M curobj_size	=	curobj_size+_objsize
00000000 =0000001F                M curobj	=	curobj+1
00000000 =FFFFA8F4                M robj_1f	rs.b	_objsize
00000000 =00000C00                M curobj_size	=	curobj_size+_objsize
00000000 =00000020                M curobj	=	curobj+1
00000000 =FFFFA954                M robj_20	rs.b	_objsize
00000000 =00000C60                M curobj_size	=	curobj_size+_objsize
00000000 =00000021                M curobj	=	curobj+1
00000000 =FFFFA9B4                M robj_21	rs.b	_objsize
00000000 =00000CC0                M curobj_size	=	curobj_size+_objsize
00000000 =00000022                M curobj	=	curobj+1
00000000 =FFFFAA14                M robj_22	rs.b	_objsize
00000000 =00000D20                M curobj_size	=	curobj_size+_objsize
00000000 =00000023                M curobj	=	curobj+1
00000000 =FFFFAA74                M robj_23	rs.b	_objsize
00000000 =00000D80                M curobj_size	=	curobj_size+_objsize
00000000 =00000024                M curobj	=	curobj+1
00000000 =FFFFAAD4                M robj_24	rs.b	_objsize
00000000 =00000DE0                M curobj_size	=	curobj_size+_objsize
00000000 =00000025                M curobj	=	curobj+1
00000000 =FFFFAB34                M robj_25	rs.b	_objsize
00000000 =00000E40                M curobj_size	=	curobj_size+_objsize
00000000 =00000026                M curobj	=	curobj+1
00000000 =FFFFAB94                M robj_26	rs.b	_objsize
00000000 =00000EA0                M curobj_size	=	curobj_size+_objsize
00000000 =00000027                M curobj	=	curobj+1
00000000 =FFFFABF4                M robj_27	rs.b	_objsize
00000000 =00000F00                M curobj_size	=	curobj_size+_objsize
00000000 =00000028                M curobj	=	curobj+1
00000000 =FFFFAC54                M robj_28	rs.b	_objsize
00000000 =00000F60                M curobj_size	=	curobj_size+_objsize
00000000 =00000029                M curobj	=	curobj+1
00000000 =FFFFACB4                M robj_29	rs.b	_objsize
00000000 =00000FC0                M curobj_size	=	curobj_size+_objsize
00000000 =0000002A                M curobj	=	curobj+1
00000000 =FFFFAD14                M robj_2a	rs.b	_objsize
00000000 =00001020                M curobj_size	=	curobj_size+_objsize
00000000 =0000002B                M curobj	=	curobj+1
00000000 =FFFFAD74                M robj_2b	rs.b	_objsize
00000000 =00001080                M curobj_size	=	curobj_size+_objsize
00000000 =0000002C                M curobj	=	curobj+1
00000000 =FFFFADD4                M robj_2c	rs.b	_objsize
00000000 =000010E0                M curobj_size	=	curobj_size+_objsize
00000000 =0000002D                M curobj	=	curobj+1
00000000 =FFFFAE34                M robj_2d	rs.b	_objsize
00000000 =00001140                M curobj_size	=	curobj_size+_objsize
00000000 =0000002E                M curobj	=	curobj+1
00000000 =FFFFAE94                M robj_2e	rs.b	_objsize
00000000 =000011A0                M curobj_size	=	curobj_size+_objsize
00000000 =0000002F                M curobj	=	curobj+1
00000000 =FFFFAEF4                M robj_2f	rs.b	_objsize
00000000 =00001200                M curobj_size	=	curobj_size+_objsize
00000000 =00000030                M curobj	=	curobj+1
00000000 =FFFFAF54                M robj_30	rs.b	_objsize
00000000 =00001260                M curobj_size	=	curobj_size+_objsize
00000000 =00000031                M curobj	=	curobj+1
00000000 =FFFFAFB4                M robj_31	rs.b	_objsize
00000000 =000012C0                M curobj_size	=	curobj_size+_objsize
00000000 =00000032                M curobj	=	curobj+1
00000000 =FFFFB014                M robj_32	rs.b	_objsize
00000000 =00001320                M curobj_size	=	curobj_size+_objsize
00000000 =00000033                M curobj	=	curobj+1
00000000 =FFFFB074                M robj_33	rs.b	_objsize
00000000 =00001380                M curobj_size	=	curobj_size+_objsize
00000000 =00000034                M curobj	=	curobj+1
00000000 =FFFFB0D4                M robj_34	rs.b	_objsize
00000000 =000013E0                M curobj_size	=	curobj_size+_objsize
00000000 =00000035                M curobj	=	curobj+1
00000000 =FFFFB134                M robj_35	rs.b	_objsize
00000000 =00001440                M curobj_size	=	curobj_size+_objsize
00000000 =00000036                M curobj	=	curobj+1
00000000 =FFFFB194                M robj_36	rs.b	_objsize
00000000 =000014A0                M curobj_size	=	curobj_size+_objsize
00000000 =00000037                M curobj	=	curobj+1
00000000 =FFFFB1F4                M robj_37	rs.b	_objsize
00000000 =00001500                M curobj_size	=	curobj_size+_objsize
00000000 =00000038                M curobj	=	curobj+1
00000000 =FFFFB254                M robj_38	rs.b	_objsize
00000000 =00001560                M curobj_size	=	curobj_size+_objsize
00000000 =00000039                M curobj	=	curobj+1
00000000 =FFFFB2B4                M robj_39	rs.b	_objsize
00000000 =000015C0                M curobj_size	=	curobj_size+_objsize
00000000 =0000003A                M curobj	=	curobj+1
00000000 =FFFFB314                M robj_3a	rs.b	_objsize
00000000 =00001620                M curobj_size	=	curobj_size+_objsize
00000000 =0000003B                M curobj	=	curobj+1
00000000 =FFFFB374                M robj_3b	rs.b	_objsize
00000000 =00001680                M curobj_size	=	curobj_size+_objsize
00000000 =0000003C                M curobj	=	curobj+1
00000000 =FFFFB3D4                M robj_3c	rs.b	_objsize
00000000 =000016E0                M curobj_size	=	curobj_size+_objsize
00000000 =0000003D                M curobj	=	curobj+1
00000000 =FFFFB434                M robj_3d	rs.b	_objsize
00000000 =00001740                M curobj_size	=	curobj_size+_objsize
00000000 =0000003E                M curobj	=	curobj+1
00000000 =FFFFB494                M robj_3e	rs.b	_objsize
00000000 =000017A0                M curobj_size	=	curobj_size+_objsize
00000000 =0000003F                M curobj	=	curobj+1
00000000 =FFFFB4F4                M robj_3f	rs.b	_objsize
00000000 =00001800                M curobj_size	=	curobj_size+_objsize
00000000 =00000040                M curobj	=	curobj+1
00000000 =FFFFB554                M robj_40	rs.b	_objsize
00000000 =00001860                M curobj_size	=	curobj_size+_objsize
00000000 =00000041                M curobj	=	curobj+1
00000000 =FFFFB5B4                M robj_41	rs.b	_objsize
00000000 =000018C0                M curobj_size	=	curobj_size+_objsize
00000000 =00000042                M curobj	=	curobj+1
00000000 =FFFFB614                M robj_42	rs.b	_objsize
00000000 =00001920                M curobj_size	=	curobj_size+_objsize
00000000 =00000043                M curobj	=	curobj+1
00000000 =FFFFB674                M robj_43	rs.b	_objsize
00000000 =00001980                M curobj_size	=	curobj_size+_objsize
00000000 =00000044                M curobj	=	curobj+1
00000000 =FFFFB6D4                M robj_44	rs.b	_objsize
00000000 =000019E0                M curobj_size	=	curobj_size+_objsize
00000000 =00000045                M curobj	=	curobj+1
00000000 =FFFFB734                M robj_45	rs.b	_objsize
00000000 =00001A40                M curobj_size	=	curobj_size+_objsize
00000000 =00000046                M curobj	=	curobj+1
00000000 =FFFFB794                M robj_46	rs.b	_objsize
00000000 =00001AA0                M curobj_size	=	curobj_size+_objsize
00000000 =00000047                M curobj	=	curobj+1
00000000 =FFFFB7F4                M robj_47	rs.b	_objsize
00000000 =00001B00                M curobj_size	=	curobj_size+_objsize
00000000 =00000048                M curobj	=	curobj+1
00000000 =FFFFB854                M robj_48	rs.b	_objsize
00000000 =00001B60                M curobj_size	=	curobj_size+_objsize
00000000 =00000049                M curobj	=	curobj+1
00000000 =FFFFB8B4                M robj_49	rs.b	_objsize
00000000 =00001BC0                M curobj_size	=	curobj_size+_objsize
00000000 =0000004A                M curobj	=	curobj+1
00000000 =FFFFB914                M robj_4a	rs.b	_objsize
00000000 =00001C20                M curobj_size	=	curobj_size+_objsize
00000000 =0000004B                M curobj	=	curobj+1
00000000 =FFFFB974                M robj_4b	rs.b	_objsize
00000000 =00001C80                M curobj_size	=	curobj_size+_objsize
00000000 =0000004C                M curobj	=	curobj+1
00000000 =FFFFB9D4                M robj_4c	rs.b	_objsize
00000000 =00001CE0                M curobj_size	=	curobj_size+_objsize
00000000 =0000004D                M curobj	=	curobj+1
00000000 =FFFFBA34                M robj_4d	rs.b	_objsize
00000000 =00001D40                M curobj_size	=	curobj_size+_objsize
00000000 =0000004E                M curobj	=	curobj+1
00000000 =FFFFBA94                M robj_4e	rs.b	_objsize
00000000 =00001DA0                M curobj_size	=	curobj_size+_objsize
00000000 =0000004F                M curobj	=	curobj+1
00000000 =FFFFBAF4                M robj_4f	rs.b	_objsize
00000000 =00001E00                M curobj_size	=	curobj_size+_objsize
00000000 =00000050                M curobj	=	curobj+1
00000000 =FFFFBB54                M robj_50	rs.b	_objsize
00000000 =00001E60                M curobj_size	=	curobj_size+_objsize
00000000 =00000051                M curobj	=	curobj+1
00000000 =FFFFBBB4                M robj_51	rs.b	_objsize
00000000 =00001EC0                M curobj_size	=	curobj_size+_objsize
00000000 =00000052                M curobj	=	curobj+1
00000000 =FFFFBC14                M robj_52	rs.b	_objsize
00000000 =00001F20                M curobj_size	=	curobj_size+_objsize
00000000 =00000053                M curobj	=	curobj+1
00000000 =FFFFBC74                M robj_53	rs.b	_objsize
00000000 =00001F80                M curobj_size	=	curobj_size+_objsize
00000000 =00000054                M curobj	=	curobj+1
00000000 =FFFFBCD4                M robj_54	rs.b	_objsize
00000000 =00001FE0                M curobj_size	=	curobj_size+_objsize
00000000 =00000055                M curobj	=	curobj+1
00000000 =FFFFBD34                M robj_55	rs.b	_objsize
00000000 =00002040                M curobj_size	=	curobj_size+_objsize
00000000 =00000056                M curobj	=	curobj+1
00000000 =FFFFBD94                M robj_56	rs.b	_objsize
00000000 =000020A0                M curobj_size	=	curobj_size+_objsize
00000000 =00000057                M curobj	=	curobj+1
00000000 =FFFFBDF4                M robj_57	rs.b	_objsize
00000000 =00002100                M curobj_size	=	curobj_size+_objsize
00000000 =00000058                M curobj	=	curobj+1
00000000 =FFFFBE54                M robj_58	rs.b	_objsize
00000000 =00002160                M curobj_size	=	curobj_size+_objsize
00000000 =00000059                M curobj	=	curobj+1
00000000 =FFFFBEB4                M robj_59	rs.b	_objsize
00000000 =000021C0                M curobj_size	=	curobj_size+_objsize
00000000 =0000005A                M curobj	=	curobj+1
00000000 =FFFFBF14                M robj_5a	rs.b	_objsize
00000000 =00002220                M curobj_size	=	curobj_size+_objsize
00000000 =0000005B                M curobj	=	curobj+1
00000000 =FFFFBF74                M robj_5b	rs.b	_objsize
00000000 =00002280                M curobj_size	=	curobj_size+_objsize
00000000 =0000005C                M curobj	=	curobj+1
00000000 =FFFFBFD4                M robj_5c	rs.b	_objsize
00000000 =000022E0                M curobj_size	=	curobj_size+_objsize
00000000 =0000005D                M curobj	=	curobj+1
00000000 =FFFFC034                M robj_5d	rs.b	_objsize
00000000 =00002340                M curobj_size	=	curobj_size+_objsize
00000000 =0000005E                M curobj	=	curobj+1
00000000 =FFFFC094                M robj_5e	rs.b	_objsize
00000000 =000023A0                M curobj_size	=	curobj_size+_objsize
00000000 =0000005F                M curobj	=	curobj+1
00000000 =FFFFC0F4                M robj_5f	rs.b	_objsize
00000000 =00002400                M curobj_size	=	curobj_size+_objsize
00000000 =00000060                M curobj	=	curobj+1
00000000 =FFFFC154                  objMemory_End	rs.b	0
00000000                            
00000000 =00000060                  OBJECT_COUNT	equ	(objMemory_End-objMemory)/_objSize
00000000                            
00000000 =FFFFC154                  objExecute	rs.b	0				; Object execution list variables (DO NOT REARRANGE THE ORDER OF THESE!)
00000000 =FFFFC154                  objExecExit	rs.l	1				; Pointer to a return intstruction that will exit object execution
00000000 =FFFFC158                  objExecFirst	rs.w	1				; Pointer to the first object to be executed in the list
00000000 =FFFFC15A                  objExecLast	rs.w	1				; Pointer to the last object to be executed in the list
00000000 =FFFFC15C                  objExecFree	rs.w	1				; Pointer to the next free slot in object memory
00000000 =FFFFC15E                  objExecute_End	rs.b	0
00000000                            
00000000 =FFFFC15A                  objDisplay	equ __rs-dnext
00000000                            		rs.b	dSize*8				; Sprite display input list (8 priority levels)
00000000 =FFFFC19E                  objDisplay_End	rs.b	0				; 
00000000                            
00000000 =FFFFC19E                  fgRowBuff	rs.b	$102				; Foreground horizontal plane buffer
00000000 =FFFFC2A0                  fgColBuff	rs.b	$82				; Foreground vertical plane buffer
00000000 =FFFFC322                  bgRowBuff	rs.b	$102				; Background horizontal plane buffer
00000000 =FFFFC424                  bgColBuff	rs.b	$82				; Background vertical plane buffer
00000000                            
00000000 =FFFFC4A6                  ampsVars		rs.b	0			; AMPS variables
00000000                            		include	"Sound/amps/code/ram.asm"
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; RAM definitions
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000 =FFFFC4A6                  mFlags		rs.b 1		; various driver flags, see below
00000000 =FFFFC4A7                  mCtrPal		rs.b 1		; frame counter fo 50hz fix
00000000 =FFFFC4A8                  mVctSFX		rs.l 1		; address of voice table for sfx
00000000 =FFFFC4AC                  mComm		rs.b 8		; communications bytes
00000000 =FFFFC4B4                  mMasterVolFM	rs.b 0		; master volume for FM channels
00000000 =FFFFC4B4                  mFadeAddr	rs.l 1		; fading program address
00000000 =FFFFC4B8                  mTempoMain	rs.b 1		; music normal tempo
00000000 =FFFFC4B9                  mTempoSpeed	rs.b 1		; music speed shoes tempo
00000000 =FFFFC4BA                  mTempo		rs.b 1		; current tempo we are using right now
00000000 =FFFFC4BB                  mTempoCur	rs.b 1		; tempo counter/accumulator
00000000 =FFFFC4BC                  mQueue		rs.b 3		; sound queue
00000000 =FFFFC4BF                  mMasterVolPSG	rs.b 1		; master volume for PSG channels
00000000 =FFFFC4C0                  mMasterVolDAC	rs.b 1		; master volume for DAC channels
00000000 =FFFFC4C1                  mSpindash	rs.b 1		; spindash rev counter
00000000 =FFFFC4C2                  mContCtr	rs.b 1		; continous sfx loop counter
00000000 =FFFFC4C3                  mContLast	rs.b 1		; last continous sfx played
00000000                            		rs.w 0		; align channel data
00000000                            
00000000 =FFFFC4C4                  mDAC1		rs.b cSize	; DAC 1 data
00000000 =FFFFC4F0                  mDAC2		rs.b cSize	; DAC 2 data
00000000 =FFFFC51C                  mFM1		rs.b cSize	; FM 1 data
00000000 =FFFFC548                  mFM2		rs.b cSize	; FM 2 data
00000000 =FFFFC574                  mFM3		rs.b cSize	; FM 3 data
00000000 =FFFFC5A0                  mFM4		rs.b cSize	; FM 4 data
00000000 =FFFFC5CC                  mFM5		rs.b cSize	; FM 5 data
00000000 =FFFFC5F8                  mPSG1		rs.b cSize	; PSG 1 data
00000000 =FFFFC624                  mPSG2		rs.b cSize	; PSG 2 data
00000000 =FFFFC650                  mPSG3		rs.b cSize	; PSG 3 data
00000000 =FFFFC67C                  mSFXDAC1	rs.b cSizeSFX	; SFX DAC 1 data
00000000 =FFFFC698                  mSFXFM3		rs.b cSizeSFX	; SFX FM 3 data
00000000 =FFFFC6B4                  mSFXFM4		rs.b cSizeSFX	; SFX FM 4 data
00000000 =FFFFC6D0                  mSFXFM5		rs.b cSizeSFX	; SFX FM 5 data
00000000 =FFFFC6EC                  mSFXPSG1	rs.b cSizeSFX	; SFX PSG 1 data
00000000 =FFFFC708                  mSFXPSG2	rs.b cSizeSFX	; SFX PSG 2 data
00000000 =FFFFC724                  mSFXPSG3	rs.b cSizeSFX	; SFX PSG 3 data
00000000                            
00000000 =FFFFC740                  msChktracker	rs.b 1		; safe mode only: If set, bring up debugger
00000000                            		rsEven
00000000                          M 	rs.b	__rs&1
00000000 =FFFFC742                  mSize		rs.w 0		; end of the driver RAM
00000000                            ; ===========================================================================
00000000                            
00000000                            		; --- ENGINE VARIABLES ---
00000000                            
00000000 =FFFFC742                  ctrlDataP1	rs.b	0				; Controller 1 data
00000000 =FFFFC742                  ctrlHoldP1	rs.b	1				; Controller 1 held button data
00000000 =FFFFC743                  ctrlPressP1	rs.b	1				; Controller 1 pressed button data
00000000                            
00000000 =FFFFC744                  ctrlDataP2	rs.b	0				; Controller 2 data
00000000 =FFFFC744                  ctrlHoldP2	rs.b	1				; Controller 2 held button data
00000000 =FFFFC745                  ctrlPressP2	rs.b	1				; Controller 2 pressed button data
00000000                            
00000000 =FFFFC746                  hwVersion	rs.b	1				; Hardware version
00000000 =FFFFC747                  vIntFlag	rs.b	0				; V-INT flag
00000000 =FFFFC747                  vIntRoutine	rs.b	1				; V-INT routine
00000000                            
00000000 =FFFFC748                  palFadeVars	rs.b	0				; Palette fade properties
00000000 =FFFFC748                  palFadeStart	rs.b	1				; Palette fade start index
00000000 =FFFFC749                  palFadeLength	rs.b	1				; Palette fade size
00000000 =FFFFC74A                  palFadeVars_End	rs.b	0
00000000                            
00000000 =FFFFC74A                  lagCounter	rs.b	1				; Lag frame counter
00000000 =FFFFC74B                  hIntFlag	rs.b	1				; H-INT run flag
00000000                            
00000000 =FFFFC74C                  vIntJump	rs.w	1				; Header will point here for V-INT
00000000 =FFFFC74E                  vIntAddress	rs.l	1				; V-INT address
00000000                            
00000000 =FFFFC752                  hIntJump	rs.w	1				; Header will point here for H-INT
00000000 =FFFFC754                  hIntAddress	rs.l	1				; H-INT address
00000000                            
00000000 =FFFFC758                  frameCounter	rs.l	1				; Frame counter
00000000                            
00000000 =FFFFC75C                  opmode		rs.b	1				; Game opmode ID
00000000 =FFFFC75D                  spriteCount	rs.b	1				; Sprite count
00000000 =FFFFC75E                  pauseFlag	rs.b	1				; Pause flag
00000000 =FFFFC75F                  hIntUpdates	rs.b	1				; Level updates in H-INT flag
00000000                            
00000000 =FFFFC760                  hIntCounter	rs.b	0
00000000 =FFFFC760                  hIntCntReg	rs.b	1				; H-INT counter register
00000000 =FFFFC761                  hIntCntValue	rs.b	1				; H-INT counter value
00000000                            
00000000 =FFFFC762                  randomSeed	rs.l	1				; RNG seed
00000000                            
00000000 =FFFFC766                  vdpReg1		rs.w	1				; VDP register 1 register ID and value
00000000 =FFFFC768                  vdpWindowY	rs.w	1				; Window Y position (VDP register)
00000000                            
00000000 =FFFFC76A                  moveCheat	rs.b	1
00000000 =FFFFC76B                  artCheat	rs.b	1
00000000                            
00000000 =FFFFC76C                  oscillators	rs.b	0				; Oscillation numbers
00000000 =FFFFC76C                  oscControl	rs.w	1				; Oscillation control
00000000 =FFFFC76E                  oscValues	rs.w	$20				; Oscialltion data
00000000 =FFFFC7AE                  oscillators_End	rs.b	0				; ''
00000000                            
00000000                            		; --- GLOBAL VARIABLES ---
00000000                            
00000000 =FFFFC7AE                  levelID		rs.b	0				; Level ID
00000000 =FFFFC7AE                  zoneID		rs.b	1				; Zone ID
00000000 =FFFFC7AF                  actID		rs.b	1				; Act ID
00000000                            
00000000 =FFFFC7B0                  checkpoint	rs.b	0				; Checkpoint RAM
00000000 =FFFFC7B0                  chkIDLast	rs.b	1				; Last checkpoint hit
00000000                            		rs.b	1
00000000 =FFFFC7B2                  chkSavedXPos	rs.w	1				; Saved player X position
00000000 =FFFFC7B4                  chkSavedYPos	rs.w	1				; Saved player Y position
00000000 =FFFFC7B6                  checkpoint_End	rs.b	0				; End of checkpoint RAM
00000000                            
00000000 =FFFFC7B6                  objManager	rs.b	0
00000000 =FFFFC7B6                  objMgrInit	rs.b	1				; Object manager initialized flag
00000000                            
00000000 =FFFFC7B7                  rStartFall	rs.b	1				; Start level by falling flag
00000000                            
00000000 =FFFFC7B8                  objMgrLayout	rs.l	1				; Object position data pointer
00000000 =FFFFC7BC                  objMgrLoadR	rs.l	1				; Object data address (for going right)
00000000 =FFFFC7C0                  objMgrLoadL	rs.l	1				; Object data address (for going left)
00000000 =FFFFC7C4                  objMgrRespR	rs.w	1				; Object respawn address (for going right)
00000000 =FFFFC7C6                  objMgrRespL	rs.w	1				; Object respawn address (for going left)
00000000 =FFFFC7C8                  objMgrCoarseX	rs.w	1				; Object manager's coarse X position
00000000 =FFFFC7CA                  objMgrCoarseY	rs.w	1				; Object manager's coarse Y position
00000000 =FFFFC7CC                  objMgrCameraX	rs.w	1				; Object manager's camera X position
00000000 =FFFFC7CE                  objMgrCameraY	rs.w	1				; Object manager's camera Y position
00000000 =FFFFC7D0                  objManager_End	rs.b	0
00000000                            
00000000 =FFFFC7D0                  palCycTimer	rs.b	1				; Palette cycle timer
00000000 =FFFFC7D1                  palCycIndex	rs.b	1				; Palette cycle index
00000000                            
00000000                            		; --- LOCAL VARIABLES ---
00000000                            
00000000 =FFFFC7D2                  opmodeVars	rs.b	0				; Start of local game variables
00000000                            		rs.b	((-__rs)&$FFFF)-$100		; You have the rest of RAM here for local variables
00000000 =FFFFFF00                  opmodeVars_End	rs.b	0				; End of local game variables
00000000                            
00000000                            		; --- STACK SPACE ---
00000000                            
00000000 =FFFFFF00                  stackSpace	rs.b	$100				; Stack space
00000000 =00000000                  stack		rs.b	0				; ''
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Title screen variables
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset	opmodeVars
00000000                            
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Level variables
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset	opmodeVars
00000000 =FFFFC7D2                  blockData	rs.b	$1800				; Block table
00000000                            
00000000 =FFFFDFD2                  ringStatus	rs.b	$400				; Ring status table
00000000 =FFFFE3D2                  ringStatus_End	rs.b	0				; ''
00000000                            
00000000 =FFFFE3D2                  ringCollect	rs.b	0				; Ring collection table
00000000 =FFFFE3D2                  ringColCount	rs.w	1				; Ring collection count
00000000 =FFFFE3D4                  ringColList	rs.b	$7E				; Ring collection list
00000000 =FFFFE452                  ringCollect_End	rs.b	0				; ''
00000000                            
00000000 =FFFFE452                  scrollSects	rs.b	$384				; Scroll sections
00000000 =FFFFE7D6                  scrollSects_End	rs.b	0				; ''
00000000                            
00000000 =FFFFE7D6                  collideList	rs.b	$80				; Collision response list
00000000 =FFFFE856                  collideList_End	rs.b	0				; ''
00000000                            
00000000 =FFFFE856                  lvlLayout	rs.b	0				; Level layout ROM addresses
00000000 =FFFFE856                  lvlLayoutFG	rs.l	1				
00000000 =FFFFE85A                  lvlLayoutBG	rs.l	1				
00000000                            
00000000 =FFFFE85E                  ringCount	rs.w	1				; Ring count
00000000 =FFFFE860                  ringAnimFrame	rs.b	1				; Ring animation frame
00000000 =FFFFE861                  ringAnimTime	rs.b	1				; Ring animation timer
00000000                            
00000000 =FFFFE862                  ringLossAnimA	rs.w	1
00000000 =FFFFE864                  ringLossAnimT	rs.b	1
00000000 =FFFFE865                  ringLossAnimF	rs.b	1
00000000                            
00000000 =FFFFE866                  ringMgrRoutine	rs.b	1				; Ring manager routine
00000000 =FFFFE867                  hudUpdateRings	rs.b	1				; Update Ring counter in the HUD flag
00000000                            
00000000 =FFFFE868                  ringMgrLayout	rs.l	1				; Ring position data pointer
00000000 =FFFFE86C                  ringMgrLoadL	rs.l	1				; Ring data address for the left side of the screen
00000000 =FFFFE870                  ringMgrLoadR	rs.l	1				; Ring data address for the right side of the screen
00000000 =FFFFE874                  ringMgrStatPtr	rs.w	1				; Ring status address
00000000                            
00000000 =FFFFE876                  playerPtrP1	rs.w	1				; Player 1 object address
00000000 =FFFFE878                  shieldPtrP1	rs.w	1				; Player 1 shield address
00000000 =FFFFE87A                  invincPtrP1	rs.w	1				; Player 1 invincibility address
00000000 =FFFFE87C                  afterImgPtrP1	rs.w	1				; Player 1 after image address
00000000                            
00000000 =FFFFE87E                  playerPtrP2	rs.w	1				; Player 2 object address
00000000 =FFFFE880                  shieldPtrP2	rs.w	1				; Player 2 shield address
00000000 =FFFFE882                  invincPtrP2	rs.w	1				; Player 2 invincibility address
00000000 =FFFFE884                  afterImgPtrP2	rs.w	1				; Player 2 after image address
00000000                            
00000000 =FFFFE886                  waterObjPtr1	rs.w	1				; Water surface 1 address
00000000 =FFFFE888                  waterObjPtr2	rs.w	1				; Water surface 2 address
00000000                            
00000000 =FFFFE88A                  cameraVars	rs.b	0				; Camera RAM
00000000 =FFFFE88A                  fgCamVars	rs.b	cSize2				; Foreground variables
00000000 =FFFFE8A8                  bgCamVars	rs.b	cSize2				; Background variables
00000000                            
00000000 =FFFFE8C6                  targetMaxCamPos	rs.b	0				; Target maximum camera positions
00000000 =FFFFE8C6                  targetMaxCamX	rs.w	1				; Target maximum camera X position
00000000 =FFFFE8C8                  targetMaxCamY	rs.w	1				; Target maximum camera Y position
00000000                            
00000000 =FFFFE8CA                  maxCamPos	rs.b	0				; Maximum camera positions
00000000 =FFFFE8CA                  maxCamXPos	rs.w	1				; Maximum camera X position
00000000 =FFFFE8CC                  maxCamYPos	rs.w	1				; Maximum camera Y position
00000000                            
00000000 =FFFFE8CE                  targetMinCamPos	rs.b	0				; Target minimum camera positions
00000000 =FFFFE8CE                  targetMinCamX	rs.w	1				; Target minimum camera X position
00000000 =FFFFE8D0                  targetMinCamY	rs.w	1				; Target minimum camera Y position
00000000                            
00000000 =FFFFE8D2                  minCamPos	rs.b	0				; Minimum camera positions
00000000 =FFFFE8D2                  minCamXPos	rs.w	1				; Minimum camera X position
00000000 =FFFFE8D4                  minCamYPos	rs.w	1				; Minimum camera Y position
00000000                            
00000000 =FFFFE8D6                  panCamPos	rs.b	0
00000000 =FFFFE8D6                  panCamXPos	rs.w	1				; Camera X center
00000000 =FFFFE8D8                  panCamYPos	rs.w	1				; Distance from the player's Y position and the camera's
00000000                            
00000000 =FFFFE8DA                  camLocked	rs.b	0				; Camera locked flags
00000000 =FFFFE8DA                  camLockX	rs.b	1				; Camera locked horizontally flag
00000000 =FFFFE8DB                  camLockY	rs.b	1				; Camera locked vertically flag
00000000                            
00000000 =FFFFE8DC                  chgCamMaxY	rs.b	1				; Camera max Y position changing flag
00000000 =FFFFE8DD                  cameraVars_End	rs.b	0				; End of camera RAM
00000000                            
00000000 =FFFFE8DD                  debugMode	rs.b	1				; Debug placement mode
00000000                            
00000000 =FFFFE8DE                  plrCtrlData	rs.b	0				; Player control data
00000000 =FFFFE8DE                  plrCtrlHold	rs.b	1				; Player control held button data
00000000 =FFFFE8DF                  plrCtrlPress	rs.b	1				; Player control pressed button data
00000000                            
00000000 =FFFFE8E0                  lvlMusic	rs.b	1				; Level music ID
00000000 =FFFFE8E1                  bossMusic	rs.b	1				; Boss music ID
00000000                            
00000000 =FFFFE8E2                  primaryColPtr	rs.l	1				; Primary level collision data pointer
00000000 =FFFFE8E6                  secondaryColPtr	rs.l	1				; Secondary level collision data pointer
00000000                            
00000000 =FFFFE8EA                  currentColAddr	rs.l	1				; Current collsion address
00000000                            
00000000 =FFFFE8EE                  layerPosition	rs.w	1				; Fake layer position
00000000                            
00000000 =FFFFE8F0                  angleValPtr	rs.l	1				; Angle value array pointer
00000000 =FFFFE8F4                  normColArrayPtr	rs.l	1				; Normal height map array pointer
00000000 =FFFFE8F8                  rotColArrayPtr	rs.l	1				; Rotated height map array pointer
00000000                            
00000000 =FFFFE8FC                  got_objNextLvl	rs.b	1				; Flag to go to the next level
00000000 =FFFFE8FD                  bossDefeated	rs.b	1
00000000                            
00000000 =FFFFE8FE                  lvlHasWater	rs.b	1				; Water in level flag
00000000 =FFFFE8FF                  waterFullscr	rs.b	1				; Water fullscreen flag
00000000 =FFFFE900                  waterYPos	rs.w	1				; Water height
00000000 =FFFFE902                  destWaterYPos	rs.w	1				; Target water height
00000000                            
00000000 =FFFFE904                  lvlFrameCnt	rs.w	1				; Level frame counter
00000000 =FFFFE906                  lvlReload	rs.b	1				; Level reload flag
00000000 =FFFFE907                  timeOver	rs.b	1				; Time over flag
00000000                            
00000000 =FFFFE908                  dynEventRout	rs.b	1				; Dynamic event routine ID
00000000                            
00000000 =FFFFE909                  rFlooactIDive	rs.b	1				; Floor active flag
00000000 =FFFFE90A                  rFloorTimer	rs.w	1				; Floor timer
00000000                            
00000000 =FFFFE90C                  lvlAnimCntrs	rs.b	$10				; Level art animation counters
00000000                            
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Camera variables
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =FFFFE88A                  fgCamXPos	equ	fgCamVars+cXPos			; Camera X position
00000000 =FFFFE892                  fgCamYPos	equ	fgCamVars+cYPos			; Camera Y position
00000000 =FFFFE8A8                  bgCamXPos	equ	bgCamVars+cXPos			; Background camera X position
00000000 =FFFFE8B0                  bgCamYPos	equ	bgCamVars+cYPos			; Background camera Y position
00000000 =FFFFE8A6                  fgRedraw	equ	fgCamVars+cRedraw		; Foreground redraw flag
00000000 =FFFFE8C4                  bgRedraw	equ	bgCamVars+cRedraw		; Background redraw flag
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Variables for the vector table
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =FFFFC74C                  vInterrupt	equ	vIntJump			; V-INT
00000000 =FFFFC752                  hInterrupt	equ	hIntJump			; H-INT
00000000                            ; =========================================================================================================================================================
00000000                            
00000000                            		include	"Config/Error/debugger.asm"	; Debugger macro set
00000000                            ; ===============================================================
00000000                            ; ---------------------------------------------------------------
00000000                            ; Error handling and debugging modules
00000000                            ; 2016-2017, Vladikcomper
00000000                            ; ---------------------------------------------------------------
00000000                            ; Debugging macros definitions file
00000000                            ; ---------------------------------------------------------------
00000000                            
00000000 =00000001                  isAMPS =		1		; Set to 1
00000000                            ; ===============================================================
00000000                            ; ---------------------------------------------------------------
00000000                            ; Constants
00000000                            ; ---------------------------------------------------------------
00000000                            
00000000                            ; ----------------------------
00000000                            ; Arguments formatting flags
00000000                            ; ----------------------------
00000000                            
00000000                            ; General arguments format flags
00000000 =00000080                  hex		equ		$80				; flag to display as hexadecimal number
00000000 =00000090                  dem		equ		$90				; flag to display as decimal number
00000000 =000000A0                  bin		equ		$A0				; flag to display as binary number
00000000 =000000B0                  sym		equ		$B0				; flag to display as symbol (treat as offset, decode into symbol +displacement, if present)
00000000 =000000C0                  fsymdisp	equ		$C0				; flag to display as symbol's displacement alone (DO NOT USE, unless complex formatting is required, see notes below)
00000000 =000000DF                  fstr		equ		$DF				; flag to display as string (treat as offset, insert string from that offset)
00000000 =000000D0                  fasm		equ		$D0				; flag to display as code (treat as offset, decode from that offset)
00000000                            
00000000                            ; NOTES:
00000000                            ;	* By default, the "sym" flag displays both symbol and displacement (e.g.: "Map_Sonic+$2E")
00000000                            ;		In case, you need a different formatting for the displacement part (different text color and such),
00000000                            ;		use "sym|split", so the displacement won't be displayed until symdisp is met
00000000                            ;	* The "symdisp" can only be used after the "sym|split" instance, which decodes offset, otherwise, it'll
00000000                            ;		display a garbage offset.
00000000                            ;	* No other argument format flags (hex, dec, bin, str) are allowed between "sym|split" and "symdisp",
00000000                            ;		otherwise, the "symdisp" results are undefined.
00000000                            ;	* When using "str" flag, the argument should point to string offset that will be inserted.
00000000                            ;		Arguments format flags CAN NOT be used in the string (as no arguments are meant to be here),
00000000                            ;		only console control flags (see below).
00000000                            ;	* The "asm" flag will use "setpat" flag to switch text color, and will reset pattern to normal again.
00000000                            ;		you must reapply any pattern you used before yourself.
00000000                            ;	* The "asm" flag will overwrite $FF0000-$FF0080, so be careful when viewing RAM.
00000000                            
00000000                            
00000000                            ; Additional flags ...
00000000                            ; ... for number formatters (hex, dec, bin)
00000000 =00000008                  signed	equ		8				; treat number as signed (display + or - before the number depending on sign)
00000000                            
00000000                            ; ... for symbol formatter (sym)
00000000 =00000008                  fsplit	equ		8				; DO NOT write displacement (if present), skip and wait for "symdisp" flag to write it later (optional)
00000000 =00000004                  forced	equ		4				; display "<unknown>" if symbol was not found, otherwise, plain offset is displayed by the displacement formatter
00000000                            
00000000                            ; ... for symbol displacement formatter (symdisp)
00000000 =00000008                  weak	equ		8				; DO NOT write plain offset if symbol is displayed as "<unknown>"
00000000                            
00000000                            ; Argument type flags:
00000000                            ; - DO NOT USE in formatted strings processed by macros, as these are included automatically
00000000                            ; - ONLY USE when writting down strings manually with DC.B
00000000 =00000000                  byte	equ		0
00000000 =00000001                  word	equ		1
00000000 =00000003                  long	equ		3
00000000                            
00000000                            ; -----------------------
00000000                            ; Console control flags
00000000                            ; -----------------------
00000000                            
00000000                            ; Plain control flags: no arguments following
00000000 =000000E0                  fendl	equ		$E0				; "End of line": flag for line break
00000000 =000000E6                  cr	equ		$E6				; "Carriage return": jump to the beginning of the line
00000000 =000000E8                  fpal0	equ		$E8				; use palette line #0
00000000 =000000EA                  fpal1	equ		$EA				; use palette line #1
00000000 =000000EC                  fpal2	equ		$EC				; use palette line #2
00000000 =000000EE                  fpal3	equ		$EE				; use palette line #3
00000000                            
00000000                            ; Parametrized control flags: followed by 1-byte argument
00000000 =000000F0                  setw	equ		$F0				; set line width: number of characters before automatic line break
00000000 =000000F4                  setoff	equ		$F4				; set tile offset: lower byte of base pattern, which points to tile index of ASCII character 00
00000000 =000000F8                  setpat	equ		$F8				; set tile pattern: high byte of base pattern, which determines palette flags and $100-tile section id
00000000 =000000FA                  setx	equ		$FA				; set x-position
00000000                            ; ---------------------------------------------------------------
00000000                            ; Macros
00000000                            ; ---------------------------------------------------------------
00000000                            
00000000                            RaiseError &
00000000                            	pea		*(pc)
00000000                            	RaiseError2 \_
00000000                            	endm
00000000                            
00000000                            RaiseError2 &
00000000                            	move.w	sr, -(sp)
00000000                            	__FSTRING_GenerateArgumentsCode \string
00000000                            	jsr		ErrorHandler
00000000                            	__FSTRING_GenerateDecodedString \string
00000000                            	if strlen("\console_program")			; if console program offset is specified ...
00000000                            		dc.b	\opts+_eh_enter_console|(((*&1)^1)*_eh_align_offset)	; add flag "_eh_align_offset" if the next byte is at odd offset ...
00000000                            		even															; ... to tell Error handler to skip this byte, so it'll jump to ...
00000000                            		jmp		\console_program										; ... an aligned "jmp" instruction that calls console program itself
00000000                            	else
00000000                            		dc.b	\opts+0						; otherwise, just specify \opts for error handler, +0 will generate dc.b 0 ...
00000000                            		even								; ... in case \opts argument is empty or skipped
00000000                            	endc
00000000                            	even
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------
00000000                            Console &
00000000                            	if strcmp("\0","write")|strcmp("\0","writeline")
00000000                            		move.w	sr, -(sp)
00000000                            		__FSTRING_GenerateArgumentsCode \1
00000000                            		movem.l	a0-a2/d7, -(sp)
00000000                            		if (__sp>0)
00000000                            			lea	4*4(sp), a2
00000000                            		endc
00000000                            		lea	.str\@(pc), a1
00000000                            		jsr	ErrorHandler.__global__console_\0\_formatted
00000000                            		movem.l	(sp)+, a0-a2/d7
00000000                            		if (__sp>8)
00000000                            			lea	__sp(sp), sp
00000000                            		elseif (__sp>0)
00000000                            			addq.w	#__sp, sp
00000000                            		endc
00000000                            		move.w	(sp)+, sr
00000000                            		bra.w	.instr_end\@
00000000                            	.str\@:
00000000                            		__FSTRING_GenerateDecodedString \1
00000000                            		even
00000000                            	.instr_end\@:
00000000                            	elseif strcmp("\0","run")
00000000                            		jsr	ErrorHandler.__extern__console_only
00000000                            		jsr	\1
00000000                            		if narg<=1		; HACK
00000000                            			bra.s	*
00000000                            		endif
00000000                            	elseif strcmp("\0","setxy")
00000000                            		move.w	sr, -(sp)
00000000                            		movem.l	d0-d1, -(sp)
00000000                            		move.w	\2, -(sp)
00000000                            		move.w	\1, -(sp)
00000000                            		jsr	ErrorHandler.__global__console_setposasxy_stack
00000000                            		addq.w	#4, sp
00000000                            		movem.l	(sp)+, d0-d1
00000000                            		move.w	(sp)+, sr
00000000                            	elseif strcmp("\0","breakline")
00000000                            		move.w	sr, -(sp)
00000000                            		jsr	ErrorHandler.__global__console_startnewline
00000000                            		move.w	(sp)+, sr
00000000                            	else
00000000                            		inform	2,"""\0"" isn't a member of ""Console"""
00000000                            	endc
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------
00000000                            __ErrorMessage &
00000000                            		__FSTRING_GenerateArgumentsCode \string
00000000                            		jsr	ErrorHandler
00000000                            		__FSTRING_GenerateDecodedString \string
00000000                            		dc.b	\opts+0
00000000                            		even
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------
00000000                            __FSTRING_GenerateArgumentsCode &
00000000                            	__pos:	set 	instr(\string,'%<')		; token position
00000000                            	__stack:set		0						; size of actual stack
00000000                            	__sp:	set		0						; stack displacement
00000000                            	; Parse string itself
00000000                            	while (__pos)
00000000                            		; Retrive expression in brackets following % char
00000000                                	__endpos:	set		instr(__pos+1,\string,'>')
00000000                                	__midpos:	set		instr(__pos+5,\string,' ')
00000000                                	if (__midpos<1)|(__midpos>__endpos)
00000000                            			__midpos: = __endpos
00000000                                	endc
00000000                            		__substr:	substr	__pos+1+1,__endpos-1,\string			; .type ea param
00000000                            		__type:		substr	__pos+1+1,__pos+1+1+1,\string			; .type
00000000                            		; Expression is an effective address (e.g. %(.w d0 hex) )
00000000                            		if "\__type">>8="."
00000000                            			__operand:	substr	__pos+1+1,__midpos-1,\string			; .type ea
00000000                            			__param:	substr	__midpos+1,__endpos-1,\string			; param
00000000                            			if "\__type"=".b"
00000000                            				pushp	"move\__operand\,1(sp)"
00000000                            				pushp	"subq.w	#2, sp"
00000000                            				__stack: = __stack+2
00000000                            				__sp: = __sp+2
00000000                            			elseif "\__type"=".w"
00000000                            				pushp	"move\__operand\,-(sp)"
00000000                            				__stack: = __stack+1
00000000                            				__sp: = __sp+2
00000000                            			elseif "\__type"=".l"
00000000                            				pushp	"move\__operand\,-(sp)"
00000000                            				__stack: = __stack+1
00000000                            				__sp: = __sp+4
00000000                            			else
00000000                            				fatal 'Unrecognized type in string operand: %<\__substr>'
00000000                            			endc
00000000                            		endc
00000000                            		__pos:	set		instr(__pos+1,\string,'%<')
00000000                            	endw
00000000                            	; Generate stack code
00000000                            	rept __stack
00000000                            		popp	__command
00000000                            		\__command
00000000                            	endr
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------
00000000                            __FSTRING_GenerateDecodedString &
00000000                            	__lpos:	set		1						; start position
00000000                            	__pos:	set 	instr(\string,'%<')		; token position
00000000                            	while (__pos)
00000000                            		; Write part of string before % token
00000000                            		__substr:	substr	__lpos,__pos-1,\string
00000000                            		dc.b	"\__substr"
00000000                            		; Retrive expression in brakets following % char
00000000                                	__endpos:	set		instr(__pos+1,\string,'>')
00000000                                	__midpos:	set		instr(__pos+5,\string,' ')
00000000                                	if (__midpos<1)|(__midpos>__endpos)
00000000                            			__midpos: = __endpos
00000000                                	endc
00000000                            		__type:		substr	__pos+1+1,__pos+1+1+1,\string			; .type
00000000                            		; Expression is an effective address (e.g. %<.w d0 hex> )
00000000                            		if "\__type">>8="."
00000000                            			__param:	substr	__midpos+1,__endpos-1,\string			; param
00000000                            			if strlen("\__param")<1
00000000                            				__param: substr ,,"hex"			; if param is ommited, set it to "hex"
00000000                            			endc
00000000                            			if "\__type"=".b"
00000000                            				dc.b	\__param
00000000                            			elseif "\__type"=".w"
00000000                            				dc.b	\__param|1
00000000                            			else
00000000                            				dc.b	\__param|3
00000000                            			endc
00000000                            		; Expression is an inline constant (e.g. %<endl> )
00000000                            		else
00000000                            			__substr:	substr	__pos+1+1,__endpos-1,\string
00000000                            			dc.b	\__substr
00000000                            		endc
00000000                            		__lpos:	set		__endpos+1
00000000                            		__pos:	set		instr(__pos+1,\string,'%<')
00000000                            	endw
00000000                            	; Write part of string before the end
00000000                            	__substr:	substr	__lpos,,\string
00000000                            	dc.b	"\__substr"
00000000                            	dc.b	0
00000000                            	endm
00000000                            		
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Header
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		include	"Config/Header.asm"
00000000                            ; =========================================================================================================================================================
00000000                            ; MegaDrive Header
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Based on MarkeyJester's shortened header and initialization
00000000                            ; =========================================================================================================================================================
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Store a string in memory with a character limit (also pads to that limit if it doesn't exceed it)
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	string	- The string
00000000                            ;	limit	- character limit
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            headStr		macro	string, limit
00000000                            		local	p
00000000                            p =		*
00000000                            		dcb.b	\limit, " "
00000000                            		org	p
00000000                            		dc.b	\string
00000000                            		org	p+\limit
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		org	0
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Vector table
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 F0A1 000C                  		dc.l	($F0<<24)|PORT_C_CTRL-1		; Stack pointer (set like so for initialization routine) (also manufacture lineF exception)
00000004                            
00000004 0000 0000                  		dc.l	.PrgInit			; Entry pointer
00000008                            
00000008 0000 0000                  		dc.l	exBus				; Bus error
0000000C 0000 0000                  		dc.l	exAddr				; Address error
00000010 0000 0000                  		dc.l	exIll				; Illegal instruction error
00000014 0000 0000                  		dc.l	exDiv				; Division by zero error
00000018 0000 0000                  		dc.l	exChk				; CHK out of bounds error
0000001C 0000 0000                  		dc.l	Trapv				; TRAPV interrupt
00000020 0000 0000                  		dc.l	exPriv				; Privilege violation error
00000024 0000 0000                  		dc.l	exTrace				; TRACE interrupt
00000028 0000 0000                  		dc.l	exLineA				; Line A emulation
0000002C 0000 0000                  		dc.l	exLineF				; Line F emulation
00000030                            
00000030 0017                       .InitVals:	dc.w	$18-1				; Number of registers to set up
00000032 8004                       		dc.w	$8004				; VDP register base (preset for register 0 - H-INT disabled)
00000034 0100                       		dc.w	$100				; Register increment (also used for Z80 later)
00000036                            
00000036 34                         		dc.b	$34				; DMA enabled, V-INT enabled
00000037 30                         		dc.b	$C000/$400			; Plane A at $C000
00000038 34                         		dc.b	$D000/$400			; Plane W at $D000
00000039 07                         		dc.b	$E000/$2000			; Plane B at $E000
0000003A 7C                         		dc.b	$F800/$200			; Sprite table at $F800
0000003B 00                         		dc.b	$00				; Unused
0000003C 00                         		dc.b	$00				; BG color line 0 entry 0
0000003D 00                         		dc.b	$00				; Unused
0000003E 00                         		dc.b	$00				; Unused
0000003F FF                         		dc.b	$FF				; H-INT every 255th line
00000040 00                         		dc.b	$00				; EXT-INT off, VScroll by screen, HScroll by screen
00000041 81                         		dc.b	$81				; H40 width, interalce disabled, S/H disabled
00000042 3F                         		dc.b	$FC00/$400			; HScroll table at $FC00
00000043 00                         		dc.b	$00				; Unused
00000044 02                         		dc.b	$02				; Autoincrement by 2
00000045 01                         		dc.b	$01				; Plane size 64x32
00000046 00                         		dc.b	$00				; Disable window
00000047 00                         		dc.b	$00				; ''
00000048 FF                         		dc.b	$FF				; DMA length $FFFF
00000049 FF                         		dc.b	$FF				; ''
0000004A 00                         		dc.b	$00				; DMA source 0
0000004B 00                         		dc.b	$00				; ''
0000004C 80                         		dc.b	$80				; '' + VRAM fill mode
0000004D                            
0000004D 40                         		dc.b	$40				; Port initialization value
0000004E                            
0000004E                            		vdpCmd	dc.l,0,VRAM,DMA			; VDP DMA at $0000
0000004E 4000 0080                M 	dc.l	((((vram&dma)&3)<<30)|((0&$3fff)<<16)|(((vram&dma)&$fc)<<2)|((0&$c000)>>14))
00000052                            
00000052 000E 1FFD                  		dc.w	$E, $2000-2-1			; Checksum error color, amount of Z80 to clear
00000056 00A0 0000                  		dc.l	Z80_RAM				; Z80 RAM
0000005A 00A1 1100                  		dc.l	Z80_BUS_REQ			; Z80 bus request
0000005E 00A1 1200                  		dc.l	Z80_RESET			; Z80 reset
00000062                            
00000062                            		vdpCmd	dc.l,0,CRAM,WRITE		; CRAM WRITE at $0000
00000062 C000 0000                M 	dc.l	((((cram&write)&3)<<30)|((0&$3fff)<<16)|(((cram&write)&$fc)<<2)|((0&$c000)>>14))
00000066                            		vdpCmd	dc.l,0,VSRAM,WRITE		; VSRAM WRITE at $0000
00000066 4000 0010                M 	dc.l	((((vsram&write)&3)<<30)|((0&$3fff)<<16)|(((vsram&write)&$fc)<<2)|((0&$c000)>>14))
0000006A                            
0000006A 9FBF DFFF                  		dc.b	$9F, $BF, $DF, $FF		; PSG mute values
0000006E                            
0000006E F3C3                       		dc.b	$F3, $C3			; di and jp instructions for Z80
00000070                            
00000070 FFFF C752                  		dc.l	hInterrupt			; Horizontal interrupt
00000074 00C0 0000                  .VDPDPort:	dc.l	VDP_DATA			; Interrupt level 5
00000078 FFFF C74C                  		dc.l	vInterrupt			; Vertical interrupt
0000007C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000007C                            ; Program initialization
0000007C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000007C                            ICD_BLK		EQU	.PrgInit
0000007C                            .PrgInit:
0000007C                            		intsOff
0000007C 007C 0700                M 	ori	#$700,sr
00000080                            
00000080                            		; --- CHECK WARM BOOT ---
00000080                            
00000080 4A57                       		tst.w	(sp)				; Has port C been initialized already?
00000082 6600 0000                  		bne.w	.WarmBoot			; If so, branch
00000086                            
00000086 7800                       		moveq	#0,d4				; Register that holds 0
00000088 7C00                       		moveq	#0,d6				; Checksum value
0000008A                            
0000008A                            		; --- CHECK TMSS ---
0000008A                            
0000008A 162F FFF5                  		move.b	-$B(sp),d3			; Get hardware version
0000008E E903                       		asl.b	#4,d3				; ''
00000090 6700                       		beq.s	.NoTMSS				; If this is a non-TMSS system, branch
00000092 2F78 0100 3FF4             		move.l	$100.w,$3FF4(sp)		; Satisfy the TMSS
00000098                            
00000098                            .NoTMSS:
00000098                            
00000098                            		; --- SET UP VDP REGISTERS ---
00000098                            
00000098 2A78 0074                  		movea.l	.VDPDPort.w,a5			; VDP data port
0000009C 4DED 0004                  		lea	4(a5),a6			; VDP control port
000000A0                            
000000A0                            .WaitDMA:
000000A0 44D6                       		move.w	(a6),ccr			; Load status
000000A2 69FC                       		bvs.s	.WaitDMA			; If there's a DMA, wait
000000A4                            
000000A4 41F8 0030                  		lea	.InitVals.w,a0			; VDP registers
000000A8 4C98 0026                  		movem.w	(a0)+,d1/d2/d5			; Get number of entries, register base, and register increment
000000AC                            
000000AC                            .InitVDPRegs:
000000AC 3C82                       		move.w	d2,(a6)				; Set register data
000000AE D445                       		add.w	d5,d2				; Next register
000000B0 1418                       		move.b	(a0)+,d2			; Get register data
000000B2 51C9 FFF8                  		dbf	d1,.InitVDPRegs			; Loop
000000B6                            
000000B6                            		; --- CLEAR VRAM ---
000000B6                            
000000B6 2C98                       		move.l	(a0)+,(a6)			; Set DMA fill destination
000000B8 3C84                       		move.w	d4,(a6)				; Set DMA fill value
000000BA                            
000000BA                            		; --- CLEAR RAM ---
000000BA                            
000000BA 2444                       		movea.l	d4,a2				; End of RAM
000000BC 323C 3FFF                  		move.w	#(RAM_END-RAM_START)>>2-1,d1	; Longwords to clear
000000C0                            
000000C0                            .ClearRAM:
000000C0 2504                       		move.l	d4,-(a2)			; Clear RAM
000000C2 51C9 FFFC                  		dbf	d1,.ClearRAM			; Loop
000000C6                            
000000C6                            		; --- SET UP FOR Z80 ---
000000C6                            
000000C6 4CD8 1A01                  		movem.l	(a0)+,d0/a1/a3/a4		; Load Z80 addresses and values
000000CA 3685                       		move.w	d5,(a3)				; Request Z80 stop
000000CC                            
000000CC                            		; --- CLEAR CRAM AND VSRAM AND INITIALIZE JOYPADS ---
000000CC                            
000000CC 4441                       		neg.w	d1				; Run the next bit 2 times
000000CE                            
000000CE                            .InitVDPJoypads:
000000CE 2C98                       		move.l	(a0)+,(a6)			; Set VDP command
000000D0 761F                       		moveq	#$80>>2-1,d3			; Longwords to clear
000000D2                            
000000D2                            .ClearVDPMem:
000000D2 2A84                       		move.l	d4,(a5)				; Clear memory
000000D4 51CB FFFC                  		dbf	d3,.ClearVDPMem			; Loop
000000D8 3F02                       		move.w	d2,-(sp)			; Initialize port
000000DA 51C9 FFF2                  		dbf	d1,.InitVDPJoypads		; Loop
000000DE                            
000000DE 3885                       		move.w	d5,(a4)				; Cancel Z80 reset
000000E0                            
000000E0                            		; --- MUTE PSG ---
000000E0                            
000000E0 7603                       		moveq	#4-1,d3				; Number of PSG channels
000000E2                            
000000E2                            .MutePSG:
000000E2 1D58 000D                  		move.b	(a0)+,$D(a6)			; Mute channel
000000E6 51CB FFFA                  		dbf	d3,.MutePSG			; Loop
000000EA                            
000000EA                            		; --- INITIALIZE Z80 ---
000000EA                            
000000EA 12D8                       		move.b	(a0)+,(a1)+			; Write di (disable Z80 interrupts)
000000EC 12D8                       		move.b	(a0)+,(a1)+			; Write jp (Will end up just looping forever at the beginning)
000000EE                            
000000EE                            .ClearZ80:
000000EE 12C4                       		move.b	d4,(a1)+			; Clear Z80
000000F0 51C8 FFFC                  		dbf	d0,.ClearZ80			; Loop
000000F4                            
000000F4 3884                       		move.w	d4,(a4)				; Reset the Z80
000000F6                            
000000F6                            		; --- CHECK THE CHECKSUM ---
000000F6                            
000000F6 41F8 0200                  		lea	$200.w,a0			; Start reading data at the end of the header
000000FA 2238 01A4                  		move.l	$1A4.w,d1			; Get ROM end address
000000FE                            
000000FE 6000                       		bra.s	.ChkChecksum			; Continue
00000100                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000100                            ; Header
00000100                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000100 5345 4741                  		dc.b	"SEGA"				; Hardware system ID
00000104                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000104                            ; Program initialization (part 2)
00000104                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000104                            .ChkChecksum:
00000104 DC58                       		add.w	(a0)+,d6			; Add ROM data to the checksum value
00000106 B288                       		cmp.l	a0,d1				; Are we at the end of the ROM?
00000108 64FA                       		bcc.s	.ChkChecksum			; If not, keep adding
0000010A BC78 018E                  		cmp.w	$18E.w,d6			; Is the checksum correct?
0000010E 6700                       		beq.s	.ChksumPassed			; If not, branch
00000110                            
00000110                            .ChksumError:
00000110                            		vdpCmd	move.l,0,CRAM,WRITE,(a6)	; Set background to red
00000110 2CBC C000 0000           M 	move.l	#((((cram&write)&3)<<30)|((0&$3fff)<<16)|(((cram&write)&$fc)<<2)|((0&$c000)>>14)),(a6)
00000116 2A80                       		move.l	d0,(a5)				; ''
00000118 60F6                       		bra.s	.ChksumError			; Loop here forever
0000011A                            
0000011A                            .ChksumPassed:
0000011A 3885                       		move.w	d5,(a4)				; Cancel Z80 reset
0000011C 3684                       		move.w	d4,(a3)				; Start the Z80
0000011E                            
0000011E                            		; --- FINISH I/O INITIALIZATION ---
0000011E                            
0000011E 3F42 0004                  		move.w	d2,4(sp)			; Initialize port C
00000122                            
00000122                            .WarmBoot:
00000122 4FF8 0000                  		lea	stack.w,sp		; Set the stack pointer
00000126 4CD4 7FFF                  		movem.l	(a4),d0-a6			; Clear registers
0000012A                            
0000012A 4EF9 0000 0000             		jmp	GameInit			; Go to the game initialization
00000130                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000130                            ; Header (part 2)
00000130                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000130                            		headStr	"\NOTES", $20			; Notes
00000130                          M 	local	p
00000130 =00000130                M p	=	*
00000130 2020 2020 2020 2020 2020+M 	dcb.b	$20," "
00000150                          M 	org	p
00000130                          M 	dc.b	""
00000130                          M 	org	p+$20
00000150                            		headStr	"\GAME_NAME", $30		; International game name
00000150                          M 	local	p
00000150 =00000150                M p	=	*
00000150 2020 2020 2020 2020 2020+M 	dcb.b	$30," "
00000180                          M 	org	p
00000150 4865 6467 6562 7265 7720+M 	dc.b	"Hedgebrew Engine Project                        "
00000180                          M 	org	p+$30
00000180 474D 2030 3030 3030 3030+  		dc.b	"GM 00000000-00"		; Version
0000018E 0000                       		dc.w	0				; Checksum value (replaced by external program)
00000190                            		headStr	"\IO_SUPPORT", $10		; I/O support
00000190                          M 	local	p
00000190 =00000190                M p	=	*
00000190 2020 2020 2020 2020 2020+M 	dcb.b	$10," "
000001A0                          M 	org	p
00000190 4A                       M 	dc.b	"J"
00000191                          M 	org	p+$10
000001A0 0000 0000 003F FFFF        		dc.l	ROM_START, ROM_END-1		; ROM start and end addresses (replaced by external program)
000001A8 00FF 0000 00FF FFFF        		dc.l	RAM_START, RAM_END-1		; RAM start and end addresses
000001B0 2020 2020                  		dc.l	SRAM_SUPPORT			; SRAM support
000001B4 2020 2020 2020 2020        		dc.l	SRAM_START, SRAM_END		; SRAM start and end addresses
000001BC                            ; =========================================================================================================================================================
000001BC                            
000001BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000001BC                            ; Entry point
000001BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000001BC                            GameInit:
000001BC                            		intsOff						; Disable interrupts
000001BC 007C 0700                M 	ori	#$700,sr
000001C0                            		
000001C0                            		clrRAM	RAM_START, RAM_END			; Clear RAM
000001C0                          M 	local	endaddr
000001C0                          M endaddr	equs	"ram_end"
000001C0 7000                     M 	moveq	#0,d0
000001C2 43F9 00FF 0000           M 	lea	ram_start,a1
000001C8 323C 3FFF                M 	move.w	#(((ram_end)-(ram_start))-((ram_start)&1))>>2-1,d1
000001CC 22C0                     M .clear_22:	move.l	d0,(a1)+
000001CE 51C9 FFFC                M 	dbf	d1,.clear_22
000001D2                            		
000001D2 6100 0000                  		bsr.w	InitDMAQueue				; Initialize the DMA queue
000001D6 6100 0000                  		bsr.w	InitVDP					; Initialize the VDP
000001DA 4EB9 0000 0000             		jsr	LoadDualPCM				; Load Dual PCM
000001E0                            		
000001E0 1039 00A1 0001             		move.b	HW_VERSION,d0				; Get hardware version
000001E6 0200 00C0                  		andi.b	#$C0,d0					; Just get region bits
000001EA 11C0 C746                  		move.b	d0,hwVersion.w				; Store in RAM
000001EE                            
000001EE 303C 4EF9                  		move.w	#$4EF9,d0				; JMP opcode
000001F2 31C0 C74C                  		move.w	d0,vIntJump.w				; Set the "JMP" command for V-INT
000001F6 31C0 C752                  		move.w	d0,hIntJump.w				; Set the "JMP" command for H-INT
000001FA 21FC 0000 0000 C74E        		move.l	#VInt_Standard,vIntAddress.w		; Set the V-INT pointer to the standard V-INT routine
00000202 21FC 0000 0000 C754        		move.l	#HInt_Water,hIntAddress.w			; Set the H-INT pointer to the standard V-INT routine
0000020A                            
0000020A 4278 9000                  		clr.w	dmaQueue.w				; Set stop token at the beginning of the DMA queue
0000020E 31FC 9000 90FC             		move.w	#dmaQueue,dmaSlot.w			; Reset the DMA queue slot
00000214                            
00000214 11FC 0000 C75C             		move.b	#gTitle,opmode.w			; Set game mode to "title"
0000021A 4EF9 0000 0000             		jmp	TitleScreen					; Go to the title screen
00000220                            
00000220                            ; =========================================================================================================================================================
00000220                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000220                            ; Go to the correct game mode
00000220                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000220                            GotoGameMode:
00000220 7000                       		moveq	#0,d0
00000222 1038 C75C                  		move.b	opmode.w,d0				; Get game mode ID
00000226 207B 0000                  		movea.l	.GameModes(pc,d0.w),a0			; Get pointer
0000022A 4ED0                       		jmp	(a0)					; Jump to it
0000022C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000022C                            .GameModes:
0000022C 0000 0000                  		dc.l	TitleScreen				; Title screen
00000230 0000 0000                  		dc.l	Level					; Level mode
00000234 0000 0000                  		dc.l	Ending					; Ending
00000238                            
00000238                            ; =========================================================================================================================================================
00000238                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000238                            ; Function libraries
00000238                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000238                            		include	"Libraries/VDP.asm"		; VDP functions
00000238                            ; =========================================================================================================================================================
00000238                            ; VDP functions
00000238                            ; =========================================================================================================================================================
00000238                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000238                            ; Initialize the VDP
00000238                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000238                            ; PARAMETERS:
00000238                            ;	Nothing
00000238                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000238                            ; RETURNS:
00000238                            ;	Nothing
00000238                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000238                            InitVDP:
00000238 31FC 8134 C766             		move.w	#$8134,vdpReg1.w		; Save VDP register 1 in RAM
0000023E 31FC 8AFF C760             		move.w	#$8AFF,hIntCntReg.w		; Save H-INT counter register in RAM
00000244                            
00000244 6000 0000                  		bra.w	InitSpriteTable			; Initialize the sprite table
00000248                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000248                            ; Clear the screen and other VDP data (64 tile width)
00000248                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000248                            ; PARAMETERS:
00000248                            ;	Nothing
00000248                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000248                            ; RETURNS:
00000248                            ;	Nothing
00000248                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000248                            ClearScreen:
00000248 4DF9 00C0 0004             		lea	VDP_CTRL,a6			; VDP control port
0000024E                            		dmaFill	0,$C000,$3000			; Clear planes
0000024E 3CBC 8F01                M 	move.w	#$8f01,(a6)
00000252 2CBC 942F 93FF           M 	move.l	#$94009300|(((($3000)-1)&$ff00)<<8)|((($3000)-1)&$ff),(a6)
00000258 3CBC 9780                M 	move.w	#$9780,(a6)
0000025C 2CBC 4000 0083           M 	move.l	#$40000080|((($c000)&$3fff)<<16)|((($c000)&$c000)>>14),(a6)
00000262 3D7C 0000 FFFC           M 	move.w	#(0)<<8,-4(a6)
00000268                          M 	waitdma	(a6)
00000268                          M .wait_24:
00000268 3216                     M 	move.w	(a6),d1
0000026A 0801 0001                M 	btst	#1,d1
0000026E 66F8                     M 	bne.s	.wait_24
00000270 3CBC 8F02                M 	move.w	#$8f02,(a6)
00000274                            
00000274                            		clrRAM	hScrollBuff, vScrollBuff_End	; Clear scroll tables
00000274                          M 	local	endaddr
00000274                          M endaddr	equs	"vscrollbuff_end"
00000274 7000                     M 	moveq	#0,d0
00000276 43F8 90FE                M 	lea	(hscrollbuff).w,a1
0000027A 323C 00F3                M 	move.w	#(((vscrollbuff_end)-(hscrollbuff))-((hscrollbuff)&1))>>2-1,d1
0000027E 22C0                     M .clear_25:	move.l	d0,(a1)+
00000280 51C9 FFFC                M 	dbf	d1,.clear_25
00000284                            		
00000284 6000 0000                  		bra.w	InitSpriteTable			; Initialize the sprite table
00000288                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000288                            ; Load a plane map
00000288                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000288                            ; PARAMETERS:
00000288                            ;	d0.l	- VDP command for writing the data to VRAM
00000288                            ;	d1.w	- Width in tiles (minus 1)
00000288                            ;	d2.w	- Height in tiles (minus 1)
00000288                            ;	d3.w	- Base tile properties for each tile
00000288                            ;	d6.l	- Delta value for drawing to the next row (only required for just LoadPlaneMap_Custom)
00000288                            ;	a1.l	- Plane map address
00000288                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000288                            ; RETURNS:
00000288                            ;	Nothing
00000288                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000288                            LoadPlaneMap:
00000288                            LoadPlaneMap_H64:
00000288 2C3C 0080 0000             		move.l	#$800000,d6			; For planes with 64 tile width
0000028E 6000                       		bra.s	LoadPlaneMap_Custom		; Load the map
00000290                            
00000290                            LoadPlaneMap_H32:
00000290 2C3C 0040 0000             		move.l	#$400000,d6			; For planes with 32 tile width
00000296 6000                       		bra.s	LoadPlaneMap_Custom		; Load the map
00000298                            
00000298                            LoadPlaneMap_H128:
00000298 2C3C 0100 0000             		move.l	#$1000000,d6			; For planes with 128 tile width
0000029E                            
0000029E                            LoadPlaneMap_Custom:
0000029E                            .RowLoop:
0000029E 23C0 00C0 0004             		move.l	d0,VDP_CTRL			; Set VDP command
000002A4 3801                       		move.w	d1,d4				; Store width
000002A6                            
000002A6                            .TileLoop:
000002A6 3A19                       		move.w	(a1)+,d5			; Get tile ID and properties
000002A8 DA43                       		add.w	d3,d5				; Add base tile properties
000002AA 33C5 00C0 0000             		move.w	d5,VDP_DATA			; Save in VRAM
000002B0 51CC FFF4                  		dbf	d4,.TileLoop			; Loop until the row has been drawn
000002B4 D086                       		add.l	d6,d0				; Next row
000002B6 51CA FFE6                  		dbf	d2,.RowLoop			; Loop until the plane has been drawn
000002BA 4E75                       		rts
000002BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000002BC                            ; Load a plane map into RAM
000002BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000002BC                            ; PARAMETERS:
000002BC                            ;	d1.w	- Width in tiles (minus 1)
000002BC                            ;	d2.w	- Height in tiles (minus 1)
000002BC                            ;	d3.w	- Base tile properties for each tile
000002BC                            ;	d6.l	- Delta value for drawing to the next row (only required for just LoadPlaneMap_Custom)
000002BC                            ;	a0.l	- Buffer to load into
000002BC                            ;	a1.l	- Plane map address
000002BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000002BC                            ; RETURNS:
000002BC                            ;	Nothing
000002BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000002BC                            LoadPlaneMap_RAM:
000002BC                            .RowLoop:
000002BC 2448                       		movea.l	a0,a2				; Copy buffer address
000002BE 3801                       		move.w	d1,d4				; Store width
000002C0                            
000002C0                            .TileLoop:
000002C0 3A19                       		move.w	(a1)+,d5			; Get tile ID and properties
000002C2 DA43                       		add.w	d3,d5				; Add base tile properties
000002C4 34C5                       		move.w	d5,(a2)+			; Save in RAM
000002C6 51CC FFF8                  		dbf	d4,.TileLoop			; Loop until the row has been drawn
000002CA D0FC 0080                  		adda.w	#$80,a0				; Next row
000002CE 51CA FFEC                  		dbf	d2,.RowLoop			; Loop until the plane has been drawn
000002D2 4E75                       		rts
000002D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000002D4                            ; Fill the plane map with a value in a specific region
000002D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000002D4                            ; PARAMETERS:
000002D4                            ;	d0.l	- VDP command for writing the data to VRAM
000002D4                            ;	d1.w	- Width in tiles (minus 1)
000002D4                            ;	d2.w	- Height in tiles (minus 1)
000002D4                            ;	d3.w	- Value to fill plane map with
000002D4                            ;	d6.l	- Delta value for drawing to the next row
000002D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000002D4                            ; RETURNS:
000002D4                            ;	Nothing
000002D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000002D4                            FillPlaneMap:
000002D4                            FillPlaneMap_H64:
000002D4 2C3C 0080 0000             		move.l	#$800000,d6			; For planes with 64 tile width
000002DA 6000                       		bra.s	FillPlaneMap_Custom		; Fill the map
000002DC                            
000002DC                            FillPlaneMap_H32:
000002DC 2C3C 0040 0000             		move.l	#$400000,d6			; For planes with 32 tile width
000002E2 6000                       		bra.s	FillPlaneMap_Custom		; Fill the map
000002E4                            
000002E4                            FillPlaneMap_H128:
000002E4 2C3C 0100 0000             		move.l	#$1000000,d6			; For planes with 128 tile width
000002EA                            
000002EA                            FillPlaneMap_Custom:
000002EA                            .RowLoop:
000002EA 23C0 00C0 0004             		move.l	d0,VDP_CTRL			; Set VDP command
000002F0 3801                       		move.w	d1,d4				; Store width
000002F2                            
000002F2                            .TileLoop:
000002F2 33C3 00C0 0000             		move.w	d3,VDP_DATA			; Save value in VRAM
000002F8 51CC FFF8                  		dbf	d4,.TileLoop			; Loop until the row has been drawn
000002FC D086                       		add.l	d6,d0				; Next row
000002FE 51CA FFEA                  		dbf	d2,.RowLoop			; Loop until the plane has been drawn
00000302 4E75                       		rts
00000304                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000304                            ; Queue a VDP DMA command to VRAM, to be issued the next time ProcessDMAQueue is called. Can be called a maximum of 18 times before the queue needs
00000304                            ; to be cleared by issuing the commands (this checks for overflow)
00000304                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000304                            ; PARAMETERS:
00000304                            ; 	d1.l	- Source address
00000304                            ; 	d2.w	- Destination address
00000304                            ; 	d3.w	- Transfer length
00000304                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000304                            ; RETURNS:
00000304                            ;	Nothing
00000304                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000304                            ; This option breaks DMA transfers that crosses a 128kB block into two. It is disabled by default because you can simply align the art in ROM
00000304                            ; and avoid the issue altogether. It is here so that you have a high-performance routine to do the job in situations where you can't align it in ROM.
00000304 =00000001                  Use128kbSafeDMA		= 1
00000304                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000304                            ; Option to mask interrupts while updating the DMA queue. This fixes many race conditions in the DMA funcion, but it costs 46(6/1) cycles. The
00000304                            ; better way to handle these race conditions would be to make unsafe callers (such as S3&K's KosM decoder) prevent these by masking off interrupts
00000304                            ; before calling and then restore interrupts after.
00000304 =00000000                  UseVIntSafeDMA		= 0
00000304                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000304                            ; Option to assume that transfer length is always less than $7FFF. Only makes sense if Use128kbSafeDMA is 1. Moreover, setting this to 1 will
00000304                            ; cause trouble on a 64kB DMA, so make sure you never do one if you set it to 1! Enabling this saves 4(1/0) cycles on the case where a DMA is
00000304                            ; broken in two and both transfers are properly queued, and nothing at all otherwise.
00000304 =00000000                  AssumeMax7FFFXfer	= 0&Use128kbSafeDMA
00000304                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000304                            ; Convenience macros, for increased maintainability of the code.
00000304                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000304                            ; Like vdpComm, but starting from an address contained in a register
00000304 =00000001                  vdpCommReg_defined = 1
00000304                            vdpCommReg	macro	reg, type, rwd, clr
00000304                            		local	cd
00000304                            cd		= \type&\rwd
00000304                            		lsl.l	#2,\reg				; Move high bits into (word-swapped) position, accidentally moving everything else
00000304                            		if ((cd)&3)<>0
00000304                            			addq.w	#((cd)&3),\reg		; Add upper access type bits
00000304                            		endif
00000304                            		ror.w	#2,\reg				; Put upper access type bits into place, also moving all other bits into their correct
00000304                            							; (word-swapped) places
00000304                            		swap	\reg				; Put all bits in proper places
00000304                            		if \clr<>0
00000304                            			andi.w	#3,\reg			; Strip whatever junk was in upper word of reg
00000304                            		endif
00000304                            		if ((cd)&$FC)=$20
00000304                            			tas.b	\reg			; Add in the DMA flag -- tas fails on memory, but works on registers
00000304                            		elseif ((cd)&$FC)<>0
00000304                            			ori.w	#(((cd)&$FC)*4),\reg	; Add in missing access type bits
00000304                            		endif
00000304                            		endm
00000304                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000304                            QueueDMATransfer:
00000304                            
00000304 3278 90FC                  		movea.w	dmaSlot.w,a1
00000308 B2FC 90FC                  		cmpa.w	#dmaSlot,a1
0000030C 6700                       		beq.s	.Done				; Return if there's no more room in the queue
0000030E                            
0000030E E289                       		lsr.l	#1,d1				; Source address is in words for the VDP registers
00000310                            
00000310 3003                       			move.w  d3,d0			; d0 = length of transfer in words
00000312                            			; Compute position of last transferred word. This handles 2 cases:
00000312                            			; (1) zero length DMAs transfer length actually transfer $10000 words
00000312                            			; (2) (source+length)&$FFFF = 0
00000312 5340                       			subq.w  #1,d0
00000314 D041                       			add.w   d1,d0			; d0 = ((src_address >> 1) & $FFFF) + ((xferlen >> 1) - 1)
00000316 6500                       			bcs.s   .DoubleTransfer		; Carry set = ($10000 << 1) = $20000, or new 128kB block
00000318                            
00000318                            		; Store VDP commands for specifying DMA into the queue
00000318 4841                       		swap	d1				; Want the high byte first
0000031A 303C 977F                  		move.w	#$977F,d0			; Command to specify source address & $FE0000, plus bitmask for the given byte
0000031E C001                       		and.b	d1,d0				; Mask in source address & $FE0000, stripping high bit in the process
00000320 32C0                       		move.w	d0,(a1)+			; Store command
00000322 3203                       		move.w	d3,d1				; Put length together with (source address & $01FFFE) >> 1...
00000324 03C9 0001                  		movep.l	d1,1(a1)			; ... and stuff them all into RAM in their proper places (movep for the win)
00000328 43E9 0008                  		lea	8(a1),a1			; Skip past all of these commands
0000032C                            
0000032C                            		vdpCommReg d2,VRAM,DMA,1		; Make DMA destination command
0000032C                          M 	local	cd
0000032C =00000021                M cd	=	vram&dma
0000032C E58A                     M 	lsl.l	#2,d2
0000032E 5242                     M 	addq.w	#((cd)&3),d2
00000330 E45A                     M 	ror.w	#2,d2
00000332 4842                     M 	swap	d2
00000334 0242 0003                M 	andi.w	#3,d2
00000338 4AC2                     M 	tas.b	d2
0000033A 22C2                       		move.l	d2,(a1)+			; Store command
0000033C                            
0000033C 4251                       		clr.w	(a1)				; Put a stop token at the end of the used part of the queue
0000033E 31C9 90FC                  		move.w	a1,dmaSlot.w			; Set the next free slot address, potentially undoing the above clr (this is intentional!)
00000342                            
00000342                            .Done:
00000342 4E75                       		rts
00000344                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000344                            .DoubleTransfer:
00000344                            			; Hand-coded version to break the DMA transfer into two smaller transfers
00000344                            			; that do not cross a 128kB boundary. This is done much faster (at the cost
00000344                            			; of space) than by the method of saving parameters and calling the normal
00000344                            			; DMA function twice, as Sonic3_Complete does.
00000344                            			; d0 is the number of words-1 that got over the end of the 128kB boundary
00000344 5240                       			addq.w	#1,d0			; Make d0 the number of words past the 128kB boundary
00000346 9640                       			sub.w	d0,d3			; First transfer will use only up to the end of the 128kB boundary
00000348                            
00000348                            			; Store VDP commands for specifying DMA into the queue
00000348 4841                       			swap	d1			; Want the high byte first
0000034A                            
0000034A                            			; Sadly, all registers we can spare are in use right now, so we can't use
0000034A                            			; no-cost RAM source safety.
0000034A 0241 007F                  			andi.w	#$7F,d1			; Strip high bit
0000034E 0041 9700                  			ori.w	#$9700,d1		; Command to specify source address & $FE0000
00000352 32C1                       			move.w	d1,(a1)+		; Store command
00000354 5201                       			addq.b	#1,d1			; Advance to next 128kB boundary (**)
00000356 3341 000C                  			move.w	d1,12(a1)		; Store it now (safe to do in all cases, as we will overwrite later if queue got filled) (**)
0000035A 3203                       			move.w	d3,d1			; Put length together with (source address & $01FFFE) >> 1...
0000035C 03C9 0001                  			movep.l	d1,1(a1)		; ... and stuff them all into RAM in their proper places (movep for the win)
00000360 43E9 0008                  			lea	8(a1),a1		; Skip past all of these commands
00000364                            
00000364 3602                       			move.w	d2,d3			; Save for later
00000366                            			vdpCommReg d2,VRAM,DMA,1	; Make DMA destination command
00000366                          M 	local	cd
00000366 =00000021                M cd	=	vram&dma
00000366 E58A                     M 	lsl.l	#2,d2
00000368 5242                     M 	addq.w	#((cd)&3),d2
0000036A E45A                     M 	ror.w	#2,d2
0000036C 4842                     M 	swap	d2
0000036E 0242 0003                M 	andi.w	#3,d2
00000372 4AC2                     M 	tas.b	d2
00000374 22C2                       			move.l	d2,(a1)+		; Store command
00000376                            
00000376 B2FC 90FC                  			cmpa.w	#dmaSlot,a1		; Did this command fill the queue?
0000037A 6700                       			beq.s	.SkipSecondTransfer	; Branch if so
0000037C                            
0000037C                            			; Store VDP commands for specifying DMA into the queue
0000037C                            			; The source address high byte was done above already in the comments marked
0000037C                            			; with (**)
0000037C 7400                       				moveq	#0,d2		; Need a zero for a 128kB block start
0000037E 3400                       				move.w	d0,d2		; Copy number of words on this new block...
00000380 05C9 0003                  				movep.l	d2,3(a1)	; ... and stuff it all into RAM at the proper places (movep for the win)
00000384 43E9 000A                  			lea	10(a1),a1		; Skip past all of these commands
00000388                            
00000388                            			; d1 contains length up to the end of the 128kB boundary
00000388 D241                       			add.w	d1,d1			; Convert it into byte length...
0000038A D243                       			add.w	d3,d1			; ... and offset destination by the correct amount
0000038C                            			vdpCommReg d1,VRAM,DMA,1	; Make DMA destination command
0000038C                          M 	local	cd
0000038C =00000021                M cd	=	vram&dma
0000038C E589                     M 	lsl.l	#2,d1
0000038E 5241                     M 	addq.w	#((cd)&3),d1
00000390 E459                     M 	ror.w	#2,d1
00000392 4841                     M 	swap	d1
00000394 0241 0003                M 	andi.w	#3,d1
00000398 4AC1                     M 	tas.b	d1
0000039A 22C1                       			move.l	d1,(a1)+		; Store command
0000039C                            
0000039C 4251                       			clr.w	(a1)			; Put a stop token at the end of the used part of the queue
0000039E 31C9 90FC                  			move.w	a1,dmaSlot.w		; Set the next free slot address, potentially undoing the above clr (this is intentional!)
000003A2                            
000003A2 4E75                       			rts
000003A4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000003A4                            .SkipSecondTransfer:
000003A4 3289                       			move.w	a1,(a1)			; Set the next free slot address, overwriting what the second (**) instruction did
000003A6                            	
000003A6 4E75                       			rts
000003A8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000003A8                            ; Issue all the queued VDP DMA commands from QueueDMATransfer, resets the queue when it's done
000003A8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000003A8                            ; PARAMETERS:
000003A8                            ;	a6.l	- VDP control port
000003A8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000003A8                            ; RETURNS:
000003A8                            ;	Nothing
000003A8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000003A8                            ProcessDMAQueue:
000003A8 43F8 9000                  		lea	dmaQueue.w,a1
000003AC 31C9 90FC                  		move.w	a1,dmaSlot.w
000003B0                            
000003B0                            		rept (dmaSlot-dmaQueue)/(7*2)
000003B0                            			move.w	(a1)+,d0
000003B0                            			beq.w	.Done			; Branch if we reached a stop token
000003B0                            			
000003B0                            			move.w	d0,(a6)			; Issue a set of VDP commands...
000003B0                            			move.l	(a1)+,(a6)
000003B0                            			move.l	(a1)+,(a6)
000003B0                            			move.w	(a1)+,(a6)
000003B0                            			move.w	(a1)+,(a6)
000003B0                            		endr
000003B0 3019                     M 	move.w	(a1)+,d0
000003B2 6700 0000                M 	beq.w	.done
000003B6 3C80                     M 	move.w	d0,(a6)
000003B8 2C99                     M 	move.l	(a1)+,(a6)
000003BA 2C99                     M 	move.l	(a1)+,(a6)
000003BC 3C99                     M 	move.w	(a1)+,(a6)
000003BE 3C99                     M 	move.w	(a1)+,(a6)
000003C0 3019                     M 	move.w	(a1)+,d0
000003C2 6700 0000                M 	beq.w	.done
000003C6 3C80                     M 	move.w	d0,(a6)
000003C8 2C99                     M 	move.l	(a1)+,(a6)
000003CA 2C99                     M 	move.l	(a1)+,(a6)
000003CC 3C99                     M 	move.w	(a1)+,(a6)
000003CE 3C99                     M 	move.w	(a1)+,(a6)
000003D0 3019                     M 	move.w	(a1)+,d0
000003D2 6700 0000                M 	beq.w	.done
000003D6 3C80                     M 	move.w	d0,(a6)
000003D8 2C99                     M 	move.l	(a1)+,(a6)
000003DA 2C99                     M 	move.l	(a1)+,(a6)
000003DC 3C99                     M 	move.w	(a1)+,(a6)
000003DE 3C99                     M 	move.w	(a1)+,(a6)
000003E0 3019                     M 	move.w	(a1)+,d0
000003E2 6700 0000                M 	beq.w	.done
000003E6 3C80                     M 	move.w	d0,(a6)
000003E8 2C99                     M 	move.l	(a1)+,(a6)
000003EA 2C99                     M 	move.l	(a1)+,(a6)
000003EC 3C99                     M 	move.w	(a1)+,(a6)
000003EE 3C99                     M 	move.w	(a1)+,(a6)
000003F0 3019                     M 	move.w	(a1)+,d0
000003F2 6700 0000                M 	beq.w	.done
000003F6 3C80                     M 	move.w	d0,(a6)
000003F8 2C99                     M 	move.l	(a1)+,(a6)
000003FA 2C99                     M 	move.l	(a1)+,(a6)
000003FC 3C99                     M 	move.w	(a1)+,(a6)
000003FE 3C99                     M 	move.w	(a1)+,(a6)
00000400 3019                     M 	move.w	(a1)+,d0
00000402 6700 0000                M 	beq.w	.done
00000406 3C80                     M 	move.w	d0,(a6)
00000408 2C99                     M 	move.l	(a1)+,(a6)
0000040A 2C99                     M 	move.l	(a1)+,(a6)
0000040C 3C99                     M 	move.w	(a1)+,(a6)
0000040E 3C99                     M 	move.w	(a1)+,(a6)
00000410 3019                     M 	move.w	(a1)+,d0
00000412 6700 0000                M 	beq.w	.done
00000416 3C80                     M 	move.w	d0,(a6)
00000418 2C99                     M 	move.l	(a1)+,(a6)
0000041A 2C99                     M 	move.l	(a1)+,(a6)
0000041C 3C99                     M 	move.w	(a1)+,(a6)
0000041E 3C99                     M 	move.w	(a1)+,(a6)
00000420 3019                     M 	move.w	(a1)+,d0
00000422 6700 0000                M 	beq.w	.done
00000426 3C80                     M 	move.w	d0,(a6)
00000428 2C99                     M 	move.l	(a1)+,(a6)
0000042A 2C99                     M 	move.l	(a1)+,(a6)
0000042C 3C99                     M 	move.w	(a1)+,(a6)
0000042E 3C99                     M 	move.w	(a1)+,(a6)
00000430 3019                     M 	move.w	(a1)+,d0
00000432 6700 0000                M 	beq.w	.done
00000436 3C80                     M 	move.w	d0,(a6)
00000438 2C99                     M 	move.l	(a1)+,(a6)
0000043A 2C99                     M 	move.l	(a1)+,(a6)
0000043C 3C99                     M 	move.w	(a1)+,(a6)
0000043E 3C99                     M 	move.w	(a1)+,(a6)
00000440 3019                     M 	move.w	(a1)+,d0
00000442 6700 0000                M 	beq.w	.done
00000446 3C80                     M 	move.w	d0,(a6)
00000448 2C99                     M 	move.l	(a1)+,(a6)
0000044A 2C99                     M 	move.l	(a1)+,(a6)
0000044C 3C99                     M 	move.w	(a1)+,(a6)
0000044E 3C99                     M 	move.w	(a1)+,(a6)
00000450 3019                     M 	move.w	(a1)+,d0
00000452 6700 0000                M 	beq.w	.done
00000456 3C80                     M 	move.w	d0,(a6)
00000458 2C99                     M 	move.l	(a1)+,(a6)
0000045A 2C99                     M 	move.l	(a1)+,(a6)
0000045C 3C99                     M 	move.w	(a1)+,(a6)
0000045E 3C99                     M 	move.w	(a1)+,(a6)
00000460 3019                     M 	move.w	(a1)+,d0
00000462 6700 0000                M 	beq.w	.done
00000466 3C80                     M 	move.w	d0,(a6)
00000468 2C99                     M 	move.l	(a1)+,(a6)
0000046A 2C99                     M 	move.l	(a1)+,(a6)
0000046C 3C99                     M 	move.w	(a1)+,(a6)
0000046E 3C99                     M 	move.w	(a1)+,(a6)
00000470 3019                     M 	move.w	(a1)+,d0
00000472 6700 0000                M 	beq.w	.done
00000476 3C80                     M 	move.w	d0,(a6)
00000478 2C99                     M 	move.l	(a1)+,(a6)
0000047A 2C99                     M 	move.l	(a1)+,(a6)
0000047C 3C99                     M 	move.w	(a1)+,(a6)
0000047E 3C99                     M 	move.w	(a1)+,(a6)
00000480 3019                     M 	move.w	(a1)+,d0
00000482 6700 0000                M 	beq.w	.done
00000486 3C80                     M 	move.w	d0,(a6)
00000488 2C99                     M 	move.l	(a1)+,(a6)
0000048A 2C99                     M 	move.l	(a1)+,(a6)
0000048C 3C99                     M 	move.w	(a1)+,(a6)
0000048E 3C99                     M 	move.w	(a1)+,(a6)
00000490 3019                     M 	move.w	(a1)+,d0
00000492 6700 0000                M 	beq.w	.done
00000496 3C80                     M 	move.w	d0,(a6)
00000498 2C99                     M 	move.l	(a1)+,(a6)
0000049A 2C99                     M 	move.l	(a1)+,(a6)
0000049C 3C99                     M 	move.w	(a1)+,(a6)
0000049E 3C99                     M 	move.w	(a1)+,(a6)
000004A0 3019                     M 	move.w	(a1)+,d0
000004A2 6700 0000                M 	beq.w	.done
000004A6 3C80                     M 	move.w	d0,(a6)
000004A8 2C99                     M 	move.l	(a1)+,(a6)
000004AA 2C99                     M 	move.l	(a1)+,(a6)
000004AC 3C99                     M 	move.w	(a1)+,(a6)
000004AE 3C99                     M 	move.w	(a1)+,(a6)
000004B0 3019                     M 	move.w	(a1)+,d0
000004B2 6700 0000                M 	beq.w	.done
000004B6 3C80                     M 	move.w	d0,(a6)
000004B8 2C99                     M 	move.l	(a1)+,(a6)
000004BA 2C99                     M 	move.l	(a1)+,(a6)
000004BC 3C99                     M 	move.w	(a1)+,(a6)
000004BE 3C99                     M 	move.w	(a1)+,(a6)
000004C0 3019                     M 	move.w	(a1)+,d0
000004C2 6700 0000                M 	beq.w	.done
000004C6 3C80                     M 	move.w	d0,(a6)
000004C8 2C99                     M 	move.l	(a1)+,(a6)
000004CA 2C99                     M 	move.l	(a1)+,(a6)
000004CC 3C99                     M 	move.w	(a1)+,(a6)
000004CE 3C99                     M 	move.w	(a1)+,(a6)
000004D0 7000                       		moveq	#0,d0
000004D2                            
000004D2                            .Done:
000004D2 31C0 9000                  		move.w	d0,dmaQueue.w
000004D6 4E75                       		rts
000004D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004D8                            ; Initialize the DMA queue
000004D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004D8                            ; PARAMETERS:
000004D8                            ;	Nothing
000004D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004D8                            ; RETURNS:
000004D8                            ;	Nothing
000004D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004D8                            InitDMAQueue:
000004D8 43F8 9000                  		lea	dmaQueue.w,a1
000004DC 32BC 0000                  		move.w	#0,(a1)
000004E0 31C9 90FC                  		move.w	a1,dmaSlot.w
000004E4 223C 9695 9493             		move.l	#$96959493,d1
000004EA =00000000                  c		= 0
000004EA                            		rept (dmaSlot-dmaQueue)/(7*2)
000004EA                            			movep.l	d1,2+c(a1)
000004EA                            c			= c+14
000004EA                            		endr
000004EA 03C9 0002                M 	movep.l	d1,2+c(a1)
000004EE =0000000E                M c	=	c+14
000004EE 03C9 0010                M 	movep.l	d1,2+c(a1)
000004F2 =0000001C                M c	=	c+14
000004F2 03C9 001E                M 	movep.l	d1,2+c(a1)
000004F6 =0000002A                M c	=	c+14
000004F6 03C9 002C                M 	movep.l	d1,2+c(a1)
000004FA =00000038                M c	=	c+14
000004FA 03C9 003A                M 	movep.l	d1,2+c(a1)
000004FE =00000046                M c	=	c+14
000004FE 03C9 0048                M 	movep.l	d1,2+c(a1)
00000502 =00000054                M c	=	c+14
00000502 03C9 0056                M 	movep.l	d1,2+c(a1)
00000506 =00000062                M c	=	c+14
00000506 03C9 0064                M 	movep.l	d1,2+c(a1)
0000050A =00000070                M c	=	c+14
0000050A 03C9 0072                M 	movep.l	d1,2+c(a1)
0000050E =0000007E                M c	=	c+14
0000050E 03C9 0080                M 	movep.l	d1,2+c(a1)
00000512 =0000008C                M c	=	c+14
00000512 03C9 008E                M 	movep.l	d1,2+c(a1)
00000516 =0000009A                M c	=	c+14
00000516 03C9 009C                M 	movep.l	d1,2+c(a1)
0000051A =000000A8                M c	=	c+14
0000051A 03C9 00AA                M 	movep.l	d1,2+c(a1)
0000051E =000000B6                M c	=	c+14
0000051E 03C9 00B8                M 	movep.l	d1,2+c(a1)
00000522 =000000C4                M c	=	c+14
00000522 03C9 00C6                M 	movep.l	d1,2+c(a1)
00000526 =000000D2                M c	=	c+14
00000526 03C9 00D4                M 	movep.l	d1,2+c(a1)
0000052A =000000E0                M c	=	c+14
0000052A 03C9 00E2                M 	movep.l	d1,2+c(a1)
0000052E =000000EE                M c	=	c+14
0000052E 03C9 00F0                M 	movep.l	d1,2+c(a1)
00000532 =000000FC                M c	=	c+14
00000532 4E75                       		rts
00000534                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000534                            ; Load a palette into the main palette buffer
00000534                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000534                            ; PARAMETERS:
00000534                            ;	d0.w	- Size of palette (divided by 2 minus 1)
00000534                            ;	a0.l	- Pointer to palette data
00000534                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000534                            LoadPalette:
00000534 43F8 98CE                  		lea	paletteBuff.w,a1			; Main palette buffer
00000538 6000                       		bra.s	LoadPalToBuf			; Load the palette
0000053A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000053A                            ; Load a palette into the target palette buffer
0000053A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000053A                            ; PARAMETERS:
0000053A                            ;	d0.w	- Size of palette (divided by 2 minus 1)
0000053A                            ;	a0.l	- Pointer to palette data
0000053A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000053A                            LoadTargetPal:
0000053A 43F8 97CE                  		lea	palFadeBuff.w,a1			; Target palette buffer
0000053E 6000                       		bra.s	LoadPalToBuf			; Load the palette
00000540                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000540                            ; Load a palette into the main water palette buffer
00000540                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000540                            ; PARAMETERS:
00000540                            ;	d0.w	- Size of palette (divided by 2 minus 1)
00000540                            ;	a0.l	- Pointer to palette data
00000540                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000540                            LoadWaterPal:
00000540 43F8 984E                  		lea	paletteBuffAlt.w,a1		; Main water palette buffer
00000544 6000                       		bra.s	LoadPalToBuf			; Load the palette
00000546                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000546                            ; Load a palette into the target water palette buffer
00000546                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000546                            ; PARAMETERS:
00000546                            ;	d0.w	- Size of palette (divided by 2 minus 1)
00000546                            ;	a0.l	- Pointer to palette data
00000546                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000546                            LoadTargetWaterPal:
00000546 43F8 974E                  		lea	palFadeBuffAlt.w,a1		; Target water palette buffer
0000054A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000054A                            ; Load a palette into a palette buffer
0000054A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000054A                            ; PARAMETERS:
0000054A                            ;	d0.w	- Size of palette (divided by 2 minus 1)
0000054A                            ;	a0.l	- Pointer to palette data
0000054A                            ;	a1.l	- Pointer to destination buffer
0000054A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000054A                            LoadPalToBuf:
0000054A 32D8                       		move.w	(a0)+,(a1)+			; Copy palette data
0000054C 51C8 FFFC                  		dbf	d0,LoadPalToBuf			; Loop
00000550 4E75                       		rts
00000552                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000552                            ; Fade the palette to black
00000552                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000552                            ; PARAMETERS:
00000552                            ;	Nothing
00000552                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000552                            ; RETURNS:
00000552                            ;	Nothing
00000552                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000552                            FadeToBlack:
00000552 31FC 003F C748             		move.w	#$003F,palFadeVars.w		; Set to fade everything
00000558                            
00000558                            FadeToBlack_Custom:
00000558 7807                       		moveq	#7,d4				; Set repeat times
0000055A                            		
0000055A                            .FadeLoop:
0000055A                            		rept	2
0000055A                            			move.b	#vFade,vIntRoutine.w	; Set V-INT routine
0000055A                            			bsr.w	VSync_Routine		; Do V-SYNC
0000055A                            		endr
0000055A 11FC 000A C747           M 	move.b	#vfade,vintroutine.w
00000560 6100 0000                M 	bsr.w	vsync_routine
00000564 11FC 000A C747           M 	move.b	#vfade,vintroutine.w
0000056A 6100 0000                M 	bsr.w	vsync_routine
0000056E 6100                       		bsr.s	FadeToBlack_Once		; Fade the colors once
00000570 51CC FFE8                  		dbf	d4,.FadeLoop			; Loop until we are done
00000574 4E75                       		rts
00000576                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000576                            FadeToBlack_Once:
00000576 7000                       		moveq	#0,d0
00000578 41F8 98CE                  		lea	paletteBuff.w,a0			; Palette buffer
0000057C 1038 C748                  		move.b	palFadeStart.w,d0		; Add starting index offset
00000580 D0C0                       		adda.w	d0,a0				; ''
00000582 1038 C749                  		move.b	palFadeLength.w,d0			; Get fade size
00000586                            
00000586                            .FadeLoop:
00000586 6100                       		bsr.s	.FadeColor			; Fade a color			
00000588 51C8 FFFC                  		dbf	d0,.FadeLoop			; Loop
0000058C                            
0000058C 7000                       		moveq	#0,d0
0000058E 41F8 984E                  		lea	paletteBuffAlt.w,a0		; Water palette buffer
00000592 1038 C748                  		move.b	palFadeStart.w,d0		; Add starting index offset
00000596 D0C0                       		adda.w	d0,a0				; ''
00000598 1038 C749                  		move.b	palFadeLength.w,d0			; Get fade size
0000059C                            
0000059C                            .FadeLoopWater:
0000059C 6100                       		bsr.s	.FadeColor			; Fade a color			
0000059E 51C8 FFFC                  		dbf	d0,.FadeLoopWater		; Loop
000005A2 4E75                       		rts
000005A4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000005A4                            .FadeColor:
000005A4 3A10                       		move.w	(a0),d5				; Load color
000005A6 6700                       		beq.s	.NoRed				; If the color is already black, branch
000005A8 3205                       		move.w	d5,d1				; Copy color
000005AA 1401                       		move.b	d1,d2				; Load green and red
000005AC 1601                       		move.b	d1,d3				; Load only red
000005AE                            
000005AE 0241 0E00                  		andi.w	#$E00,d1			; Get only blue
000005B2 6700                       		beq.s	.NoBlue				; If blue is finished, branch
000005B4 0445 0200                  		subi.w	#$200,d5			; Decrease blue
000005B8                            
000005B8                            .NoBlue:
000005B8 0202 00E0                  		andi.b	#$E0,d2				; Get only green
000005BC 6700                       		beq.s	.NoGreen			; If green is finished, branch
000005BE 0445 0020                  		subi.w	#$20,d5				; Decrease green
000005C2                            
000005C2                            .NoGreen:
000005C2 0203 000E                  		andi.b	#$E,d3				; Get only red
000005C6 6700                       		beq.s	.NoRed				; If red is finished, branch
000005C8 5545                       		subq.w	#2,d5				; Decrease red
000005CA                            
000005CA                            .NoRed:
000005CA 30C5                       		move.w	d5,(a0)+			; Save the color
000005CC 4E75                       		rts
000005CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000005CE                            ; Fade the palette from black to the target palette
000005CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000005CE                            ; PARAMETERS:
000005CE                            ;	Nothing
000005CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000005CE                            ; RETURNS:
000005CE                            ;	Nothing
000005CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000005CE                            FadeFromBlack:
000005CE 31FC 003F C748             		move.w	#$003F,palFadeVars.w		; Set to fade everything
000005D4                            
000005D4                            FadeFromBlack_Custom:
000005D4 780E                       		moveq	#$E,d4				; Maximum color check
000005D6                            
000005D6                            .FadeLoop:
000005D6                            		rept	2
000005D6                            			move.b	#vFade,vIntRoutine.w	; Set V-INT routine
000005D6                            			bsr.w	VSync_Routine		; Do V-SYNC
000005D6                            		endr
000005D6 11FC 000A C747           M 	move.b	#vfade,vintroutine.w
000005DC 6100 0000                M 	bsr.w	vsync_routine
000005E0 11FC 000A C747           M 	move.b	#vfade,vintroutine.w
000005E6 6100 0000                M 	bsr.w	vsync_routine
000005EA 6100                       		bsr.s	FadeFromBlack_Once		; Fade the colors once
000005EC 5504                       		subq.b	#2,d4				; Decrement color check
000005EE 66E6                       		bne.s	.FadeLoop			; If we are not done, branch
000005F0                            
000005F0 11FC 000A C747             		move.b	#vFade,vIntRoutine.w		; Set V-INT routine
000005F6 6000 0000                  		bra.w	VSync_Routine			; Do V-SYNC so that the colors transfer
000005FA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000005FA                            FadeFromBlack_Once:
000005FA 7000                       		moveq	#0,d0
000005FC 41F8 98CE                  		lea	paletteBuff.w,a0			; Palette buffer
00000600 43F8 97CE                  		lea	palFadeBuff.w,a1			; Target palette buffer
00000604 1038 C748                  		move.b	palFadeStart.w,d0		; Add starting index offset
00000608 D0C0                       		adda.w	d0,a0				; ''
0000060A D2C0                       		adda.w	d0,a1				; ''
0000060C 1038 C749                  		move.b	palFadeLength.w,d0			; Get fade size
00000610                            
00000610                            .FadeLoop:
00000610 6100                       		bsr.s	.FadeColor			; Fade a color			
00000612 51C8 FFFC                  		dbf	d0,.FadeLoop			; Loop
00000616                            
00000616 7000                       		moveq	#0,d0
00000618 41F8 984E                  		lea	paletteBuffAlt.w,a0		; Water palette buffer
0000061C 43F8 974E                  		lea	palFadeBuffAlt.w,a1		; Target water palette buffer
00000620 1038 C748                  		move.b	palFadeStart.w,d0		; Add starting index offset
00000624 D0C0                       		adda.w	d0,a0				; ''
00000626 D2C0                       		adda.w	d0,a1				; ''
00000628 1038 C749                  		move.b	palFadeLength.w,d0			; Get fade size
0000062C                            
0000062C                            .FadeLoopWater:
0000062C 6100                       		bsr.s	.FadeColor			; Fade a color			
0000062E 51C8 FFFC                  		dbf	d0,.FadeLoopWater		; Loop
00000632 4E75                       		rts
00000634                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000634                            .FadeColor:
00000634 1A11                       		move.b	(a1),d5				; Load blue
00000636 3219                       		move.w	(a1)+,d1			; Load green and red
00000638 1401                       		move.b	d1,d2				; Load red
0000063A E809                       		lsr.b	#4,d1				; Get only green
0000063C 0202 000E                  		andi.b	#$E,d2				; Get only red
00000640                            
00000640 3610                       		move.w	(a0),d3				; Load current color
00000642 B805                       		cmp.b	d5,d4				; Should the blue fade?
00000644 6200                       		bhi.s	.NoBlue				; If not, branch
00000646 0643 0200                  		addi.w	#$200,d3			; Increase blue
0000064A                            
0000064A                            .NoBlue:
0000064A B801                       		cmp.b	d1,d4				; Should the green fade?
0000064C 6200                       		bhi.s	.NoGreen			; If not, branch
0000064E 0643 0020                  		addi.w	#$20,d3				; Increase green
00000652                            
00000652                            .NoGreen:
00000652 B802                       		cmp.b	d2,d4				; Should the red fade?
00000654 6200                       		bhi.s	.NoRed				; If not, branch
00000656 5443                       		addq.w	#2,d3				; Increase red
00000658                            
00000658                            .NoRed:
00000658 30C3                       		move.w	d3,(a0)+			; Save the color
0000065A 4E75                       		rts
0000065C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000065C                            ; Fade the palette to white
0000065C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000065C                            ; PARAMETERS:
0000065C                            ;	Nothing
0000065C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000065C                            ; RETURNS:
0000065C                            ;	Nothing
0000065C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000065C                            FadeToWhite:
0000065C 31FC 003F C748             		move.w	#$003F,palFadeVars.w		; Set to fade everything
00000662                            
00000662                            FadeToWhite_Custom:
00000662 7807                       		moveq	#7,d4				; Set repeat times
00000664                            
00000664                            .FadeLoop:
00000664                            		rept	2
00000664                            			move.b	#vFade,vIntRoutine.w	; Set V-INT routine
00000664                            			bsr.w	VSync_Routine		; Do V-SYNC
00000664                            		endr
00000664 11FC 000A C747           M 	move.b	#vfade,vintroutine.w
0000066A 6100 0000                M 	bsr.w	vsync_routine
0000066E 11FC 000A C747           M 	move.b	#vfade,vintroutine.w
00000674 6100 0000                M 	bsr.w	vsync_routine
00000678 6100                       		bsr.s	FadeToWhite_Once		; Fade the colors once
0000067A 51CC FFE8                  		dbf	d4,.FadeLoop			; Loop until we are done
0000067E 4E75                       		rts
00000680                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000680                            FadeToWhite_Once:
00000680 7000                       		moveq	#0,d0
00000682 41F8 98CE                  		lea	paletteBuff.w,a0			; Palette buffer
00000686 1038 C748                  		move.b	palFadeStart.w,d0		; Add starting index offset
0000068A D0C0                       		adda.w	d0,a0				; ''
0000068C 1038 C749                  		move.b	palFadeLength.w,d0			; Get fade size
00000690                            
00000690                            .FadeLoop:
00000690 6100                       		bsr.s	.FadeColor			; Fade a color			
00000692 51C8 FFFC                  		dbf	d0,.FadeLoop			; Loop
00000696                            
00000696 7000                       		moveq	#0,d0
00000698 41F8 984E                  		lea	paletteBuffAlt.w,a0		; Water palette buffer
0000069C 1038 C748                  		move.b	palFadeStart.w,d0		; Add starting index offset
000006A0 D0C0                       		adda.w	d0,a0				; ''
000006A2 1038 C749                  		move.b	palFadeLength.w,d0			; Get fade size
000006A6                            
000006A6                            .FadeLoopWater:
000006A6 6100                       		bsr.s	.FadeColor			; Fade a color			
000006A8 51C8 FFFC                  		dbf	d0,.FadeLoopWater		; Loop
000006AC 4E75                       		rts
000006AE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000006AE                            .FadeColor:
000006AE 3A10                       		move.w	(a0),d5				; Load color
000006B0 0C45 0EEE                  		cmpi.w	#$EEE,d5			; Is it already white?
000006B4 6700                       		beq.s	.NoRed				; If so, branch
000006B6 3205                       		move.w	d5,d1				; Copy color
000006B8 1401                       		move.b	d1,d2				; Load green and red
000006BA 1601                       		move.b	d1,d3				; Load only red
000006BC                            
000006BC 0241 0E00                  		andi.w	#$E00,d1			; Get only blue
000006C0 0C41 0E00                  		cmpi.w	#$E00,d1			; Is blue finished?
000006C4 6700                       		beq.s	.NoBlue				; If do, branch
000006C6 0645 0200                  		addi.w	#$200,d5			; Increase blue
000006CA                            
000006CA                            .NoBlue:
000006CA 0202 00E0                  		andi.b	#$E0,d2				; Get only green
000006CE 0C02 00E0                  		cmpi.b	#$E0,d2				; Is green finished?
000006D2 6700                       		beq.s	.NoGreen			; If so, branch
000006D4 0645 0020                  		addi.w	#$20,d5				; Increase green
000006D8                            
000006D8                            .NoGreen:
000006D8 0203 000E                  		andi.b	#$E,d3				; Get only red
000006DC 0C03 000E                  		cmpi.b	#$E,d3				; Is red finished?
000006E0 6700                       		beq.s	.NoRed				; If so, branch
000006E2 5445                       		addq.w	#2,d5				; Increase red
000006E4                            
000006E4                            .NoRed:
000006E4 30C5                       		move.w	d5,(a0)+			; Save the color
000006E6 4E75                       		rts
000006E8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000006E8                            ; Fade the palette from white to the target palette
000006E8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000006E8                            ; PARAMETERS:
000006E8                            ;	Nothing
000006E8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000006E8                            ; RETURNS:
000006E8                            ;	Nothing
000006E8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000006E8                            FadeFromWhite:
000006E8 31FC 003F C748             		move.w	#$003F,palFadeVars.w		; Set to fade everything
000006EE                            
000006EE                            FadeFromWhite_Custom:
000006EE 7800                       		moveq	#0,d4				; Minimum color check
000006F0                            		
000006F0                            .FadeLoop:
000006F0                            		rept	2
000006F0                            			move.b	#vFade,vIntRoutine.w	; Set V-INT routine
000006F0                            			bsr.w	VSync_Routine		; Do V-SYNC
000006F0                            		endr
000006F0 11FC 000A C747           M 	move.b	#vfade,vintroutine.w
000006F6 6100 0000                M 	bsr.w	vsync_routine
000006FA 11FC 000A C747           M 	move.b	#vfade,vintroutine.w
00000700 6100 0000                M 	bsr.w	vsync_routine
00000704 6100                       		bsr.s	FadeFromWhite_Once		; Fade the colors once
00000706 5404                       		addq.b	#2,d4				; Decrement color check
00000708 0C04 000E                  		cmpi.b	#$E,d4				; Are we done?
0000070C 66E2                       		bne.s	.FadeLoop			; If not, branch
0000070E                            
0000070E 11FC 000A C747             		move.b	#vFade,vIntRoutine.w		; Set V-INT routine
00000714 6000 0000                  		bra.w	VSync_Routine			; Do V-SYNC so that the colors transfer
00000718                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000718                            FadeFromWhite_Once:
00000718 7000                       		moveq	#0,d0
0000071A 41F8 98CE                  		lea	paletteBuff.w,a0			; Palette buffer
0000071E 43F8 97CE                  		lea	palFadeBuff.w,a1			; Target palette buffer
00000722 1038 C748                  		move.b	palFadeStart.w,d0		; Add starting index offset
00000726 D0C0                       		adda.w	d0,a0				; ''
00000728 D2C0                       		adda.w	d0,a1				; ''
0000072A 1038 C749                  		move.b	palFadeLength.w,d0			; Get fade size
0000072E                            
0000072E                            .FadeLoop:
0000072E 6100                       		bsr.s	.FadeColor			; Fade a color			
00000730 51C8 FFFC                  		dbf	d0,.FadeLoop			; Loop
00000734                            
00000734 7000                       		moveq	#0,d0
00000736 41F8 984E                  		lea	paletteBuffAlt.w,a0		; Water palette buffer
0000073A 43F8 974E                  		lea	palFadeBuffAlt.w,a1		; Target water palette buffer
0000073E 1038 C748                  		move.b	palFadeStart.w,d0		; Add starting index offset
00000742 D0C0                       		adda.w	d0,a0				; ''
00000744 D2C0                       		adda.w	d0,a1				; ''
00000746 1038 C749                  		move.b	palFadeLength.w,d0			; Get fade size
0000074A                            
0000074A                            .FadeLoopWater:
0000074A 6100                       		bsr.s	.FadeColor			; Fade a color			
0000074C 51C8 FFFC                  		dbf	d0,.FadeLoopWater		; Loop
00000750 4E75                       		rts
00000752                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000752                            .FadeColor:
00000752 1A11                       		move.b	(a1),d5				; Load blue
00000754 3219                       		move.w	(a1)+,d1			; Load green and red
00000756 1401                       		move.b	d1,d2				; Load red
00000758 E809                       		lsr.b	#4,d1				; Get only green
0000075A 0202 000E                  		andi.b	#$E,d2				; Get only red
0000075E                            
0000075E 3610                       		move.w	(a0),d3				; Load current color
00000760 B805                       		cmp.b	d5,d4				; Should the blue fade?
00000762 6500                       		bcs.s	.NoBlue				; If not, branch
00000764 0443 0200                  		subi.w	#$200,d3			; Decrease blue
00000768                            
00000768                            .NoBlue:
00000768 B801                       		cmp.b	d1,d4				; Should the green fade?
0000076A 6500                       		bcs.s	.NoGreen			; If not, branch
0000076C 0443 0020                  		subi.w	#$20,d3				; Decrease green
00000770                            
00000770                            .NoGreen:
00000770 B802                       		cmp.b	d2,d4				; Should the red fade?
00000772 6500                       		bcs.s	.NoRed				; If not, branch
00000774 5543                       		subq.w	#2,d3				; Decrease red
00000776                            
00000776                            .NoRed:
00000776 30C3                       		move.w	d3,(a0)+			; Save the color
00000778 4E75                       		rts
0000077A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000077A                            ; Fade the palette from the current palette to the target palette
0000077A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000077A                            ; PARAMETERS:
0000077A                            ;	Nothing
0000077A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000077A                            ; RETURNS:
0000077A                            ;	Nothing
0000077A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000077A                            FadeToPalette:
0000077A 31FC 003F C748             		move.w	#$003F,palFadeVars.w		; Set to fade everything
00000780                            
00000780                            FadeToPalette_Custom:
00000780 7000                       		moveq	#0,d0
00000782 41F8 98CE                  		lea	paletteBuff.w,a0			; Palette buffer
00000786 1038 C748                  		move.b	palFadeStart.w,d0		; Add starting index offset
0000078A D0C0                       		adda.w	d0,a0				; ''
0000078C                            
0000078C 7807                       		moveq	#7,d4				; Set repeat times
0000078E                            
0000078E                            .FadeLoop:
0000078E                            		rept	2
0000078E                            			move.b	#vFade,vIntRoutine.w	; Set V-INT routine
0000078E                            			bsr.w	VSync_Routine		; Do V-SYNC
0000078E                            		endr
0000078E 11FC 000A C747           M 	move.b	#vfade,vintroutine.w
00000794 6100 0000                M 	bsr.w	vsync_routine
00000798 11FC 000A C747           M 	move.b	#vfade,vintroutine.w
0000079E 6100 0000                M 	bsr.w	vsync_routine
000007A2 6100                       		bsr.s	FadeToPalette_Once		; Fade the colors once
000007A4 51CC FFE8                  		dbf	d4,.FadeLoop			; Loop until we are done
000007A8 4E75                       		rts
000007AA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000007AA                            FadeToPalette_Once:
000007AA 7000                       		moveq	#0,d0
000007AC 41F8 98CE                  		lea	paletteBuff.w,a0			; Palette buffer
000007B0 43F8 97CE                  		lea	palFadeBuff.w,a1			; Target palette buffer
000007B4 1038 C748                  		move.b	palFadeStart.w,d0		; Add starting index offset
000007B8 D0C0                       		adda.w	d0,a0				; ''
000007BA D2C0                       		adda.w	d0,a1				; ''
000007BC 1038 C749                  		move.b	palFadeLength.w,d0			; Get fade size
000007C0                            
000007C0                            .FadeLoop:
000007C0 6100                       		bsr.s	.FadeColor			; Fade a color			
000007C2 51C8 FFFC                  		dbf	d0,.FadeLoop			; Loop
000007C6                            
000007C6 7000                       		moveq	#0,d0
000007C8 41F8 984E                  		lea	paletteBuffAlt.w,a0		; Water palette buffer
000007CC 43F8 974E                  		lea	palFadeBuffAlt.w,a1		; Target water palette buffer
000007D0 1038 C748                  		move.b	palFadeStart.w,d0		; Add starting index offset
000007D4 D0C0                       		adda.w	d0,a0				; ''
000007D6 D2C0                       		adda.w	d0,a1				; ''
000007D8 1038 C749                  		move.b	palFadeLength.w,d0			; Get fade size
000007DC                            
000007DC                            .FadeLoopWater:
000007DC 6100                       		bsr.s	.FadeColor			; Fade a color			
000007DE 51C8 FFFC                  		dbf	d0,.FadeLoopWater		; Loop
000007E2 4E75                       		rts
000007E4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000007E4                            .FadeColor:
000007E4 3610                       		move.w	(a0),d3				; Get color
000007E6 B659                       		cmp.w	(a1)+,d3			; Has the color already reached the target color?
000007E8 6700                       		beq.s	.NoRed				; If so, branch
000007EA                            		
000007EA 3229 FFFE                  		move.w	-2(a1),d1			; Get green and red
000007EE 1401                       		move.b	d1,d2				; Get red only
000007F0 0202 000E                  		andi.b	#$E,d2				; ''
000007F4 E809                       		lsr.b	#4,d1				; Get green only
000007F6                            
000007F6 1A29 FFFE                  		move.b	-2(a1),d5			; Get blue
000007FA BA10                       		cmp.b	(a0),d5				; Does blue need to fade?
000007FC 6700                       		beq.s	.NoBlue				; If not, branch
000007FE 6500                       		bcs.s	.DecBlue			; If it needs to be decreased, branch
00000800 0643 0200                  		addi.w	#$200,d3			; Increase blue
00000804 6000                       		bra.s	.NoBlue				; Continue
00000806                            
00000806                            .DecBlue:
00000806 0443 0200                  		subi.w	#$200,d3			; Decrease blue
0000080A                            
0000080A                            .NoBlue:
0000080A 3A10                       		move.w	(a0),d5				; Get green
0000080C E80D                       		lsr.b	#4,d5				; ''
0000080E B205                       		cmp.b	d5,d1				; Does green need to fade?
00000810 6700                       		beq.s	.NoGreen			; If not, branch
00000812 6500                       		bcs.s	.DecGreen			; If it needs to be decreased, branch
00000814 0603 0020                  		addi.b	#$20,d3				; Increase green
00000818 6000                       		bra.s	.NoGreen			; Continue
0000081A                            
0000081A                            .DecGreen:
0000081A 0403 0020                  		subi.b	#$20,d3				; Decrease green
0000081E                            
0000081E                            .NoGreen:
0000081E 3A10                       		move.w	(a0),d5				; Get red
00000820 0205 000E                  		andi.b	#$E,d5				; ''
00000824 B405                       		cmp.b	d5,d2				; Does red need to fade?
00000826 6700                       		beq.s	.NoRed				; If not, branch
00000828 6500                       		bcs.s	.DecRed				; If it needs to be decreased, branch
0000082A 5403                       		addq.b	#2,d3				; Increase red
0000082C 6000                       		bra.s	.NoRed				; Continue
0000082E                            
0000082E                            .DecRed:
0000082E 5503                       		subq.b	#2,d3				; Decrease red
00000830                            
00000830                            .NoRed:
00000830 30C3                       		move.w	d3,(a0)+			; Save new color
00000832 4E75                       		rts
00000834                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000834                            ; Initialize the sprite table
00000834                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000834                            InitSpriteTable:
00000834 7000                       		moveq	#0,d0
00000836 41F8 94CE                  		lea	spriteBuff.w,a0			; Sprite table buffer
0000083A 7201                       		moveq	#1,d1				; Link value
0000083C 7E4F                       		moveq	#($280/8)-1,d7			; Number of sprites
0000083E                            
0000083E                            .Loop:
0000083E 3080                       		move.w	d0,(a0)				; Move off screen
00000840 1141 0003                  		move.b	d1,3(a0)			; Set link value
00000844 5241                       		addq.w	#1,d1				; Increment link value
00000846 5048                       		addq.w	#8,a0				; Next sprite
00000848 51CF FFF4                  		dbf	d7,.Loop			; Loop
0000084C 1140 FFFB                  		move.b	d0,-5(a0)			; Set final link value to 0
00000850 4E75                       		rts
00000852                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000852                            ; Draw the sprites from mappings
00000852                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000852                            ; PARAMETERS:
00000852                            ;	d0.w	- X position
00000852                            ;	d1.w	- Y position
00000852                            ;	d4.w	- Number of sprites to draw
00000852                            ;	d5.w	- Sprite tile properties
00000852                            ;	d6.b	- Render flags
00000852                            ;	d7.w	- Max number of sprites left to draw
00000852                            ;	a1.l	- Mappings frame data
00000852                            ;	a6.l	- Sprite table buffer
00000852                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000852                            ; RETURNS:
00000852                            ;	Nothing
00000852                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000852                            DrawSprite:
00000852 E20E                       		lsr.b	#1,d6				; Is this sprite flipped horizontally?
00000854 6500                       		bcs.s	DrawSprite_FlipX		; If so, branch
00000856 E20E                       		lsr.b	#1,d6				; Is this sprite flipped vertically?
00000858 6500 0000                  		bcs.w	DrawSprite_FlipY		; If so, branch
0000085C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000085C                            ; Draw the sprites from mappings with no flip checks
0000085C                            ; (Parameters inherited from DrawSprite, minus d6, a.k.a. render flags)
0000085C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000085C                            DrawSprite_Loop:
0000085C 1419                       		move.b	(a1)+,d2			; Get Y offset
0000085E 4882                       		ext.w	d2				; ''
00000860 D441                       		add.w	d1,d2				; Add onto Y position
00000862 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000864 1CD9                       		move.b	(a1)+,(a6)+			; Store sprite size
00000866 524E                       		addq.w	#1,a6				; Skip link data
00000868 3419                       		move.w	(a1)+,d2			; Get tile properties
0000086A D445                       		add.w	d5,d2				; Add base tile properties
0000086C 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
0000086E 3419                       		move.w	(a1)+,d2			; Get X offset
00000870 D440                       		add.w	d0,d2				; Add onto X position
00000872 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000874 5347                       		subq.w	#1,d7				; Decrement sprite count
00000876 5BCC FFE4                  		dbmi	d4,DrawSprite_Loop		; Loop if there are still enough sprites left
0000087A                            		
0000087A                            DrawSprite_End:
0000087A 4E75                       		rts
0000087C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000087C                            ; Draw the sprites from mappings, horizontally flipped
0000087C                            ; (Parameters inherited from DrawSprite)
0000087C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000087C                            DrawSprite_FlipX:
0000087C E20E                       		lsr.b	#1,d6				; Is this sprite flipped vertically?
0000087E 6500                       		bcs.s	DrawSprite_FlipXY		; If so, branch
00000880                            
00000880                            .Loop:
00000880 1419                       		move.b	(a1)+,d2			; Get Y offset
00000882 4882                       		ext.w	d2				; ''
00000884 D441                       		add.w	d1,d2				; Add onto Y position
00000886 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000888 1C19                       		move.b	(a1)+,d6			; Get sprite size
0000088A 1CC6                       		move.b	d6,(a6)+			; Store in sprite table
0000088C 524E                       		addq.w	#1,a6				; Skip link data
0000088E 3419                       		move.w	(a1)+,d2			; Get tile properties
00000890 D445                       		add.w	d5,d2				; Add base tile properties
00000892 0A42 0800                  		eori.w	#$800,d2			; Flip horizontally
00000896 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000898 3419                       		move.w	(a1)+,d2			; Get X offset
0000089A 4442                       		neg.w	d2				; Negate it
0000089C 1C3B 6000                  		move.b	DrawSprite_XFlipOff(pc,d6.w),d6	; Get the X offset to apply
000008A0 9446                       		sub.w	d6,d2				; Subtract the new X offset
000008A2 D440                       		add.w	d0,d2				; Add onto X position
000008A4 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000008A6 5347                       		subq.w	#1,d7				; Decrement sprite count
000008A8 5BCC FFD6                  		dbmi	d4,.Loop			; Loop if there are still enough sprites left
000008AC 4E75                       		rts
000008AE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000008AE                            DrawSprite_XFlipOff:
000008AE 0808 0808                  		dc.b	8, 8, 8, 8
000008B2 1010 1010                  		dc.b	$10, $10, $10, $10
000008B6 1818 1818                  		dc.b	$18, $18, $18, $18
000008BA 2020 2020                  		dc.b	$20, $20, $20, $20
000008BE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000008BE                            ; Draw the sprites from mappings, horizontally and vertically flipped
000008BE                            ; (Parameters inherited from DrawSprite, minus d6, a.k.a. render flags)
000008BE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000008BE                            DrawSprite_FlipXY:
000008BE 1419                       		move.b	(a1)+,d2			; Get Y offset
000008C0 4882                       		ext.w	d2				; ''
000008C2 4442                       		neg.w	d2				; Negate it
000008C4 1C11                       		move.b	(a1),d6				; Get sprite sizes
000008C6 1C3B 6000                  		move.b	DrawSprite_YFlipOff(pc,d6.w),d6	; Get the Y offset to apply
000008CA 9446                       		sub.w	d6,d2				; Subtract from the Y offset
000008CC D441                       		add.w	d1,d2				; Add onto Y position
000008CE 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000008D0 1C19                       		move.b	(a1)+,d6			; Get sprite size
000008D2 1CC6                       		move.b	d6,(a6)+			; Store in sprite table
000008D4 524E                       		addq.w	#1,a6				; Skip link data
000008D6 3419                       		move.w	(a1)+,d2			; Get tile properties
000008D8 D445                       		add.w	d5,d2				; Add base tile properties
000008DA 0A42 1800                  		eori.w	#$1800,d2			; Flip horizontally and vertically
000008DE 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000008E0 3419                       		move.w	(a1)+,d2			; Get X offset
000008E2 4442                       		neg.w	d2				; Negate it
000008E4 1C3B 60C8                  		move.b	DrawSprite_XFlipOff(pc,d6.w),d6	; Get the X offset to apply
000008E8 9446                       		sub.w	d6,d2				; Subtract the new X offset
000008EA D440                       		add.w	d0,d2				; Add onto X position
000008EC 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000008EE 5347                       		subq.w	#1,d7				; Decrement sprite count
000008F0 5BCC FFCC                  		dbmi	d4,DrawSprite_FlipXY		; Loop if there are still enough sprites left
000008F4 4E75                       		rts
000008F6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000008F6                            DrawSprite_YFlipOff:
000008F6 0810 1820                  		dc.b	8, $10, $18, $20
000008FA 0810 1820                  		dc.b	8, $10, $18, $20
000008FE 0810 1820                  		dc.b	8, $10, $18, $20
00000902 0810 1820                  		dc.b	8, $10, $18, $20
00000906                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000906                            ; Draw the sprites from mappings, vertically flipped
00000906                            ; (Parameters inherited from DrawSprite)
00000906                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000906                            DrawSprite_FlipY:
00000906 1419                       		move.b	(a1)+,d2			; Get Y offset
00000908 4882                       		ext.w	d2				; ''
0000090A 4442                       		neg.w	d2				; Negate it
0000090C 1C19                       		move.b	(a1)+,d6			; Get sprite sizes
0000090E 1D46 0002                  		move.b	d6,2(a6)			; Store in sprite table
00000912 1C3B 60E2                  		move.b	DrawSprite_YFlipOff(pc,d6.w),d6	; Get the Y offset to apply
00000916 9446                       		sub.w	d6,d2				; Subtract from the Y offset
00000918 D441                       		add.w	d1,d2				; Add onto Y position
0000091A 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
0000091C 544E                       		addq.w	#2,a6				; Skip link data
0000091E 3419                       		move.w	(a1)+,d2			; Get tile properties
00000920 D445                       		add.w	d5,d2				; Add base tile properties
00000922 0A42 1000                  		eori.w	#$1000,d2			; Flip vertically
00000926 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000928 3419                       		move.w	(a1)+,d2			; Get X offset
0000092A D440                       		add.w	d0,d2				; Add onto X position
0000092C 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
0000092E 5347                       		subq.w	#1,d7				; Decrement sprite count
00000930 5BCC FFD4                  		dbmi	d4,DrawSprite_FlipY		; Loop if there are still enough sprites left
00000934 4E75                       		rts
00000936                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000936                            ; Draw the sprites from mappings (with boundary checks)
00000936                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000936                            ; PARAMETERS:
00000936                            ;	d0.w	- X position
00000936                            ;	d1.w	- Y position
00000936                            ;	d4.w	- Number of sprites to draw
00000936                            ;	d5.w	- Sprite tile properties
00000936                            ;	d6.b	- Render flags
00000936                            ;	d7.w	- Max number of sprites left to draw
00000936                            ;	a1.l	- Mappings frame data
00000936                            ;	a6.l	- Sprite table buffer
00000936                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000936                            ; RETURNS:
00000936                            ;	Nothing
00000936                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000936                            DrawSprite_BoundChk:
00000936 E20E                       		lsr.b	#1,d6				; Is this sprite flipped horizontally?
00000938 6500                       		bcs.s	DrawSprite_BndChk_FlipX		; If so, branch
0000093A E20E                       		lsr.b	#1,d6				; Is this sprite flipped vertically?
0000093C 6500 0000                  		bcs.w	DrawSprite_BndChk_FlipY		; If so, branch
00000940                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000940                            ; Draw the sprites from mappings (with boundary checks) with no flip checks
00000940                            ; (Parameters inherited from DrawSprite_BoundChk, minus d6, a.k.a. render flags)
00000940                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000940                            DrawSprBndChk_Loop:
00000940 1419                       		move.b	(a1)+,d2			; Get Y offset
00000942 4882                       		ext.w	d2				; ''
00000944 D441                       		add.w	d1,d2				; Add onto Y position
00000946 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it above the screen?
0000094A 6300                       		bls.s	.Next_YOffScr			; If so, branch
0000094C 0C42 0160                  		cmpi.w	#224+128,d2			; Is it below the screen?
00000950 6400                       		bhs.s	.Next_YOffScr			; If so, branch
00000952 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000954 1CD9                       		move.b	(a1)+,(a6)+			; Store sprite size
00000956 524E                       		addq.w	#1,a6				; Skip link data
00000958 3419                       		move.w	(a1)+,d2			; Get tile properties
0000095A D445                       		add.w	d5,d2				; Add base tile properties
0000095C 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
0000095E 3419                       		move.w	(a1)+,d2			; Get X offset
00000960 D440                       		add.w	d0,d2				; Add onto X position
00000962 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it left of the screen?
00000966 6300                       		bls.s	.Next_XOffScr			; If so, branch
00000968 0C42 01C0                  		cmpi.w	#320+128,d2			; Is it right of the screen?
0000096C 6400                       		bhs.s	.Next_XOffScr			; If so, branch
0000096E 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000970 5347                       		subq.w	#1,d7				; Decrement sprite count
00000972 5BCC FFCC                  		dbmi	d4,DrawSprBndChk_Loop		; Loop if there are still enough sprites left
00000976 4E75                       		rts
00000978                            
00000978                            .Next_XOffScr:
00000978 5D4E                       		subq.w	#6,a6				; Go back to the start of the current sprite entry
0000097A 51CC FFC4                  		dbf	d4,DrawSprBndChk_Loop		; Loop if there are still enough sprites left
0000097E 4E75                       		rts
00000980                            
00000980                            .Next_YOffScr:
00000980 5A49                       		addq.w	#5,a1				; Go to the next sprite in the mappings in the mappings
00000982 51CC FFBC                  		dbf	d4,DrawSprBndChk_Loop		; Loop if there are still enough sprites left
00000986 4E75                       		rts
00000988                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000988                            ; Draw the sprites from mappings (with boundary checks), horizontally flipped
00000988                            ; (Parameters inherited from DrawSprite_BoundChk)
00000988                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000988                            DrawSprite_BndChk_FlipX:
00000988 E20E                       		lsr.b	#1,d6				; Is this sprite flipped vertically?
0000098A 6500                       		bcs.s	DrawSprite_BndChk_FlipXY	; If so, branch
0000098C                            
0000098C                            .Loop:
0000098C 1419                       		move.b	(a1)+,d2			; Get Y offset
0000098E 4882                       		ext.w	d2				; ''
00000990 D441                       		add.w	d1,d2				; Add onto Y position
00000992 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it above the screen?
00000996 6300                       		bls.s	.Next_YOffScr			; If so, branch
00000998 0C42 0160                  		cmpi.w	#224+128,d2			; Is it below the screen?
0000099C 6400                       		bhs.s	.Next_YOffScr			; If so, branch
0000099E 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000009A0 1C19                       		move.b	(a1)+,d6			; Get sprite size
000009A2 1CC6                       		move.b	d6,(a6)+			; Store in sprite table
000009A4 524E                       		addq.w	#1,a6				; Skip link data
000009A6 3419                       		move.w	(a1)+,d2			; Get tile properties
000009A8 D445                       		add.w	d5,d2				; Add base tile properties
000009AA 0A42 0800                  		eori.w	#$800,d2			; Flip horizontally
000009AE 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000009B0 3419                       		move.w	(a1)+,d2			; Get X offset
000009B2 4442                       		neg.w	d2				; Negate it
000009B4 1C3B 6000                  		move.b	DrwSprBndChk_XFlips(pc,d6.w),d6; Get the X offset to apply
000009B8 9446                       		sub.w	d6,d2				; Subtract the new X offset
000009BA D440                       		add.w	d0,d2				; Add onto X position
000009BC 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it left of the screen?
000009C0 6300                       		bls.s	.Next_XOffScr			; If so, branch
000009C2 0C42 01C0                  		cmpi.w	#320+128,d2			; Is it right of the screen?
000009C6 6400                       		bhs.s	.Next_XOffScr			; If so, branch
000009C8 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000009CA 5347                       		subq.w	#1,d7				; Decrement sprite count
000009CC 5BCC FFBE                  		dbmi	d4,.Loop			; Loop if there are still enough sprites left
000009D0 4E75                       		rts
000009D2                            
000009D2                            .Next_XOffScr:
000009D2 5D4E                       		subq.w	#6,a6				; Go back to the start of the current sprite entry
000009D4 51CC FFB6                  		dbf	d4,.Loop			; Loop if there are still enough sprites left
000009D8 4E75                       		rts
000009DA                            
000009DA                            .Next_YOffScr:
000009DA 5A49                       		addq.w	#5,a1				; Go to the next sprite in the mappings
000009DC 51CC FFAE                  		dbf	d4,.Loop			; Loop if there are still enough sprites left
000009E0 4E75                       		rts
000009E2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000009E2                            DrwSprBndChk_XFlips:
000009E2 0808 0808                  		dc.b	8, 8, 8, 8
000009E6 1010 1010                  		dc.b	$10, $10, $10, $10
000009EA 1818 1818                  		dc.b	$18, $18, $18, $18
000009EE 2020 2020                  		dc.b	$20, $20, $20, $20
000009F2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000009F2                            ; Draw the sprites from mappings (with boundary checks), horizontally and vertically flipped
000009F2                            ; (Parameters inherited from DrawSprite, minus d6, a.k.a. render flags)
000009F2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000009F2                            DrawSprite_BndChk_FlipXY:
000009F2 1419                       		move.b	(a1)+,d2			; Get Y offset
000009F4 4882                       		ext.w	d2				; ''
000009F6 4442                       		neg.w	d2				; Negate it
000009F8 1C11                       		move.b	(a1),d6				; Get sprite sizes
000009FA 1C3B 6000                  		move.b	DrwSprBndChk_YFlips(pc,d6.w),d6; Get the Y offset to apply
000009FE 9446                       		sub.w	d6,d2				; Subtract from the Y offset
00000A00 D441                       		add.w	d1,d2				; Add onto Y position
00000A02 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it above the screen?
00000A06 6300                       		bls.s	.Next_YOffScr			; If so, branch
00000A08 0C42 0160                  		cmpi.w	#224+128,d2			; Is it below the screen?
00000A0C 6400                       		bhs.s	.Next_YOffScr			; If so, branch
00000A0E 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000A10 1C19                       		move.b	(a1)+,d6			; Get sprite size
00000A12 1CC6                       		move.b	d6,(a6)+			; Store in sprite table
00000A14 524E                       		addq.w	#1,a6				; Skip link data
00000A16 3419                       		move.w	(a1)+,d2			; Get tile properties
00000A18 D445                       		add.w	d5,d2				; Add base tile properties
00000A1A 0A42 1800                  		eori.w	#$1800,d2			; Flip horizontally and vertically
00000A1E 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000A20 3419                       		move.w	(a1)+,d2			; Get X offset
00000A22 4442                       		neg.w	d2				; Negate it
00000A24 1C3B 60BC                  		move.b	DrwSprBndChk_XFlips(pc,d6.w),d6; Get the X offset to apply
00000A28 9446                       		sub.w	d6,d2				; Subtract the new X offset
00000A2A D440                       		add.w	d0,d2				; Add onto X position
00000A2C 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it left of the screen?
00000A30 6300                       		bls.s	.Next_XOffScr			; If so, branch
00000A32 0C42 01C0                  		cmpi.w	#320+128,d2			; Is it right of the screen?
00000A36 6400                       		bhs.s	.Next_XOffScr			; If so, branch
00000A38 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000A3A 5347                       		subq.w	#1,d7				; Decrement sprite count
00000A3C 5BCC FFB4                  		dbmi	d4,DrawSprite_BndChk_FlipXY	; Loop if there are still enough sprites left
00000A40 4E75                       		rts
00000A42                            
00000A42                            .Next_XOffScr:
00000A42 5D4E                       		subq.w	#6,a6				; Go back to the start of the current sprite entry
00000A44 51CC FFAC                  		dbf	d4,DrawSprite_BndChk_FlipXY	; Loop if there are still enough sprites left
00000A48 4E75                       		rts
00000A4A                            
00000A4A                            .Next_YOffScr:
00000A4A 5A49                       		addq.w	#5,a1				; Go to the next sprite in the mappings
00000A4C 51CC FFA4                  		dbf	d4,DrawSprite_BndChk_FlipXY	; Loop if there are still enough sprites left
00000A50 4E75                       		rts
00000A52                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A52                            DrwSprBndChk_YFlips:
00000A52 0810 1820                  		dc.b	8, $10, $18, $20
00000A56 0810 1820                  		dc.b	8, $10, $18, $20
00000A5A 0810 1820                  		dc.b	8, $10, $18, $20
00000A5E 0810 1820                  		dc.b	8, $10, $18, $20
00000A62                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A62                            ; Draw the sprites from mappings (with boundary checks), vertically flipped
00000A62                            ; (Parameters inherited from DrawSprite_BoundChk)
00000A62                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A62                            DrawSprite_BndChk_FlipY:
00000A62 1419                       		move.b	(a1)+,d2			; Get Y offset
00000A64 4882                       		ext.w	d2				; ''
00000A66 4442                       		neg.w	d2				; Negate it
00000A68 1C19                       		move.b	(a1)+,d6			; Get sprite sizes
00000A6A 1D46 0002                  		move.b	d6,2(a6)			; Store in sprite table
00000A6E 1C3B 60E2                  		move.b	DrwSprBndChk_YFlips(pc,d6.w),d6; Get the Y offset to apply
00000A72 9446                       		sub.w	d6,d2				; Subtract from the Y offset
00000A74 D441                       		add.w	d1,d2				; Add onto Y position
00000A76 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it above the screen?
00000A7A 6300                       		bls.s	.Next_YOffScr			; If so, branch
00000A7C 0C42 0160                  		cmpi.w	#224+128,d2			; Is it below the screen?
00000A80 6400                       		bhs.s	.Next_YOffScr			; If so, branch
00000A82 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000A84 544E                       		addq.w	#2,a6				; Skip link data
00000A86 3419                       		move.w	(a1)+,d2			; Get tile properties
00000A88 D445                       		add.w	d5,d2				; Add base tile properties
00000A8A 0A42 1000                  		eori.w	#$1000,d2			; Flip vertically
00000A8E 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000A90 3419                       		move.w	(a1)+,d2			; Get X offset
00000A92 D440                       		add.w	d0,d2				; Add onto X position
00000A94 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it left of the screen?
00000A98 6300                       		bls.s	.Next_XOffScr			; If so, branch
00000A9A 0C42 01C0                  		cmpi.w	#320+128,d2			; Is it right of the screen?
00000A9E 6400                       		bhs.s	.Next_XOffScr			; If so, branch
00000AA0 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000AA2 5347                       		subq.w	#1,d7				; Decrement sprite count
00000AA4 5BCC FFBC                  		dbmi	d4,DrawSprite_BndChk_FlipY	; Loop if there are still enough sprites left
00000AA8 4E75                       		rts
00000AAA                            
00000AAA                            .Next_XOffScr:
00000AAA 5D4E                       		subq.w	#6,a6				; Go back to the start of the current sprite entry
00000AAC 51CC FFB4                  		dbf	d4,DrawSprite_BndChk_FlipY	; Loop if there are still enough sprites left
00000AB0 4E75                       		rts
00000AB2                            
00000AB2                            .Next_YOffScr:
00000AB2 5A49                       		addq.w	#5,a1				; Go to the next sprite in the mappings
00000AB4 51CC FFAC                  		dbf	d4,DrawSprite_BndChk_FlipY	; Loop if there are still enough sprites left
00000AB8 4E75                       		rts
00000ABA                            ; =========================================================================================================================================================
00000ABA                            		include	"Libraries/Joypad.asm"		; Joypad functions
00000ABA                            ; =========================================================================================================================================================
00000ABA                            ; Joypad functions
00000ABA                            ; =========================================================================================================================================================
00000ABA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000ABA                            ; Read joypad input
00000ABA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000ABA                            ; PARAMETERS:
00000ABA                            ;	Nothing
00000ABA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000ABA                            ; RETURNS:
00000ABA                            ;	Nothing
00000ABA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000ABA                            ReadJoypads:
00000ABA 41F8 C742                  	lea	ctrlDataP1.w,a0			; 8	; load RAM space for joypad data
00000ABE 43F9 00A1 0002             	lea	PORT_A_DATA-1,a1		; 12	; load I/O data port A
00000AC4 7000                       	moveq	#%00000000,d0			; 4	; prepare TH = 0 request value
00000AC6 7240                       	moveq	#%01000000,d1			; 4	; prepare TH = 1 request value
00000AC8                            
00000AC8                            	; Repeat the following twice to
00000AC8                            	; collect input from both pads
00000AC8                            	rept	2
00000AC8                            		move.w	d0,(a1)			; 8	; set TH = 0 (burn 8 cycles to wait for returned data by setting up bitmasks below)
00000AC8                            		moveq	#%00110000,d2		; 4	; button bitmask mask for TH = 0
00000AC8                            		moveq	#%00111111,d3		; 4	; button bitmask for TH = 1
00000AC8                            		and.w	(a1),d2			; 8	; collect current button data for TH = 0 (A and Start)
00000AC8                            		move.w	d1,(a1)			; 8	; set TH = 1 (burn 8 cycles again below to wait)
00000AC8                            		add.b	d2,d2			; 4	; shift TH = 0 button bits to the left by two
00000AC8                            		add.b	d2,d2			; 4	; (A and start will be bits $6 and $7 in saved data)
00000AC8                            		and.w	(a1)+,d3		; 8	; collect current button data for TH = 1 (Up, Down, Left, Right, B, and C)
00000AC8                            		or.b	d3,d2			; 4	; combine collected button bits
00000AC8                            		not.b	d2			; 4	; flip bits (now pressed = 1 and not pressed = 0)
00000AC8                            		move.b	(a0),d3			; 8	; d3 = last collected button data
00000AC8                            		eor.b	d2,d3			; 4	; remove any currently pressed buttons from d3
00000AC8                            		move.b	d2,(a0)+		; 8	; save d2 (current button presses) as current held buttons
00000AC8                            		and.b	d2,d3			; 4	; limit d3 (pressed buttons) to only include current buttons
00000AC8                            		move.b	d3,(a0)+		; 8	; save all pressed buttons for this frame
00000AC8                            	endr
00000AC8 3280                     M 	move.w	d0,(a1)
00000ACA 7430                     M 	moveq	#%00110000,d2
00000ACC 763F                     M 	moveq	#%00111111,d3
00000ACE C451                     M 	and.w	(a1),d2
00000AD0 3281                     M 	move.w	d1,(a1)
00000AD2 D402                     M 	add.b	d2,d2
00000AD4 D402                     M 	add.b	d2,d2
00000AD6 C659                     M 	and.w	(a1)+,d3
00000AD8 8403                     M 	or.b	d3,d2
00000ADA 4602                     M 	not.b	d2
00000ADC 1610                     M 	move.b	(a0),d3
00000ADE B503                     M 	eor.b	d2,d3
00000AE0 10C2                     M 	move.b	d2,(a0)+
00000AE2 C602                     M 	and.b	d2,d3
00000AE4 10C3                     M 	move.b	d3,(a0)+
00000AE6 3280                     M 	move.w	d0,(a1)
00000AE8 7430                     M 	moveq	#%00110000,d2
00000AEA 763F                     M 	moveq	#%00111111,d3
00000AEC C451                     M 	and.w	(a1),d2
00000AEE 3281                     M 	move.w	d1,(a1)
00000AF0 D402                     M 	add.b	d2,d2
00000AF2 D402                     M 	add.b	d2,d2
00000AF4 C659                     M 	and.w	(a1)+,d3
00000AF6 8403                     M 	or.b	d3,d2
00000AF8 4602                     M 	not.b	d2
00000AFA 1610                     M 	move.b	(a0),d3
00000AFC B503                     M 	eor.b	d2,d3
00000AFE 10C2                     M 	move.b	d2,(a0)+
00000B00 C602                     M 	and.b	d2,d3
00000B02 10C3                     M 	move.b	d3,(a0)+
00000B04                            
00000B04 4E75                       	rts					; 16	; return
00000B06                            
00000B06                            ; =========================================================================================================================================================
00000B06                            		include	"Libraries/Decompression.asm"	; Decompression functions
00000B06                            ; =========================================================================================================================================================
00000B06                            ; Decompression functions
00000B06                            ; =========================================================================================================================================================
00000B06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000B06                            ; Kosinski decompression (General purpose)
00000B06                            ; New faster version by written by vladikcomper, with additional improvements by MarkeyJester and Flamewing
00000B06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000B06                            ; PARAMETERS:
00000B06                            ;	a0.l	- Source address
00000B06                            ;	a1.l	- Destination address
00000B06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000B06                            ; RETURNS:
00000B06                            ;	a1.l	- End of decompressed data address
00000B06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000B06 =00000001                  _Kos_UseLUT			equ	1
00000B06 =00000003                  _Kos_LoopUnroll			equ	3
00000B06 =00000001                  _Kos_ExtremeUnrolling		equ	1
00000B06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000B06                            _Kos_RunBitStream macro
00000B06                            		dbra	d2,.skip\@
00000B06                            		moveq	#7,d2				; Set repeat count to 8.
00000B06                            		move.b	d1,d0				; Use the remaining 8 bits.
00000B06                            		not.w	d3				; Have all 16 bits been used up?
00000B06                            		bne.s	.skip\@				; Branch if not.
00000B06                            		move.b	(a0)+,d0			; Get desc field low-byte.
00000B06                            		move.b	(a0)+,d1			; Get desc field hi-byte.
00000B06                            	if _Kos_UseLUT=1
00000B06                            		move.b	(a4,d0.w),d0			; Invert bit order...
00000B06                            		move.b	(a4,d1.w),d1			; ... for both bytes.
00000B06                            	endif
00000B06                            .skip\@:
00000B06                            		endm
00000B06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000B06                            _Kos_ReadBit macro
00000B06                            	if _Kos_UseLUT=1
00000B06                            		add.b	d0,d0				; Get a bit from the bitstream.
00000B06                            	else
00000B06                            		lsr.b	#1,d0				; Get a bit from the bitstream.
00000B06                            	endif
00000B06                            		endm
00000B06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000B06                            KosDec:
00000B06 7E07                       		moveq	#(1<<_Kos_LoopUnroll)-1,d7
00000B08 7000                       		moveq	#0,d0
00000B0A 7200                       		moveq	#0,d1
00000B0C 49FA 0000                  		lea	KosDec_ByteMap(pc),a4		; Load LUT pointer.
00000B10 1018                       		move.b	(a0)+,d0			; Get desc field low-byte.
00000B12 1218                       		move.b	(a0)+,d1			; Get desc field hi-byte.
00000B14 1034 0000                  		move.b	(a4,d0.w),d0			; Invert bit order...
00000B18 1234 1000                  		move.b	(a4,d1.w),d1			; ... for both bytes.
00000B1C 7407                       		moveq	#7,d2				; Set repeat count to 8.
00000B1E 7600                       		moveq	#0,d3				; d3 will be desc field switcher.
00000B20 6000                       		bra.s	.FetchNewCode
00000B22                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000B22                            .FetchCodeLoop:
00000B22                            		; Code 1 (Uncompressed byte).
00000B22                            		_Kos_RunBitStream
00000B22 51CA 0000                M 	dbra	d2,.skip_30
00000B26 7407                     M 	moveq	#7,d2
00000B28 1001                     M 	move.b	d1,d0
00000B2A 4643                     M 	not.w	d3
00000B2C 6600                     M 	bne.s	.skip_30
00000B2E 1018                     M 	move.b	(a0)+,d0
00000B30 1218                     M 	move.b	(a0)+,d1
00000B32 1034 0000                M 	move.b	(a4,d0.w),d0
00000B36 1234 1000                M 	move.b	(a4,d1.w),d1
00000B3A                          M .skip_30:
00000B3A 12D8                       		move.b	(a0)+,(a1)+
00000B3C                             
00000B3C                            .FetchNewCode:
00000B3C                            		_Kos_ReadBit
00000B3C D000                     M 	add.b	d0,d0
00000B3E 65E2                       		bcs.s	.FetchCodeLoop			; If code = 1, branch.
00000B40                             
00000B40                            		; Codes 00 and 01.
00000B40 7AFF                       		moveq	#-1,d5
00000B42 4BD1                       		lea	(a1),a5
00000B44                            		_Kos_RunBitStream
00000B44 51CA 0000                M 	dbra	d2,.skip_32
00000B48 7407                     M 	moveq	#7,d2
00000B4A 1001                     M 	move.b	d1,d0
00000B4C 4643                     M 	not.w	d3
00000B4E 6600                     M 	bne.s	.skip_32
00000B50 1018                     M 	move.b	(a0)+,d0
00000B52 1218                     M 	move.b	(a0)+,d1
00000B54 1034 0000                M 	move.b	(a4,d0.w),d0
00000B58 1234 1000                M 	move.b	(a4,d1.w),d1
00000B5C                          M .skip_32:
00000B5C                            		_Kos_ReadBit
00000B5C D000                     M 	add.b	d0,d0
00000B5E 6500 0000                  		bcs.w	.Code_01
00000B62                             
00000B62                            		; Code 00 (Dictionary ref. short).
00000B62                            		_Kos_RunBitStream
00000B62 51CA 0000                M 	dbra	d2,.skip_34
00000B66 7407                     M 	moveq	#7,d2
00000B68 1001                     M 	move.b	d1,d0
00000B6A 4643                     M 	not.w	d3
00000B6C 6600                     M 	bne.s	.skip_34
00000B6E 1018                     M 	move.b	(a0)+,d0
00000B70 1218                     M 	move.b	(a0)+,d1
00000B72 1034 0000                M 	move.b	(a4,d0.w),d0
00000B76 1234 1000                M 	move.b	(a4,d1.w),d1
00000B7A                          M .skip_34:
00000B7A                            		_Kos_ReadBit
00000B7A D000                     M 	add.b	d0,d0
00000B7C 6500                       		bcs.s	.Copy45
00000B7E                            		_Kos_RunBitStream
00000B7E 51CA 0000                M 	dbra	d2,.skip_36
00000B82 7407                     M 	moveq	#7,d2
00000B84 1001                     M 	move.b	d1,d0
00000B86 4643                     M 	not.w	d3
00000B88 6600                     M 	bne.s	.skip_36
00000B8A 1018                     M 	move.b	(a0)+,d0
00000B8C 1218                     M 	move.b	(a0)+,d1
00000B8E 1034 0000                M 	move.b	(a4,d0.w),d0
00000B92 1234 1000                M 	move.b	(a4,d1.w),d1
00000B96                          M .skip_36:
00000B96                            		_Kos_ReadBit
00000B96 D000                     M 	add.b	d0,d0
00000B98 6500                       		bcs.s	.Copy3
00000B9A                            		_Kos_RunBitStream
00000B9A 51CA 0000                M 	dbra	d2,.skip_38
00000B9E 7407                     M 	moveq	#7,d2
00000BA0 1001                     M 	move.b	d1,d0
00000BA2 4643                     M 	not.w	d3
00000BA4 6600                     M 	bne.s	.skip_38
00000BA6 1018                     M 	move.b	(a0)+,d0
00000BA8 1218                     M 	move.b	(a0)+,d1
00000BAA 1034 0000                M 	move.b	(a4,d0.w),d0
00000BAE 1234 1000                M 	move.b	(a4,d1.w),d1
00000BB2                          M .skip_38:
00000BB2 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
00000BB4 DAC5                       		adda.w	d5,a5
00000BB6 12DD                       		move.b	(a5)+,(a1)+
00000BB8 12DD                       		move.b	(a5)+,(a1)+
00000BBA 6080                       		bra.s	.FetchNewCode
00000BBC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000BBC                            .Copy3:
00000BBC                            		_Kos_RunBitStream
00000BBC 51CA 0000                M 	dbra	d2,.skip_39
00000BC0 7407                     M 	moveq	#7,d2
00000BC2 1001                     M 	move.b	d1,d0
00000BC4 4643                     M 	not.w	d3
00000BC6 6600                     M 	bne.s	.skip_39
00000BC8 1018                     M 	move.b	(a0)+,d0
00000BCA 1218                     M 	move.b	(a0)+,d1
00000BCC 1034 0000                M 	move.b	(a4,d0.w),d0
00000BD0 1234 1000                M 	move.b	(a4,d1.w),d1
00000BD4                          M .skip_39:
00000BD4 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
00000BD6 DAC5                       		adda.w	d5,a5
00000BD8 12DD                       		move.b	(a5)+,(a1)+
00000BDA 12DD                       		move.b	(a5)+,(a1)+
00000BDC 12DD                       		move.b	(a5)+,(a1)+
00000BDE 6000 FF5C                  		bra.w	.FetchNewCode
00000BE2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000BE2                            .Copy45:
00000BE2                            		_Kos_RunBitStream
00000BE2 51CA 0000                M 	dbra	d2,.skip_40
00000BE6 7407                     M 	moveq	#7,d2
00000BE8 1001                     M 	move.b	d1,d0
00000BEA 4643                     M 	not.w	d3
00000BEC 6600                     M 	bne.s	.skip_40
00000BEE 1018                     M 	move.b	(a0)+,d0
00000BF0 1218                     M 	move.b	(a0)+,d1
00000BF2 1034 0000                M 	move.b	(a4,d0.w),d0
00000BF6 1234 1000                M 	move.b	(a4,d1.w),d1
00000BFA                          M .skip_40:
00000BFA                            		_Kos_ReadBit
00000BFA D000                     M 	add.b	d0,d0
00000BFC 6500                       		bcs.s	.Copy5
00000BFE                            		_Kos_RunBitStream
00000BFE 51CA 0000                M 	dbra	d2,.skip_42
00000C02 7407                     M 	moveq	#7,d2
00000C04 1001                     M 	move.b	d1,d0
00000C06 4643                     M 	not.w	d3
00000C08 6600                     M 	bne.s	.skip_42
00000C0A 1018                     M 	move.b	(a0)+,d0
00000C0C 1218                     M 	move.b	(a0)+,d1
00000C0E 1034 0000                M 	move.b	(a4,d0.w),d0
00000C12 1234 1000                M 	move.b	(a4,d1.w),d1
00000C16                          M .skip_42:
00000C16 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
00000C18 DAC5                       		adda.w	d5,a5
00000C1A 12DD                       		move.b	(a5)+,(a1)+
00000C1C 12DD                       		move.b	(a5)+,(a1)+
00000C1E 12DD                       		move.b	(a5)+,(a1)+
00000C20 12DD                       		move.b	(a5)+,(a1)+
00000C22 6000 FF18                  		bra.w	.FetchNewCode
00000C26                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000C26                            .Copy5:
00000C26                            		_Kos_RunBitStream
00000C26 51CA 0000                M 	dbra	d2,.skip_43
00000C2A 7407                     M 	moveq	#7,d2
00000C2C 1001                     M 	move.b	d1,d0
00000C2E 4643                     M 	not.w	d3
00000C30 6600                     M 	bne.s	.skip_43
00000C32 1018                     M 	move.b	(a0)+,d0
00000C34 1218                     M 	move.b	(a0)+,d1
00000C36 1034 0000                M 	move.b	(a4,d0.w),d0
00000C3A 1234 1000                M 	move.b	(a4,d1.w),d1
00000C3E                          M .skip_43:
00000C3E 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
00000C40 DAC5                       		adda.w	d5,a5
00000C42 12DD                       		move.b	(a5)+,(a1)+
00000C44 12DD                       		move.b	(a5)+,(a1)+
00000C46 12DD                       		move.b	(a5)+,(a1)+
00000C48 12DD                       		move.b	(a5)+,(a1)+
00000C4A 12DD                       		move.b	(a5)+,(a1)+
00000C4C 6000 FEEE                  		bra.w	.FetchNewCode
00000C50                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000C50                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000C50                            .Code_01:
00000C50 7800                       		moveq	#0,d4				; d4 will contain copy count.
00000C52                            		; Code 01 (Dictionary ref. long / special).
00000C52                            		_Kos_RunBitStream
00000C52 51CA 0000                M 	dbra	d2,.skip_44
00000C56 7407                     M 	moveq	#7,d2
00000C58 1001                     M 	move.b	d1,d0
00000C5A 4643                     M 	not.w	d3
00000C5C 6600                     M 	bne.s	.skip_44
00000C5E 1018                     M 	move.b	(a0)+,d0
00000C60 1218                     M 	move.b	(a0)+,d1
00000C62 1034 0000                M 	move.b	(a4,d0.w),d0
00000C66 1234 1000                M 	move.b	(a4,d1.w),d1
00000C6A                          M .skip_44:
00000C6A 1C18                       		move.b	(a0)+,d6			; d6 = %LLLLLLLL.
00000C6C 1818                       		move.b	(a0)+,d4			; d4 = %HHHHHCCC.
00000C6E 1A04                       		move.b	d4,d5				; d5 = %11111111 HHHHHCCC.
00000C70 EB4D                       		lsl.w	#5,d5				; d5 = %111HHHHH CCC00000.
00000C72 1A06                       		move.b	d6,d5				; d5 = %111HHHHH LLLLLLLL.
00000C74 C847                       		and.w	d7,d4				; d4 = %00000CCC.
00000C76 6600                       		bne.s	.StreamCopy			; if CCC=0, branch.
00000C78                             
00000C78                            		; special mode (extended counter)
00000C78 1818                       		move.b	(a0)+,d4			; Read cnt
00000C7A 6700                       		beq.s	.Quit				; If cnt=0, quit decompression.
00000C7C 5304                       		subq.b	#1,d4
00000C7E 6700 FEBC                  		beq.w	.FetchNewCode			; If cnt=1, fetch a new code.
00000C82                             
00000C82 DAC5                       		adda.w	d5,a5
00000C84 12DD                       		move.b	(a5)+,(a1)+			; Do 1 extra copy (to compensate +1 to copy counter).
00000C86 3C04                       		move.w	d4,d6
00000C88 4646                       		not.w	d6
00000C8A CC47                       		and.w	d7,d6
00000C8C DC46                       		add.w	d6,d6
00000C8E E64C                       		lsr.w	#_Kos_LoopUnroll,d4
00000C90 4EFB 6000                  		jmp	.LargeCopy(pc,d6.w)
00000C94                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000C94                            .LargeCopy:
00000C94                            	rept (1<<_Kos_LoopUnroll)
00000C94                            		move.b	(a5)+,(a1)+
00000C94                            	endr
00000C94 12DD                     M 	move.b	(a5)+,(a1)+
00000C96 12DD                     M 	move.b	(a5)+,(a1)+
00000C98 12DD                     M 	move.b	(a5)+,(a1)+
00000C9A 12DD                     M 	move.b	(a5)+,(a1)+
00000C9C 12DD                     M 	move.b	(a5)+,(a1)+
00000C9E 12DD                     M 	move.b	(a5)+,(a1)+
00000CA0 12DD                     M 	move.b	(a5)+,(a1)+
00000CA2 12DD                     M 	move.b	(a5)+,(a1)+
00000CA4 51CC FFEE                  		dbra	d4,.LargeCopy
00000CA8 6000 FE92                  		bra.w	.FetchNewCode
00000CAC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000CAC                            .StreamCopy:
00000CAC DAC5                       		adda.w	d5,a5
00000CAE 12DD                       		move.b	(a5)+,(a1)+			; Do 1 extra copy (to compensate +1 to copy counter).
00000CB0 BF44                       		eor.w	d7,d4
00000CB2 D844                       		add.w	d4,d4
00000CB4 4EFB 4000                  		jmp	.MediumCopy(pc,d4.w)
00000CB8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000CB8                            .MediumCopy:
00000CB8                            	rept 8
00000CB8                            		move.b	(a5)+,(a1)+
00000CB8                            	endr
00000CB8 12DD                     M 	move.b	(a5)+,(a1)+
00000CBA 12DD                     M 	move.b	(a5)+,(a1)+
00000CBC 12DD                     M 	move.b	(a5)+,(a1)+
00000CBE 12DD                     M 	move.b	(a5)+,(a1)+
00000CC0 12DD                     M 	move.b	(a5)+,(a1)+
00000CC2 12DD                     M 	move.b	(a5)+,(a1)+
00000CC4 12DD                     M 	move.b	(a5)+,(a1)+
00000CC6 12DD                     M 	move.b	(a5)+,(a1)+
00000CC8 6000 FE72                  		bra.w	.FetchNewCode
00000CCC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000CCC                            .Quit:
00000CCC 4E75                       		rts
00000CCE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000CCE                            KosDec_ByteMap:
00000CCE 0080 40C0 20A0 60E0 1090+  		dc.b	$00,$80,$40,$C0,$20,$A0,$60,$E0,$10,$90,$50,$D0,$30,$B0,$70,$F0
00000CDE 0888 48C8 28A8 68E8 1898+  		dc.b	$08,$88,$48,$C8,$28,$A8,$68,$E8,$18,$98,$58,$D8,$38,$B8,$78,$F8
00000CEE 0484 44C4 24A4 64E4 1494+  		dc.b	$04,$84,$44,$C4,$24,$A4,$64,$E4,$14,$94,$54,$D4,$34,$B4,$74,$F4
00000CFE 0C8C 4CCC 2CAC 6CEC 1C9C+  		dc.b	$0C,$8C,$4C,$CC,$2C,$AC,$6C,$EC,$1C,$9C,$5C,$DC,$3C,$BC,$7C,$FC
00000D0E 0282 42C2 22A2 62E2 1292+  		dc.b	$02,$82,$42,$C2,$22,$A2,$62,$E2,$12,$92,$52,$D2,$32,$B2,$72,$F2
00000D1E 0A8A 4ACA 2AAA 6AEA 1A9A+  		dc.b	$0A,$8A,$4A,$CA,$2A,$AA,$6A,$EA,$1A,$9A,$5A,$DA,$3A,$BA,$7A,$FA
00000D2E 0686 46C6 26A6 66E6 1696+  		dc.b	$06,$86,$46,$C6,$26,$A6,$66,$E6,$16,$96,$56,$D6,$36,$B6,$76,$F6
00000D3E 0E8E 4ECE 2EAE 6EEE 1E9E+  		dc.b	$0E,$8E,$4E,$CE,$2E,$AE,$6E,$EE,$1E,$9E,$5E,$DE,$3E,$BE,$7E,$FE
00000D4E 0181 41C1 21A1 61E1 1191+  		dc.b	$01,$81,$41,$C1,$21,$A1,$61,$E1,$11,$91,$51,$D1,$31,$B1,$71,$F1
00000D5E 0989 49C9 29A9 69E9 1999+  		dc.b	$09,$89,$49,$C9,$29,$A9,$69,$E9,$19,$99,$59,$D9,$39,$B9,$79,$F9
00000D6E 0585 45C5 25A5 65E5 1595+  		dc.b	$05,$85,$45,$C5,$25,$A5,$65,$E5,$15,$95,$55,$D5,$35,$B5,$75,$F5
00000D7E 0D8D 4DCD 2DAD 6DED 1D9D+  		dc.b	$0D,$8D,$4D,$CD,$2D,$AD,$6D,$ED,$1D,$9D,$5D,$DD,$3D,$BD,$7D,$FD
00000D8E 0383 43C3 23A3 63E3 1393+  		dc.b	$03,$83,$43,$C3,$23,$A3,$63,$E3,$13,$93,$53,$D3,$33,$B3,$73,$F3
00000D9E 0B8B 4BCB 2BAB 6BEB 1B9B+  		dc.b	$0B,$8B,$4B,$CB,$2B,$AB,$6B,$EB,$1B,$9B,$5B,$DB,$3B,$BB,$7B,$FB
00000DAE 0787 47C7 27A7 67E7 1797+  		dc.b	$07,$87,$47,$C7,$27,$A7,$67,$E7,$17,$97,$57,$D7,$37,$B7,$77,$F7
00000DBE 0F8F 4FCF 2FAF 6FEF 1F9F+  		dc.b	$0F,$8F,$4F,$CF,$2F,$AF,$6F,$EF,$1F,$9F,$5F,$DF,$3F,$BF,$7F,$FF
00000DCE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000DCE                            ; Enigma decompression (Mainly for plane mappings)
00000DCE                            ; New faster version by written by vladikcomper, with additional improvements by MarkeyJester and Flamewing
00000DCE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000DCE                            ; PARAMETERS:
00000DCE                            ;	d0.w	- Base tile properties (tile ID, flags, etc.)
00000DCE                            ;	a0.l	- Source address
00000DCE                            ;	a1.l	- Destination address
00000DCE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000DCE                            ; RETURNS:
00000DCE                            ;	a1.l	- End of decompressed data address
00000DCE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000DCE                            EniDec:
00000DCE                            		push.l d0-d7/a1-a5
00000DCE 48E7 FF7C                M 	movem.l	d0-d7/a1-a5,-(sp)
00000DD2 3640                       		movea.w d0,a3				; Store base tile properties
00000DD4 1018                       		move.b	(a0)+,d0
00000DD6 4880                       		ext.w	d0
00000DD8 3A40                       		movea.w d0,a5				; Store first byte, extended to word
00000DDA 1818                       		move.b	(a0)+,d4			; Store second byte
00000DDC E70C                       		lsl.b	#3,d4				; Multiply by 8
00000DDE 3458                       		movea.w (a0)+,a2			; Store third and fourth byte
00000DE0 D4CB                       		adda.w	a3,a2				; Add base tile properties
00000DE2 3858                       		movea.w (a0)+,a4			; Store fifth and sixth byte
00000DE4 D8CB                       		adda.w	a3,a4				; Add base tile properties
00000DE6 1A18                       		move.b	(a0)+,d5			; Store seventh byte
00000DE8 E145                       		asl.w	#8,d5				; Shift up by a byte
00000DEA 1A18                       		move.b	(a0)+,d5			; Store eigth byte in lower register byte
00000DEC 7C10                       		moveq	#$10,d6				; 16 bits = 2 bytes
00000DEE                            
00000DEE                            EniDec_Loop:
00000DEE 7007                       		moveq	#7,d0				; Process 7 bits at a time
00000DF0 3E06                       		move.w	d6,d7
00000DF2 9E40                       		sub.w	d0,d7
00000DF4 3205                       		move.w	d5,d1
00000DF6 EE69                       		lsr.w	d7,d1
00000DF8 0241 007F                  		andi.w	#$7F,d1				; Keep only lower 7 bits
00000DFC 3401                       		move.w	d1,d2
00000DFE 0C41 0040                  		cmpi.w	#$40,d1				; Is Bit 6 set?
00000E02 6400                       		bcc.s	.getnext			; If so, branch
00000E04 7006                       		moveq	#6,d0				; If not, process 6 bits instead of 7
00000E06 E24A                       		lsr.w	#1,d2				; Bitfield now becomes TTSSSS isntead of TTTSSSS
00000E08                            
00000E08                            .getnext:
00000E08 6100 0000                  		bsr.w	EniDec_ChkGetNextByte
00000E0C 0242 000F                  		andi.w	#$F,d2				; Keep only lower nibble
00000E10 E849                       		lsr.w	#4,d1				; Store upper nibble (max value = 7)
00000E12 D241                       		add.w	d1,d1
00000E14 4EFB 1000                  		jmp	EniDec_JmpTable(pc,d1.w)
00000E18                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E18                            EniDec_Sub0:
00000E18 32CA                       		move.w	a2,(a1)+			; Write to destination
00000E1A 524A                       		addq.w	#1,a2				; Increment
00000E1C 51CA FFFA                  		dbf	d2,EniDec_Sub0			; Repeat
00000E20 60CC                       		bra.s	EniDec_Loop
00000E22                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E22                            EniDec_Sub4:
00000E22 32CC                       		move.w	a4,(a1)+			; Write to destination
00000E24 51CA FFFC                  		dbf	d2,EniDec_Sub4			; Repeat
00000E28 60C4                       		bra.s	EniDec_Loop
00000E2A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E2A                            EniDec_Sub8:
00000E2A 6100 0000                  		bsr.w	EniDec_GetInlineCopyVal
00000E2E                            
00000E2E                            .loop1:
00000E2E 32C1                       		move.w	d1,(a1)+
00000E30 51CA FFFC                  		dbf	d2,.loop1
00000E34 60B8                       		bra.s	EniDec_Loop
00000E36                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E36                            EniDec_SubA:
00000E36 6100 0000                  		bsr.w	EniDec_GetInlineCopyVal
00000E3A                            
00000E3A                            .loop2:
00000E3A 32C1                       		move.w	d1,(a1)+
00000E3C 5241                       		addq.w	#1,d1
00000E3E 51CA FFFA                  		dbf	d2,.loop2
00000E42 60AA                       		bra.s	EniDec_Loop
00000E44                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E44                            EniDec_SubC:
00000E44 6100 0000                  		bsr.w	EniDec_GetInlineCopyVal
00000E48                            
00000E48                            .loop3:
00000E48 32C1                       		move.w	d1,(a1)+
00000E4A 5341                       		subq.w	#1,d1
00000E4C 51CA FFFA                  		dbf	d2,.loop3
00000E50 609C                       		bra.s	EniDec_Loop
00000E52                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E52                            EniDec_SubE:
00000E52 0C42 000F                  		cmpi.w	#$F,d2
00000E56 6700                       		beq.s	EniDec_End
00000E58                            
00000E58                            .loop4:
00000E58 6100 0000                  		bsr.w	EniDec_GetInlineCopyVal
00000E5C 32C1                       		move.w	d1,(a1)+
00000E5E 51CA FFF8                  		dbf	d2,.loop4
00000E62 608A                       		bra.s	EniDec_Loop
00000E64                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E64                            EniDec_JmpTable:
00000E64 60B2                       		bra.s	EniDec_Sub0
00000E66 60B0                       		bra.s	EniDec_Sub0
00000E68 60B8                       		bra.s	EniDec_Sub4
00000E6A 60B6                       		bra.s	EniDec_Sub4
00000E6C 60BC                       		bra.s	EniDec_Sub8
00000E6E 60C6                       		bra.s	EniDec_SubA
00000E70 60D2                       		bra.s	EniDec_SubC
00000E72 60DE                       		bra.s	EniDec_SubE
00000E74                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E74                            EniDec_End:
00000E74 5348                       		subq.w	#1,a0
00000E76 0C46 0010                  		cmpi.w	#16,d6				; Were we going to start on a completely new byte?
00000E7A 6600                       		bne.s	.norollback			; If not, branch
00000E7C 5348                       		subq.w	#1,a0
00000E7E                            
00000E7E                            .norollback:
00000E7E 3008                       		move.w	a0,d0
00000E80 E248                       		lsr.w	#1,d0				; Are we on an odd byte?
00000E82 6400                       		bcc.s	.evendest			; If not, branch
00000E84 5248                       		addq.w	#1,a0				; Ensure we're on an even byte
00000E86                            
00000E86                            .evendest:
00000E86                            		pop.l	d0-d7/a1-a5
00000E86 4CDF 3EFF                M 	movem.l	(sp)+,d0-d7/a1-a5
00000E8A 4E75                       		rts
00000E8C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E8C                            EniDec_GetInlineCopyVal:
00000E8C 360B                       		move.w	a3,d3				; Store base tile properties
00000E8E 1204                       		move.b	d4,d1
00000E90 D201                       		add.b	d1,d1
00000E92 6400                       		bcc.s	.nopriority			; If d4 was < $80
00000E94 5346                       		subq.w	#1,d6				; Get next bit number
00000E96 0D05                       		btst	d6,d5				; Is the bit set?
00000E98 6700                       		beq.s	.nopriority			; If not, branch
00000E9A 0043 8000                  		ori.w	#(1<<15),d3			; Set high priority bit
00000E9E                            
00000E9E                            .nopriority:
00000E9E D201                       		add.b	d1,d1
00000EA0 6400                       		bcc.s	.nopal1				; If d4 < $40
00000EA2 5346                       		subq.w	#1,d6				; Get next bit number
00000EA4 0D05                       		btst	d6,d5				; Is the bit set?
00000EA6 6700                       		beq.s	.nopal1				; If not, branch
00000EA8 0643 4000                  		addi.w	#(2<<13),d3			; Set the second palette bit
00000EAC                            
00000EAC                            .nopal1:
00000EAC D201                       		add.b	d1,d1
00000EAE 6400                       		bcc.s	.nopal0				; If d4 was < $20
00000EB0 5346                       		subq.w	#1,d6				; Get next bit number
00000EB2 0D05                       		btst	d6,d5				; Is the bit set?
00000EB4 6700                       		beq.s	.nopal0				; If not, branch
00000EB6 0643 2000                  		addi.w	#(1<<13),d3			; Set the first palette bit
00000EBA                            
00000EBA                            .nopal0:
00000EBA D201                       		add.b	d1,d1
00000EBC 6400                       		bcc.s	.noyflip			; If d4 was < $10
00000EBE 5346                       		subq.w	#1,d6				; Get next bit number
00000EC0 0D05                       		btst	d6,d5				; Is the bit set?
00000EC2 6700                       		beq.s	.noyflip			; If not, branch
00000EC4 0043 1000                  		ori.w	#(1<<12),d3			; Set the Y flip bit
00000EC8                            
00000EC8                            .noyflip:
00000EC8 D201                       		add.b	d1,d1
00000ECA 6400                       		bcc.s	.noxflip			; If d4 was < 8
00000ECC 5346                       		subq.w	#1,d6				; Get next bit number
00000ECE 0D05                       		btst	d6,d5				; Is the bit set?
00000ED0 6700                       		beq.s	.noxflip			; If not, branch
00000ED2 0043 0800                  		ori.w	#(1<<11),d3			; Set the X flip bit
00000ED6                            
00000ED6                            .noxflip:
00000ED6 3205                       		move.w	d5,d1
00000ED8 3E06                       		move.w	d6,d7				; Get remaining bits
00000EDA 9E4D                       		sub.w	a5,d7				; Subtract minimum bit number
00000EDC 6400                       		bcc.s	.GotEnoughBits			; If we're beyond that, branch
00000EDE 3C07                       		move.w	d7,d6
00000EE0 0646 0010                  		addi.w	#16,d6				; 16 bits = 2 bytes
00000EE4 4447                       		neg.w	d7				; Calculate bit deficit
00000EE6 EF69                       		lsl.w	d7,d1				; Make space for this many bits
00000EE8 1A10                       		move.b	(a0),d5				; Get next byte
00000EEA EF3D                       		rol.b	d7,d5				; Make the upper X bits the lower X bits
00000EEC DE47                       		add.w	d7,d7
00000EEE CA7B 7000                  		and.w	EniDec_AndVals-2(pc,d7.w),d5	; Only keep X lower bits
00000EF2 D245                       		add.w	d5,d1				; Compensate for the bit deficit
00000EF4                            
00000EF4                            .AddBits:
00000EF4 300D                       		move.w	a5,d0
00000EF6 D040                       		add.w	d0,d0
00000EF8 C27B 0000                  		and.w	EniDec_AndVals-2(pc,d0.w),d1	; Only keep as many bits as required
00000EFC D243                       		add.w	d3,d1				; Add base tile properties
00000EFE 1A18                       		move.b	(a0)+,d5			; Get current byte, move onto next byte
00000F00 E14D                       		lsl.w	#8,d5				; Shift up by a byte
00000F02 1A18                       		move.b	(a0)+,d5			; Store next byte in lower register byte
00000F04 4E75                       		rts
00000F06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F06                            .GotEnoughBits:
00000F06 6700                       		beq.s	.GotExactCount			; If the exact number of bits are leftover, branch
00000F08 EE69                       		lsr.w	d7,d1				; Remove unneeded bits
00000F0A 300D                       		move.w	a5,d0
00000F0C D040                       		add.w	d0,d0
00000F0E C27B 0000                  		and.w	EniDec_AndVals-2(pc,d0.w),d1	; Only keep as many bits as required
00000F12 D243                       		add.w	d3,d1				; Add base tile properties
00000F14 300D                       		move.w	a5,d0				; Store number of bits used up by inline copy
00000F16 6000                       		bra.s	EniDec_ChkGetNextByte		; Move onto next byte
00000F18                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F18                            .GotExactCount:
00000F18 7C10                       		moveq	#16,d6				; 16 bits = 2 bytes
00000F1A 60D8                       		bra.s	.AddBits
00000F1C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F1C                            EniDec_AndVals:
00000F1C 0001 0003 0007 000F        		dc.w	1, 3, 7, $F
00000F24 001F 003F 007F 00FF        		dc.w	$1F, $3F, $7F, $FF
00000F2C 01FF 03FF 07FF 0FFF        		dc.w	$1FF, $3FF, $7FF, $FFF
00000F34 1FFF 3FFF 7FFF FFFF        		dc.w	$1FFF, $3FFF, $7FFF, $FFFF
00000F3C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F3C                            EniDec_ChkGetNextByte:
00000F3C 9C40                       		sub.w	d0,d6
00000F3E 0C46 0009                  		cmpi.w	#9,d6
00000F42 6400                       		bcc.s	.Done
00000F44 5046                       		addq.w	#8,d6				; 8 bits = 1 byte
00000F46 E145                       		asl.w	#8,d5				; Shift up by a byte
00000F48 1A18                       		move.b	(a0)+,d5			; Store next byte in lower register byte
00000F4A                            
00000F4A                            .Done:
00000F4A 4E75                       		rts
00000F4C                            ; --------------------------------------------------------------------------------------------------------------------------------------
00000F4C                            ; Load a Kosinski Moduled Queue
00000F4C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F4C                            ; PARAMETERS:
00000F4C                            ;	a3.l	- Queue pointer
00000F4C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F4C                            ; RETURNS:
00000F4C                            ;	Nothing
00000F4C                            ; --------------------------------------------------------------------------------------------------------------------------------------
00000F4C                            LoadKosMQueue:
00000F4C 3C1B                       		move.w	(a3)+,d6			; Get number of entries
00000F4E 6B00                       		bmi.s	.End				; If it's negative, branch
00000F50                            
00000F50                            .Queue:
00000F50 225B                       		movea.l	(a3)+,a1			; Get art pointer
00000F52 341B                       		move.w	(a3)+,d2			; Get VRAM address
00000F54 6100                       		bsr.s	QueueKosMData			; Queue
00000F56 51CE FFF8                  		dbf	d6,.Queue			; Loop
00000F5A                            
00000F5A                            .End:
00000F5A 4E75                       		rts
00000F5C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F5C                            ; Adds a Kosinski Moduled archive to the module queue
00000F5C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F5C                            ; PARAMETERS:
00000F5C                            ;	d2.w	- Destination in VRAM
00000F5C                            ;	a1.l	- Address of the archive
00000F5C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F5C                            ; RETURNS:
00000F5C                            ;	Nothing
00000F5C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F5C                            QueueKosMData:
00000F5C 45F8 9994                  		lea	kosMList.w,a2
00000F60 4A92                       		tst.l	(a2)				; Is the first slot free?
00000F62 6700                       		beq.s	ProcessKosM_Init		; If it is, branch
00000F64                            		
00000F64                            .FindFreeSlot:
00000F64 5C4A                       		addq.w	#6,a2				; Otherwise, check next slot
00000F66 4A92                       		tst.l	(a2)
00000F68 66FA                       		bne.s	.FindFreeSlot
00000F6A 24C9                       		move.l	a1,(a2)+			; Store source address
00000F6C 34C2                       		move.w	d2,(a2)+			; Store destination VRAM address
00000F6E 4E75                       		rts
00000F70                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F70                            ; Initializes processing of the first module on the queue
00000F70                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F70                            ; PARAMETERS:
00000F70                            ;	Nothing
00000F70                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F70                            ; RETURNS:
00000F70                            ;	Nothing
00000F70                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F70                            ProcessKosM_Init:
00000F70 3619                       		move.w	(a1)+,d3			; Get uncompressed size
00000F72 0C43 A000                  		cmpi.w	#$A000,d3
00000F76 6600                       		bne.s	.GotSize
00000F78 363C 8000                  		move.w	#$8000,d3			; $A000 means $8000 for some reason
00000F7C                            
00000F7C                            .GotSize:
00000F7C E24B                       		lsr.w	#1,d3
00000F7E 3003                       		move.w	d3,d0
00000F80 EB58                       		rol.w	#5,d0
00000F82 0240 001F                  		andi.w	#$1F,d0				; Get number of complete modules
00000F86 11C0 9990                  		move.b	d0,kosMModules.w
00000F8A 0283 0000 07FF             		andi.l	#$7FF,d3			; Get size of last module in words
00000F90 6600                       		bne.s	.GotLeftover			; Branch if it's non-zero
00000F92 5338 9990                  		subq.b	#1,kosMModules.w		; Otherwise decrement the number of modules
00000F96 263C 0000 0800             		move.l	#$800,d3			; And take the size of the last module to be $800 words
00000F9C                            
00000F9C                            .GotLeftover:
00000F9C 31C3 9992                  		move.w	d3,kosMLastSize.w
00000FA0 31C2 9998                  		move.w	d2,kosMDestination.w
00000FA4 21C9 9994                  		move.l	a1,kosMSource.w
00000FA8 5238 9990                  		addq.b	#1,kosMModules.w		; Store total number of modules
00000FAC 4E75                       		rts
00000FAE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000FAE                            ; Processes the first module on the queue
00000FAE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000FAE                            ; PARAMETERS:
00000FAE                            ;	Nothing
00000FAE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000FAE                            ; RETURNS:
00000FAE                            ;	Nothing
00000FAE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000FAE                            ProcessKosM:
00000FAE 4A38 9990                  		tst.b	kosMModules.w
00000FB2 6600                       		bne.s	.ModulesLeft
00000FB4                            
00000FB4                            .Done:
00000FB4 4E75                       		rts
00000FB6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000FB6                            .ModulesLeft:
00000FB6 6B00                       		bmi.s	.DecompressionStarted
00000FB8 0C78 0004 994E             		cmpi.w	#(kosList_End-kosList)/8,kosCount.w
00000FBE 64F4                       		bhs.s	.Done				; Branch if the Kosinski decompression queue is full
00000FC0 2278 9994                  		movea.l	kosMList.w,a1
00000FC4 45F8 8000                  		lea	kosMBuff.w,a2
00000FC8 6100 0000                  		bsr.w	QueueKosData			; Add current module to decompression queue
00000FCC 0038 0080 9990             		ori.b	#$80,kosMModules.w		; And set bit to signify decompression in progress
00000FD2 4E75                       		rts
00000FD4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000FD4                            .DecompressionStarted:
00000FD4 4A78 994E                  		tst.w	kosCount.w
00000FD8 66DA                       		bne.s	.Done				; Branch if the decompression isn't complete
00000FDA                            
00000FDA                            		; Otherwise, DMA the decompressed data to VRAM
00000FDA 0238 007F 9990             		andi.b	#$7F,kosMModules.w
00000FE0 263C 0000 0800             		move.l	#$1000/2,d3
00000FE6 5338 9990                  		subq.b	#1,kosMModules.w
00000FEA 6600                       		bne.s	.Skip				; Branch if it isn't the last module
00000FEC 3638 9992                  		move.w	kosMLastSize.w,d3
00000FF0                            
00000FF0                            .Skip:
00000FF0 3438 9998                  		move.w	kosMDestination.w,d2
00000FF4 3002                       		move.w	d2,d0
00000FF6 D043                       		add.w	d3,d0
00000FF8 D043                       		add.w	d3,d0
00000FFA 31C0 9998                  		move.w	d0,kosMDestination.w		; Set new destination
00000FFE 2038 9994                  		move.l	kosMList.w,d0
00001002 2238 9970                  		move.l	kosList.w,d1
00001006 9081                       		sub.l	d1,d0
00001008 0280 0000 000F             		andi.l	#$F,d0
0000100E D280                       		add.l	d0,d1				; Round to the nearest $10 boundary
00001010 21C1 9994                  		move.l	d1,kosMList.w		; And set new source
00001014 223C FFFF 8000             		move.l	#kosMBuff,d1
0000101A 6100 F2E8                  		bsr.w	QueueDMATransfer
0000101E 4A38 9990                  		tst.b	kosMModules.w
00001022 6600 0000                  		bne.w	.Exit				; Return if this wasn't the last module
00001026 41F8 9994                  		lea	kosMList.w,a0
0000102A 43F8 999A                  		lea	(kosMList+6).w,a1
0000102E                            	rept (kosMList_End-kosMList)/6-1
0000102E                            		move.l	(a1)+,(a0)+			; Otherwise, shift all entries up
0000102E                            		move.w	(a1)+,(a0)+
0000102E                            	endr
0000102E 20D9                     M 	move.l	(a1)+,(a0)+
00001030 30D9                     M 	move.w	(a1)+,(a0)+
00001032 20D9                     M 	move.l	(a1)+,(a0)+
00001034 30D9                     M 	move.w	(a1)+,(a0)+
00001036 20D9                     M 	move.l	(a1)+,(a0)+
00001038 30D9                     M 	move.w	(a1)+,(a0)+
0000103A 20D9                     M 	move.l	(a1)+,(a0)+
0000103C 30D9                     M 	move.w	(a1)+,(a0)+
0000103E 20D9                     M 	move.l	(a1)+,(a0)+
00001040 30D9                     M 	move.w	(a1)+,(a0)+
00001042 20D9                     M 	move.l	(a1)+,(a0)+
00001044 30D9                     M 	move.w	(a1)+,(a0)+
00001046 20D9                     M 	move.l	(a1)+,(a0)+
00001048 30D9                     M 	move.w	(a1)+,(a0)+
0000104A 20D9                     M 	move.l	(a1)+,(a0)+
0000104C 30D9                     M 	move.w	(a1)+,(a0)+
0000104E 20D9                     M 	move.l	(a1)+,(a0)+
00001050 30D9                     M 	move.w	(a1)+,(a0)+
00001052 20D9                     M 	move.l	(a1)+,(a0)+
00001054 30D9                     M 	move.w	(a1)+,(a0)+
00001056 20D9                     M 	move.l	(a1)+,(a0)+
00001058 30D9                     M 	move.w	(a1)+,(a0)+
0000105A 20D9                     M 	move.l	(a1)+,(a0)+
0000105C 30D9                     M 	move.w	(a1)+,(a0)+
0000105E 20D9                     M 	move.l	(a1)+,(a0)+
00001060 30D9                     M 	move.w	(a1)+,(a0)+
00001062 20D9                     M 	move.l	(a1)+,(a0)+
00001064 30D9                     M 	move.w	(a1)+,(a0)+
00001066 20D9                     M 	move.l	(a1)+,(a0)+
00001068 30D9                     M 	move.w	(a1)+,(a0)+
0000106A 20D9                     M 	move.l	(a1)+,(a0)+
0000106C 30D9                     M 	move.w	(a1)+,(a0)+
0000106E 20D9                     M 	move.l	(a1)+,(a0)+
00001070 30D9                     M 	move.w	(a1)+,(a0)+
00001072 20D9                     M 	move.l	(a1)+,(a0)+
00001074 30D9                     M 	move.w	(a1)+,(a0)+
00001076 20D9                     M 	move.l	(a1)+,(a0)+
00001078 30D9                     M 	move.w	(a1)+,(a0)+
0000107A 20D9                     M 	move.l	(a1)+,(a0)+
0000107C 30D9                     M 	move.w	(a1)+,(a0)+
0000107E 20D9                     M 	move.l	(a1)+,(a0)+
00001080 30D9                     M 	move.w	(a1)+,(a0)+
00001082 20D9                     M 	move.l	(a1)+,(a0)+
00001084 30D9                     M 	move.w	(a1)+,(a0)+
00001086 20D9                     M 	move.l	(a1)+,(a0)+
00001088 30D9                     M 	move.w	(a1)+,(a0)+
0000108A 20D9                     M 	move.l	(a1)+,(a0)+
0000108C 30D9                     M 	move.w	(a1)+,(a0)+
0000108E 20D9                     M 	move.l	(a1)+,(a0)+
00001090 30D9                     M 	move.w	(a1)+,(a0)+
00001092 20D9                     M 	move.l	(a1)+,(a0)+
00001094 30D9                     M 	move.w	(a1)+,(a0)+
00001096 20D9                     M 	move.l	(a1)+,(a0)+
00001098 30D9                     M 	move.w	(a1)+,(a0)+
0000109A 20D9                     M 	move.l	(a1)+,(a0)+
0000109C 30D9                     M 	move.w	(a1)+,(a0)+
0000109E 20D9                     M 	move.l	(a1)+,(a0)+
000010A0 30D9                     M 	move.w	(a1)+,(a0)+
000010A2 20D9                     M 	move.l	(a1)+,(a0)+
000010A4 30D9                     M 	move.w	(a1)+,(a0)+
000010A6 20D9                     M 	move.l	(a1)+,(a0)+
000010A8 30D9                     M 	move.w	(a1)+,(a0)+
000010AA 4298                       		clr.l	(a0)+				; And mark the last slot as free
000010AC 4258                       		clr.w	(a0)+
000010AE 2038 9994                  		move.l	kosMList.w,d0
000010B2 6700                       		beq.s	.Exit				; Return if the queue is now empty
000010B4 2240                       		movea.l	d0,a1
000010B6 3438 9998                  		move.w	kosMDestination.w,d2
000010BA 6000 FEB4                  		bra.w	ProcessKosM_Init
000010BE                            
000010BE                            .Exit:
000010BE 4E75                       		rts
000010C0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000010C0                            ; Adds Kosinski-compressed data to the decompression queue
000010C0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000010C0                            ; PARAMETERS:
000010C0                            ;	a1.l	- Compressed data address
000010C0                            ;	a2.l	- Decompression destination in RAM
000010C0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000010C0                            ; RETURNS:
000010C0                            ;	Nothing
000010C0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000010C0                            QueueKosData:
000010C0 3038 994E                  		move.w	kosCount.w,d0
000010C4 E748                       		lsl.w	#3,d0
000010C6 47F8 9970                  		lea	kosList.w,a3
000010CA 2789 0000                  		move.l	a1,(a3,d0.w)			; Store source
000010CE 278A 0004                  		move.l	a2,4(a3,d0.w)			; Store destination
000010D2 5278 994E                  		addq.w	#1,kosCount.w
000010D6 4E75                       		rts
000010D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000010D8                            ; Checks if V-INT occured in the middle of Kosinski queue processing and stores the location from which processing is to resume if it did
000010D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000010D8                            ; PARAMETERS:
000010D8                            ;	Nothing
000010D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000010D8                            ; RETURNS:
000010D8                            ;	Nothing
000010D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000010D8                            SetKosBookmark:
000010D8 4A78 994E                  		tst.w	kosCount.w
000010DC 6A00                       		bpl.s	.Done				; Branch if a decompression wasn't in progress
000010DE 202F 0042                  		move.l	$42(sp),d0			; Check address V-INT is supposed to rte to
000010E2 0C80 0000 0000             		cmpi.l	#ProcessKos_Main,d0
000010E8 6500                       		bcs.s	.Done
000010EA 0C80 0000 0000             		cmpi.l	#ProcessKos_Done,d0
000010F0 6400                       		bcc.s	.Done
000010F2 21EF 0042 996C             		move.l	$42(sp),kosBookmark.w
000010F8 2F7C 0000 0000 0042        		move.l	#BackupKosRegs,$42(sp)		; Force V-INT to rte here instead if needed
00001100                            
00001100                            .Done:
00001100 4E75                       		rts
00001102                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001102                            ; Processes the first entry in the Kosinski decompression queue
00001102                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001102                            ; PARAMETERS:
00001102                            ;	Nothing
00001102                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001102                            ; RETURNS:
00001102                            ;	Nothing
00001102                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001102                            ProcessKos:
00001102 4A78 994E                  		tst.w	kosCount.w
00001106 6700 0000                  		beq.w	ProcessKos_Done
0000110A 6B00 0000                  		bmi.w	RestoreKosBookmark		; Branch if a decompression was interrupted by V-int
0000110E                            
0000110E                            ProcessKos_Main:
0000110E 0078 8000 994E             		ori.w	#$8000,kosCount.w	; Set sign bit to signify decompression in progress
00001114 2078 9970                  		movea.l	kosList.w,a0
00001118 2278 9974                  		movea.l	kosDestination.w,a1
0000111C                            		
0000111C                            		; What follows is identical to the normal Kosinski decompressor
0000111C 7E07                       		moveq	#(1<<_Kos_LoopUnroll)-1,d7
0000111E 7000                       		moveq	#0,d0
00001120 7200                       		moveq	#0,d1
00001122 49FA FBAA                  		lea	KosDec_ByteMap(pc),a4		; Load LUT pointer.
00001126 1018                       		move.b	(a0)+,d0			; Get desc field low-byte.
00001128 1218                       		move.b	(a0)+,d1			; Get desc field hi-byte.
0000112A 1034 0000                  		move.b	(a4,d0.w),d0			; Invert bit order...
0000112E 1234 1000                  		move.b	(a4,d1.w),d1			; ... for both bytes.
00001132 7407                       		moveq	#7,d2				; Set repeat count to 8.
00001134 7600                       		moveq	#0,d3				; d3 will be desc field switcher.
00001136 6000                       		bra.s	.FetchNewCode
00001138                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001138                            .FetchCodeLoop:
00001138                            		; Code 1 (Uncompressed byte).
00001138                            		_Kos_RunBitStream
00001138 51CA 0000                M 	dbra	d2,.skip_47
0000113C 7407                     M 	moveq	#7,d2
0000113E 1001                     M 	move.b	d1,d0
00001140 4643                     M 	not.w	d3
00001142 6600                     M 	bne.s	.skip_47
00001144 1018                     M 	move.b	(a0)+,d0
00001146 1218                     M 	move.b	(a0)+,d1
00001148 1034 0000                M 	move.b	(a4,d0.w),d0
0000114C 1234 1000                M 	move.b	(a4,d1.w),d1
00001150                          M .skip_47:
00001150 12D8                       		move.b	(a0)+,(a1)+
00001152                            
00001152                            .FetchNewCode:
00001152                            		_Kos_ReadBit
00001152 D000                     M 	add.b	d0,d0
00001154 65E2                       		bcs.s	.FetchCodeLoop			; If code = 1, branch.
00001156                            
00001156                            		; Codes 00 and 01.
00001156 7AFF                       		moveq	#-1,d5
00001158 4BD1                       		lea	(a1),a5
0000115A                            		_Kos_RunBitStream
0000115A 51CA 0000                M 	dbra	d2,.skip_49
0000115E 7407                     M 	moveq	#7,d2
00001160 1001                     M 	move.b	d1,d0
00001162 4643                     M 	not.w	d3
00001164 6600                     M 	bne.s	.skip_49
00001166 1018                     M 	move.b	(a0)+,d0
00001168 1218                     M 	move.b	(a0)+,d1
0000116A 1034 0000                M 	move.b	(a4,d0.w),d0
0000116E 1234 1000                M 	move.b	(a4,d1.w),d1
00001172                          M .skip_49:
00001172                            		_Kos_ReadBit
00001172 D000                     M 	add.b	d0,d0
00001174 6500 0000                  		bcs.w	.Code_01
00001178                            
00001178                            		; Code 00 (Dictionary ref. short).
00001178                            		_Kos_RunBitStream
00001178 51CA 0000                M 	dbra	d2,.skip_51
0000117C 7407                     M 	moveq	#7,d2
0000117E 1001                     M 	move.b	d1,d0
00001180 4643                     M 	not.w	d3
00001182 6600                     M 	bne.s	.skip_51
00001184 1018                     M 	move.b	(a0)+,d0
00001186 1218                     M 	move.b	(a0)+,d1
00001188 1034 0000                M 	move.b	(a4,d0.w),d0
0000118C 1234 1000                M 	move.b	(a4,d1.w),d1
00001190                          M .skip_51:
00001190                            		_Kos_ReadBit
00001190 D000                     M 	add.b	d0,d0
00001192 6500                       		bcs.s	.Copy45
00001194                            		_Kos_RunBitStream
00001194 51CA 0000                M 	dbra	d2,.skip_53
00001198 7407                     M 	moveq	#7,d2
0000119A 1001                     M 	move.b	d1,d0
0000119C 4643                     M 	not.w	d3
0000119E 6600                     M 	bne.s	.skip_53
000011A0 1018                     M 	move.b	(a0)+,d0
000011A2 1218                     M 	move.b	(a0)+,d1
000011A4 1034 0000                M 	move.b	(a4,d0.w),d0
000011A8 1234 1000                M 	move.b	(a4,d1.w),d1
000011AC                          M .skip_53:
000011AC                            		_Kos_ReadBit
000011AC D000                     M 	add.b	d0,d0
000011AE 6500                       		bcs.s	.Copy3
000011B0                            		_Kos_RunBitStream
000011B0 51CA 0000                M 	dbra	d2,.skip_55
000011B4 7407                     M 	moveq	#7,d2
000011B6 1001                     M 	move.b	d1,d0
000011B8 4643                     M 	not.w	d3
000011BA 6600                     M 	bne.s	.skip_55
000011BC 1018                     M 	move.b	(a0)+,d0
000011BE 1218                     M 	move.b	(a0)+,d1
000011C0 1034 0000                M 	move.b	(a4,d0.w),d0
000011C4 1234 1000                M 	move.b	(a4,d1.w),d1
000011C8                          M .skip_55:
000011C8 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
000011CA DAC5                       		adda.w	d5,a5
000011CC 12DD                       		move.b	(a5)+,(a1)+
000011CE 12DD                       		move.b	(a5)+,(a1)+
000011D0 6080                       		bra.s	.FetchNewCode
000011D2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000011D2                            .Copy3:
000011D2                            		_Kos_RunBitStream
000011D2 51CA 0000                M 	dbra	d2,.skip_56
000011D6 7407                     M 	moveq	#7,d2
000011D8 1001                     M 	move.b	d1,d0
000011DA 4643                     M 	not.w	d3
000011DC 6600                     M 	bne.s	.skip_56
000011DE 1018                     M 	move.b	(a0)+,d0
000011E0 1218                     M 	move.b	(a0)+,d1
000011E2 1034 0000                M 	move.b	(a4,d0.w),d0
000011E6 1234 1000                M 	move.b	(a4,d1.w),d1
000011EA                          M .skip_56:
000011EA 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
000011EC DAC5                       		adda.w	d5,a5
000011EE 12DD                       		move.b	(a5)+,(a1)+
000011F0 12DD                       		move.b	(a5)+,(a1)+
000011F2 12DD                       		move.b	(a5)+,(a1)+
000011F4 6000 FF5C                  		bra.w	.FetchNewCode
000011F8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000011F8                            .Copy45:
000011F8                            		_Kos_RunBitStream
000011F8 51CA 0000                M 	dbra	d2,.skip_57
000011FC 7407                     M 	moveq	#7,d2
000011FE 1001                     M 	move.b	d1,d0
00001200 4643                     M 	not.w	d3
00001202 6600                     M 	bne.s	.skip_57
00001204 1018                     M 	move.b	(a0)+,d0
00001206 1218                     M 	move.b	(a0)+,d1
00001208 1034 0000                M 	move.b	(a4,d0.w),d0
0000120C 1234 1000                M 	move.b	(a4,d1.w),d1
00001210                          M .skip_57:
00001210                            		_Kos_ReadBit
00001210 D000                     M 	add.b	d0,d0
00001212 6500                       		bcs.s	.Copy5
00001214                            		_Kos_RunBitStream
00001214 51CA 0000                M 	dbra	d2,.skip_59
00001218 7407                     M 	moveq	#7,d2
0000121A 1001                     M 	move.b	d1,d0
0000121C 4643                     M 	not.w	d3
0000121E 6600                     M 	bne.s	.skip_59
00001220 1018                     M 	move.b	(a0)+,d0
00001222 1218                     M 	move.b	(a0)+,d1
00001224 1034 0000                M 	move.b	(a4,d0.w),d0
00001228 1234 1000                M 	move.b	(a4,d1.w),d1
0000122C                          M .skip_59:
0000122C 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
0000122E DAC5                       		adda.w	d5,a5
00001230 12DD                       		move.b	(a5)+,(a1)+
00001232 12DD                       		move.b	(a5)+,(a1)+
00001234 12DD                       		move.b	(a5)+,(a1)+
00001236 12DD                       		move.b	(a5)+,(a1)+
00001238 6000 FF18                  		bra.w	.FetchNewCode
0000123C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000123C                            .Copy5:
0000123C                            		_Kos_RunBitStream
0000123C 51CA 0000                M 	dbra	d2,.skip_60
00001240 7407                     M 	moveq	#7,d2
00001242 1001                     M 	move.b	d1,d0
00001244 4643                     M 	not.w	d3
00001246 6600                     M 	bne.s	.skip_60
00001248 1018                     M 	move.b	(a0)+,d0
0000124A 1218                     M 	move.b	(a0)+,d1
0000124C 1034 0000                M 	move.b	(a4,d0.w),d0
00001250 1234 1000                M 	move.b	(a4,d1.w),d1
00001254                          M .skip_60:
00001254 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
00001256 DAC5                       		adda.w	d5,a5
00001258 12DD                       		move.b	(a5)+,(a1)+
0000125A 12DD                       		move.b	(a5)+,(a1)+
0000125C 12DD                       		move.b	(a5)+,(a1)+
0000125E 12DD                       		move.b	(a5)+,(a1)+
00001260 12DD                       		move.b	(a5)+,(a1)+
00001262 6000 FEEE                  		bra.w	.FetchNewCode
00001266                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001266                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001266                            .Code_01:
00001266 7800                       		moveq	#0,d4				; d4 will contain copy count.
00001268                            		; Code 01 (Dictionary ref. long / special).
00001268                            		_Kos_RunBitStream
00001268 51CA 0000                M 	dbra	d2,.skip_61
0000126C 7407                     M 	moveq	#7,d2
0000126E 1001                     M 	move.b	d1,d0
00001270 4643                     M 	not.w	d3
00001272 6600                     M 	bne.s	.skip_61
00001274 1018                     M 	move.b	(a0)+,d0
00001276 1218                     M 	move.b	(a0)+,d1
00001278 1034 0000                M 	move.b	(a4,d0.w),d0
0000127C 1234 1000                M 	move.b	(a4,d1.w),d1
00001280                          M .skip_61:
00001280 1C18                       		move.b	(a0)+,d6			; d6 = %LLLLLLLL.
00001282 1818                       		move.b	(a0)+,d4			; d4 = %HHHHHCCC.
00001284 1A04                       		move.b	d4,d5				; d5 = %11111111 HHHHHCCC.
00001286 EB4D                       		lsl.w	#5,d5				; d5 = %111HHHHH CCC00000.
00001288 1A06                       		move.b	d6,d5				; d5 = %111HHHHH LLLLLLLL.
0000128A C847                       		and.w	d7,d4				; d4 = %00000CCC.
0000128C 6600                       		bne.s	.StreamCopy			; if CCC=0, branch.
0000128E                            
0000128E                            		; special mode (extended counter)
0000128E 1818                       		move.b	(a0)+,d4			; Read cnt
00001290 6700                       		beq.s	.Quit				; If cnt=0, quit decompression.
00001292 5304                       		subq.b	#1,d4
00001294 6700 FEBC                  		beq.w	.FetchNewCode			; If cnt=1, fetch a new code.
00001298                            
00001298 DAC5                       		adda.w	d5,a5
0000129A 12DD                       		move.b	(a5)+,(a1)+			; Do 1 extra copy (to compensate +1 to copy counter).
0000129C 3C04                       		move.w	d4,d6
0000129E 4646                       		not.w	d6
000012A0 CC47                       		and.w	d7,d6
000012A2 DC46                       		add.w	d6,d6
000012A4 E64C                       		lsr.w	#_Kos_LoopUnroll,d4
000012A6 4EFB 6000                  		jmp	.LargeCopy(pc,d6.w)
000012AA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000012AA                            .LargeCopy:
000012AA                            	rept (1<<_Kos_LoopUnroll)
000012AA                            		move.b	(a5)+,(a1)+
000012AA                            	endr
000012AA 12DD                     M 	move.b	(a5)+,(a1)+
000012AC 12DD                     M 	move.b	(a5)+,(a1)+
000012AE 12DD                     M 	move.b	(a5)+,(a1)+
000012B0 12DD                     M 	move.b	(a5)+,(a1)+
000012B2 12DD                     M 	move.b	(a5)+,(a1)+
000012B4 12DD                     M 	move.b	(a5)+,(a1)+
000012B6 12DD                     M 	move.b	(a5)+,(a1)+
000012B8 12DD                     M 	move.b	(a5)+,(a1)+
000012BA 51CC FFEE                  		dbra	d4,.LargeCopy
000012BE 6000 FE92                  		bra.w	.FetchNewCode
000012C2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000012C2                            .StreamCopy:
000012C2 DAC5                       		adda.w	d5,a5
000012C4 12DD                       		move.b	(a5)+,(a1)+			; Do 1 extra copy (to compensate +1 to copy counter).
000012C6 BF44                       		eor.w	d7,d4
000012C8 D844                       		add.w	d4,d4
000012CA 4EFB 4000                  		jmp	.MediumCopy(pc,d4.w)
000012CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000012CE                            .MediumCopy:
000012CE                            	rept 8
000012CE                            		move.b	(a5)+,(a1)+
000012CE                            	endr
000012CE 12DD                     M 	move.b	(a5)+,(a1)+
000012D0 12DD                     M 	move.b	(a5)+,(a1)+
000012D2 12DD                     M 	move.b	(a5)+,(a1)+
000012D4 12DD                     M 	move.b	(a5)+,(a1)+
000012D6 12DD                     M 	move.b	(a5)+,(a1)+
000012D8 12DD                     M 	move.b	(a5)+,(a1)+
000012DA 12DD                     M 	move.b	(a5)+,(a1)+
000012DC 12DD                     M 	move.b	(a5)+,(a1)+
000012DE 6000 FE72                  		bra.w	.FetchNewCode
000012E2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000012E2                            .Quit:	
000012E2 21C8 9970                  		move.l	a0,kosList.w
000012E6 21C9 9974                  		move.l	a1,kosDestination.w
000012EA 0278 7FFF 994E             		andi.w	#$7FFF,kosCount.w		; Clear decompression in progress bit
000012F0 5378 994E                  		subq.w	#1,kosCount.w
000012F4 6700                       		beq.s	ProcessKos_Done			; Branch if there aren't any entries remaining in the queue
000012F6 41F8 9970                  		lea	kosList.w,a0
000012FA 43F8 9978                  		lea	(kosList+8).w,a1		; Otherwise, shift all entries up
000012FE                            	rept (kosList_End-kosList)/8-1
000012FE                            		move.l	(a1)+,(a0)+
000012FE                            		move.l	(a1)+,(a0)+
000012FE                            	endr
000012FE 20D9                     M 	move.l	(a1)+,(a0)+
00001300 20D9                     M 	move.l	(a1)+,(a0)+
00001302 20D9                     M 	move.l	(a1)+,(a0)+
00001304 20D9                     M 	move.l	(a1)+,(a0)+
00001306 20D9                     M 	move.l	(a1)+,(a0)+
00001308 20D9                     M 	move.l	(a1)+,(a0)+
0000130A                            
0000130A                            ProcessKos_Done:
0000130A 4E75                       		rts
0000130C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000130C                            RestoreKosBookmark:
0000130C 4CB8 007F 9950             		movem.w	kosRegisters.w,d0-d6
00001312 4CF8 2300 995E             		movem.l	(kosRegisters+2*7).w,a0-a1/a5
00001318 2F38 996C                  		move.l	kosBookmark.w,-(sp)
0000131C 3F38 996A                  		move.w	kosStatusReg.w,-(sp)
00001320 7E07                       		moveq	#(1<<_Kos_LoopUnroll)-1,d7
00001322 49FA F9AA                  		lea	KosDec_ByteMap(pc),a4		; Load LUT poiner
00001326 4E73                       		rte
00001328                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001328                            BackupKosRegs:
00001328 40F8 996A                  		move	sr,kosStatusReg.w
0000132C 48B8 007F 9950             		movem.w	d0-d6,kosRegisters.w
00001332 48F8 2300 995E             		movem.l	a0-a1/a5,(kosRegisters+2*7).w
00001338 4E75                       		rts
0000133A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000133A                            ; Load Kosinski compressed art into VRAM
0000133A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000133A                            ; PARAMETERS:
0000133A                            ;	a0.l	- Source address
0000133A                            ;	a1.l	- Destination address
0000133A                            ;	a2.w	- VRAM address
0000133A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000133A                            ; RETURNS:
0000133A                            ;	Nothing
0000133A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000133A                            LoadKosArt:
0000133A 2649                       		movea.l	a1,a3				; Save destination address
0000133C 6100 F7C8                  		bsr.w	KosDec				; Decompress the art
00001340                            
00001340 93CB                       		suba.l	a3,a1				; Get size of decompressed art
00001342 3609                       		move.w	a1,d3				; ''
00001344 E24B                       		lsr.w	#1,d3				; Divide by 2 for DMA
00001346 220B                       		move.l	a3,d1				; Use destination address for DMA source
00001348 340A                       		move.w	a2,d2				; Get destination VRAM address
0000134A 6000 EFB8                  		bra.w	QueueDMATransfer		; Queue a DMA transfer
0000134E                            ; =========================================================================================================================================================
0000134E                            		include	"Libraries/Math.asm"		; Math functions
0000134E                            ; =========================================================================================================================================================
0000134E                            ; Math functions
0000134E                            ; =========================================================================================================================================================
0000134E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000134E                            ; Get a pseudo random number
0000134E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000134E                            ; PARAMETERS:
0000134E                            ;	Nothing
0000134E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000134E                            ; RETURNS:
0000134E                            ;	d0.l	- Random number
0000134E                            ;	d1.l	- New seed
0000134E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000134E                            RandomNumber:
0000134E 2238 C762                  		move.l	randomSeed.w,d1			; Get seed
00001352 6600                       		bne.s	.Generate			; If it's already initialized, branch
00001354 223C 2A6D 365B             		move.l	#$2A6D365B,d1			; Initialize the seed
0000135A                            
0000135A                            .Generate:
0000135A 2001                       		move.l	d1,d0				; Do a bunch of calculations to get a "random" number
0000135C E581                       		asl.l	#2,d1				; ''
0000135E D280                       		add.l	d0,d1				; ''
00001360 E781                       		asl.l	#3,d1				; ''
00001362 D280                       		add.l	d0,d1				; ''
00001364 3001                       		move.w	d1,d0				; ''
00001366 4841                       		swap	d1				; ''
00001368 D041                       		add.w	d1,d0				; ''
0000136A 3200                       		move.w	d0,d1				; ''
0000136C 4841                       		swap	d1				; ''
0000136E 21C1 C762                  		move.l	d1,randomSeed.w			; Set new seed
00001372 4E75                       		rts
00001374                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001374                            ; Calculate the sine and cosine of an angle
00001374                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001374                            ; PARAMETERS:
00001374                            ;	d0.b	- Angle
00001374                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001374                            ; RETURNS:
00001374                            ;	d0.w	- Sine value
00001374                            ;	d1.w	- Cosine value	
00001374                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001374                            CalcSine:
00001374 0240 00FF                  		andi.w	#$FF,d0				; Only allow angles 0-$FF
00001378 5040                       		addq.w	#8,d0				; Turn into offset
0000137A D040                       		add.w	d0,d0				; ''
0000137C 323B 0000                  		move.w	SineTable-$10+$80(pc,d0.w),d1	; Get cosine value
00001380 303B 0000                  		move.w	SineTable-$10(pc,d0.w),d0	; Get sine value
00001384 4E75                       		rts
00001386                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001386                            SineTable:
00001386 0000 0006 000C 0012 0019+  		dc.w	$0000, $0006, $000C, $0012, $0019, $001F, $0025, $002B, $0031, $0038, $003E, $0044, $004A, $0050, $0056, $005C
000013A6 0061 0067 006D 0073 0078+  		dc.w	$0061, $0067, $006D, $0073, $0078, $007E, $0083, $0088, $008E, $0093, $0098, $009D, $00A2, $00A7, $00AB, $00B0
000013C6 00B5 00B9 00BD 00C1 00C5+  		dc.w	$00B5, $00B9, $00BD, $00C1, $00C5, $00C9, $00CD, $00D1, $00D4, $00D8, $00DB, $00DE, $00E1, $00E4, $00E7, $00EA
000013E6 00EC 00EE 00F1 00F3 00F4+  		dc.w	$00EC, $00EE, $00F1, $00F3, $00F4, $00F6, $00F8, $00F9, $00FB, $00FC, $00FD, $00FE, $00FE, $00FF, $00FF, $00FF
00001406 0100 00FF 00FF 00FF 00FE+  		dc.w	$0100, $00FF, $00FF, $00FF, $00FE, $00FE, $00FD, $00FC, $00FB, $00F9, $00F8, $00F6, $00F4, $00F3, $00F1, $00EE
00001426 00EC 00EA 00E7 00E4 00E1+  		dc.w	$00EC, $00EA, $00E7, $00E4, $00E1, $00DE, $00DB, $00D8, $00D4, $00D1, $00CD, $00C9, $00C5, $00C1, $00BD, $00B9
00001446 00B5 00B0 00AB 00A7 00A2+  		dc.w	$00B5, $00B0, $00AB, $00A7, $00A2, $009D, $0098, $0093, $008E, $0088, $0083, $007E, $0078, $0073, $006D, $0067
00001466 0061 005C 0056 0050 004A+  		dc.w	$0061, $005C, $0056, $0050, $004A, $0044, $003E, $0038, $0031, $002B, $0025, $001F, $0019, $0012, $000C, $0006
00001486 0000 FFFA FFF4 FFEE FFE7+  		dc.w	$0000, $FFFA, $FFF4, $FFEE, $FFE7, $FFE1, $FFDB, $FFD5, $FFCF, $FFC8, $FFC2, $FFBC, $FFB6, $FFB0, $FFAA, $FFA4
000014A6 FF9F FF99 FF93 FF8B FF88+  		dc.w	$FF9F, $FF99, $FF93, $FF8B, $FF88, $FF82, $FF7D, $FF78, $FF72, $FF6D, $FF68, $FF63, $FF5E, $FF59, $FF55, $FF50
000014C6 FF4B FF47 FF43 FF3F FF3B+  		dc.w	$FF4B, $FF47, $FF43, $FF3F, $FF3B, $FF37, $FF33, $FF2F, $FF2C, $FF28, $FF25, $FF22, $FF1F, $FF1C, $FF19, $FF16
000014E6 FF14 FF12 FF0F FF0D FF0C+  		dc.w	$FF14, $FF12, $FF0F, $FF0D, $FF0C, $FF0A, $FF08, $FF07, $FF05, $FF04, $FF03, $FF02, $FF02, $FF01, $FF01, $FF01
00001506 FF00 FF01 FF01 FF01 FF02+  		dc.w	$FF00, $FF01, $FF01, $FF01, $FF02, $FF02, $FF03, $FF04, $FF05, $FF07, $FF08, $FF0A, $FF0C, $FF0D, $FF0F, $FF12
00001526 FF14 FF16 FF19 FF1C FF1F+  		dc.w	$FF14, $FF16, $FF19, $FF1C, $FF1F, $FF22, $FF25, $FF28, $FF2C, $FF2F, $FF33, $FF37, $FF3B, $FF3F, $FF43, $FF47
00001546 FF4B FF50 FF55 FF59 FF5E+  		dc.w	$FF4B, $FF50, $FF55, $FF59, $FF5E, $FF63, $FF68, $FF6D, $FF72, $FF78, $FF7D, $FF82, $FF88, $FF8B, $FF93, $FF99
00001566 FF9F FFA4 FFAA FFB0 FFB6+  		dc.w	$FF9F, $FFA4, $FFAA, $FFB0, $FFB6, $FFBC, $FFC2, $FFC8, $FFCF, $FFD5, $FFDB, $FFE1, $FFE7, $FFEE, $FFF4, $FFFA
00001586 0000 0006 000C 0012 0019+  		dc.w	$0000, $0006, $000C, $0012, $0019, $001F, $0025, $002B, $0031, $0038, $003E, $0044, $004A, $0050, $0056, $005C
000015A6 0061 0067 006D 0073 0078+  		dc.w	$0061, $0067, $006D, $0073, $0078, $007E, $0083, $0088, $008E, $0093, $0098, $009D, $00A2, $00A7, $00AB, $00B0
000015C6 00B5 00B9 00BD 00C1 00C5+  		dc.w	$00B5, $00B9, $00BD, $00C1, $00C5, $00C9, $00CD, $00D1, $00D4, $00D8, $00DB, $00DE, $00E1, $00E4, $00E7, $00EA
000015E6 00EC 00EE 00F1 00F3 00F4+  		dc.w	$00EC, $00EE, $00F1, $00F3, $00F4, $00F6, $00F8, $00F9, $00FB, $00FC, $00FD, $00FE, $00FE, $00FF, $00FF, $00FF
00001606 0100 00FF 00FF 00FF 00FE+  		dc.w	$0100, $00FF, $00FF, $00FF, $00FE, $00FE, $00FD, $00FC, $00FB, $00F9, $00F8, $00F6, $00F4, $00F3, $00F1, $00EE
00001626 00EC 00EA 00E7 00E4 00E1+  		dc.w	$00EC, $00EA, $00E7, $00E4, $00E1, $00DE, $00DB, $00D8, $00D4, $00D1, $00CD, $00C9, $00C5, $00C1, $00BD, $00B9
00001646 00B5 00B0 00AB 00A7 00A2+  		dc.w	$00B5, $00B0, $00AB, $00A7, $00A2, $009D, $0098, $0093, $008E, $0088, $0083, $007E, $0078, $0073, $006D, $0067
00001666 0061 005C 0056 0050 004A+  		dc.w	$0061, $005C, $0056, $0050, $004A, $0044, $003E, $0038, $0031, $002B, $0025, $001F, $0019, $0012, $000C, $0006
00001686 0000 FFFA FFF4 FFEE FFE7+  		dc.w	$0000, $FFFA, $FFF4, $FFEE, $FFE7, $FFE1, $FFDB, $FFD5, $FFCF, $FFC8, $FFC2, $FFBC, $FFB6, $FFB0, $FFAA, $FFA4
000016A6 FF9F FF99 FF93 FF8B FF88+  		dc.w	$FF9F, $FF99, $FF93, $FF8B, $FF88, $FF82, $FF7D, $FF78, $FF72, $FF6D, $FF68, $FF63, $FF5E, $FF59, $FF55, $FF50
000016C6 FF4B FF47 FF43 FF3F FF3B+  		dc.w	$FF4B, $FF47, $FF43, $FF3F, $FF3B, $FF37, $FF33, $FF2F, $FF2C, $FF28, $FF25, $FF22, $FF1F, $FF1C, $FF19, $FF16
000016E6 FF14 FF12 FF0F FF0D FF0C+  		dc.w	$FF14, $FF12, $FF0F, $FF0D, $FF0C, $FF0A, $FF08, $FF07, $FF05, $FF04, $FF03, $FF02, $FF02, $FF01, $FF01, $FF01
00001706 FF00 FF01 FF01 FF01 FF02+  		dc.w	$FF00, $FF01, $FF01, $FF01, $FF02, $FF02, $FF03, $FF04, $FF05, $FF07, $FF08, $FF0A, $FF0C, $FF0D, $FF0F, $FF12
00001726 FF14 FF16 FF19 FF1C FF1F+  		dc.w	$FF14, $FF16, $FF19, $FF1C, $FF1F, $FF22, $FF25, $FF28, $FF2C, $FF2F, $FF33, $FF37, $FF3B, $FF3F, $FF43, $FF47
00001746 FF4B FF50 FF55 FF59 FF5E+  		dc.w	$FF4B, $FF50, $FF55, $FF59, $FF5E, $FF63, $FF68, $FF6D, $FF72, $FF78, $FF7D, $FF82, $FF88, $FF8B, $FF93, $FF99
00001766 FF9F FFA4 FFAA FFB0 FFB6+  		dc.w	$FF9F, $FFA4, $FFAA, $FFB0, $FFB6, $FFBC, $FFC2, $FFC8, $FFCF, $FFD5, $FFDB, $FFE1, $FFE7, $FFEE, $FFF4, $FFFA
00001786                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001786                            ; Calculate the arctangent of y/x
00001786                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001786                            ; PARAMETERS:
00001786                            ;	d1.w	- X position
00001786                            ;	d2.w	- Y position
00001786                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001786                            ; RETURNS:
00001786                            ;	d0.w	- The angle
00001786                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001786                            CalcArcTan:
00001786                            		push.l	d3-d4
00001786 48E7 1800                M 	movem.l	d3-d4,-(sp)
0000178A 7600                       		moveq	#0,d3
0000178C 7800                       		moveq	#0,d4
0000178E 3601                       		move.w	d1,d3
00001790 3802                       		move.w	d2,d4
00001792 8843                       		or.w	d3,d4
00001794 6700                       		beq.s	GetArcTan_Zero			; Special case when both x and y are zero
00001796 3802                       		move.w	d2,d4
00001798                            		
00001798 4A43                       		tst.w	d3
0000179A 6A00                       		bpl.s	.NotNeg
0000179C 4443                       		neg.w	d3
0000179E                            
0000179E                            .NotNeg:
0000179E 4A44                       		tst.w	d4
000017A0 6A00                       		bpl.s	.NotNeg2
000017A2 4444                       		neg.w	d4
000017A4                            
000017A4                            .NotNeg2:
000017A4 B843                       		cmp.w	d3,d4
000017A6 6400                       		bhs.s	.NotGreater			; If |y| >= |x|
000017A8 E18C                       		lsl.l	#8,d4
000017AA 88C3                       		divu.w	d3,d4
000017AC 7000                       		moveq	#0,d0
000017AE 103B 4000                  		move.b	ArcTanTable(pc,d4.w),d0
000017B2 6000                       		bra.s	.Skip
000017B4                            
000017B4                            .NotGreater:
000017B4 E18B                       		lsl.l	#8,d3
000017B6 86C4                       		divu.w	d4,d3
000017B8 7040                       		moveq	#$40,d0
000017BA 903B 3000                  		sub.b	ArcTanTable(pc,d3.w),d0		; arctan(y/x) = 90 - arctan(x/y)
000017BE                            
000017BE                            .Skip:
000017BE 4A41                       		tst.w	d1
000017C0 6A00                       		bpl.s	.Skip2
000017C2 4440                       		neg.w	d0
000017C4 0640 0080                  		addi.w	#$80,d0				; Place angle in appropriate quadrant
000017C8                            
000017C8                            .Skip2:
000017C8 4A42                       		tst.w	d2
000017CA 6A00                       		bpl.s	.Skip3
000017CC 4440                       		neg.w	d0
000017CE 0640 0100                  		addi.w	#$100,d0			; Place angle in appropriate quadrant
000017D2                            
000017D2                            .Skip3:
000017D2                            		pop.l	d3-d4
000017D2 4CDF 0018                M 	movem.l	(sp)+,d3-d4
000017D6 4E75                       		rts
000017D8                            
000017D8                            GetArcTan_Zero:
000017D8 303C 0040                  		move.w	#$40,d0				; Angle = 90 degrees
000017DC                            		pop.l	d3-d4
000017DC 4CDF 0018                M 	movem.l	(sp)+,d3-d4
000017E0 4E75                       		rts
000017E2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000017E2                            ArcTanTable:
000017E2 0000 0000 0101             		dc.b	$00, $00, $00, $00, $01, $01
000017E8 0101 0101 0202             		dc.b	$01, $01, $01, $01, $02, $02
000017EE 0202 0202 0303             		dc.b	$02, $02, $02, $02, $03, $03
000017F4 0303 0303 0304             		dc.b	$03, $03, $03, $03, $03, $04
000017FA 0404 0404 0405             		dc.b	$04, $04, $04, $04, $04, $05
00001800 0505 0505 0506             		dc.b	$05, $05, $05, $05, $05, $06
00001806 0606 0606 0606             		dc.b	$06, $06, $06, $06, $06, $06
0000180C 0707 0707 0707             		dc.b	$07, $07, $07, $07, $07, $07
00001812 0808 0808 0808             		dc.b	$08, $08, $08, $08, $08, $08
00001818 0809 0909 0909             		dc.b	$08, $09, $09, $09, $09, $09
0000181E 090A 0A0A 0A0A             		dc.b	$09, $0A, $0A, $0A, $0A, $0A
00001824 0A0A 0B0B 0B0B             		dc.b	$0A, $0A, $0B, $0B, $0B, $0B
0000182A 0B0B 0B0C 0C0C             		dc.b	$0B, $0B, $0B, $0C, $0C, $0C
00001830 0C0C 0C0C 0D0D             		dc.b	$0C, $0C, $0C, $0C, $0D, $0D
00001836 0D0D 0D0D 0D0E             		dc.b	$0D, $0D, $0D, $0D, $0D, $0E
0000183C 0E0E 0E0E 0E0E             		dc.b	$0E, $0E, $0E, $0E, $0E, $0E
00001842 0F0F 0F0F 0F0F             		dc.b	$0F, $0F, $0F, $0F, $0F, $0F
00001848 0F10 1010 1010             		dc.b	$0F, $10, $10, $10, $10, $10
0000184E 1010 1111 1111             		dc.b	$10, $10, $11, $11, $11, $11
00001854 1111 1111 1212             		dc.b	$11, $11, $11, $11, $12, $12
0000185A 1212 1212 1213             		dc.b	$12, $12, $12, $12, $12, $13
00001860 1313 1313 1313             		dc.b	$13, $13, $13, $13, $13, $13
00001866 1314 1414 1414             		dc.b	$13, $14, $14, $14, $14, $14
0000186C 1414 1415 1515             		dc.b	$14, $14, $14, $15, $15, $15
00001872 1515 1515 1515             		dc.b	$15, $15, $15, $15, $15, $15
00001878 1616 1616 1616             		dc.b	$16, $16, $16, $16, $16, $16
0000187E 1616 1717 1717             		dc.b	$16, $16, $17, $17, $17, $17
00001884 1717 1717 1718             		dc.b	$17, $17, $17, $17, $17, $18
0000188A 1818 1818 1818             		dc.b	$18, $18, $18, $18, $18, $18
00001890 1818 1919 1919             		dc.b	$18, $18, $19, $19, $19, $19
00001896 1919 1919 1919             		dc.b	$19, $19, $19, $19, $19, $19
0000189C 1A1A 1A1A 1A1A             		dc.b	$1A, $1A, $1A, $1A, $1A, $1A
000018A2 1A1A 1A1B 1B1B             		dc.b	$1A, $1A, $1A, $1B, $1B, $1B
000018A8 1B1B 1B1B 1B1B             		dc.b	$1B, $1B, $1B, $1B, $1B, $1B
000018AE 1B1C 1C1C 1C1C             		dc.b	$1B, $1C, $1C, $1C, $1C, $1C
000018B4 1C1C 1C1C 1C1C             		dc.b	$1C, $1C, $1C, $1C, $1C, $1C
000018BA 1D1D 1D1D 1D1D             		dc.b	$1D, $1D, $1D, $1D, $1D, $1D
000018C0 1D1D 1D1D 1D1E             		dc.b	$1D, $1D, $1D, $1D, $1D, $1E
000018C6 1E1E 1E1E 1E1E             		dc.b	$1E, $1E, $1E, $1E, $1E, $1E
000018CC 1E1E 1E1E 1F1F             		dc.b	$1E, $1E, $1E, $1E, $1F, $1F
000018D2 1F1F 1F1F 1F1F             		dc.b	$1F, $1F, $1F, $1F, $1F, $1F
000018D8 1F1F 1F1F 2020             		dc.b	$1F, $1F, $1F, $1F, $20, $20
000018DE 2020 2020 2000             		dc.b	$20, $20, $20, $20, $20, $00
000018E4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000018E4                            ; Initialize oscillation
000018E4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000018E4                            InitOscillation:
000018E4 43F8 C76C                  		lea	oscillators.w,a1
000018E8 45FA 0000                  		lea	OscInitData(pc),a2
000018EC 7200                       		moveq	#(OscInitData_End-OscInitData)>>1-1,d1
000018EE                            
000018EE                            .LoadData:
000018EE 32DA                       		move.w	(a2)+,(a1)+
000018F0 51C9 FFFC                  		dbf	d1,.LoadData
000018F4 4E75                       		rts
000018F6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000018F6                            OscInitData:
000018F6 007D                       		dc.w	%0000000001111101
000018F8 0080 0000                  		dc.w	$0080, $0000
000018FC 0080 0000                  		dc.w	$0080, $0000
00001900 0080 0000                  		dc.w	$0080, $0000
00001904 0080 0000                  		dc.w	$0080, $0000
00001908 0080 0000                  		dc.w	$0080, $0000
0000190C 0080 0000                  		dc.w	$0080, $0000
00001910 0080 0000                  		dc.w	$0080, $0000
00001914 0080 0000                  		dc.w	$0080, $0000
00001918 0080 0000                  		dc.w	$0080, $0000
0000191C 3848 00EE                  		dc.w	$3848, $00EE
00001920 2080 00B4                  		dc.w	$2080, $00B4
00001924 3080 010E                  		dc.w	$3080, $010E
00001928 5080 01C2                  		dc.w	$5080, $01C2
0000192C 7080 0276                  		dc.w	$7080, $0276
00001930 0080 0000                  		dc.w	$0080, $0000
00001934 4000 00FE                  		dc.w	$4000, $00FE
00001938                            OscInitData_End:
00001938                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001938                            ; Update oscillation
00001938                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001938                            UpdateOscillation:
00001938 43F8 C76C                  		lea	oscillators.w,a1
0000193C 45FA 0000                  		lea	OscUpdateData(pc),a2
00001940 3619                       		move.w	(a1)+,d3
00001942 7200                       		moveq	#(OscUpdateData_End-OscUpdateData)>>2-1,d1
00001944                            
00001944                            .OscLoop:
00001944 341A                       		move.w	(a2)+,d2
00001946 381A                       		move.w	(a2)+,d4
00001948 0303                       		btst	d1,d3
0000194A 6600                       		bne.s	.Sub
0000194C 3029 0002                  		move.w	2(a1),d0
00001950 D042                       		add.w	d2,d0
00001952 3340 0002                  		move.w	d0,2(a1)
00001956 D151                       		add.w	d0,(a1)
00001958 B811                       		cmp.b	(a1),d4
0000195A 6200                       		bhi.s	.DoLoop
0000195C 03C3                       		bset	d1,d3
0000195E 6000                       		bra.s	.DoLoop
00001960                            
00001960                            .Sub:
00001960 3029 0002                  		move.w	2(a1),d0
00001964 9042                       		sub.w	d2,d0
00001966 3340 0002                  		move.w	d0,2(a1)
0000196A D151                       		add.w	d0,(a1)
0000196C B811                       		cmp.b	(a1),d4
0000196E 6300                       		bls.s	.DoLoop
00001970 0383                       		bclr	d1,d3
00001972                            
00001972                            .DoLoop:
00001972 5849                       		addq.w	#4,a1
00001974 51C9 FFCE                  		dbf	d1,.OscLoop
00001978                            
00001978 31C3 C76C                  		move.w	d3,oscControl.w
0000197C                            
0000197C                            .End:
0000197C 4E75                       		rts
0000197E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000197E                            OscUpdateData:
0000197E 0002 0010                  		dc.w	$02, $10
00001982 0002 0018                  		dc.w	$02, $18
00001986 0002 0020                  		dc.w	$02, $20
0000198A 0002 0030                  		dc.w	$02, $30
0000198E 0004 0020                  		dc.w	$04, $20
00001992 0008 0008                  		dc.w	$08, $08
00001996 0008 0040                  		dc.w	$08, $40
0000199A 0004 0040                  		dc.w	$04, $40
0000199E 0002 0038                  		dc.w	$02, $38
000019A2 0002 0038                  		dc.w	$02, $38
000019A6 0002 0020                  		dc.w	$02, $20
000019AA 0003 0030                  		dc.w	$03, $30
000019AE 0005 0050                  		dc.w	$05, $50
000019B2 0007 0070                  		dc.w	$07, $70
000019B6 0002 0040                  		dc.w	$02, $40
000019BA 0002 0040                  		dc.w	$02, $40
000019BE                            OscUpdateData_End:
000019BE                            ; =========================================================================================================================================================
000019BE                            		include	"Libraries/Object.asm"		; Object functions
000019BE                            ; =========================================================================================================================================================
000019BE                            ; Object functions
000019BE                            ; =========================================================================================================================================================
000019BE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000019BE                            ; Initialize object lists
000019BE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000019BE                            ; PARAMETERS:
000019BE                            ;	Nothing
000019BE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000019BE                            ; RETURNS:
000019BE                            ;	Nothing
000019BE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000019BE                            InitObjectList:
000019BE                            		clrRAM	objRespawn,objMemory_End		; Clear respawn table and object memory
000019BE                          M 	local	endaddr
000019BE                          M endaddr	equs	"objmemory_end"
000019BE 7000                     M 	moveq	#0,d0
000019C0 43F8 9A54                M 	lea	(objrespawn).w,a1
000019C4 323C 09BF                M 	move.w	#(((objmemory_end)-(objrespawn))-((objrespawn)&1))>>2-1,d1
000019C8 22C0                     M .clear_65:	move.l	d0,(a1)+
000019CA 51C9 FFFC                M 	dbf	d1,.clear_65
000019CE                            
000019CE                            	; setup tail object
000019CE 31FC C154 C158             		move.w	#objExecExit,objExecFirst.w		; set the first object as the tail object
000019D4 31FC C154 C15A             		move.w	#objExecExit,objExecLast.w		; set the last object as the tail object
000019DA 21FC 0000 0000 C154        		move.l	#.rts,objExecExit.w		; set the next rts as the tail object pointer
000019E2                            
000019E2                            	; setup free object list
000019E2 41F8 9D54                  		lea	objMemory.w,a0			; load the objects list into a0
000019E6 31C8 C15C                  		move.w	a0,objExecFree.w			; set the first object as the first free object
000019EA 705E                       		moveq	#OBJECT_COUNT-2,d0		; load object count to d0
000019EC 7260                       		moveq	#_objSize,d1			; load object size to d1
000019EE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000019EE                            
000019EE                            .load
000019EE D0C1                       		add.w	d1,a0				; go to the next object now
000019F0 3148 FFA6                  		move.w	a0,_objPrev-_objSize(a0)		; save new previous pointer
000019F4 42A8 0008                  		clr.l	_objDrawNext(a0)			; clear the display link values
000019F8 51C8 FFF4                  		dbf	d0,.load			; loop for every object
000019FC                            
000019FC 4268 0006                  		clr.w	_objPrev(a0)			; set the last previous pointer to 0
00001A00                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A00                            
00001A00                            	; reset display table
00001A00 43F8 C156                  		lea	objDisplay-dNext.w,a1		; get display table address to a1
00001A04 7207                       		moveq	#8-1,d1				; loop for all the layers
00001A06                            
00001A06                            .dsp
00001A06 3349 000E                  		move.w	a1,dPrev+dNext(a1)		; update prev pointer
00001A0A 5849                       		addq.w	#dNext,a1			; advance to the actual address
00001A0C 3349 0004                  		move.w	a1,dNext(a1)			; update next pointer
00001A10                            
00001A10 42A9 0006                  		clr.l	dN2(a1)				; clear the list end pointers
00001A14 5849                       		addq.w	#dSize-dNext,a1			; go to the next layer
00001A16 51C9 FFEE                  		dbf	d1,.dsp				; loop for all layers
00001A1A                            
00001A1A                            .rts
00001A1A 4E75                       		rts
00001A1C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A1C                            ; Find the first free object space available
00001A1C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A1C                            ; PARAMETERS:
00001A1C                            ;	Nothing
00001A1C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A1C                            ; RETURNS:
00001A1C                            ;	a1.l	- Pointer to the SST space in the free object space
00001A1C                            ;	a2.l	- Trashed
00001A1C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A1C                            FindFreeObj:
00001A1C 3038 C15C                  		move.w	objExecFree.w,d0			; get pointer to the next free object
00001A20 6700                       		beq.s	.rts				; if it's a null pointer (z=1), return
00001A22 3240                       		movea.w	d0,a1				; load to a1
00001A24 31E9 0006 C15C             		move.w	_objPrev(a1),objExecFree.w		; copy the next free object pointer to list start
00001A2A                            
00001A2A 3478 C15A                  		move.w	objExecLast.w,a2			; load last object to a2
00001A2E 31C9 C15A                  		move.w	a1,objExecLast.w			; save as the new last object
00001A32 336A 0004 0004             		move.w	_objNext(a2),_objNext(a1)		; copy the next pointer from old tail to new object
00001A38 3549 0004                  		move.w	a1,_objNext(a2)			; save new object as next pointer for old tail
00001A3C 334A 0006                  		move.w	a2,_objPrev(a1)			; save old tail as prev pointer for new object
00001A40                            
00001A40                            .rts:
00001A40 4E75                       		rts
00001A42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A42                            ; Delete another object
00001A42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A42                            ; PARAMETERS:
00001A42                            ;	a1.l	- Pointer to object space to clear
00001A42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A42                            ; RETURNS:
00001A42                            ;	a1.l	- Trashed
00001A42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A42                            DeleteOtherObj:
00001A42 4850                       		pea	(a0)
00001A44 2049                       		move.l	a1,a0
00001A46 6100                       		bsr.s	DeleteObject
00001A48                            		pop.l	a0
00001A48 205F                     M 	move.l	(sp)+,a0
00001A4A 4E75                       		rts
00001A4C                            
00001A4C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A4C                            ; Delete the current object
00001A4C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A4C                            ; PARAMETERS:
00001A4C                            ;	Nothing
00001A4C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A4C                            ; RETURNS:
00001A4C                            ;	a1.l	- Trashed
00001A4C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A4C                            DeleteObject:
00001A4C                            	removeSprite	a0, a1, 1			; remove object display
00001A4C 4A68 0008                M 	tst.w	_objdrawnext(a0)
00001A50 6700                     M 	beq.s	.yes_67
00001A52 3268 000A                M 	move.w	_objdrawprev(a0),a1
00001A56 3368 0008 0008           M 	move.w	_objdrawnext(a0),_objdrawnext(a1)
00001A5C 3268 0008                M 	move.w	_objdrawnext(a0),a1
00001A60 3368 000A 000A           M 	move.w	_objdrawprev(a0),_objdrawprev(a1)
00001A66                          M .no_67
00001A66 42A8 0008                M 	clr.l	_objdrawnext(a0)
00001A6A                          M .yes_67
00001A6A 3268 0006                  		move.w	_objPrev(a0),a1			; copy previous pointer to a1
00001A6E 3368 0004 0004             		move.w	_objNext(a0),_objNext(a1)		; copy next pointer to previous object
00001A74 3268 0004                  		move.w	_objNext(a0),a1			; get next object to a1
00001A78 3368 0006 0006             		move.w	_objPrev(a0),_objPrev(a1)		; copy previous pointer
00001A7E                            
00001A7E 3178 C15C 0006             		move.w	objExecFree.w,_objPrev(a0)		; get the head of the free list to previous pointer of this object
00001A84 31C8 C15C                  		move.w	a0,objExecFree.w			; save as the new head of free list
00001A88                            
00001A88                            ; clear object memory
00001A88 7000                       		moveq	#0,d0				; clear d0
00001A8A 7214                       		moveq	#(((_objSize-_objDrawPrev)>>2)-1),d1	; set loop count
00001A8C                            
00001A8C 4852                       		pea	(a2)				; backup a2
00001A8E 45E8 000A                  		lea	_objDrawPrev(a0),a2		; load the first property to clear to a2
00001A92                            		
00001A92                            .clrLoop:
00001A92 24C0                       		move.l	d0,(a2)+			; clear a longword of the object slot's memory
00001A94 51C9 FFFC                  		dbf	d1,.clrLoop			; loop through to clear all object properties
00001A98                            
00001A98 34C0                       		move.w	d0,(a2)+			; clear the last word of data if the object ram per slot does not divide evenly by 4
00001A9A                            
00001A9A                            		pop.l	a2				; restore a2
00001A9A 245F                     M 	move.l	(sp)+,a2
00001A9C 4E75                       		rts
00001A9E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A9E                            ; Render object sprites
00001A9E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A9E                            ; PARAMETERS:
00001A9E                            ;	Nothing
00001A9E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A9E                            ; RETURNS:
00001A9E                            ;	Nothing
00001A9E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A9E                            RendeobjMemory:
00001A9E 7E4F                       		moveq	#($280/8)-1,d7			; Max sprite count
00001AA0 7C00                       		moveq	#0,d6				; Render flags
00001AA2                            
00001AA2 47F8 E88A                  		lea	fgCamVars.w,a3			; Foreground camera variables
00001AA6 4BF8 C15E                  		lea	objDisplay+dNext.w,a5	; Sprite input table
00001AAA 4DF8 94CE                  		lea	spriteBuff.w,a6			; Sprite table buffer
00001AAE                            
00001AAE 0C38 0004 C75C             		cmpi.b	#gLevel,opmode.w		; Are we in level mode?
00001AB4                            ;		bne.s	.PrioLvlLoop			; If not, branch
00001AB4                            ;		jsr	Level_RenderHUDAndRings		; Render the HUD & Rings (in that order)
00001AB4                            
00001AB4                            .PrioLvlLoop:
00001AB4 3055                       		move.w	(a5),a0				; Load priority level address to a0
00001AB6 504D                       		add.w	#dSize,a5			; Skip bunch of shit
00001AB8 4A68 0008                  		tst.w	_objDrawNext(a0)			; Is the next pointer for a valid object?
00001ABC 6700 0000                  		beq.w	.NextPrioLvl			; If not, branch
00001AC0                            
00001AC0                            .ObjectLoop:
00001AC0                            	;	movea.w	(a4)+,a0			; Get object SST address
00001AC0 4A90                       		tst.l	_objAddress(a0)			; Is this object slot used?
00001AC2 6700 0000                  		beq.w	.NextObject			; If not, branch
00001AC6                            
00001AC6 0228 007F 000D             		andi.b	#$7F,_objRender(a0)		; Clear on-screen flag
00001ACC 1C28 000D                  		move.b	_objRender(a0),d6			; Store render flags
00001AD0 3028 0014                  		move.w	_objXPos(a0),d0			; Get X position
00001AD4 3228 0018                  		move.w	_objYPos(a0),d1			; Get Y position
00001AD8                            
00001AD8 0806 0006                  		btst	#6,d6				; Is the multi sprite flag set?
00001ADC 6600 0000                  		bne.w	.MultiDraw			; If so, branch
00001AE0 0806 0002                  		btst	#2,d6				; Is the sprite to be drawn via screen space?
00001AE4 6700                       		beq.s	.Render				; If not, branch
00001AE6                            
00001AE6 9053                       		sub.w	cXPos(a3),d0			; Subtract the camera's X position from the sprite's
00001AE8 926B 0008                  		sub.w	cYPos(a3),d1			; Subtract the camera's Y position from the sprite's
00001AEC                            
00001AEC                            .Render:
00001AEC 7400                       		moveq	#0,d2
00001AEE 1428 0017                  		move.b	_objDrawW(a0),d2			; Get sprite width
00001AF2 3600                       		move.w	d0,d3				; Get sprite X position
00001AF4 D642                       		add.w	d2,d3				; Add width
00001AF6 6B00                       		bmi.s	.NextObject			; If it's off screen on the left, branch
00001AF8 3600                       		move.w	d0,d3				; Get sprite X position
00001AFA 9642                       		sub.w	d2,d3				; Subtract width
00001AFC 0C43 0140                  		cmpi.w	#320,d3				; Is it off screen on the right?
00001B00 6C00                       		bge.s	.NextObject			; If so, branch
00001B02 0640 0080                  		addi.w	#128,d0				; Move sprite on screen
00001B06                            
00001B06 7400                       		moveq	#0,d2
00001B08 1428 001B                  		move.b	_objDrawH(a0),d2			; Get sprite height
00001B0C 3601                       		move.w	d1,d3				; Get sprite Y position
00001B0E D642                       		add.w	d2,d3				; Add height
00001B10 6B00                       		bmi.s	.NextObject			; If it's off screen on the top, branch
00001B12 3601                       		move.w	d1,d3				; Get sprite Y position
00001B14 9642                       		sub.w	d2,d3				; Subtract height
00001B16 0C43 00E0                  		cmpi.w	#224,d3				; Is it off screen on the bottom?
00001B1A 6C00                       		bge.s	.NextObject			; If so, branch
00001B1C 0641 0080                  		addi.w	#128,d1				; Move sprite on screen
00001B20                            
00001B20 0028 0080 000D             		ori.b	#$80,_objRender(a0)		; Set on-screen flag
00001B26 4A47                       		tst.w	d7				; Do we still have some sprite space left?
00001B28 6B00                       		bmi.s	.NextObject			; If not, branch
00001B2A                            
00001B2A 2828 0010                  		move.l	_objMapping(a0),d4			; Get mappings pointer
00001B2E 6700                       		beq.s	.NextObject			; If blank, branch
00001B30 2244                       		movea.l	d4,a1				; Store it
00001B32 7800                       		moveq	#0,d4
00001B34 0806 0005                  		btst	#5,d6				; Is the static sprite flag set
00001B38 6600                       		bne.s	.Static				; If so, branch
00001B3A 1828 0010                  		move.b	_objFrame(a0),d4			; Get mapping frame
00001B3E D844                       		add.w	d4,d4				; Turn into offset
00001B40 D2F1 4000                  		adda.w	(a1,d4.w),a1			; Get mapping frame data pointer
00001B44 3819                       		move.w	(a1)+,d4			; Get mapping frame sprite count
00001B46 5344                       		subq.w	#1,d4				; Subtract 1 from sprite count
00001B48 6B00                       		bmi.s	.NextObject			; If there are no sprites to draw, branch
00001B4A                            
00001B4A                            .Static:
00001B4A 3A28 000E                  		move.w	_objVRAM(a0),d5			; Get sprite tile properties
00001B4E 6100 ED02                  		bsr.w	DrawSprite			; Draw the sprites
00001B52                            
00001B52                            .NextObject:	
00001B52 3068 0008                  		move.w	_objDrawNext(a0),a0		; Load next object to a0
00001B56 4A68 0008                  		tst.w	_objDrawNext(a0)			; Check the next pointer for valid object
00001B5A 6600 FF64                  		bne.w	.ObjectLoop			; If there are still some sprites to draw in this priority level, branch
00001B5E                            
00001B5E                            .NextPrioLvl:
00001B5E BAFC C19E                  		cmpa.w	#objDisplay_End,a5		; Are we at the end of the input table?
00001B62 6500 FF50                  		blo.w	.PrioLvlLoop			; If not, branch
00001B66                            
00001B66 3C07                       		move.w	d7,d6				; Get remaining sprite count
00001B68 6B00                       		bmi.s	.SetDrawnSprites		; If we have filled the entire sprite table, branch
00001B6A 7000                       		moveq	#0,d0
00001B6C                            
00001B6C                            .FillRest:
00001B6C 3C80                       		move.w	d0,(a6)				; Move sprite off screen
00001B6E 504E                       		addq.w	#8,a6				; Next sprite
00001B70 51CF FFFA                  		dbf	d7,.FillRest			; Loop
00001B74                            
00001B74                            .SetDrawnSprites:
00001B74 0446 004F                  		subi.w	#($280/8)-1,d6			; Get number of sprites drawn
00001B78 4446                       		neg.w	d6				; ''
00001B7A 11C6 C75D                  		move.b	d6,spriteCount.w		; Store it
00001B7E                            
00001B7E 4E75                       		rts
00001B80                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001B80                            .MultiDraw:
00001B80 0806 0002                  		btst	#2,d6				; Is the sprite to be drawn via screen space?
00001B84 6700                       		beq.s	.RenderMain			; If not, branch
00001B86                            
00001B86 9053                       		sub.w	cXPos(a3),d0			; Subtract the camera's X position from the sprite's
00001B88 926B 0008                  		sub.w	cYPos(a3),d1			; Subtract the camera's Y position from the sprite's
00001B8C                            
00001B8C                            .RenderMain:
00001B8C 7400                       		moveq	#0,d2
00001B8E 1428 0017                  		move.b	_objDrawW(a0),d2			; Get main sprite width
00001B92 3600                       		move.w	d0,d3				; Get main sprite X position
00001B94 D642                       		add.w	d2,d3				; Add width
00001B96 6BBA                       		bmi.s	.NextObject			; If it's off screen on the left, branch
00001B98 3600                       		move.w	d0,d3				; Get main sprite X position
00001B9A 9642                       		sub.w	d2,d3				; Subtract width
00001B9C 0C43 0140                  		cmpi.w	#320,d3				; Is it off screen on the right?
00001BA0 6CB0                       		bge.s	.NextObject			; If so, branch
00001BA2 0640 0080                  		addi.w	#128,d0				; Move sprite on screen
00001BA6                            
00001BA6 1428 001B                  		move.b	_objDrawH(a0),d2			; Get main sprite height
00001BAA 3601                       		move.w	d1,d3				; Get main sprite Y position
00001BAC D642                       		add.w	d2,d3				; Add height
00001BAE 6BA2                       		bmi.s	.NextObject			; If it's off screen on the top, branch
00001BB0 3601                       		move.w	d1,d3				; Get main sprite Y position
00001BB2 9642                       		sub.w	d2,d3				; Subtract height
00001BB4 0C43 00E0                  		cmpi.w	#224,d3				; Is it off screen on the bottom?
00001BB8 6C98                       		bge.s	.NextObject			; If so, branch
00001BBA 0641 0080                  		addi.w	#128,d1				; Move sprite on screen
00001BBE                            
00001BBE 0028 0080 000D             		ori.b	#$80,_objRender(a0)		; Set on-screen flag
00001BC4 4A47                       		tst.w	d7				; Do we still have some sprite space left?
00001BC6 6B00 FF8A                  		bmi.w	.NextObject			; If not, branch
00001BCA                            
00001BCA 3A28 000E                  		move.w	_objVRAM(a0),d5			; Get sprite tile properties
00001BCE 2828 0010                  		move.l	_objMapping(a0),d4			; Get mappings pointer
00001BD2 6700 FF7E                  		beq.w	.NextObject			; If blank, branch
00001BD6 2444                       		movea.l	d4,a2				; Store it
00001BD8 7800                       		moveq	#0,d4
00001BDA 1828 0010                  		move.b	_objFrame(a0),d4			; Get mapping frame
00001BDE D844                       		add.w	d4,d4				; Turn into offset
00001BE0 43D2                       		lea	(a2),a1				; Copy mappings data pointer
00001BE2 D2F1 4000                  		adda.w	(a1,d4.w),a1			; Get mapping frame data pointer
00001BE6 3819                       		move.w	(a1)+,d4			; Get mapping frame sprite count
00001BE8 5344                       		subq.w	#1,d4				; Subtract 1 from sprite count
00001BEA 6B00                       		bmi.s	.RenderSubSprites		; If there are no sprites to draw, branch
00001BEC 3606                       		move.w	d6,d3				; Store render flags
00001BEE 6100 ED46                  		bsr.w	DrawSprite_BoundChk		; Draw the sprites
00001BF2 3C03                       		move.w	d3,d6				; Restore render flags
00001BF4                            
00001BF4 4A47                       		tst.w	d7				; Do we still have some sprite space left?
00001BF6 6B00 FF5A                  		bmi.w	.NextObject			; If not, branch
00001BFA                            
00001BFA                            .RenderSubSprites:
00001BFA 3628 002E                  		move.w	_objSubCnt(a0),d3			; Get sub sprite count
00001BFE 5343                       		subq.w	#1,d3				; Subtract 1
00001C00 6B00 FF50                  		bmi.w	.NextObject			; If there are no sprites to draw, branch
00001C04 41E8 0030                  		lea	_objSubStart(a0),a0		; Get sub sprite SSTs start
00001C08                            
00001C08                            .RenderSubSprs_Loop:
00001C08 3018                       		move.w	(a0)+,d0			; Get X position
00001C0A 0640 0080                  		addi.w	#128,d0				; Move on screen
00001C0E 3218                       		move.w	(a0)+,d1			; Get Y position
00001C10 0641 0080                  		addi.w	#128,d1				; Move on screen
00001C14                            
00001C14 0806 0002                  		btst	#2,d6				; Is the sprite to be drawn via screen space?
00001C18 6700                       		beq.s	.RenderSub			; If not, branch
00001C1A                            
00001C1A 9053                       		sub.w	cXPos(a3),d0			; Subtract the camera's X position from the sprite's
00001C1C 926B 0008                  		sub.w	cYPos(a3),d1			; Subtract the camera's Y position from the sprite's
00001C20                            
00001C20                            .RenderSub:
00001C20 3818                       		move.w	(a0)+,d4			; Get mapping frame
00001C22 D844                       		add.w	d4,d4				; Turn into offset
00001C24 43D2                       		lea	(a2),a1				; Copy mappings data pointer
00001C26 D2F1 4000                  		adda.w	(a1,d4.w),a1			; Get mapping frame data pointer
00001C2A 3819                       		move.w	(a1)+,d4			; Get mapping frame sprite count
00001C2C 5344                       		subq.w	#1,d4				; Subtract 1 from sprite count
00001C2E 6B00                       		bmi.s	.RenderSubSprs_ChkLoop		; If there are no sprites to draw, branch
00001C30                            		push.w	d6				; Store render flags
00001C30 3F06                     M 	move.w	d6,-(sp)
00001C32 6100 ED02                  		bsr.w	DrawSprite_BoundChk		; Draw the sprites
00001C36                            		pop.w	d6				; Restore render flags
00001C36 3C1F                     M 	move.w	(sp)+,d6
00001C38                            
00001C38                            .RenderSubSprs_ChkLoop:
00001C38 4A47                       		tst.w	d7				; Do we still have some sprite space left?
00001C3A 5BCB FFCC                  		dbmi	d3,.RenderSubSprs_Loop		; If so, loop
00001C3E 6000 FF12                  		bra.w	.NextObject			; Continue on rendering other sprites
00001C42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001C42                            ; Animate an object's sprite
00001C42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001C42                            ; PARAMETERS:
00001C42                            ;	a0.l	- Object space pointer
00001C42                            ;	a1.l	- Animation script pointer
00001C42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001C42                            ; RETURNS:
00001C42                            ;	Nothing
00001C42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001C42                            AnimateObject:
00001C42 7000                       		moveq	#0,d0
00001C44 1028 0020                  		move.b	_objAnim(a0),d0			; Get animation ID
00001C48 B028 0021                  		cmp.b	_objPrevAnim(a0),d0			; Has it changed?
00001C4C 6700                       		beq.s	.Run				; If not, branch
00001C4E 1140 0021                  		move.b	d0,_objPrevAnim(a0)			; Save the new ID
00001C52 4228 0022                  		clr.b	_objAnimFrame(a0)			; Reset animation
00001C56 4228 0023                  		clr.b	_objAnimTimer(a0)			; Reset animation timer
00001C5A                            
00001C5A                            .Run:
00001C5A 5328 0023                  		subq.b	#1,_objAnimTimer(a0)		; Decrement animation timer
00001C5E 6A00                       		bpl.s	.Wait				; If it hasn't run out, branch
00001C60 D040                       		add.w	d0,d0				; Turn ID into offset
00001C62 D2F1 0000                  		adda.w	(a1,d0.w),a1			; Get pointer to current animation script
00001C66 1151 0023                  		move.b	(a1),_objAnimTimer(a0)		; Set new animation timer
00001C6A                            
00001C6A 7200                       		moveq	#0,d1
00001C6C 1228 0022                  		move.b	_objAnimFrame(a0),d1		; Get current value in the script
00001C70 1031 1001                  		move.b	1(a1,d1.w),d0			; ''
00001C74 0C00 00FA                  		cmpi.b	#$FA,d0				; Is it a command value?
00001C78 6400                       		bhs.s	.CmdReset			; If so, branch
00001C7A                            
00001C7A                            .Next:
00001C7A 1140 0010                  		move.b	d0,_objFrame(a0)			; Set mapping frame ID
00001C7E 1028 0028                  		move.b	_objStatus(a0),d0			; Get status
00001C82 0200 0003                  		andi.b	#3,d0				; Only get flip bits
00001C86 0228 00FC 000D             		andi.b	#$FC,_objRender(a0)		; Mask out flip bits in render flags
00001C8C 8128 000D                  		or.b	d0,_objRender(a0)			; Set flip bits
00001C90 5228 0022                  		addq.b	#1,_objAnimFrame(a0)		; Advance into the animation script
00001C94                            
00001C94                            .Wait:
00001C94 4E75                       		rts
00001C96                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001C96                            .CmdReset:
00001C96 5200                       		addq.b	#1,d0				; Is this flag $FF (reset)?
00001C98 6600                       		bne.s	.CmdJump			; If not, branch
00001C9A 4228 0022                  		clr.b	_objAnimFrame(a0)			; Reset animation
00001C9E 1029 0001                  		move.b	1(a1),d0			; Get first frame ID
00001CA2 60D6                       		bra.s	.Next				; Continue
00001CA4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CA4                            .CmdJump:
00001CA4 5200                       		addq.b	#1,d0				; Is this flag $FE (jump)?
00001CA6 6600                       		bne.s	.CmdSetAnim			; If not, branch
00001CA8 1031 1002                  		move.b	2(a1,d1.w),d0			; Get jump offset
00001CAC 9128 0022                  		sub.b	d0,_objAnimFrame(a0)		; Go back
00001CB0 9200                       		sub.b	d0,d1				; ''
00001CB2 1031 1001                  		move.b	1(a1,d1.w),d0			; Get new frame ID
00001CB6 60C2                       		bra.s	.Next				; Continue
00001CB8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CB8                            .CmdSetAnim:
00001CB8 5200                       		addq.b	#1,d0				; Is this flag $FD (set animation ID)?
00001CBA 6600                       		bne.s	.CmdNextRout			; If not, branch
00001CBC 1171 1002 0020             		move.b	2(a1,d1.w),_objAnim(a0)		; Set new animation ID
00001CC2 4E75                       		rts
00001CC4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CC4                            .CmdNextRout:
00001CC4 5200                       		addq.b	#1,d0				; Is this flag $FC (next routine)?
00001CC6 6600                       		bne.s	.CmdReset2ndRout		; If not, branch
00001CC8 5428 0025                  		addq.b	#2,_objRoutine(a0)			; Next routine
00001CCC 4228 0023                  		clr.b	_objAnimTimer(a0)			; Reset animation timer
00001CD0 5228 0022                  		addq.b	#1,_objAnimFrame(a0)		; Next animation frame
00001CD4 4E75                       		rts
00001CD6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CD6                            .CmdReset2ndRout:
00001CD6 5200                       		addq.b	#1,d0				; Is this flag $FB (reset secondary routine)?
00001CD8 6600                       		bne.s	.CmdNext2ndRout			; If not, branch
00001CDA 4228 0023                  		clr.b	_objAnimTimer(a0)			; Reset animation timer
00001CDE                            ;		clr.b	oWFZRout(a0)			; Reset routine
00001CDE 4E75                       		rts
00001CE0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CE0                            .CmdNext2ndRout:
00001CE0 5200                       		addq.b	#1,d0				; Is this flag $FA (next secondary routine)?
00001CE2 6600                       		bne.s	.CmdEnd				; If not, branch
00001CE4                            ;		addq.b	#2,oWFZRout(a0)			; Next routine
00001CE4 4E75                       		rts
00001CE6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CE6                            .CmdEnd:
00001CE6 4E75                       		rts
00001CE8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CE8                            ; Load object DPLCs
00001CE8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CE8                            ; PARAMETERS:
00001CE8                            ;	d4.w	- Target VRAM address
00001CE8                            ;	d6.l	- Pointer to uncompressed art
00001CE8                            ;	a2.l	- Pointer to DPLCs
00001CE8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CE8                            ; RETURNS:
00001CE8                            ;	Nothing
00001CE8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CE8                            LoadObjDPLCs:
00001CE8 7000                       		moveq	#0,d0
00001CEA 1028 0010                  		move.b	_objFrame(a0),d0			; Get mapping frame
00001CEE B010                       		cmp.b	_objPrevDPLC(a0),d0		; Do we need to update the art?
00001CF0 6700                       		beq.s	.End				; If not, branch
00001CF2 1080                       		move.b	d0,_objPrevDPLC(a0)		; Save the frame ID so we don't constantly load the art
00001CF4 D040                       		add.w	d0,d0				; Turn ID into offset
00001CF6 D4F2 0000                  		adda.w	(a2,d0.w),a2			; Get pointer to DPLC data for the frame
00001CFA 3A1A                       		move.w	(a2)+,d5			; Get DPLC entry count
00001CFC 5345                       		subq.w	#1,d5				; Subtract 1
00001CFE 6B00                       		bmi.s	.End				; If there are no more entires left, branch
00001D00                            
00001D00                            .ReadEntries:
00001D00 7200                       		moveq	#0,d1
00001D02 321A                       		move.w	(a2)+,d1			; Get DPLC entry data
00001D04 3601                       		move.w	d1,d3				; Copy that
00001D06 E04B                       		lsr.w	#8,d3				; Get tile count
00001D08 0243 00F0                  		andi.w	#$F0,d3				; ''
00001D0C 0643 0010                  		addi.w	#$10,d3				; ''
00001D10 0241 0FFF                  		andi.w	#$FFF,d1			; Get offset in art data
00001D14 EB89                       		lsl.l	#5,d1				; ''
00001D16 D286                       		add.l	d6,d1				; Get pointer in art data
00001D18 3404                       		move.w	d4,d2				; Copy VRAM address
00001D1A D843                       		add.w	d3,d4				; Add tile count to VRAM address
00001D1C D843                       		add.w	d3,d4				; ''
00001D1E 4EB8 0304                  		jsr	QueueDMATransfer.w		; Queue the art
00001D22 51CD FFDC                  		dbf	d5,.ReadEntries			; Loop
00001D26                            
00001D26                            .End:
00001D26 4E75                       		rts
00001D28                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D28                            ; Move an object by it's velocity values
00001D28                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D28                            ; PARAMETERS:
00001D28                            ;	a0.l	- Object space pointer
00001D28                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D28                            ; RETURNS:
00001D28                            ;	Nothing
00001D28                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D28                            ObjectMove:
00001D28 3028 001C                  		move.w	_objXVel(a0),d0			; Get X velocity
00001D2C 48C0                       		ext.l	d0				; ''
00001D2E E188                       		lsl.l	#8,d0				; Shift
00001D30 D1A8 0014                  		add.l	d0,_objXPos(a0)			; Add to the X position
00001D34 3028 001E                  		move.w	_objYVel(a0),d0			; Get Y velocity
00001D38 48C0                       		ext.l	d0				; ''
00001D3A E188                       		lsl.l	#8,d0				; Shift
00001D3C D1A8 0018                  		add.l	d0,_objYPos(a0)			; Add to the Y position
00001D40 4E75                       		rts
00001D42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D42                            ; Move an object by it's velocity values (with gravity)
00001D42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D42                            ; PARAMETERS:
00001D42                            ;	a0.l	- Object space pointer
00001D42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D42                            ; RETURNS:
00001D42                            ;	Nothing
00001D42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D42                            ObjectMoveAndFall:
00001D42 3028 001C                  		move.w	_objXVel(a0),d0			; Get X velocity
00001D46 48C0                       		ext.l	d0				; ''
00001D48 E188                       		lsl.l	#8,d0				; Shift
00001D4A D1A8 0014                  		add.l	d0,_objXPos(a0)			; Add to the X position
00001D4E 3028 001E                  		move.w	_objYVel(a0),d0			; Get Y velocity
00001D52 0668 000C 001E             		addi.w	#$0C,_objYVel(a0)			; Apply gravity
00001D58 48C0                       		ext.l	d0				; ''
00001D5A E188                       		lsl.l	#8,d0				; Shift
00001D5C D1A8 0018                  		add.l	d0,_objYPos(a0)			; Add to the Y position
00001D60 4E75                       		rts
00001D62                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D62                            ; Check if a specific object is nearby
00001D62                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D62                            ; PARAMETERS:
00001D62                            ;	a0.l	- Current object space pointer
00001D62                            ;	a1.l	- Range data pointer
00001D62                            ;	a2.l	- Object to check's space pointer
00001D62                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D62                            ; RETURNS:
00001D62                            ;	d0.w	- Return status (0 if not in range, other object's space pointer if in range)
00001D62                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D62                            CheckObjInRange:
00001D62 7000                       		moveq	#0,d0
00001D64 322A 0014                  		move.w	_objXPos(a2),d1			; Get other object's position
00001D68 342A 0018                  		move.w	_objYPos(a2),d2			; ''
00001D6C 3628 0014                  		move.w	_objXPos(a0),d3			; Get current object's position
00001D70 3828 0018                  		move.w	_objYPos(a0),d4			; ''
00001D74 D659                       		add.w	(a1)+,d3			; Get left boundary
00001D76 3A03                       		move.w	d3,d5				; Copy
00001D78 DA59                       		add.w	(a1)+,d5			; Get right boundary
00001D7A D859                       		add.w	(a1)+,d4			; Get top boundary
00001D7C 3C04                       		move.w	d4,d6				; Copy
00001D7E DC59                       		add.w	(a1)+,d6			; Get bottom boundary
00001D80 B243                       		cmp.w	d3,d1				; Is the object past the left boundary?
00001D82 6500                       		blo.s	.End				; If not, branch
00001D84 B245                       		cmp.w	d5,d1				; Is the object within the horizontal range?
00001D86 6400                       		bhs.s	.End				; If not, branch
00001D88 B444                       		cmp.w	d4,d2				; Is the object past the top boundary?
00001D8A 6500                       		blo.s	.End				; If not, branch
00001D8C B446                       		cmp.w	d6,d2				; Is the object within the vertical range?
00001D8E 6400                       		bhs.s	.End				; If not, branch
00001D90 300A                       		move.w	a2,d0				; Copy other object's RAM space pointer as the return status
00001D92                            
00001D92                            .End:
00001D92 4E75                       		rts
00001D94                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D94                            ; Object manager
00001D94                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D94                            ObjectManager:
00001D94 4A38 C7B6                  		tst.b	objMgrInit.w
00001D98 6600                       		bne.s	ObjectManagerMain
00001D9A                            
00001D9A                            ObjectManagerInit:
00001D9A 50F8 C7B6                  		st	objMgrInit.w			; Set the init flag
00001D9E                            
00001D9E 2078 C7B8                  		movea.l	objMgrLayout.w,a0		; Get object data pointer
00001DA2 21C8 C7BC                  		move.l	a0,objMgrLoadR.w
00001DA6 21C8 C7C0                  		move.l	a0,objMgrLoadL.w			; Store address of object layout
00001DAA                            
00001DAA 47F8 9A54                  		lea	objRespawn.w,a3			; Object respawn table
00001DAE                            
00001DAE 3C38 E88A                  		move.w	fgCamXPos.w,d6			; Camera's X position
00001DB2 0446 0080                  		subi.w	#$80,d6				; Subtract 128
00001DB6 6400                       		bhs.s	.NoReset			; Branch if it doesn't go past the left boundary
00001DB8 7C00                       		moveq	#0,d6				; Cap at left boundary
00001DBA                            
00001DBA                            .NoReset:
00001DBA 0246 FF80                  		andi.w	#$FF80,d6			; Keep in chunks of 128 pixels
00001DBE                            
00001DBE 2078 C7BC                  		movea.l	objMgrLoadR.w,a0			; Get address of the object loader for the right side of the screen
00001DC2                            
00001DC2                            .ChkObjsLeft:
00001DC2 BC50                       		cmp.w	(a0),d6				; Compare object position
00001DC4 6300                       		bls.s	.ChkDone			; If higher than d6, branch
00001DC6 5C48                       		addq.w	#6,a0				; Next object
00001DC8 524B                       		addq.w	#1,a3				; Next respawn table index
00001DCA 60F6                       		bra.s	.ChkObjsLeft			; Loop
00001DCC                            
00001DCC                            .ChkDone:
00001DCC 21C8 C7BC                  		move.l	a0,objMgrLoadR.w			; Store new addresses
00001DD0 31CB C7C6                  		move.w	a3,objMgrRespL.w			; ''
00001DD4                            
00001DD4 47F8 9A54                  		lea	objRespawn.w,a3			; Object respawn table
00001DD8                            
00001DD8 2078 C7C0                  		movea.l	objMgrLoadL.w,a0
00001DDC 0446 0080                  		subi.w	#$80,d6				; Subtract from camera's X position again
00001DE0 6500                       		bcs.s	.ChkDone2			; But is done to account for the object loader later on
00001DE2                            
00001DE2                            .ChkObjsRight:
00001DE2 BC50                       		cmp.w	(a0),d6				; Compate object position
00001DE4 6300                       		bls.s	.ChkDone2			; If higher than d6, branch
00001DE6 5C48                       		addq.w	#6,a0				; Next object
00001DE8 524B                       		addq.w	#1,a3				; Next respawn table index
00001DEA 60F6                       		bra.s	.ChkObjsRight			; Loop
00001DEC                            
00001DEC                            .ChkDone2:
00001DEC 21C8 C7C0                  		move.l	a0,objMgrLoadL.w			; Store new addresses
00001DF0 31CB C7C4                  		move.w	a3,objMgrRespR.w			; ''
00001DF4                            
00001DF4 31FC FFFF C7CC             		move.w	#-1,objMgrCameraX.w			; Reset manager's camera X position
00001DFA 3038 E892                  		move.w	fgCamYPos.w,d0			; Get camera's Y position
00001DFE 0240 FF80                  		andi.w	#$FF80,d0			; Keep in range
00001E02 31C0 C7CE                  		move.w	d0,objMgrCameraY.w			; Store it so unnecessary Y checks shouldn't be done
00001E06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001E06                            ObjectManagerMain:
00001E06 3238 E892                  		move.w	fgCamYPos.w,d1			; Get camera's Y position
00001E0A 0441 0080                  		subi.w	#$80,d1				; Subtract 128 pixels
00001E0E 0241 FF80                  		andi.w	#$FF80,d1			; Keep in range
00001E12 31C1 C7CA                  		move.w	d1,objMgrCoarseY.w		; Store this
00001E16                            
00001E16 3238 E88A                  		move.w	fgCamXPos.w,d1			; Get camera's X position
00001E1A 0441 0080                  		subi.w	#$80,d1				; Subtract 128 pixels
00001E1E 0241 FF80                  		andi.w	#$FF80,d1			; Keep in range
00001E22 31C1 C7C8                  		move.w	d1,objMgrCoarseX.w		; Store this
00001E26                            		
00001E26 49F9 0000 0000             		lea	Level_ObjIndex,a4		; Level object index
00001E2C                            
00001E2C 3638 E892                  		move.w	fgCamYPos.w,d3			; Get camera's Y position
00001E30 0243 FF80                  		andi.w	#$FF80,d3			; Keep in range
00001E34 3803                       		move.w	d3,d4				; Copy
00001E36 0644 0200                  		addi.w	#$200,d4			; Lower Y boundary
00001E3A 0443 0080                  		subi.w	#$80,d3				; Upper Y boundary
00001E3E 6A00                       		bpl.s	.SetNoWrap			; If still positive, branch
00001E40 7600                       		moveq	#0,d3				; Cap at upper level boundary
00001E42                            
00001E42                            .SetNoWrap:
00001E42 3A3C 0FFF                  		move.w	#$FFF,d5
00001E46 3C38 E88A                  		move.w	fgCamXPos.w,d6			; Get camera's X position
00001E4A 0246 FF80                  		andi.w	#$FF80,d6			; Keep in range
00001E4E BC78 C7CC                  		cmp.w	objMgrCameraX.w,d6			; Check against last range
00001E52 6700 0000                  		beq.w	Level_LoadObjs_SameXRange	; Branch if they are the same
00001E56 6C00                       		bge.s	Level_LoadObjs_Forward		; If new range is greater than the last, branch
00001E58                            
00001E58 31C6 C7CC                  		move.w	d6,objMgrCameraX.w			; Set new range
00001E5C                            
00001E5C 2078 C7C0                  		movea.l	objMgrLoadL.w,a0			; Get current objects on the left side of the screen
00001E60 3678 C7C4                  		movea.w	objMgrRespR.w,a3			; And the appropriate respawn list
00001E64                            
00001E64 0446 0080                  		subi.w	#$80,d6				; Subtract 128 from the X position
00001E68 6500                       		blo.s	.EndLoad			; If outside of the level boundary, branch
00001E6A                            
00001E6A 4EB8 1A1C                  		jsr	FindFreeObj.w			; Attempt to load a new object
00001E6E 6700                       		beq.s	.EndLoad			; Branch if it failed
00001E70                            
00001E70                            .LoadLoop:
00001E70 BC68 FFFA                  		cmp.w	-6(a0),d6			; Check if the last object is in range
00001E74 6C00                       		bge.s	.EndLoadRst			; If not, branch
00001E76 5D88                       		subq.l	#6,a0				; Get actual object address
00001E78 534B                       		subq.w	#1,a3				; Get acutal respawn table address
00001E7A                            
00001E7A 6100 0000                  		bsr.w	Level_LoadObject		; Attempt to spawn the object
00001E7E 6700                       		beq.s	.LoadFail			; Branch if it could not be loaded
00001E80 5D88                       		subq.l	#6,a0
00001E82 60EC                       		bra.s	.LoadLoop			; Attempt to load another object
00001E84                            
00001E84                            .LoadFail:
00001E84 5C88                       		addq.l	#6,a0				; Undo object loading
00001E86 524B                       		addq.w	#1,a3
00001E88 6000                       		bra.s	.EndLoad
00001E8A                            .EndLoadRst:
00001E8A 4EB8 1A42                  		jsr	DeleteOtherObj.w
00001E8E                            
00001E8E                            .EndLoad:
00001E8E 21C8 C7C0                  		move.l	a0,objMgrLoadL.w			; Store new addresses
00001E92 31CB C7C4                  		move.w	a3,objMgrRespR.w
00001E96                            
00001E96 2078 C7BC                  		movea.l	objMgrLoadR.w,a0			; Get current objects on the right side of the screen
00001E9A 3678 C7C6                  		movea.w	objMgrRespL.w,a3			; And the appropriate respawn list
00001E9E                            
00001E9E 0646 0300                  		addi.w	#$300,d6			; Load 2 chunks forward
00001EA2                            
00001EA2                            .ChkLoop:
00001EA2 BC68 FFFA                  		cmp.w	-6(a0),d6			; Check if the last object is out of range
00001EA6 6E00                       		bgt.s	.ChkDone			; If so, branch
00001EA8 5D88                       		subq.l	#6,a0				; Get the object before this
00001EAA 534B                       		subq.w	#1,a3				; And its respawn index
00001EAC 60F4                       		bra.s	.ChkLoop			; Check next object
00001EAE                            
00001EAE                            .ChkDone:
00001EAE 21C8 C7BC                  		move.l	a0,objMgrLoadR.w			; Store new addresses
00001EB2 31CB C7C6                  		move.w	a3,objMgrRespL.w
00001EB6 6000                       		bra.s	Level_LoadObjs_SameXRange	; Continue
00001EB8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001EB8                            Level_LoadObjs_Forward:
00001EB8 31C6 C7CC                  		move.w	d6,objMgrCameraX.w			; Set new range
00001EBC                            
00001EBC 2078 C7BC                  		movea.l	objMgrLoadR.w,a0			; Get current objects on the right side of the screen
00001EC0 3678 C7C6                  		movea.w	objMgrRespL.w,a3			; And the appropriate respawn list
00001EC4                            
00001EC4 0646 0280                  		addi.w	#$280,d6			; Load 2 chunks forward
00001EC8                            
00001EC8 4EB8 1A1C                  		jsr	FindFreeObj.w			; Attempt to load a new object
00001ECC 6700                       		beq.s	.EndLoad			; Branch if it failed
00001ECE                            
00001ECE                            .LoadLoop:
00001ECE BC50                       		cmp.w	(a0),d6				; Check if the last obhect is in range
00001ED0 6300                       		bls.s	.EndLoadRst			; If not, branch
00001ED2 6100 0000                  		bsr.w	Level_LoadObject		; Attempt to spawn the object
00001ED6 6700                       		beq.s	.EndLoad			; If it failed to, branch
00001ED8 524B                       		addq.w	#1,a3				; Get acutal respawn table address
00001EDA 60F2                       		bra.s	.LoadLoop
00001EDC                            
00001EDC                            .EndLoadRst:
00001EDC 4EB8 1A42                  		jsr	DeleteOtherObj.w
00001EE0                            
00001EE0                            .EndLoad:
00001EE0 21C8 C7BC                  		move.l	a0,objMgrLoadR.w			; Store new addresses
00001EE4 31CB C7C6                  		move.w	a3,objMgrRespL.w
00001EE8                            
00001EE8 2078 C7C0                  		movea.l	objMgrLoadL.w,a0			; Get current objects on the left side of the screen
00001EEC 3678 C7C4                  		movea.w	objMgrRespR.w,a3			; And the appropriate respawn list
00001EF0                            
00001EF0 0446 0300                  		subi.w	#$300,d6			; Check 1 chunk backwards
00001EF4 6500                       		blo.s	.ChkDone			; If outside of level, branch
00001EF6                            
00001EF6                            .ChkLoop:
00001EF6 BC50                       		cmp.w	(a0),d6				; Check if the last object is out of range
00001EF8 6300                       		bls.s	.ChkDone			; If so, branch
00001EFA 5C88                       		addq.l	#6,a0				; Get the object before this
00001EFC 524B                       		addq.w	#1,a3				; And its respawn index
00001EFE 60F6                       		bra.s	.ChkLoop			; Check next object
00001F00                            
00001F00                            .ChkDone:
00001F00 21C8 C7C0                  		move.l	a0,objMgrLoadL.w			; Store new addresses
00001F04 31CB C7C4                  		move.w	a3,objMgrRespR.w
00001F08                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001F08                            Level_LoadObjs_SameXRange:
00001F08 3C38 E892                  		move.w	fgCamYPos.w,d6			; Get camera's X position
00001F0C 0246 FF80                  		andi.w	#$FF80,d6			; Keep in range
00001F10 3606                       		move.w	d6,d3				; Copy
00001F12 BC78 C7CE                  		cmp.w	objMgrCameraY.w,d6			; Check against last range
00001F16 6700 0000                  		beq.w	.LoadEnd			; Branch if they are the same
00001F1A 6C00                       		bge.s	.MovingDown			; If the new raqnge is greater than the last, branch
00001F1C                            
00001F1C 0443 0080                  		subi.w	#$80,d3				; Loop 1 chunk up
00001F20 6B00 0000                  		bmi.w	.LoadEnd
00001F24 6000                       		bra.s	.YCheck
00001F26                            
00001F26                            .MovingDown:
00001F26 0643 0180                  		addi.w	#$180,d3			; Look 1 chunk down
00001F2A                            
00001F2A                            .YCheck:
00001F2A 4EB8 1A1C                  		jsr	FindFreeObj.w			; Attempt to load a new object
00001F2E 6700                       		beq.s	.LoadEnd			; If failed, branch
00001F30                            		
00001F30 3803                       		move.w	d3,d4				; Copy Y position
00001F32 0644 0080                  		addi.w	#$80,d4				; Look one chunk down
00001F36 3A3C 0FFF                  		move.w	#$FFF,d5
00001F3A                            
00001F3A 2078 C7C0                  		movea.l	objMgrLoadL.w,a0			; Get current objects on the left side of the screen
00001F3E 3678 C7C4                  		movea.w	objMgrRespR.w,a3			; And the appropriate respawn list
00001F42 2E38 C7BC                  		move.l	objMgrLoadR.w,d7			; Get current objects on the right side of the screen
00001F46 9E88                       		sub.l	a0,d7				; Subtract the left position from the right
00001F48 6700                       		beq.s	.LoadEndRst			; Branch if no objects
00001F4A 5488                       		addq.l	#2,a0				; Align to object's Y position
00001F4C                            
00001F4C                            .LoadNext:
00001F4C 4A13                       		tst.b	(a3)				; Has the object been loaded?
00001F4E 6B00                       		bmi.s	.LoadFail			; If so, branch
00001F50                            
00001F50 3210                       		move.w	(a0),d1				; Get object's Y position
00001F52 C245                       		and.w	d5,d1				; Keep in range of 0-$FFF
00001F54 B243                       		cmp.w	d3,d1
00001F56 6500                       		blo.s	.LoadFail			; Branch if out of range in the top
00001F58 B244                       		cmp.w	d4,d1
00001F5A 6200                       		bhi.s	.LoadFail			; Branch if out of range in the botoom
00001F5C                            
00001F5C 08D3 0007                  		bset	#7,(a3)				; Mark as loaded
00001F60 3368 FFFE 0014             		move.w	-2(a0),_objXPos(a1)			; Set X position
00001F66 3210                       		move.w	(a0),d1				; Get object's Y position
00001F68 3401                       		move.w	d1,d2				; Copy it
00001F6A C245                       		and.w	d5,d1				; Keep in range of 0-$FFF
00001F6C 3341 0018                  		move.w	d1,_objYPos(a1)			; Set Y position
00001F70                            
00001F70 E75A                       		rol.w	#3,d2				; Get X and Y flip bits
00001F72 0242 0003                  		andi.w	#3,d2				; ''
00001F76 1342 000D                  		move.b	d2,_objRender(a1)			; Set render flags
00001F7A 1342 0028                  		move.b	d2,_objStatus(a1)			; Set status
00001F7E                            
00001F7E 1428 0002                  		move.b	2(a0),d2			; Get ID
00001F82 D442                       		add.w	d2,d2				; Make it an index in the level object index list
00001F84 D442                       		add.w	d2,d2
00001F86 22B4 2000                  		move.l	(a4,d2.w),_objAddress(a1)		; Set address
00001F8A                            
00001F8A 1368 0003 0024             		move.b	3(a0),_objSubtype(a1)		; Set subtype
00001F90 334B 0026                  		move.w	a3,_objRespawn(a1)			; Set respawn address
00001F94                            
00001F94 4EB8 1A1C                  		jsr	FindFreeObj.w			; Find a free object slot
00001F98 6700                       		beq.s	.LoadEnd			; If none could be loaded, branch
00001F9A                            
00001F9A                            .LoadFail:
00001F9A 5C88                       		addq.l	#6,a0				; Next object
00001F9C 524B                       		addq.w	#1,a3				; ''
00001F9E 5D87                       		subq.l	#6,d7				; Subtract the size of the entry
00001FA0 66AA                       		bne.s	.LoadNext			; If there are some objects remaining, branch
00001FA2                            
00001FA2                            .LoadEndRst:
00001FA2 4EB8 1A42                  		jsr	DeleteOtherObj.w
00001FA6                            
00001FA6                            .LoadEnd:
00001FA6 31C6 C7CE                  		move.w	d6,objMgrCameraY.w		; Store manager's camera Y position
00001FAA 4E75                       		rts
00001FAC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001FAC                            ; Load an object from the object layout
00001FAC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001FAC                            ; PARAMETERS:
00001FAC                            ;	d3.w	- Upper boundary
00001FAC                            ;	d4.w	- Lower boundary
00001FAC                            ;	d5.w	- Y position limit
00001FAC                            ;	a0.l	- Index of object layout
00001FAC                            ;	a1.l	- Target object
00001FAC                            ;	a3.l	- Respawn table address
00001FAC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001FAC                            Level_LoadObject:
00001FAC 4A13                       		tst.b	(a3)				; Has the object been loaded?
00001FAE 6A00                       		bpl.s	.NotLoaded			; If not, branch
00001FB0 5C88                       		addq.l	#6,a0				; Next object
00001FB2 7201                       		moveq	#1,d1				; Ensure that upstream code knows to continue loading
00001FB4 4E75                       		rts
00001FB6                            
00001FB6                            .NotLoaded:
00001FB6 3E18                       		move.w	(a0)+,d7			; X position
00001FB8 3218                       		move.w	(a0)+,d1			; Y position
00001FBA 3401                       		move.w	d1,d2				; Copy
00001FBC 6B00                       		bmi.s	.LoadNoY			; If the object is set to ignore Y checks, branch
00001FBE C245                       		and.w	d5,d1				; Keey Y in range
00001FC0 B243                       		cmp.w	d3,d1
00001FC2 6500                       		bcs.s	.End				; Branch if in range
00001FC4 B244                       		cmp.w	d4,d1
00001FC6 6300                       		bls.s	.Spawn				; Branch if in range
00001FC8                            
00001FC8                            .End:
00001FC8 5448                       		addq.w	#2,a0				; Next objeect
00001FCA 7201                       		moveq	#1,d1				; Ensure that upstream code knows to continue loading
00001FCC 4E75                       		rts
00001FCE                            
00001FCE                            .LoadNoY:
00001FCE C245                       		and.w	d5,d1				; Keey Y in range
00001FD0                            
00001FD0                            .Spawn:
00001FD0 08D3 0007                  		bset	#7,(a3)				; Mark as loaded
00001FD4 3347 0014                  		move.w	d7,_objXPos(a1)			; Store X position
00001FD8 3341 0018                  		move.w	d1,_objYPos(a1)			; Store Y position
00001FDC                            
00001FDC E75A                       		rol.w	#3,d2				; Get X and Y flip bits
00001FDE 0242 0003                  		andi.w	#3,d2				; ''
00001FE2 1342 000D                  		move.b	d2,_objRender(a1)			; Set render flags
00001FE6 1342 0028                  		move.b	d2,_objStatus(a1)			; Set status
00001FEA                            
00001FEA 1418                       		move.b	(a0)+,d2			; Get ID
00001FEC D442                       		add.w	d2,d2				; Make it an index in the level object index list
00001FEE D442                       		add.w	d2,d2
00001FF0 22B4 2000                  		move.l	(a4,d2.w),_objAddress(a1)		; Set address
00001FF4                            
00001FF4 1358 0024                  		move.b	(a0)+,_objSubtype(a1)		; Set subtype
00001FF8 334B 0026                  		move.w	a3,_objRespawn(a1)			; Set respawn address
00001FFC                            		
00001FFC 6000 FA1E                  		bra.w	FindFreeObj			; Find a free object slot
00002000                            		
00002000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002000                            ; Check if the object is in range on the camera. If it isn't, delete it
00002000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002000                            ; PARAMETERS:
00002000                            ;	a0.l	- Object space pointer
00002000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002000                            ; RETURNS:
00002000                            ;	Nothing
00002000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002000                            CheckObjActive:
00002000 3028 0014                  		move.w	_objXPos(a0),d0			; Get X position
00002004                            
00002004                            CheckObjActive2:
00002004 0240 FF80                  		andi.w	#$FF80,d0			; Only allow multiples of $80
00002008 9078 C7C8                  		sub.w	objMgrCoarseX.w,d0		; Subtract the camera's coarse X position
0000200C 0C40 0280                  		cmpi.w	#$280,d0			; Has it gone offscreen?
00002010 6200                       		bhi.s	.Delete				; If so, branch
00002012 4E75                       		rts
00002014                            
00002014                            .Delete:
00002014 3028 0026                  		move.w	_objRespawn(a0),d0			; Get respawn table entry address
00002018 6700                       		beq.s	.DoDelete			; If 0, branch
0000201A 3440                       		movea.w	d0,a2
0000201C 0892 0007                  		bclr	#7,(a2)				; Mark as gone
00002020                            
00002020                            .DoDelete:
00002020 4EF8 1A4C                  		jmp	DeleteObject.w			; Delete the object
00002024                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002024                            ; Get orientation to player
00002024                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002024                            ; PARAMETERS:
00002024                            ;	a0.l	- Object space pointer
00002024                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002024                            ; RETURNS:
00002024                            ;	a1.l	- Player object
00002024                            ;	d0.w	- 0 if player is left from object, 2 if right
00002024                            ;	d1.w	- 0 if player is above object, 2 if below
00002024                            ;	d2.w	- Player's horizontal distance to object
00002024                            ;	d3.w	- Player's vertical distance to object
00002024                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002024                            GetOrientToPlayer:
00002024 7000                       		moveq	#0,d0
00002026 7200                       		moveq	#0,d1
00002028                            
00002028 3278 E876                  		movea.w	playerPtrP1.w,a1		; Get player object
0000202C                            
0000202C 3428 0014                  		move.w	_objXPos(a0),d2			; Get horizonal distance
00002030 9469 0014                  		sub.w	_objXPos(a1),d2			; ''
00002034 6A00                       		bpl.s	.GetY				; Branch if the player is left from the object
00002036 5440                       		addq.w	#2,d0				; Set flag to indicate that the player is right from the object
00002038                            
00002038                            .GetY:
00002038 3628 0018                  		move.w	_objYPos(a0),d3			; Get vertical distance
0000203C 9669 0018                  		sub.w	_objYPos(a1),d3			; ''
00002040 6400                       		bhs.s	.End				; Branch if the player is above the object
00002042 5441                       		addq.w	#2,d1				; Set flag to indicate that the player is below the object
00002044                            
00002044                            .End:
00002044 4E75                       		rts
00002046                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002046                            ; Cap an object's speed
00002046                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002046                            ; PARAMETERS:
00002046                            ;	a0.l	- Object space pointer
00002046                            ;	d0.w	- Max X speed
00002046                            ;	d1.w	- Max Y speed
00002046                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002046                            ; RETURNS:
00002046                            ;	Nothing
00002046                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002046                            CapObjSpeed:
00002046 3428 001C                  		move.w	_objXVel(a0),d2			; Get X velocity
0000204A 6A00                       		bpl.s	.ChkRight			; If we are going right, branch
0000204C 4440                       		neg.w	d0				; Get absolute speed
0000204E B440                       		cmp.w	d0,d2				; Has it gone over the limit?
00002050 6400                       		bhs.s	.ChkUp				; If not, branch
00002052 3400                       		move.w	d0,d2				; Cap the speed
00002054 6000                       		bra.s	.ChkUp				; Continue
00002056                            
00002056                            .ChkRight:
00002056 B440                       		cmp.w	d0,d2				; Has it gone over the limit?
00002058 6300                       		bls.s	.ChkUp				; If not, branch
0000205A 3400                       		move.w	d0,d2				; Cap the speed
0000205C                            
0000205C                            .ChkUp:
0000205C 3628 001E                  		move.w	_objYVel(a0),d3			; Get Y velocity
00002060 6A00                       		bpl.s	.ChkDown			; If we are going right, branch
00002062 4441                       		neg.w	d1				; Get absolute speed
00002064 B641                       		cmp.w	d1,d3				; Has it gone over the limit?
00002066 6400                       		bhs.s	.UpdateVel			; If not, branch
00002068 3601                       		move.w	d1,d3				; Cap the speed
0000206A 6000                       		bra.s	.UpdateVel			; Continue
0000206C                            
0000206C                            .ChkDown:
0000206C B641                       		cmp.w	d1,d3				; Has it gone over the limit?
0000206E 6300                       		bls.s	.UpdateVel			; If not, branch
00002070 3601                       		move.w	d1,d3				; Cap the speed
00002072                            
00002072                            .UpdateVel:
00002072 3142 001C                  		move.w	d2,_objXVel(a0)			; Set X velocity
00002076 3142 001E                  		move.w	d2,_objYVel(a0)			; Set Y velocity
0000207A 4E75                       		rts
0000207C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000207C                            ; Load a child object	NTP: no idea wtf to do about this one. do we even need it since all objects are kinda linked anyway? we'll have to see
0000207C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000207C                            ; PARAMETERS:
0000207C                            ;	a2.l	- Object data
0000207C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000207C                            ; RETURNS:
0000207C                            ;	Nothing
0000207C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000207C                            ; LoadChildObject:
0000207C 6100 F99E                  		bsr.w	FindFreeObj			; Find a free object slot
00002080 6600                       		bne.s	.End				; If there is non, branch
00002082 301A                       		move.w	(a2)+,d0			; Get parent object SST
00002084 3388 0000                  		move.w	a0,(a1,d0.w)			; Store parent object
00002088 301A                       		move.w	(a2)+,d0			; Get child object SST
0000208A 3189 0000                  		move.w	a1,(a0,d0.w)			; Store child object
0000208E 229A                       		move.l	(a2)+,_objAddress(a1)			; Set object pointer
00002090 135A 0024                  		move.b	(a2)+,_objSubtype(a1)		; Set subtype
00002094 3368 0014 0014             		move.w	_objXPos(a0),_objXPos(a1)			; Set X
0000209A 3368 0018 0018             		move.w	_objYPos(a0),_objYPos(a1)			; Set Y
000020A0                            
000020A0                            .End:
000020A0 4E75                       		rts
000020A2                            ; =========================================================================================================================================================
000020A2                            		include	"Libraries/Interrupt.asm"	; Interrupt functions
000020A2                            ; =========================================================================================================================================================
000020A2                            ; Interrupt functions
000020A2                            ; =========================================================================================================================================================
000020A2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000020A2                            ; Vertical Interrupts
000020A2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000020A2                            VInt_Standard:
000020A2                            		intsOff					; Turn interrupts off
000020A2 007C 0700                M 	ori	#$700,sr
000020A6                            		push.l	d0-a6				; Save registers
000020A6 48E7 FFFE                M 	movem.l	d0-a6,-(sp)
000020AA                            		
000020AA 4DF9 00C0 0004             		lea	VDP_CTRL,a6			; VDP control port
000020B0 4BEE FFFC                  		lea	-4(a6),a5			; VDP data port
000020B4                            
000020B4                            .WaitForVBLANK:
000020B4 3016                       		move.w	(a6),d0				; Get VDP status
000020B6 0240 0008                  		andi.w	#8,d0				; Are we in a VBLANK period?
000020BA 67F8                       		beq.s	.WaitForVBLANK			; If not, wait
000020BC                            
000020BC 0838 0006 C746             		btst	#6,hwVersion.w		; Is this a PAL system?
000020C2 6700                       		beq.s	.SetVScroll			; If not, branch
000020C4 303C 0700                  		move.w	#$700,d0			; Do a delay
000020C8 51C8 FFFE                  		dbf	d0,*				; ''
000020CC                            
000020CC                            .SetVScroll:
000020CC                            		dma68k	vScrollBuff,0,$50,VSRAM		; Load VScroll buffer into VSRAM
000020CC 2CBC 9400 9328           M 	move.l	#$94009300|(((($50)/2)&$ff00)<<8)|((($50)/2)&$ff),(a6)
000020D2 2CBC 96CA 953F           M 	move.l	#$96009500|((((vscrollbuff)/2)&$ff00)<<8)|(((vscrollbuff)/2)&$ff),(a6)
000020D8 3CBC 977F                M 	move.w	#$9700|(((vscrollbuff)>>17)&$7f),(a6)
000020DC                          M 	vdpcmd	move.w,0,vsram,dma,>>16,(a6)
000020DC 3CBC 4000                M 	move.w	#((((vsram&dma)&3)<<30)|((0&$3fff)<<16)|(((vsram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
000020E0                          M 	vdpcmd	move.w,0,vsram,dma,&$ffff,-(sp)
000020E0 3F3C 0090                M 	move.w	#((((vsram&dma)&3)<<30)|((0&$3fff)<<16)|(((vsram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
000020E4 3C9F                     M 	move.w	(sp)+,(a6)
000020E6                            
000020E6 4A38 C747                  		tst.b	vIntRoutine.w			; Is the game lagging?
000020EA 6700 0000                  		beq.w	VInt_Lag_Main			; If so, branch
000020EE 4238 C74A                  		clr.b	lagCounter.w			; Clear lag frame counter
000020F2                            
000020F2 7000                       		moveq	#0,d0
000020F4 1038 C747                  		move.b	vIntRoutine.w,d0		; Get V-INT routine ID
000020F8 4238 C747                  		clr.b	vIntRoutine.w			; Clear V-INT routine ID
000020FC 50F8 C74B                  		st	hIntFlag.w			; Allow the H-INT to run
00002100 303B 0000                  		move.w	VInt_Routines(pc,d0.w),d0	; Get V-INT routine offset
00002104 4EBB 0000                  		jsr	VInt_Routines(pc,d0.w)		; Jump to the routine
00002108                            
00002108                            VInt_FinishUpdates:
00002108 4EB9 0000 0000             		jsr	UpdateAMPS			; Run the AMPS driver
0000210E                            
0000210E                            VInt_End:
0000210E 52B8 C758                  		addq.l	#1,frameCounter.w		; Increment frame count
00002112 6100 F23A                  		bsr.w	RandomNumber			; Generate a random number
00002116                            		
00002116                            		pop.l	d0-a6				; Restore registers
00002116 4CDF 7FFF                M 	movem.l	(sp)+,d0-a6
0000211A                            		intsOn					; Turn interrupts on
0000211A 027C F8FF                M 	andi	#$f8ff,sr
0000211E                            		lagOn					; Turn on the lag-o-meter
0000211E 4E73                       		rte
00002120                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002120                            ; V-INT routines
00002120                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002120                            VInt_Routines:
00002120 0000                       		dc.w	VInt_Lag-VInt_Routines		; Lag routine
00002122 0000                       		dc.w	VInt_General-VInt_Routines	; General routine
00002124 0000                       		dc.w	VInt_Level-VInt_Routines	; Level routine
00002126 0000                       		dc.w	VInt_LevelLoad-VInt_Routines	; Level load routine
00002128 0000                       		dc.w	VInt_Title-VInt_Routines	; Title screen routine
0000212A 0000                       		dc.w	VInt_Fade-VInt_Routines		; Fade routine
0000212C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000212C                            ; V-INT lag routine
0000212C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000212C                            VInt_Lag:
0000212C 584F                       		addq.w	#4,sp				; Don't return to caller
0000212E                            
0000212E                            VInt_Lag_Main:
0000212E 4A38 E8FF                  		tst.b	waterFullscr.w		; Is water fullscreen?
00002132 6600                       		bne.s	.WaterPal			; If so, branch
00002134                            		dma68k	paletteBuff,0,$80,CRAM		; Load palette into CRAM
00002134 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
0000213A 2CBC 96CC 9567           M 	move.l	#$96009500|((((palettebuff)/2)&$ff00)<<8)|(((palettebuff)/2)&$ff),(a6)
00002140 3CBC 977F                M 	move.w	#$9700|(((palettebuff)>>17)&$7f),(a6)
00002144                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
00002144 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
00002148                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
00002148 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
0000214C 3C9F                     M 	move.w	(sp)+,(a6)
0000214E 6000                       		bra.s	.Cont				; Continue
00002150                            
00002150                            .WaterPal:
00002150                            		dma68k	paletteBuffAlt,0,$80,CRAM		; Load water palette into CRAM
00002150 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
00002156 2CBC 96CC 9527           M 	move.l	#$96009500|((((palettebuffalt)/2)&$ff00)<<8)|(((palettebuffalt)/2)&$ff),(a6)
0000215C 3CBC 977F                M 	move.w	#$9700|(((palettebuffalt)>>17)&$7f),(a6)
00002160                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
00002160 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
00002164                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
00002164 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
00002168 3C9F                     M 	move.w	(sp)+,(a6)
0000216A                            
0000216A                            .Cont:	
0000216A 3CB8 C760                  		move.w	hIntCntReg.w,(a6)		; Set H-INT counter
0000216E                            
0000216E 5238 C74A                  		addq.b	#1,lagCounter.w		; Increment lag counter
00002172 6000 FF94                  		bra.w	VInt_FinishUpdates		; Go update SMPS
00002176                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002176                            ; V-INT general routine
00002176                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002176                            VInt_General:
00002176 6100 0000                  		bsr.w	VInt_Update			; Do updates
0000217A 6000 EF5C                  		bra.w	SetKosBookmark			; Set Kosinski decompression bookmark
0000217E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000217E                            ; V-INT level load routine
0000217E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000217E                            VInt_LevelLoad:
0000217E 6100 E93A                  		bsr.w	ReadJoypads			; Read joypads
00002182                            
00002182 4A38 E8FF                  		tst.b	waterFullscr.w		; Is water fullscreen?
00002186 6600                       		bne.s	.WaterPal			; If so, branch
00002188                            		dma68k	paletteBuff,0,$80,CRAM		; Load palette into CRAM
00002188 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
0000218E 2CBC 96CC 9567           M 	move.l	#$96009500|((((palettebuff)/2)&$ff00)<<8)|(((palettebuff)/2)&$ff),(a6)
00002194 3CBC 977F                M 	move.w	#$9700|(((palettebuff)>>17)&$7f),(a6)
00002198                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
00002198 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
0000219C                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
0000219C 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
000021A0 3C9F                     M 	move.w	(sp)+,(a6)
000021A2 6000                       		bra.s	.Cont				; Continue
000021A4                            
000021A4                            .WaterPal:
000021A4                            		dma68k	paletteBuffAlt,0,$80,CRAM		; Load water palette into CRAM
000021A4 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
000021AA 2CBC 96CC 9527           M 	move.l	#$96009500|((((palettebuffalt)/2)&$ff00)<<8)|(((palettebuffalt)/2)&$ff),(a6)
000021B0 3CBC 977F                M 	move.w	#$9700|(((palettebuffalt)>>17)&$7f),(a6)
000021B4                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
000021B4 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
000021B8                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
000021B8 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
000021BC 3C9F                     M 	move.w	(sp)+,(a6)
000021BE                            
000021BE                            .Cont:
000021BE 3CB8 C760                  		move.w	hIntCntReg.w,(a6)		; Set H-INT counter
000021C2                            		
000021C2                            		dma68k	spriteBuff,$F800,$280,VRAM	; Load sprite table into VRAM
000021C2 2CBC 9401 9340           M 	move.l	#$94009300|(((($280)/2)&$ff00)<<8)|((($280)/2)&$ff),(a6)
000021C8 2CBC 96CA 9567           M 	move.l	#$96009500|((((spritebuff)/2)&$ff00)<<8)|(((spritebuff)/2)&$ff),(a6)
000021CE 3CBC 977F                M 	move.w	#$9700|(((spritebuff)>>17)&$7f),(a6)
000021D2                          M 	vdpcmd	move.w,$f800,vram,dma,>>16,(a6)
000021D2 3CBC 7800                M 	move.w	#((((vram&dma)&3)<<30)|(($f800&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($f800&$c000)>>14))>>16,(a6)
000021D6                          M 	vdpcmd	move.w,$f800,vram,dma,&$ffff,-(sp)
000021D6 3F3C 0083                M 	move.w	#((((vram&dma)&3)<<30)|(($f800&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($f800&$c000)>>14))&$ffff,-(sp)
000021DA 3C9F                     M 	move.w	(sp)+,(a6)
000021DC                            		dma68k	hScrollBuff,$FC00,$380,VRAM	; Load H-Scroll table into VRAM
000021DC 2CBC 9401 93C0           M 	move.l	#$94009300|(((($380)/2)&$ff00)<<8)|((($380)/2)&$ff),(a6)
000021E2 2CBC 96C8 957F           M 	move.l	#$96009500|((((hscrollbuff)/2)&$ff00)<<8)|(((hscrollbuff)/2)&$ff),(a6)
000021E8 3CBC 977F                M 	move.w	#$9700|(((hscrollbuff)>>17)&$7f),(a6)
000021EC                          M 	vdpcmd	move.w,$fc00,vram,dma,>>16,(a6)
000021EC 3CBC 7C00                M 	move.w	#((((vram&dma)&3)<<30)|(($fc00&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($fc00&$c000)>>14))>>16,(a6)
000021F0                          M 	vdpcmd	move.w,$fc00,vram,dma,&$ffff,-(sp)
000021F0 3F3C 0083                M 	move.w	#((((vram&dma)&3)<<30)|(($fc00&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($fc00&$c000)>>14))&$ffff,-(sp)
000021F4 3C9F                     M 	move.w	(sp)+,(a6)
000021F6 6100 E1B0                  		bsr.w	ProcessDMAQueue			; Process DMA queue
000021FA                            		
000021FA 6000 EEDC                  		bra.w	SetKosBookmark			; Set Kosinski decompression bookmark
000021FE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000021FE                            ; V-INT level routine
000021FE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000021FE                            VInt_Level:
000021FE 43F8 E88A                  		lea	fgCamVars.w,a1			; Foreground level drawing variables
00002202 47F8 C2A0                  		lea	fgColBuff.w,a3		; Foreground column plane buffer
00002206 49F8 C19E                  		lea	fgRowBuff.w,a4		; Foreground row plane buffer
0000220A 4EB9 0000 0000             		jsr	VInt_DrawLevel			; Update the foreground plane
00002210 43F8 E8A8                  		lea	bgCamVars.w,a1			; Background level drawing variables
00002214 47F8 C424                  		lea	bgColBuff.w,a3		; Background column plane buffer
00002218 49F8 C322                  		lea	bgRowBuff.w,a4		; Background row plane buffer
0000221C 4EB9 0000 0000             		jsr	VInt_DrawLevel			; Update the background plane
00002222                            
00002222 6100 E896                  		bsr.w	ReadJoypads			; Read joypads
00002226                            
00002226 4A38 E8FF                  		tst.b	waterFullscr.w		; Is water fullscreen?
0000222A 6600                       		bne.s	.WaterPal			; If so, branch
0000222C                            		dma68k	paletteBuff,0,$80,CRAM		; Load palette into CRAM
0000222C 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
00002232 2CBC 96CC 9567           M 	move.l	#$96009500|((((palettebuff)/2)&$ff00)<<8)|(((palettebuff)/2)&$ff),(a6)
00002238 3CBC 977F                M 	move.w	#$9700|(((palettebuff)>>17)&$7f),(a6)
0000223C                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
0000223C 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
00002240                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
00002240 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
00002244 3C9F                     M 	move.w	(sp)+,(a6)
00002246 6000                       		bra.s	.Cont				; Continue
00002248                            
00002248                            .WaterPal:
00002248                            		dma68k	paletteBuffAlt,0,$80,CRAM		; Load water palette into CRAM
00002248 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
0000224E 2CBC 96CC 9527           M 	move.l	#$96009500|((((palettebuffalt)/2)&$ff00)<<8)|(((palettebuffalt)/2)&$ff),(a6)
00002254 3CBC 977F                M 	move.w	#$9700|(((palettebuffalt)>>17)&$7f),(a6)
00002258                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
00002258 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
0000225C                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
0000225C 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
00002260 3C9F                     M 	move.w	(sp)+,(a6)
00002262                            
00002262                            .Cont:
00002262 3CB8 C760                  		move.w	hIntCntReg.w,(a6)		; Set H-INT counter
00002266                            
00002266                            		dma68k	spriteBuff,$F800,$280,VRAM	; Load sprite table into VRAM
00002266 2CBC 9401 9340           M 	move.l	#$94009300|(((($280)/2)&$ff00)<<8)|((($280)/2)&$ff),(a6)
0000226C 2CBC 96CA 9567           M 	move.l	#$96009500|((((spritebuff)/2)&$ff00)<<8)|(((spritebuff)/2)&$ff),(a6)
00002272 3CBC 977F                M 	move.w	#$9700|(((spritebuff)>>17)&$7f),(a6)
00002276                          M 	vdpcmd	move.w,$f800,vram,dma,>>16,(a6)
00002276 3CBC 7800                M 	move.w	#((((vram&dma)&3)<<30)|(($f800&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($f800&$c000)>>14))>>16,(a6)
0000227A                          M 	vdpcmd	move.w,$f800,vram,dma,&$ffff,-(sp)
0000227A 3F3C 0083                M 	move.w	#((((vram&dma)&3)<<30)|(($f800&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($f800&$c000)>>14))&$ffff,-(sp)
0000227E 3C9F                     M 	move.w	(sp)+,(a6)
00002280                            		dma68k	hScrollBuff,$FC00,$380,VRAM	; Load H-Scroll table into VRAM
00002280 2CBC 9401 93C0           M 	move.l	#$94009300|(((($380)/2)&$ff00)<<8)|((($380)/2)&$ff),(a6)
00002286 2CBC 96C8 957F           M 	move.l	#$96009500|((((hscrollbuff)/2)&$ff00)<<8)|(((hscrollbuff)/2)&$ff),(a6)
0000228C 3CBC 977F                M 	move.w	#$9700|(((hscrollbuff)>>17)&$7f),(a6)
00002290                          M 	vdpcmd	move.w,$fc00,vram,dma,>>16,(a6)
00002290 3CBC 7C00                M 	move.w	#((((vram&dma)&3)<<30)|(($fc00&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($fc00&$c000)>>14))>>16,(a6)
00002294                          M 	vdpcmd	move.w,$fc00,vram,dma,&$ffff,-(sp)
00002294 3F3C 0083                M 	move.w	#((((vram&dma)&3)<<30)|(($fc00&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($fc00&$c000)>>14))&$ffff,-(sp)
00002298 3C9F                     M 	move.w	(sp)+,(a6)
0000229A 6100 E10C                  		bsr.w	ProcessDMAQueue			; Process DMA queue
0000229E                            		
0000229E 0C38 005C C761             		cmpi.b	#92,hIntCntValue.w		; Would V-INT be unable to do updates in the next frame?
000022A4 6400                       		bhs.s	.DoUpdates			; If not, branch
000022A6 50F8 C75F                  		st	hIntUpdates.W		; Set updates in H-INT flag
000022AA 584F                       		addq.w	#4,sp				; Skip SMPS update routine afterwards
000022AC 6100 EE2A                  		bsr.w	SetKosBookmark			; Set Kosinski decompression bookmark
000022B0 6000 FE5C                  		bra.w	VInt_End			; Continue
000022B4                            
000022B4                            .DoUpdates:
000022B4 4EB9 0000 0000             		jsr	Level_UpdateHUD			; Update the HUD
000022BA 6000 EE1C                  		bra.w	SetKosBookmark			; Set Kosinski decompression bookmark
000022BE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000022BE                            ; V-INT title screen update routine
000022BE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000022BE                            VInt_Title:
000022BE 4E75                       		rts
000022C0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000022C0                            ;		bsr.w	ReadJoypads			; Read joypads
000022C0                            ;
000022C0                            ;		move.l	#$C0000000,VDP_CTRL		; Write palette to CRAM
000022C0                            ;		lea	paletteBuff.w,a0			; ''
000022C0                            ;		moveq	#$80>>2-1,d0			; ''
000022C0                            ;
000022C0                            ;.WritePal:
000022C0                            ;		move.l	(a0)+,VDP_DATA			; ''
000022C0                            ;		dbf	d0,.WritePal			; ''
000022C0                            ;
000022C0                            ;		move.l	#$78000003,VDP_CTRL		; Write sprite data to VRAM
000022C0                            ;		lea	spriteBuff.w,a0			; ''
000022C0                            ;		move.w	#$280>>2-1,d0			; ''
000022C0                            ;
000022C0                            ;.WriteSprs:
000022C0                            ;		move.l	(a0)+,VDP_DATA			; ''
000022C0                            ;		dbf	d0,.WriteSprs			; ''
000022C0                            ;
000022C0                            ;		move.l	#$7C000003,VDP_CTRL		; Write HScroll table to VRAM
000022C0                            ;		lea	hScrollBuff.w,a0			; ''
000022C0                            ;		move.w	#$380>>2-1,d0			; ''
000022C0                            ;
000022C0                            ;.WriteHScrl:
000022C0                            ;		move.l	(a0)+,VDP_DATA			; ''
000022C0                            ;		dbf	d0,.WriteHScrl			; ''
000022C0                            ;		rts
000022C0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000022C0                            ; Do standard updates in V-INT
000022C0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000022C0                            VInt_Update:
000022C0                            	; NTP: We don't want to update sprites during a fade, thus it's not shared with the below interrupt routine
000022C0                            		dma68k	spriteBuff,$F800,$280,VRAM	; Load sprite table into VRAM
000022C0 2CBC 9401 9340           M 	move.l	#$94009300|(((($280)/2)&$ff00)<<8)|((($280)/2)&$ff),(a6)
000022C6 2CBC 96CA 9567           M 	move.l	#$96009500|((((spritebuff)/2)&$ff00)<<8)|(((spritebuff)/2)&$ff),(a6)
000022CC 3CBC 977F                M 	move.w	#$9700|(((spritebuff)>>17)&$7f),(a6)
000022D0                          M 	vdpcmd	move.w,$f800,vram,dma,>>16,(a6)
000022D0 3CBC 7800                M 	move.w	#((((vram&dma)&3)<<30)|(($f800&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($f800&$c000)>>14))>>16,(a6)
000022D4                          M 	vdpcmd	move.w,$f800,vram,dma,&$ffff,-(sp)
000022D4 3F3C 0083                M 	move.w	#((((vram&dma)&3)<<30)|(($f800&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($f800&$c000)>>14))&$ffff,-(sp)
000022D8 3C9F                     M 	move.w	(sp)+,(a6)
000022DA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000022DA                            ; V-INT fade routine
000022DA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000022DA                            VInt_Fade:
000022DA 6100 E7DE                  		bsr.w	ReadJoypads			; Read joypads
000022DE                            
000022DE 4A38 E8FF                  		tst.b	waterFullscr.w		; Is water fullscreen?
000022E2 6600                       		bne.s	.WaterPal			; If so, branch
000022E4                            		dma68k	paletteBuff,0,$80,CRAM		; Load palette into CRAM
000022E4 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
000022EA 2CBC 96CC 9567           M 	move.l	#$96009500|((((palettebuff)/2)&$ff00)<<8)|(((palettebuff)/2)&$ff),(a6)
000022F0 3CBC 977F                M 	move.w	#$9700|(((palettebuff)>>17)&$7f),(a6)
000022F4                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
000022F4 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
000022F8                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
000022F8 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
000022FC 3C9F                     M 	move.w	(sp)+,(a6)
000022FE 6000                       		bra.s	.Cont				; Continue
00002300                            
00002300                            .WaterPal:
00002300                            		dma68k	paletteBuffAlt,0,$80,CRAM		; Load water palette into CRAM
00002300 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
00002306 2CBC 96CC 9527           M 	move.l	#$96009500|((((palettebuffalt)/2)&$ff00)<<8)|(((palettebuffalt)/2)&$ff),(a6)
0000230C 3CBC 977F                M 	move.w	#$9700|(((palettebuffalt)>>17)&$7f),(a6)
00002310                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
00002310 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
00002314                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
00002314 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
00002318 3C9F                     M 	move.w	(sp)+,(a6)
0000231A                            
0000231A                            .Cont:
0000231A 3CB8 C760                  		move.w	hIntCntReg.w,(a6)		; Set H-INT counter
0000231E                            
0000231E                            		dma68k	hScrollBuff,$FC00,$380,VRAM	; Load H-Scroll table into VRAM
0000231E 2CBC 9401 93C0           M 	move.l	#$94009300|(((($380)/2)&$ff00)<<8)|((($380)/2)&$ff),(a6)
00002324 2CBC 96C8 957F           M 	move.l	#$96009500|((((hscrollbuff)/2)&$ff00)<<8)|(((hscrollbuff)/2)&$ff),(a6)
0000232A 3CBC 977F                M 	move.w	#$9700|(((hscrollbuff)>>17)&$7f),(a6)
0000232E                          M 	vdpcmd	move.w,$fc00,vram,dma,>>16,(a6)
0000232E 3CBC 7C00                M 	move.w	#((((vram&dma)&3)<<30)|(($fc00&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($fc00&$c000)>>14))>>16,(a6)
00002332                          M 	vdpcmd	move.w,$fc00,vram,dma,&$ffff,-(sp)
00002332 3F3C 0083                M 	move.w	#((((vram&dma)&3)<<30)|(($fc00&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($fc00&$c000)>>14))&$ffff,-(sp)
00002336 3C9F                     M 	move.w	(sp)+,(a6)
00002338 6000 E06E                  		bra.w	ProcessDMAQueue			; Process DMA queue
0000233C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000233C                            ; V-INT routine that only runs the SMPS driver
0000233C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000233C                            VInt_RunSMPS:
0000233C                            		push.l	d0-a6				; Save registers
0000233C 48E7 FFFE                M 	movem.l	d0-a6,-(sp)
00002340                            		
00002340                            .WaitForVBLANK:
00002340 3039 00C0 0004             		move.w	VDP_CTRL,d0			; Get VDP status
00002346 0240 0008                  		andi.w	#8,d0				; Are we in a VBLANK period?
0000234A 67F4                       		beq.s	.WaitForVBLANK			; If not, wait
0000234C                            
0000234C 0838 0006 C746             		btst	#6,hwVersion.w		; Is this a PAL system?
00002352 6700                       		beq.s	.UpdateSMPS			; If not, branch
00002354 303C 0700                  		move.w	#$700,d0			; Do a delay
00002358 51C8 FFFE                  		dbf	d0,*				; ''
0000235C                            
0000235C                            .UpdateSMPS:
0000235C 4EB9 0000 0000             		jsr	UpdateAMPS			; Run the AMPS driver
00002362                            
00002362 52B8 C758                  		addq.l	#1,frameCounter.w		; Increment frame count
00002366 6100 EFE6                  		bsr.w	RandomNumber			; Generate a random number
0000236A                            		
0000236A                            		pop.l	d0-a6				; Restore registers
0000236A 4CDF 7FFF                M 	movem.l	(sp)+,d0-a6
0000236E 4E73                       		rte
00002370                            
00002370                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002370                            ; Wait for the vertical interrupt to run and finish
00002370                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002370                            ; PARAMETERS:
00002370                            ;	Nothing
00002370                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002370                            ; RETURNS:
00002370                            ;	Nothing
00002370                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002370                            VSync:
00002370 50F8 C747                  		st	vIntFlag.w			; Set V-INT flag
00002374                            
00002374                            VSync_Routine:
00002374                            		intsOn					; Enable interrupts
00002374 027C F8FF                M 	andi	#$f8ff,sr
00002378                            		lagOff					; Turn off the lag-o-meter
00002378                            
00002378                            .Wait:
00002378 4A38 C747                  		tst.b	vIntFlag.w			; Has the V-INT run yet?
0000237C 66FA                       		bne.s	.Wait				; If not, wait some more
0000237E 4E75                       		rts
00002380                            
00002380                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002380                            ; Horizontal interrupt for palette swapping (for water)
00002380                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002380                            HInt_Water:
00002380                            		intsOff					; Disable interrupts
00002380 007C 0700                M 	ori	#$700,sr
00002384                            
00002384 4A38 C74B                  		tst.b	hIntFlag.w			; Is the H-INT allowed to run?
00002388 6700                       		beq.s	.End				; If not, branch
0000238A 4238 C74B                  		clr.b	hIntFlag.w			; Clear the H-INT flag
0000238E                            
0000238E                            		push.l	a0-a1				; Save registers
0000238E 48E7 00C0                M 	movem.l	a0-a1,-(sp)
00002392                            
00002392 43F9 00C0 0000             		lea	VDP_DATA,a1			; VDP data port
00002398 337C 8AFF 0004             		move.w	#$8AFF,4(a1)			; Don't do any more H-INT calls for the rest of the frame
0000239E 41F8 984E                  		lea	paletteBuffAlt.w,a0		; Water palette
000023A2                            		vdpCmd	move.l, 0, CRAM, WRITE, 4(a1)	; Set VDP command
000023A2 237C C000 0000 0004      M 	move.l	#((((cram&write)&3)<<30)|((0&$3fff)<<16)|(((cram&write)&$fc)<<2)|((0&$c000)>>14)),4(a1)
000023AA                            		rept	32
000023AA                            			move.l	(a0)+,(a1)		; Tranfer palette
000023AA                            		endr
000023AA 2298                     M 	move.l	(a0)+,(a1)
000023AC 2298                     M 	move.l	(a0)+,(a1)
000023AE 2298                     M 	move.l	(a0)+,(a1)
000023B0 2298                     M 	move.l	(a0)+,(a1)
000023B2 2298                     M 	move.l	(a0)+,(a1)
000023B4 2298                     M 	move.l	(a0)+,(a1)
000023B6 2298                     M 	move.l	(a0)+,(a1)
000023B8 2298                     M 	move.l	(a0)+,(a1)
000023BA 2298                     M 	move.l	(a0)+,(a1)
000023BC 2298                     M 	move.l	(a0)+,(a1)
000023BE 2298                     M 	move.l	(a0)+,(a1)
000023C0 2298                     M 	move.l	(a0)+,(a1)
000023C2 2298                     M 	move.l	(a0)+,(a1)
000023C4 2298                     M 	move.l	(a0)+,(a1)
000023C6 2298                     M 	move.l	(a0)+,(a1)
000023C8 2298                     M 	move.l	(a0)+,(a1)
000023CA 2298                     M 	move.l	(a0)+,(a1)
000023CC 2298                     M 	move.l	(a0)+,(a1)
000023CE 2298                     M 	move.l	(a0)+,(a1)
000023D0 2298                     M 	move.l	(a0)+,(a1)
000023D2 2298                     M 	move.l	(a0)+,(a1)
000023D4 2298                     M 	move.l	(a0)+,(a1)
000023D6 2298                     M 	move.l	(a0)+,(a1)
000023D8 2298                     M 	move.l	(a0)+,(a1)
000023DA 2298                     M 	move.l	(a0)+,(a1)
000023DC 2298                     M 	move.l	(a0)+,(a1)
000023DE 2298                     M 	move.l	(a0)+,(a1)
000023E0 2298                     M 	move.l	(a0)+,(a1)
000023E2 2298                     M 	move.l	(a0)+,(a1)
000023E4 2298                     M 	move.l	(a0)+,(a1)
000023E6 2298                     M 	move.l	(a0)+,(a1)
000023E8 2298                     M 	move.l	(a0)+,(a1)
000023EA                            		pop.l	a0-a1				; Restore registers
000023EA 4CDF 0300                M 	movem.l	(sp)+,a0-a1
000023EE                            		
000023EE 4A38 C75F                  		tst.b	hIntUpdates.w		; Do we need to do level updates in here?
000023F2 6600                       		bne.s	.DoUpdates			; If so, branch
000023F4                            
000023F4                            .End:
000023F4 4E73                       		rte
000023F6                            
000023F6                            .DoUpdates:
000023F6 4238 C75F                  		clr.b	hIntUpdates.w		; Clear the update flag
000023FA                            		push.l	d0-a6				; Save registers
000023FA 48E7 FFFE                M 	movem.l	d0-a6,-(sp)
000023FE 4DF9 00C0 0004             		lea	VDP_CTRL,a6			; VDP control port
00002404 4BEE FFFC                  		lea	-4(a6),a5			; VDP data port
00002408 4EB9 0000 0000             		jsr	Level_UpdateHUD			; Update the HUD
0000240E 4EB9 0000 0000             		jsr	UpdateAMPS			; Run the AMPS driver
00002414                            		pop.l	d0-a6				; Restore registers
00002414 4CDF 7FFF                M 	movem.l	(sp)+,d0-a6
00002418 4E73                       		rte
0000241A                            ; =========================================================================================================================================================
0000241A                            
0000241A                            ; =========================================================================================================================================================
0000241A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000241A                            ; Opmode Main Code
0000241A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000241A                            		include	"Opmodes/Title/Main.asm"
0000241A                            ; =========================================================================================================================================================
0000241A                            ; Title splash screen
0000241A                            ; =========================================================================================================================================================
0000241A                            locVRAM:	macro loc,controlport
0000241A                            		move.l	#($40000000+(((loc)&$3FFF)<<16)+(((loc)&$C000)>>14)),(VDP_CTRL).l
0000241A                            		endm
0000241A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000241A                            TitleScreen:
0000241A                                    playSnd #Mus_Stop,  1
0000241A 11FC 0003 C4BC           M 	move.b	#mus_stop,(mqueue+((1)-1)).w
00002420 6100 E130                          bsr.w    FadeToBlack
00002424 4BF9 00C0 0004                     lea     (VDP_CTRL).l,   a5
0000242A 3ABC 8004                          move.w  #$8004, (a5)
0000242E 3ABC 8230                          move.w  #$8230, (a5)
00002432 3ABC 8407                          move.w  #$8407, (a5)
00002436 3ABC 8700                          move.w  #$8700, (a5)
0000243A 3ABC 8B00                          move.w  #$8B00, (a5)
0000243E 3038 9000                          move.w  (dmaQueue).w,   d0
00002442 0200 00BF                          andi.b  #$BF,   d0
00002446 33C0 00C0 0004                     move.w  d0, (VDP_CTRL).l
0000244C                            
0000244C 6100 DDFA                          bsr.w   ClearScreen
00002450 43F9 0000 0000             		lea	KosM_SegaLogo,a1		; Load background art
00002456 343C 0000                  		move.w	#$0,d2				; ''
0000245A 6100 EB00                  		bsr.w	QueueKosMData			; ''
0000245E                                    
0000245E                            .WaitPLCs:
0000245E 11FC 0002 C747             		move.b	#vGeneral,vIntRoutine.w		; Level load V-INT routine
00002464 4EB8 1102                  		jsr	ProcessKos.w			; Process Kosinski queue
00002468 4EB8 2374                  		jsr	VSync_Routine.w			; V-SYNC
0000246C 4EB8 0FAE                  		jsr	ProcessKosM.w			; Process Kosinski Moduled queue
00002470 4A38 9990                  		tst.b	kosMModules.w			; Are there still modules left?
00002474 66E8                       		bne.s	.WaitPLCs			; If so, branch
00002476                            
00002476 41F9 0000 0000             		lea	WWZ_Pal,a0			; Load palette to target buffer
0000247C 303C 0000                  		move.w	#(WWZ_Pal_End-WWZ_Pal)>>1-1,d0
00002480 6100 E0B8                  		bsr.w	LoadTargetPal			; ''
00002484                            
00002484 6100 E148                          bsr.w   FadeFromBlack
00002488                                 ;   RaiseError  "End of title successfully reached"
00002488                                .loop:
00002488                            	;	move.b	#gLevel,opmode.w			; Set game mode to "title"
00002488                            	;	jmp	Level					; Go to the title screen
00002488 60FE                       		bra.s	.loop
0000248A                            
0000248A                            KosM_SegaLogo:
0000248A                                    incbin  "Opmodes/Title/Sega Art.bin"
000027C4                            
000027C4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------	
000027C4                            ;		playSnd	#Mus_Stop, 1			; Stop sound
000027C4                            ;
000027C4                            ;		bsr.w	FadeToBlack			; Fade to black
000027C4                            ;
000027C4                            ;		intsOff					; Disable interrupts
000027C4                            ;		clrRAM	kosVars
000027C4                            ;		clrRAM	checkpoint
000027C4                            ;		clrRAM	opmodeVars
000027C4                            ;		clrRAM	objMemory
000027C4                            ;
000027C4                            ;		lea	VDP_CTRL,a5
000027C4                            ;		move.w	#$8004,(a5)			; $8004 - Disable H-INT, H/V Counter
000027C4                            ;		move.w	#$8174,(a5)			; $8134 - Enable display, enable V-INT, enable DMA, V28
000027C4                            ;		move.w	#$8230,(a5)			; $8230 - Plane A at $C000
000027C4                            ;		move.w	#$8407,(a5)			; $8407 - Plane B at $E000
000027C4                            ;		move.w	#$9011,(a5)			; $9001 - 64x64 cell plane area
000027C4                            ;		move.w	#$9200,(a5)			; $9200 - Window V position at default
000027C4                            ;		move.w	#$8B00,(a5)			; $8B03 - V-Scroll by screen, H-Scroll by screen
000027C4                            ;		move.w	#$8700,(a5)			; $8700 - BG color pal 0 color 0
000027C4                            ;		clr.w	dmaQueue.w			; Set stop token at the beginning of the DMA queue
000027C4                            ;		move.w	#dmaQueue,dmaSlot.w	; Reset the DMA queue slot
000027C4                            ;
000027C4                            ;		bsr.w	ClearScreen			; Clear screen
000027C4                            ;
000027C4                            ;		lea	palFadeBuff.w,a0			; Fade target palette
000027C4                            ;		moveq	#$80>>2-1,d0			; Size
000027C4                            ;
000027C4                            ;.FillPal:
000027C4                            ;		move.l	#$0EEE0EEE,(a0)+		; Fill palette with white
000027C4                            ;		dbf	d0,.FillPal			; Loop
000027C4                            ;
000027C4                            ;		bsr.w	FadeFromBlack			; Fade from black
000027C4                            ;		
000027C4                            ;		bsr.w	SEGA_FMV			; Run SEGA FMV
000027C4                            ;
000027C4                            ;TitleScreen2:
000027C4                            ;		intsOff
000027C4                            ;
000027C4                            ;		clr.b	artCheat.w
000027C4                            ;		clrRAM	opmodeVars
000027C4                            ;		clrRAM	objMemory
000027C4                            ;
000027C4                            ;		move.w	#$8200|($C000/$400),VDP_CTRL	; Reset plane A address
000027C4                            ;		bsr.w	FadeToWhite			; Fade to white
000027C4                            ;
000027C4                            ;		intsOff
000027C4                            ;		bsr.w	ClearScreen			; Clear screen
000027C4                            ;
000027C4                            ;		lea	MapEni_TitleBG,a0		; Decompress background mappings
000027C4                            ;		lea	miscBuff,a1			; Decompress into RAM
000027C4                            ;		moveq	#1,d0				; Base tile properties: Tile ID 1, no flags
000027C4                            ;		bsr.w	EniDec				; Decompress!
000027C4                            ;
000027C4                            ;		lea	miscBuff,a1			; Load mappings
000027C4                            ;		move.l	#$60000003,d0			; At (0, 0) on plane A
000027C4                            ;		moveq	#$27,d1				; $28x$1C tiles
000027C4                            ;		moveq	#$1B,d2				; ''
000027C4                            ;		moveq	#0,d3				; Base tile properties: Tile ID 0, no flags
000027C4                            ;		bsr.w	LoadPlaneMap			; Load the map
000027C4                            ;
000027C4                            ;		lea	MapEni_TitleLogo,a0		; Decompress logo mappings
000027C4                            ;		lea	miscBuff,a1			; Decompress into RAM
000027C4                            ;		move.w	#$8370,d0			; Base tile properties: Tile ID 1, no flags
000027C4                            ;		bsr.w	EniDec				; Decompress!
000027C4                            ;
000027C4                            ;		lea	miscBuff,a1			; Load mappings
000027C4                            ;		move.l	#$41040003,d0			; At (0, 0) on plane A
000027C4                            ;		moveq	#$E,d1				; $28x$1C tiles
000027C4                            ;		moveq	#$C,d2				; ''
000027C4                            ;		moveq	#0,d3				; Base tile properties: Tile ID 0, no flags
000027C4                            ;		bsr.w	LoadPlaneMap			; Load the map
000027C4                            ;
000027C4                            ;		lea	Pal_Title,a0			; Load palette to target buffer
000027C4                            ;		move.w	#(Pal_Title_End-Pal_Title)>>1-1,d0
000027C4                            ;		bsr.w	LoadTargetPal			; ''
000027C4                            ;
000027C4                            ;		lea	ArtKosM_TitleBG,a1		; Load background art
000027C4                            ;		move.w	#$20,d2				; ''
000027C4                            ;		bsr.w	QueueKosMData			; ''
000027C4                            ;
000027C4                            ;		lea	ArtKosM_TitleLogo,a1		; Load logo art
000027C4                            ;		move.w	#$6E00,d2			; ''
000027C4                            ;		bsr.w	QueueKosMData			; ''
000027C4                            ;
000027C4                            ;		lea	ArtKosM_TtlSonic,a1		; Load Sonic art
000027C4                            ;		move.w	#$4000,d2			; ''
000027C4                            ;		bsr.w	QueueKosMData			; ''
000027C4                            ;
000027C4                            ;		lea	ArtKosM_TtlBird,a1		; Load bird art
000027C4                            ;		move.w	#$8400,d2			; ''
000027C4                            ;		bsr.w	QueueKosMData			; ''
000027C4                            ;
000027C4                            ;		lea	ArtKosM_TtlGlove,a1		; Load glove art
000027C4                            ;		move.w	#$8600,d2			; ''
000027C4                            ;		bsr.w	QueueKosMData			; ''
000027C4                            ;
000027C4                            ;.WaitPLCs:
000027C4                            ;		move.b	#vGeneral,vIntRoutine.w		; Level load V-INT routine
000027C4                            ;		jsr	ProcessKos.w			; Process Kosinski queue
000027C4                            ;		jsr	VSync_Routine.w			; V-SYNC
000027C4                            ;		jsr	ProcessKosM.w			; Process Kosinski Moduled queue
000027C4                            ;		tst.b	kosMModules.w			; Are there still modules left?
000027C4                            ;		bne.s	.WaitPLCs			; If so, branch
000027C4                            ;		move.b	#vGeneral,vIntRoutine.w		; Level load V-INT routine
000027C4                            ;		jsr	VSync_Routine.w			; V-SYNC
000027C4                            ;		
000027C4                            ;		move.l	#ObjTtlSonic,rObj_0.w		; Load the Sonic object
000027C4                            ;		move.w	#320+96,(rObj_0+oX).w		; Set X
000027C4                            ;		move.w	#128,(rObj_0+oY).w		; Set Y
000027C4                            ;
000027C4                            ;		move.l	#ObjTtlBird,rObj_1.w		; Load the bird object
000027C4                            ;		move.w	#-64,(rObj_1+oX).w		; Set X
000027C4                            ;		move.w	#64,(rObj_1+oY).w		; Set Y
000027C4                            ;
000027C4                            ;		move.l	#ObjTtlGlove,rObj_2.w		; Load the glove object
000027C4                            ;		move.w	#224,(rObj_2+oX).w		; Set X
000027C4                            ;		move.w	#320,(rObj_2+oY).w		; Set Y
000027C4                            ;
000027C4                            ;		jsr	RunObjects.w			; Run objects
000027C4                            ;		jsr	RendeobjMemory.w			; Render objects
000027C4                            ;
000027C4                            ;		clr.w	palCycTimer.w		; Reset palette cycle
000027C4                            ;
000027C4                            ;		bsr.w	FadeFromWhite			; Fade from white
000027C4                            ;
000027C4                            ;		lea	SampleList+$C0,a3		; Play title screen music
000027C4                            ;		jsr	PlayDAC1			; ''
000027C4                            ;
000027C4                            ;.Loop:
000027C4                            ;		move.b	#vTitle,vIntRoutine.w		; V-SYNC
000027C4                            ;		bsr.w	VSync_Routine			; ''
000027C4                            ;
000027C4                            ;		bsr.s	Title_Updates			; Do updates
000027C4                            ;		
000027C4                            ;		jsr	RunObjects.w			; Run objects
000027C4                            ;		jsr	RendeobjMemory.w			; Render objects
000027C4                            ;
000027C4                            ;		lea	FreeMove_Cheat(pc),a0
000027C4                            ;		lea	moveCheat.w,a1
000027C4                            ;		lea	rCheatEntry.w,a2
000027C4                            ;		bsr.w	Title_ChkCheats
000027C4                            ;		lea	Art_Cheat(pc),a0
000027C4                            ;		lea	artCheat.w,a1
000027C4                            ;		lea	rCheatEntry2.w,a2
000027C4                            ;		bsr.w	Title_ChkCheats
000027C4                            ;
000027C4                            ;		tst.b	artCheat.w
000027C4                            ;		bne.w	BinbowieArt
000027C4                            ;
000027C4                            ;		tst.b	ctrlPressP1.w			; Has start been pressed
000027C4                            ;		bpl.s	.Loop				; If so, branch
000027C4                            ;
000027C4                            ;		st	(rObj_2+oGloveFlag).w		; Set the punch flag
000027C4                            ;
000027C4                            ;		lea	SampleList+$E0,a3		; Punch
000027C4                            ;		jsr	PlayDAC1			; ''
000027C4                            ;
000027C4                            ;.PunchLoop:
000027C4                            ;		move.b	#vTitle,vIntRoutine.w		; V-SYNC
000027C4                            ;		bsr.w	VSync_Routine			; ''
000027C4                            ;
000027C4                            ;		bsr.s	Title_Updates			; Do updates
000027C4                            ;
000027C4                            ;		jsr	RunObjects.w			; Run objects
000027C4                            ;		jsr	RendeobjMemory.w			; Render objects
000027C4                            ;		
000027C4                            ;		tst.b	(rObj_2+oGloveTime).w		; Has the timer run out?
000027C4                            ;		bpl.s	.PunchLoop			; If not, loop
000027C4                            ;		
000027C4                            ;		st	rStartFall.w			; Set flag to start the level by falling
000027C4                            ;
000027C4                            ;		move.b	#gLevel,opmode.w		; Set game mode to "level"
000027C4                            ;		jmp	Level				; Go to level
000027C4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000027C4                            ; Palette cycle
000027C4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000027C4                            ;Title_Updates:
000027C4                            ;		move.b	rLogoAngle.w,d0		; Get logo hover angle
000027C4                            ;		addq.b	#4,rLogoAngle.w		; Increment angle
000027C4                            ;		jsr	CalcSine.w			; Get sine
000027C4                            ;		asr.w	#5,d0				; ''
000027C4                            ;		move.w	d0,vScrollBuffFG.w		; Set logo's Y position
000027C4                            ;
000027C4                            ;		subq.b	#1,palCycTimer.w		; Decrement timer
000027C4                            ;		bpl.s	.End				; If it hasn't run out, branch
000027C4                            ;		move.b	#6,palCycTimer.w		; Reset timer
000027C4                            ;		
000027C4                            ;		moveq	#0,d0
000027C4                            ;		move.b	palCycIndex.w,d0		; Get index
000027C4                            ;		mulu.w	#$C,d0				; Turn into offset
000027C4                            ;		lea	PalCyc_Title(pc,d0.w),a0	; Get pointer to palette data
000027C4                            ;		lea	(paletteBuff+$14).w,a1		; Palette
000027C4                            ;		move.w	(a0)+,(a1)+			; Load palette
000027C4                            ;		move.w	(a0)+,(a1)+			; ''
000027C4                            ;		move.w	(a0)+,(a1)+			; ''
000027C4                            ;		move.w	(a0)+,(a1)+			; ''
000027C4                            ;		move.w	(a0)+,(a1)+			; ''
000027C4                            ;		move.w	(a0)+,(a1)+			; ''
000027C4                            ;		
000027C4                            ;		addq.b	#1,palCycIndex.w		; Increment index
000027C4                            ;		cmpi.b	#6,palCycIndex.w		; Has it reached the end?
000027C4                            ;		bcs.s	.End				; If not, branch
000027C4                            ;		clr.b	palCycIndex.w		; Reset index
000027C4                            
000027C4                            ;.End:
000027C4                            ;		rts
000027C4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000027C4                            ;PalCyc_Title:
000027C4                            ;		dc.w	$00E, $08E, $0EE, $0E0, $E00, $808
000027C4                            ;		dc.w	$08E, $0EE, $0E0, $E00, $808, $00E
000027C4                            ;		dc.w	$0EE, $0E0, $E00, $808, $00E, $08E
000027C4                            ;		dc.w	$0E0, $E00, $808, $00E, $08E, $0EE
000027C4                            ;		dc.w	$E00, $808, $00E, $08E, $0EE, $0E0
000027C4                            ;		dc.w	$808, $00E, $08E, $0EE, $0E0, $E00
000027C4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000027C4                            ; Check for cheats
000027C4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000027C4                            ;Title_ChkCheats:
000027C4                            ;		tst.b	(a1)
000027C4                            ;		bne.s	.End
000027C4                            ;		move.w	(a2),d0
000027C4                            ;		adda.w	d0,a0
000027C4                            ;		move.b	ctrlPressP1.w,d0
000027C4                            ;		cmp.b	(a0),d0
000027C4                            ;		bne.s	.ResetCheat
000027C4                            ;		addq.w	#1,(a2)
000027C4                            ;		tst.b	d0
000027C4                            ;		bne.s	.End
000027C4                            ;		st	(a1)
000027C4                            ;		playSnd	#sRing, 2
000027C4                            ;		rts
000027C4                            ;
000027C4                            ;.ResetCheat:
000027C4                            ;		tst.b	d0
000027C4                            ;		beq.s	.End
000027C4                            ;		clr.w	(a2)
000027C4                            ;
000027C4                            ;.End:
000027C4                            ;		rts
000027C4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000027C4                            ;FreeMove_Cheat:
000027C4                            ;		dc.b	1, 2, 4, 8, 0, $FF
000027C4                            ;		even
000027C4                            ;Art_Cheat:
000027C4                            ;		dc.b	1, 1, 2, 2, 4, 8, 4, 8, $40, $10, $40, $10, 0, $FF
000027C4                            ;		even
000027C4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000027C4                            ; BinBowie's art
000027C4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000027C4                            ;BinbowieArt:
000027C4                            ;		bsr.w	FadeToWhite			; Fade to white
000027C4                            ;		
000027C4                            ;		lea	SampleList,a3
000027C4                            ;		jsr	PlayDAC1
000027C4                            ;
000027C4                            ;		intsOff
000027C4                            ;
000027C4                            ;		jsr	ClearScreen.w
000027C4                            ;
000027C4                            ;		lea	MapEni_BinBowieArt(pc),a0	; Decompress mappings
000027C4                            ;		lea	miscBuff,a1			; Decompress into RAM
000027C4                            ;		moveq	#1,d0				; Base tile properties: Tile ID 1, no flags
000027C4                            ;		bsr.w	EniDec				; Decompress!
000027C4                            ;
000027C4                            ;		lea	miscBuff,a1			; Load mappings
000027C4                            ;		move.l	#$40000003,d0			; At (0, 0) on plane A
000027C4                            ;		moveq	#$27,d1				; $28x$1C tiles
000027C4                            ;		moveq	#$1B,d2				; ''
000027C4                            ;		moveq	#0,d3				; Base tile properties: Tile ID 0, no flags
000027C4                            ;		bsr.w	LoadPlaneMap			; Load the map
000027C4                            ;
000027C4                            ;		lea	Pal_BinBowieArt,a0		; Load palette to target buffer
000027C4                            ;		move.w	#(Pal_BinBowieArt_End-Pal_BinBowieArt)>>1-1,d0
000027C4                            ;		bsr.w	LoadTargetPal			; ''
000027C4                            ;
000027C4                            ;		lea	ArtKosM_BinBowieArt,a1		; Load art
000027C4                            ;		move.w	#$20,d2				; ''
000027C4                            ;		bsr.w	QueueKosMData			; ''
000027C4                            ;
000027C4                            ;.WaitPLCs:
000027C4                            ;		move.b	#vGeneral,vIntRoutine.w		; Level load V-INT routine
000027C4                            ;		jsr	ProcessKos.w			; Process Kosinski queue
000027C4                            ;		jsr	VSync_Routine.w			; V-SYNC
000027C4                            ;		jsr	ProcessKosM.w			; Process Kosinski Moduled queue
000027C4                            ;		tst.b	kosMModules.w			; Are there still modules left?
000027C4                            ;		bne.s	.WaitPLCs			; If so, branch
000027C4                            ;		move.b	#vGeneral,vIntRoutine.w		; Level load V-INT routine
000027C4                            ;		jsr	VSync_Routine.w			; V-SYNC
000027C4                            ;
000027C4                            ;		jsr	FadeFromWhite.w
000027C4                            ;
000027C4                            ;		lea	SampleList+$100,a3
000027C4                            ;		jsr	PlayDAC1
000027C4                            ;
000027C4                            ;.Loop:
000027C4                            ;		move.b	#vTitle,vIntRoutine.w		; Level load V-INT routine
000027C4                            ;		jsr	ProcessKos.w			; Process Kosinski queue
000027C4                            ;		move.b	ctrlPressP1.w,d0
000027C4                            ;		andi.b	#%10010000,d0
000027C4                            ;		beq.s	.Loop
000027C4                            ;
000027C4                            ;		jmp	TitleScreen2
000027C4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000027C4                            ; Objects
000027C4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000027C4                            ;		include	"Title Screen/Objects/Sonic/Code.asm"
000027C4                            ;		include	"Title Screen/Objects/Bird/Code.asm"
000027C4                            ;		include	"Title Screen/Objects/Glove/Code.asm"
000027C4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000027C4                            ; Art
000027C4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000027C4                            ;ArtKosM_TitleBG:
000027C4                            ;		incbin	"Title Screen/Data/Art - Background.kosm.bin"
000027C4                            ;		even
000027C4                            ;ArtKosM_TitleLogo:
000027C4                            ;		incbin	"Title Screen/Data/Art - Logo.kosm.bin"
000027C4                            ;		even
000027C4                            ;ArtKosM_BinBowieArt:
000027C4                            ;		incbin	"Title Screen/Data/Art - BinBowie.kosm.bin"
000027C4                            ;		even
000027C4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000027C4                            ; Plane mappings
000027C4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000027C4                            ;MapEni_TitleBG:
000027C4                            ;		incbin	"Title Screen/Data/Map - Background.eni.bin"
000027C4                            ;		even
000027C4                            ;MapEni_TitleLogo:
000027C4                            ;		incbin	"Title Screen/Data/Map - Logo.eni.bin"
000027C4                            ;		even
000027C4                            ;MapEni_BinBowieArt:
000027C4                            ;		incbin	"Title Screen/Data/Map - BinBowie.eni.bin"
000027C4                            ;		even
000027C4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000027C4                            ; Palette
000027C4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000027C4                            ;Pal_Title:
000027C4                            ;		incbin	"Title Screen/Data/Palette.pal.bin"
000027C4                            ;Pal_Title_End:
000027C4                            ;		even
000027C4                            ;Pal_BinBowieArt:
000027C4                            ;		incbin	"Title Screen/Data/BinBowie Palette.pal.bin"
000027C4                            ;Pal_BinBowieArt_End:
000027C4                            ;		even
000027C4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000027C4                            ; SEGA FMV
000027C4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000027C4                            ;		include	"Title Screen/SEGA FMV/FMV.asm"
000027C4                            ; =========================================================================================================================================================
000027C4                            		include	"Opmodes/Gameplay/Main.asm"
000027C4                            ; =========================================================================================================================================================
000027C4                            ; Level
000027C4                            ; =========================================================================================================================================================
000027C4                            Level:
000027C4                            		playSnd	#Mus_FadeOut, 1			; Fade out sound
000027C4 11FC 0002 C4BC           M 	move.b	#mus_fadeout,(mqueue+((1)-1)).w
000027CA                            
000027CA 4EB8 0552                  		jsr	FadeToBlack			; Fade to black
000027CE                            
000027CE                            Level_NoFade:
000027CE                            		; --- Set up the VDP ---
000027CE                            
000027CE                            		intsOff					; Disable interrupts
000027CE 007C 0700                M 	ori	#$700,sr
000027D2                            		displayOff				; Disable display
000027D2 3038 C766                M 	move.w	vdpreg1.w,d0
000027D6 0200 00BF                M 	andi.b	#%10111111,d0
000027DA 33C0 00C0 0004           M 	move.w	d0,vdp_ctrl
000027E0                            
000027E0 4BF9 00C0 0004             		lea	VDP_CTRL,a5			; VDP control port
000027E6 3ABC 8004                  		move.w	#$8004,(a5)			; Disable H-INT
000027EA 3ABC 8230                  		move.w	#$8230,(a5)			; Plane A at $C000
000027EE 3ABC 8407                  		move.w	#$8407,(a5)			; Plane B at $E000
000027F2 3ABC 8720                  		move.w	#$8720,(a5)			; Set background color to palette line 2, entry 0
000027F6 3ABC 8B03                  		move.w	#$8B03,(a5)			; V-Scroll by screen, H-Scroll by scanline
000027FA 3ABC 9001                  		move.w	#$9001,(a5)			; 64x32 cell plane area
000027FE 303C 9200                  		move.w	#$9200,d0			; Make the window invisible
00002802 31C0 C768                  		move.w	d0,vdpWindowY.w			; ''
00002806 3A80                       		move.w	d0,(a5)				; ''
00002808 4278 9000                  		clr.w	dmaQueue.w			; Set stop token at the beginning of the DMA queue
0000280C 31FC 9000 90FC             		move.w	#dmaQueue,dmaSlot.w	; Reset the DMA queue slot
00002812                            
00002812 4EB8 0248                  		jsr	ClearScreen.w			; Clear the screen
00002816                            
00002816                            		; --- Clear some RAM ---
00002816                            
00002816                            		clrRAM	kosVars			; Clear Kosinski queue variables
00002816                          M 	local	endaddr
00002816                          M endaddr	equs	"kosvars_End"
00002816 7000                     M 	moveq	#0,d0
00002818 43F8 994E                M 	lea	(kosvars).w,a1
0000281C 323C 0040                M 	move.w	#(((kosvars_end)-(kosvars))-((kosvars)&1))>>2-1,d1
00002820 22C0                     M .clear_135:	move.l	d0,(a1)+
00002822 51C9 FFFC                M 	dbf	d1,.clear_135
00002826 32C0                     M 	move.w	d0,(a1)+
00002828                            		clrRAM	opmodeVars			; Clear variables
00002828                          M 	local	endaddr
00002828                          M endaddr	equs	"opmodevars_End"
00002828 7000                     M 	moveq	#0,d0
0000282A 43F8 C7D2                M 	lea	(opmodevars).w,a1
0000282E 323C 0DCA                M 	move.w	#(((opmodevars_end)-(opmodevars))-((opmodevars)&1))>>2-1,d1
00002832 22C0                     M .clear_136:	move.l	d0,(a1)+
00002834 51C9 FFFC                M 	dbf	d1,.clear_136
00002838 32C0                     M 	move.w	d0,(a1)+
0000283A                            		clrRAM	oscillators			; Clear oscillation data
0000283A                          M 	local	endaddr
0000283A                          M endaddr	equs	"oscillators_End"
0000283A 7000                     M 	moveq	#0,d0
0000283C 43F8 C76C                M 	lea	(oscillators).w,a1
00002840 323C 000F                M 	move.w	#(((oscillators_end)-(oscillators))-((oscillators)&1))>>2-1,d1
00002844 22C0                     M .clear_137:	move.l	d0,(a1)+
00002846 51C9 FFFC                M 	dbf	d1,.clear_137
0000284A 32C0                     M 	move.w	d0,(a1)+
0000284C                            
0000284C                            		; --- Do some final initializing and play the level music ---
0000284C                            
0000284C 11FC 0003 E861             		move.b	#3,ringAnimTime.w		; Set ring animation timer
00002852 31FC 001E E90A             		move.w	#30,rFloorTimer.w		; Set floor timer
00002858 4278 C7D0                  		clr.w	palCycTimer.w		; Reset palette cycle
0000285C                            
0000285C 41FA 0000                  		lea	Level_MusicIDs(pc),a0		; Music ID list
00002860 3038 C7AE                  		move.w	levelID.w,d0			; Get level ID
00002864 E218                       		ror.b	#1,d0				; Turn into offset
00002866 EE48                       		lsr.w	#7,d0				; ''
00002868 1030 0000                  		move.b	(a0,d0.w),d0			; Get music ID
0000286C 11C0 E8E0                  		move.b	d0,lvlMusic.w		; Store it
00002870                            		playSnd	d0, 1				; Play it
00002870 11C0 C4BC                M 	move.b	d0,(mqueue+((1)-1)).w
00002874                            
00002874                            		intsOn					; Enable interrupts
00002874 027C F8FF                M 	andi	#$f8ff,sr
00002878                            
00002878                            		; --- Load level data ---
00002878                            
00002878 47F9 0000 0000             		lea	PLC_LevelMain,a3		; Load main level PLCs
0000287E 4EB8 0F4C                  		jsr	LoadKosMQueue.w			; ''
00002882                            
00002882 4EB8 19BE                  		jsr	InitObjectList.w
00002886                            
00002886 4EB8 1A1C                  		jsr	FindFreeObj.w
0000288A 22BC 0000 0000             		move.l	#ObjPlayer,_objAddress(a1)		; Load Player object
00002890 31C9 E876                  		move.w	a1,playerPtrP1.w		; Store the address
00002894                            
00002894 4A38 E8FE                  		tst.b	lvlHasWater.w			; Does the level have water?
00002898 6700                       		beq.s	.NoSurface			; If not, branch
0000289A                            
0000289A                            							; Load water surfaces
0000289A 4EB8 1A1C                  		jsr	FindFreeObj.w
0000289E 22BC 0000 0000             		move.l	#ObjWaterSurface,_objAddress(a1)
000028A4 337C 0060 0014             		move.w	#$60,_objXPos(a1)
000028AA 31C9 E886                  		move.w	a1,waterObjPtr1.w		; Store the address
000028AE                            
000028AE 4EB8 1A1C                  		jsr	FindFreeObj.w
000028B2 22BC 0000 0000             		move.l	#ObjWaterSurface,_objAddress(a1)
000028B8 337C 0120 0014             		move.w	#$120,_objXPos(a1)
000028BE 31C9 E888                  		move.w	a1,waterObjPtr2.w		; Store the address
000028C2                            
000028C2                            .NoSurface:
000028C2 6100 0000                  		bsr.w	Level_LoadData			; Load level data
000028C6                            
000028C6                            .WaitPLCs:
000028C6 11FC 0002 C747             		move.b	#vGeneral,vIntRoutine.w		; Level load V-INT routine
000028CC 4EB8 1102                  		jsr	ProcessKos.w			; Process Kosinski queue
000028D0 4EB8 2374                  		jsr	VSync_Routine.w			; V-SYNC
000028D4 4EB8 0FAE                  		jsr	ProcessKosM.w			; Process Kosinski Moduled queue
000028D8 4A38 9990                  		tst.b	kosMModules.w			; Are there still modules left?
000028DC 66E8                       		bne.s	.WaitPLCs			; If so, branch
000028DE                            
000028DE 4238 E8FE                  		clr.b	lvlHasWater.w			; Clear the water flag
000028E2                            
000028E2 41FA 0000                  		lea	Level_WatelevelIDs(pc),a0	; Water heights
000028E6 3038 C7AE                  		move.w	levelID.w,d0			; Get level ID
000028EA E218                       		ror.b	#1,d0				; Turn into offset
000028EC EC48                       		lsr.w	#6,d0				; ''
000028EE 3030 0000                  		move.w	(a0,d0.w),d0			; Get water height
000028F2 6B00                       		bmi.s	.NoWater			; If it's negative, branch
000028F4 31C0 E900                  		move.w	d0,waterYPos.w		; Set the water height
000028F8 31C0 E902                  		move.w	d0,destWaterYPos.w
000028FC                            
000028FC 50F8 E8FE                  		st	lvlHasWater.w			; Set the water flag
00002900 33FC 8014 00C0 0004        		move.w	#$8014,VDP_CTRL			; Enable H-INT
00002908 6100 0000                  		bsr.w	Level_WaterHeight		; Update water height
0000290C 33F8 C760 00C0 0004        		move.w	hIntCntReg.w,VDP_CTRL		; Set H-INT counter
00002914                            
00002914                            .NoWater:
00002914 31FC 00A0 E8D6             		move.w	#320/2,panCamXPos.w		; Set camera X center
0000291A                            
0000291A 4EB8 18E4                  		jsr	InitOscillation.w		; Initialize oscillation
0000291E                            
0000291E 6100 0000                  		bsr.w	Level_HandleCamera		; Initialize the camera
00002922                            	;	bsr.w	Level_InitHUD			; Initialize the HUD
00002922 6100 0000                  		bsr.w	Level_WaterHeight		; Initialize water height
00002926                            
00002926 6100 0000                  		bsr.w	Level_AnimateArt		; Animate level art
0000292A                            
0000292A                            		; --- Load the planes ---
0000292A                            
0000292A                            		intsOff					; Disable interrupts
0000292A 007C 0700                M 	ori	#$700,sr
0000292E 21FC 0000 233C C74E        		move.l	#VInt_RunSMPS,vIntAddress.w	; Swap V-INT
00002936                            		intsOn					; Enable interrupts
00002936 027C F8FF                M 	andi	#$f8ff,sr
0000293A 6100 0000                  		bsr.w	Level_InitPlanes		; Initialize the planes
0000293E                            		intsOff					; Disable interrupts
0000293E 007C 0700                M 	ori	#$700,sr
00002942 21FC 0000 20A2 C74E        		move.l	#VInt_Standard,vIntAddress.w	; Swap V-INT
0000294A                            		intsOn					; Enable interrupts
0000294A 027C F8FF                M 	andi	#$f8ff,sr
0000294E 11FC 0006 C747             		move.b	#vLvlLoad,vIntRoutine.w		; Level load V-INT routine
00002954 4EB8 2374                  		jsr	VSync_Routine.w			; V-SYNC
00002958                            
00002958                            		; --- Load the level objects and rings ---
00002958                            
00002958 51F8 C7B6                  		sf	objMgrInit.w			; Reset object manager routine
0000295C 6100 0000                  		bsr.w	Level_RingsManager		; Initialize the ring manager
00002960 4EB8 1D94                  		jsr	ObjectManager.w			; Run the object manager
00002964                            	runObjects
00002964 3078 C158                M 	movea.w	objexecfirst.w,a0
00002968 2250                     M 	move.l	_objaddress(a0),a1
0000296A 4E91                     M 	jsr	(a1)
0000296C 4EB8 1A9E                  		jsr	RendeobjMemory.w			; Render objects
00002970                            
00002970 4238 E906                  		clr.b	lvlReload.w			; Clear the level reload flag
00002974                            
00002974                            		displayOn				; Enable display
00002974 3038 C766                M 	move.w	vdpreg1.w,d0
00002978 0000 0040                M 	ori.b	#%01000000,d0
0000297C 33C0 00C0 0004           M 	move.w	d0,vdp_ctrl
00002982 4EB8 05CE                  		jsr	FadeFromBlack.w			; Fade from black
00002986                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002986                            ; Main loop
00002986                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002986                            .Loop:
00002986 11FC 0004 C747             		move.b	#vLevel,vIntRoutine.w		; Level V-INT routine
0000298C 4EB8 1102                  		jsr	ProcessKos.w			; Process Kosinski queue
00002990 4EB8 2374                  		jsr	VSync_Routine.w			; V-SYNC
00002994                            
00002994 4EB8 0000                  		jsr	CheckPause.w			; Check for pausing
00002998 5278 E904                  		addq.w	#1,lvlFrameCnt.w			; Increment frame counter
0000299C                            
0000299C 4EB8 1938                  		jsr	UpdateOscillation.w		; Update oscillation
000029A0                            
000029A0 6100 0000                  		bsr.w	Level_RingsManager		; Run the ring manager
000029A4 4EB8 1D94                  		jsr	ObjectManager.w			; Run the object manager
000029A8                            
000029A8                            	runObjects
000029A8 3078 C158                M 	movea.w	objexecfirst.w,a0
000029AC 2250                     M 	move.l	_objaddress(a0),a1
000029AE 4E91                     M 	jsr	(a1)
000029B0                            
000029B0 4A38 E906                  		tst.b	lvlReload.w			; Does the level need to be reloaded?
000029B4 6600 FE0E                  		bne.w	Level				; If so, branch
000029B8                            
000029B8 6100 0000                  		bsr.w	Level_HandleCamera		; Handle the camera
000029BC 6100 0000                  		bsr.w	Level_UpdatePlanes		; Update the planes (draw new tiles and scroll)
000029C0 6100 0000                  		bsr.w	Level_UpdateWaterSurface	; Update the water surface
000029C4                            
000029C4 4EB8 1A9E                  		jsr	RendeobjMemory.w			; Render objects
000029C8                            
000029C8 6100 0000                  		bsr.w	Level_WaterHeight		; Update water height
000029CC 6100 0000                  		bsr.w	Level_AnimateArt		; Animate level art
000029D0 6100 0000                  		bsr.w	Level_PalCycle			; Do palette cycling
000029D4 6100 0000                  		bsr.w	Level_DynEvents			; Run dynamic events
000029D8                            
000029D8 5338 E861                  		subq.b	#1,ringAnimTime.w		; Decrement ring animation timer
000029DC 6A00                       		bpl.s	.NoRingAni			; If it hasn't run out, branch
000029DE 11FC 0003 E861             		move.b	#3,ringAnimTime.w		; Reset animation timer
000029E4 5238 E860                  		addq.b	#1,ringAnimFrame.w			; Next ring frame
000029E8 0238 0007 E860             		andi.b	#7,ringAnimFrame.w			; Limit it
000029EE                            
000029EE 7000                       		moveq	#0,d0
000029F0 1038 E860                  		move.b	ringAnimFrame.w,d0			; Get ring frame
000029F4 EF48                       		lsl.w	#7,d0				; Convert to offset
000029F6 223C 0000 0000             		move.l	#ArtUnc_Ring,d1			; Source address
000029FC D280                       		add.l	d0,d1				; ''
000029FE 343C D780                  		move.w	#$D780,d2			; VRAM address
00002A02 363C 0040                  		move.w	#$80/2,d3			; Size
00002A06 4EB8 0304                  		jsr	QueueDMATransfer.w		; Queue a transfer
00002A0A                            
00002A0A                            .NoRingAni:
00002A0A 4A38 E864                  		tst.b	ringLossAnimT.w
00002A0E 6700                       		beq.s	.NoRingLossAni
00002A10 7000                       		moveq	#0,d0
00002A12 1038 E864                  		move.b	ringLossAnimT.w,d0
00002A16 D078 E862                  		add.w	ringLossAnimA.w,d0
00002A1A 31C0 E862                  		move.w	d0,ringLossAnimA.w
00002A1E E158                       		rol.w	#8,d0
00002A20 0240 0007                  		andi.w	#7,d0
00002A24 11C0 E865                  		move.b	d0,ringLossAnimF.w
00002A28 5338 E864                  		subq.b	#1,ringLossAnimT.w
00002A2C                            
00002A2C 7000                       		moveq	#0,d0
00002A2E 1038 E865                  		move.b	ringLossAnimF.w,d0		; Get ring frame
00002A32 EF48                       		lsl.w	#7,d0				; Convert to offset
00002A34 223C 0000 0000             		move.l	#ArtUnc_Ring,d1			; Source address
00002A3A D280                       		add.l	d0,d1				; ''
00002A3C 343C D680                  		move.w	#$D680,d2			; VRAM address
00002A40 363C 0040                  		move.w	#$80/2,d3			; Size
00002A44 4EB8 0304                  		jsr	QueueDMATransfer.w		; Queue a transfer
00002A48                            
00002A48                            .NoRingLossAni:
00002A48 4EB8 0FAE                  		jsr	ProcessKosM.w			; Process Kosinski Moduled queue
00002A4C                            
00002A4C 0C38 0004 C75C             		cmpi.b	#gLevel,opmode.w		; Is the game mode level?
00002A52 6700 FF32                  		beq.w	.Loop				; If so, branch
00002A56 4EF8 0220                  		jmp	GotoGameMode.w			; Go to the correct game mode
00002A5A                            
00002A5A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002A5A                            ; Check for pausing
00002A5A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002A5A                            CheckPause:
00002A5A 4A38 C75E                  		tst.b	pauseFlag.w			; Is the game already paused?
00002A5E 6600                       		bne.s	.SetPause			; If so, branch
00002A60 0838 0007 C743             		btst	#7,ctrlPressP1.w			; Has the start button been pressed?
00002A66 6700                       		beq.s	.End				; If not, branch
00002A68                            
00002A68                            .SetPause:
00002A68 50F8 C75E                  		st	pauseFlag.w			; Pause the game
00002A6C                            		AMPS_MUSPAUSE				; Pause the music
00002A6C 11FC 0008 C4BE           M 	move.b	#mus_pause,mqueue+2.w
00002A72                            
00002A72                            .PauseLoop:
00002A72 11FC 0002 C747             		move.b	#vGeneral,vIntRoutine.w		; General V-INT routine
00002A78 6100 F8FA                  		bsr.w	VSync_Routine			; V-SYNC
00002A7C 0838 0007 C743             		btst	#7,ctrlPressP1.w			; Has the start button been pressed?
00002A82 67EE                       		beq.s	.PauseLoop			; If not, branch
00002A84                            
00002A84                            		AMPS_MUSUNPAUSE				; Unpause the music
00002A84 11FC 0009 C4BE           M 	move.b	#mus_unpause,mqueue+2.w
00002A8A 4238 C75E                  		clr.b	pauseFlag.w			; Unpause the game
00002A8E                            
00002A8E                            .End:
00002A8E 4E75                       		rts
00002A90                            
00002A90                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002A90                            ; Level functions
00002A90                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002A90                            		include	"Opmodes/Gameplay/Level Drawing.asm"
00002A90                            ; =========================================================================================================================================================
00002A90                            ; Level drawing functions (Based on Sonic Crackers' and S3K's level drawing engine)
00002A90                            ; =========================================================================================================================================================
00002A90                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002A90                            ; Initialize the planes
00002A90                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002A90                            ; PARAMETERS:
00002A90                            ;	Nothing
00002A90                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002A90                            ; RETURNS:
00002A90                            ;	Nothing
00002A90                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002A90                            Level_InitPlanes:
00002A90 43F8 E88A                  		lea	fgCamVars.w,a1			; Get foreground level drawing RAM
00002A94 47F8 C2A0                  		lea	fgColBuff.w,a3			; Get foreground column plane buffer
00002A98 49F8 C19E                  		lea	fgRowBuff.w,a4			; Get foreground row plane buffer
00002A9C                            
00002A9C 237C 4000 0003 0012        		move.l	#$40000003,cVDP(a1)		; Set the base VDP command for drawing tiles
00002AA4 4269 0016                  		clr.w	cLayout(a1)			; Set the offset for the level layout (foreground)
00002AA8                            		
00002AA8 3038 C7AE                  		move.w	levelID.w,d0			; Get level ID
00002AAC E218                       		ror.b	#1,d0				; Turn into offset
00002AAE E648                       		lsr.w	#3,d0				; ''
00002AB0 41F9 0000 0000             		lea	Level_RenderRouts,a0		; Get initialization routine list
00002AB6 2370 0008 0018             		move.l	8(a0,d0.w),cUpdate(a1)		; Set the update routine pointer
00002ABC 2070 0000                  		movea.l	(a0,d0.w),a0			; Get initialization pointer
00002AC0 4E90                       		jsr	(a0)				; Jump to it
00002AC2                            
00002AC2 31E9 0008 947E             		move.w	cYPos(a1),vScrollBuffFG.w		; Set the V-Scroll value for the foreground
00002AC8                            
00002AC8 43F8 E8A8                  		lea	bgCamVars.w,a1			; Get background level drawing RAM
00002ACC 47F8 C424                  		lea	bgColBuff.w,a3			; Get background column plane buffer
00002AD0 49F8 C322                  		lea	bgRowBuff.w,a4			; Get background row plane buffer
00002AD4                            		
00002AD4 237C 6000 0003 0012        		move.l	#$60000003,cVDP(a1)		; Set the base VDP command for drawing tils
00002ADC 337C 0004 0016             		move.w	#4,cLayout(a1)			; Set the offset for the level layout (background)
00002AE2                            		
00002AE2 3038 C7AE                  		move.w	levelID.w,d0			; Get level ID
00002AE6 E218                       		ror.b	#1,d0				; Turn into offset
00002AE8 E648                       		lsr.w	#3,d0				; ''
00002AEA 41F9 0000 0000             		lea	Level_RenderRouts+4,a0		; Get initialization routine list
00002AF0 2370 0008 0018             		move.l	8(a0,d0.w),cUpdate(a1)		; Set the update routine pointer
00002AF6 2070 0000                  		movea.l	(a0,d0.w),a0			; Get initialization pointer
00002AFA 4E90                       		jsr	(a0)				; Jump to it
00002AFC                            
00002AFC 31E9 0008 9480             		move.w	cYPos(a1),vScrollBuffBG.w		; Set the V-Scroll value for the background
00002B02 4E75                       		rts
00002B04                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B04                            ; Update the planes
00002B04                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B04                            Level_UpdatePlanes:
00002B04 43F8 E88A                  		lea	fgCamVars.w,a1			; Get foreground level drawing RAM
00002B08 47F8 C2A0                  		lea	fgColBuff.w,a3		; Get foreground column plane buffer
00002B0C 49F8 C19E                  		lea	fgRowBuff.w,a4		; Get foreground row plane buffer
00002B10                            		
00002B10 2069 0018                  		movea.l	cUpdate(a1),a0			; Get the update routine pointer
00002B14 4E90                       		jsr	(a0)				; Jump to it
00002B16                            		
00002B16 43F8 E8A8                  		lea	bgCamVars.w,a1			; Get background level drawing RAM
00002B1A 47F8 C424                  		lea	bgColBuff.w,a3		; Get background column plane buffer
00002B1E 49F8 C322                  		lea	bgRowBuff.w,a4		; Get background row plane buffer
00002B22                            
00002B22 2069 0018                  		movea.l	cUpdate(a1),a0			; Get the update routine pointer
00002B26 4E90                       		jsr	(a0)				; Jump to it
00002B28                            
00002B28 45F8 E88A                  		lea	fgCamVars.w,a2			; Get foreground level drawing RAM
00002B2C 3552 0004                  		move.w	cXPos(a2),cXPrev(a2)		; Update the previous X position for the foreground
00002B30 356A 0008 000C             		move.w	cYPos(a2),cYPrev(a2)		; Update the previous Y position for the foreground
00002B36 31EA 0008 947E             		move.w	cYPos(a2),vScrollBuffFG.w		; Set the V-Scroll value for the foreground
00002B3C 3351 0004                  		move.w	cXPos(a1),cXPrev(a1)		; Update the previous X position for the background
00002B40 3369 0008 000C             		move.w	cYPos(a1),cYPrev(a1)		; Update the previous Y position for the background
00002B46 31E9 0008 9480             		move.w	cYPos(a1),vScrollBuffBG.w		; Set the V-Scroll value for the background
00002B4C                            
00002B4C 4E75                       		rts
00002B4E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B4E                            ; General foreground initialization
00002B4E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B4E                            General_InitFG:
00002B4E 6000 0000                  		bra.w	Level_RefreshPlane		; Refresh the plane
00002B52                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B52                            ; General background initialization
00002B52                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B52                            General_InitBG:
00002B52 45F8 E88A                  		lea	fgCamVars.w,a2			; Get foreground level drawing RAM
00002B56 3012                       		move.w	cXPos(a2),d0			; Get foreground X position
00002B58 E240                       		asr.w	#1,d0				; Divide by 2
00002B5A 3280                       		move.w	d0,cXPos(a1)			; Set as background X position
00002B5C 302A 0008                  		move.w	cYPos(a2),d0			; Get foreground Y position
00002B60 E240                       		asr.w	#1,d0				; Divide by 2
00002B62 3340 0008                  		move.w	d0,cYPos(a1)			; Set as background Y position
00002B66                            
00002B66 6100 0000                  		bsr.w	Level_RefreshPlane		; Refresh the plane
00002B6A                            		
00002B6A 6000 0000                  		bra.w	ScrollStaticBG			; Set up the scroll offsets
00002B6E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B6E                            ; General foreground update
00002B6E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B6E                            General_UpdateFG:
00002B6E 6100 0000                  		bsr.w	Level_ChkRedrawPlane		; Check if the plane needs to be redrawn
00002B72                            		
00002B72 780E                       		moveq	#(240/16)-1,d4			; Number of blocks per column
00002B74 7A14                       		moveq	#(336/16)-1,d5			; Number of blocks per row
00002B76 6000 0000                  		bra.w	Level_UpdatePlane		; Update the plane
00002B7A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B7A                            ; General background update
00002B7A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B7A                            General_UpdateBG:
00002B7A 45F8 E88A                  		lea	fgCamVars.w,a2			; Get foreground level drawing RAM
00002B7E 3012                       		move.w	cXPos(a2),d0			; Get foreground X position
00002B80 E240                       		asr.w	#1,d0				; Divide by 2
00002B82 3280                       		move.w	d0,cXPos(a1)			; Set as background X position
00002B84 302A 0008                  		move.w	cYPos(a2),d0			; Get foreground Y position
00002B88 E240                       		asr.w	#1,d0				; Divide by 2
00002B8A 3340 0008                  		move.w	d0,cYPos(a1)			; Set as background Y position
00002B8E                            
00002B8E 6100 0000                  		bsr.w	Level_ChkRedrawPlane		; Check if the plane needs to be redrawn
00002B92 780E                       		moveq	#(240/16)-1,d4			; Number of blocks per column
00002B94 7A14                       		moveq	#(336/16)-1,d5			; Number of blocks per row
00002B96 6100 0000                  		bsr.w	Level_UpdatePlane		; Update the plane
00002B9A                            		
00002B9A 6000 0000                  		bra.w	ScrollStaticBG			; Scroll the planes
00002B9E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B9E                            ; Draw new tiles in the level
00002B9E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B9E                            ; PARAMETERS:
00002B9E                            ;	a1.l	- Camera RAM
00002B9E                            ;	a2.l	- Plane buffer for columns
00002B9E                            ;	a3.l	- Plane buffer for rows
00002B9E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B9E                            ; RETURNS:
00002B9E                            ;	Nothing
00002B9E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B9E                            VInt_DrawLevel:
00002B9E 3629 0012                  		move.w	cVDP(a1),d3			; High word of VDP command
00002BA2 3829 0014                  		move.w	cVDP+2(a1),d4			; Low word of VDP command
00002BA6                            
00002BA6 3013                       		move.w	(a3),d0				; Get high VDP command word
00002BA8 6700 0000                  		beq.w	VInt_DrawLvlRows2		; If it's 0, branch
00002BAC 425B                       		clr.w	(a3)+				; Reset high VDP command word in buffer
00002BAE 3CBC 8F80                  		move.w	#$8F80,(a6)			; Set auto-increment to $80
00002BB2                            
00002BB2                            		; --- DRAW THE FIRST HALF OF THE COLUMN ---
00002BB2                            
00002BB2 3200                       		move.w	d0,d1				; Save high VDP command
00002BB4 7E0F                       		moveq	#(256/16)-1,d7			; Max number of blocks
00002BB6 7C00                       		moveq	#0,d6
00002BB8 1C29 0011                  		move.b	cCBlks(a1),d6			; Get number of blocks in the first set
00002BBC 9E46                       		sub.w	d6,d7				; Get number of blocks in the second set
00002BBE                            
00002BBE 3C80                       		move.w	d0,(a6)				; Set VDP command
00002BC0 3C84                       		move.w	d4,(a6)				; ''
00002BC2 6000                       		bra.s	.DrawCol1_1_Start		; Start
00002BC4                            
00002BC4                            .DrawCol1_1_Loop:
00002BC4 2A9B                       		move.l	(a3)+,(a5)			; Draw blocks
00002BC6                            
00002BC6                            .DrawCol1_1_Start:
00002BC6 51CE FFFC                  		dbf	d6,.DrawCol1_1_Loop		; Loop
00002BCA                            
00002BCA 3403                       		move.w	d3,d2				; Wrap to the top of the plane
00002BCC 0642 007C                  		addi.w	#$7C,d2				; ''
00002BD0 C042                       		and.w	d2,d0				; ''
00002BD2                            
00002BD2 3C80                       		move.w	d0,(a6)				; Set VDP command
00002BD4 3C84                       		move.w	d4,(a6)				; ''
00002BD6                            
00002BD6                            .DrawCol1_2_Loop:
00002BD6 2A9B                       		move.l	(a3)+,(a5)			; Draw blocks
00002BD8 51CF FFFC                  		dbf	d7,.DrawCol1_2_Loop		; Loop
00002BDC                            
00002BDC                            		; --- DRAW THE SECOND HALF OF THE COLUMN ---
00002BDC                            
00002BDC 5441                       		addq.w	#2,d1				; Move over to the right
00002BDE 7E0F                       		moveq	#(256/16)-1,d7			; Max number of blocks
00002BE0 7C00                       		moveq	#0,d6
00002BE2 1C29 0011                  		move.b	cCBlks(a1),d6			; Get number of blocks in the first set
00002BE6 9E46                       		sub.w	d6,d7				; Get number of blocks in the second set
00002BE8                            
00002BE8 3C81                       		move.w	d1,(a6)				; Set VDP command
00002BEA 3C84                       		move.w	d4,(a6)				; ''
00002BEC 6000                       		bra.s	.DrawCol2_1_Start		; Start
00002BEE                            
00002BEE                            .DrawCol2_1_Loop:
00002BEE 2A9B                       		move.l	(a3)+,(a5)			; Draw blocks
00002BF0                            
00002BF0                            .DrawCol2_1_Start:
00002BF0 51CE FFFC                  		dbf	d6,.DrawCol2_1_Loop		; Loop
00002BF4                            
00002BF4 3403                       		move.w	d3,d2				; Wrap to the top of the plane
00002BF6 0642 007E                  		addi.w	#$7E,d2				; ''
00002BFA C242                       		and.w	d2,d1				; ''
00002BFC                            
00002BFC 3C81                       		move.w	d1,(a6)				; Set VDP command
00002BFE 3C84                       		move.w	d4,(a6)				; ''
00002C00                            
00002C00                            .DrawCol2_2_Loop:
00002C00 2A9B                       		move.l	(a3)+,(a5)			; Draw blocks
00002C02 51CF FFFC                  		dbf	d7,.DrawCol2_2_Loop		; Loop
00002C06                            
00002C06 3CBC 8F02                  		move.w	#$8F02,(a6)			; Autoincrement by 2
00002C0A 6000                       		bra.s	VInt_DrawLvlRows2		; Continue
00002C0C                            
00002C0C                            VInt_DrawLvlRows:
00002C0C 3629 0012                  		move.w	cVDP(a1),d3			; High word of VDP command
00002C10 3829 0014                  		move.w	cVDP+2(a1),d4			; Low word of VDP command
00002C14                            
00002C14                            VInt_DrawLvlRows2:
00002C14 3014                       		move.w	(a4),d0				; Get high VDP command
00002C16 6700 0000                  		beq.w	.End				; If it's 0, branch
00002C1A 425C                       		clr.w	(a4)+				; Don't run this again unless necessary
00002C1C                            		
00002C1C                            		; --- DRAW THE FIRST HALF OF THE ROW ---
00002C1C                            
00002C1C 3200                       		move.w	d0,d1				; Save high VDP command
00002C1E 7E1F                       		moveq	#(512/16)-1,d7			; Max number of blocks
00002C20 7C00                       		moveq	#0,d6
00002C22 1C29 0010                  		move.b	cRBlks(a1),d6			; Get number of blocks in the first set
00002C26 9E46                       		sub.w	d6,d7				; Get number of blocks in the second set
00002C28                            
00002C28 3C80                       		move.w	d0,(a6)				; Set VDP command
00002C2A 3C84                       		move.w	d4,(a6)				; ''
00002C2C 6000                       		bra.s	.DrawRow1_1_Start		; Start
00002C2E                            
00002C2E                            .DrawRow1_1_Loop:
00002C2E 2A9C                       		move.l	(a4)+,(a5)			; Draw blocks
00002C30                            
00002C30                            .DrawRow1_1_Start:
00002C30 51CE FFFC                  		dbf	d6,.DrawRow1_1_Loop		; Loop
00002C34                            
00002C34 3403                       		move.w	d3,d2				; Wrap to the leftmost side of the plane
00002C36 0642 0F00                  		addi.w	#$F00,d2			; ''
00002C3A C042                       		and.w	d2,d0				; ''
00002C3C                            
00002C3C 3C80                       		move.w	d0,(a6)				; Set VDP command
00002C3E 3C84                       		move.w	d4,(a6)				; ''
00002C40                            
00002C40                            .DrawRow1_2_Loop:
00002C40 2A9C                       		move.l	(a4)+,(a5)			; Draw blocks
00002C42 51CF FFFC                  		dbf	d7,.DrawRow1_2_Loop		; Loop
00002C46                            
00002C46                            		; --- DRAW THE SECOND HALF OF THE ROW ---
00002C46                            
00002C46 0641 0080                  		addi.w	#$80,d1				; Move over down
00002C4A 7E1F                       		moveq	#(512/16)-1,d7			; Max number of blocks
00002C4C 7C00                       		moveq	#0,d6
00002C4E 1C29 0010                  		move.b	cRBlks(a1),d6			; Get number of blocks in the first set
00002C52 9E46                       		sub.w	d6,d7				; Get number of blocks in the second set
00002C54                            
00002C54 3C81                       		move.w	d1,(a6)				; Set VDP command
00002C56 3C84                       		move.w	d4,(a6)				; ''
00002C58 6000                       		bra.s	.DrawRow2_1_Start		; Start
00002C5A                            
00002C5A                            .DrawRow2_1_Loop:
00002C5A 2A9C                       		move.l	(a4)+,(a5)			; Draw blocks
00002C5C                            
00002C5C                            .DrawRow2_1_Start:
00002C5C 51CE FFFC                  		dbf	d6,.DrawRow2_1_Loop		; Loop
00002C60                            
00002C60 3403                       		move.w	d3,d2				; Wrap to the leftmost side of the plane
00002C62 0642 0F80                  		addi.w	#$F80,d2			; ''
00002C66 C242                       		and.w	d2,d1				; ''
00002C68                            
00002C68 3C81                       		move.w	d1,(a6)				; Set VDP command
00002C6A 3C84                       		move.w	d4,(a6)				; ''
00002C6C                            
00002C6C                            .DrawRow2_2_Loop:
00002C6C 2A9C                       		move.l	(a4)+,(a5)			; Draw blocks
00002C6E 51CF FFFC                  		dbf	d7,.DrawRow2_2_Loop		; Loop
00002C72                            
00002C72                            .End:
00002C72 4E75                       		rts
00002C74                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002C74                            ; Handle plane drawing
00002C74                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002C74                            ; PARAMETERS:
00002C74                            ;	d4.w	- Number of blocks per column
00002C74                            ;	d5.w	- Number of blocks per row
00002C74                            ;	a1.l	- Camera variables
00002C74                            ;	a2.l	- Layout pointer
00002C74                            ;	a3.l	- Column plane buffer
00002C74                            ;	a4.l	- Row plane buffer
00002C74                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002C74                            ; RETURNS:
00002C74                            ;	Nothing
00002C74                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002C74                            Level_UpdatePlane:
00002C74                            		push.l	d5/a4				; Push row plane buffer address
00002C74 48E7 0408                M 	movem.l	d5/a4,-(sp)
00002C78 6100                       		bsr.s	Level_UpdatePlaneX		; Handle horizontal plane updating
00002C7A                            		pop.l	d5/a4				; Restore row plane buffer address
00002C7A 4CDF 1020                M 	movem.l	(sp)+,d5/a4
00002C7E 3805                       		move.w	d5,d4				; Number of blocks per column
00002C80                            		; Continue to update the plane vertically
00002C80                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002C80                            ; Handle plane drawing (vertical redrawing only)
00002C80                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002C80                            ; PARAMETERS:
00002C80                            ;	d4.w	- Number of blocks per row
00002C80                            ;	a1.l	- Camera variables
00002C80                            ;	a4.l	- Row plane buffer
00002C80                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002C80                            ; RETURNS:
00002C80                            ;	Nothing
00002C80                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002C80                            Level_UpdatePlaneY:
00002C80 3029 0008                  		move.w	cYPos(a1),d0			; Get Y
00002C84 0240 FFF0                  		andi.w	#$FFF0,d0			; Only allow multiples of $10
00002C88 3229 000E                  		move.w	cYPrevR(a1),d1			; Get previous y (rounded)
00002C8C 3340 000E                  		move.w	d0,cYPrevR(a1)			; Save new rounded y
00002C90                            		
00002C90 9240                       		sub.w	d0,d1				; Get distance travelled
00002C92 6700                       		beq.s	.End				; If a new row doesn't need to be drawn, branch
00002C94 6B00                       		bmi.s	.DrawDown			; If a new column needs to be drawn on the bottom of the screen, branch
00002C96                            		
00002C96                            .DrawUp:
00002C96 3011                       		move.w	cXPos(a1),d0			; Get X
00002C98 3229 0008                  		move.w	cYPos(a1),d1			; Get Y
00002C9C 6000 0000                  		bra.w	Level_GetRow			; Draw a row
00002CA0                            
00002CA0                            .DrawDown:
00002CA0 3011                       		move.w	cXPos(a1),d0			; Get X
00002CA2 3229 000C                  		move.w	cYPrev(a1),d1			; Get Y
00002CA6 0641 00F0                  		addi.w	#224+16,d1			; Go to the bottom of the screen
00002CAA 6000 0000                  		bra.w	Level_GetRow			; Draw a row
00002CAE                            
00002CAE                            .End:
00002CAE 4E75                       		rts
00002CB0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002CB0                            ; Handle plane drawing (horizontal redrawing only)
00002CB0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002CB0                            ; PARAMETERS:
00002CB0                            ;	d4.w	- Number of blocks per column
00002CB0                            ;	a1.l	- Camera variables
00002CB0                            ;	a3.l	- Column plane buffer
00002CB0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002CB0                            ; RETURNS:
00002CB0                            ;	Nothing
00002CB0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002CB0                            Level_UpdatePlaneX:
00002CB0 3011                       		move.w	cXPos(a1),d0			; Get X
00002CB2 0240 FFF0                  		andi.w	#$FFF0,d0			; Only allow multiples of $10
00002CB6 3229 0006                  		move.w	cXPrevR(a1),d1			; Get previous X (rounded)
00002CBA 3340 0006                  		move.w	d0,cXPrevR(a1)			; Save new rounded X
00002CBE                            		
00002CBE 9240                       		sub.w	d0,d1				; Get distance travelled
00002CC0 6700                       		beq.s	.End				; If a new column doesn't need to be drawn, branch
00002CC2 6B00                       		bmi.s	.DrawRight			; If a new column needs to be drawn on the right side of the screen, branch
00002CC4                            		
00002CC4                            .DrawLeft:
00002CC4 3011                       		move.w	cXPos(a1),d0			; Get X
00002CC6 3229 0008                  		move.w	cYPos(a1),d1			; Get Y
00002CCA 6000 0000                  		bra.w	Level_GetCol			; Draw a column
00002CCE                            		
00002CCE                            .DrawRight:
00002CCE 3029 0004                  		move.w	cXPrev(a1),d0			; Get previous X
00002CD2 0640 0150                  		addi.w	#320+16,d0			; Go to the right side of the screen
00002CD6 3229 0008                  		move.w	cYPos(a1),d1			; Get Y
00002CDA 6000 0000                  		bra.w	Level_GetCol			; Draw a column
00002CDE                            
00002CDE                            .End:
00002CDE 4E75                       		rts
00002CE0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002CE0                            ; Macro to calculate the high VDP command word for the plane buffer
00002CE0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002CE0                            ; PARAMETERS:
00002CE0                            ;	a1.l	- Camera variables
00002CE0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002CE0                            ; RETURNS:
00002CE0                            ;	d2.w	- The high VDP command word
00002CE0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002CE0                            calcHiVDP	macro
00002CE0                            		move.w	d0,d2				; Copy X
00002CE0                            		move.w	d1,d3				; Copy Y
00002CE0                            		lsl.w	#4,d3				; Multiply Y by $10
00002CE0                            		andi.w	#$F00,d3			; Only allow 0-$F00 with multiples of $100
00002CE0                            		lsr.w	#2,d2				; Divide X by 4
00002CE0                            		andi.w	#$7C,d2				; Only allow 0-$7C with multiples of 4
00002CE0                            		add.w	d3,d2				; Add Y onto X
00002CE0                            		or.w	cVDP(a1),d2			; Combine with high VDP command word
00002CE0                            		endm
00002CE0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002CE0                            ; Macro to get an address in chunk data relative to a position
00002CE0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002CE0                            ; PARAMETERS:
00002CE0                            ;	d1.l	- $FFFFXXXX
00002CE0                            ;	a2.l	- Layout data
00002CE0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002CE0                            ; RETURNS:
00002CE0                            ;	a6.l	- Pointer in chunk data to the correct block
00002CE0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002CE0                            getChunk	macro
00002CE0                            		moveq	#-1,d1				; Prepare chunk pointer
00002CE0                            		move.b	(a2,d0.w),d1			; Get chunk ID
00002CE0                            		andi.w	#$FF,d1				; ''
00002CE0                            		lsl.w	#7,d1				; Turn into offset
00002CE0                            		movea.l	d1,a6				; Store into a6
00002CE0                            		endm
00002CE0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002CE0                            ; Get a block row and store it in a plane buffer
00002CE0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002CE0                            ; PARAMETERS:
00002CE0                            ;	d0.w	- X position
00002CE0                            ;	d1.w	- Y position
00002CE0                            ;	d4.w	- Number of blocks to draw (minus 1)
00002CE0                            ;	a1.l	- Camera variables
00002CE0                            ;	a4.l	- Row plane buffer
00002CE0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002CE0                            ; RETURNS:
00002CE0                            ;	Nothing
00002CE0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002CE0                            Level_GetRow:
00002CE0 45F8 E856                  		lea	lvlLayout.w,a2			; Get level layout pointer address
00002CE4 D4E9 0016                  		adda.w	cLayout(a1),a2			; Add camera offset value
00002CE8 2452                       		movea.l	(a2),a2				; Load address stored within the pointer
00002CEA                            
00002CEA 47F8 C7D2                  		lea	blockData.w,a3			; Get block table address
00002CEE 4BEC 0082                  		lea	$82(a4),a5			; Store plane buffer address for the bottom tiles in the row
00002CF2                            
00002CF2                            		calcHiVDP				; Get high VDP command word
00002CF2 3400                     M 	move.w	d0,d2
00002CF4 3601                     M 	move.w	d1,d3
00002CF6 E94B                     M 	lsl.w	#4,d3
00002CF8 0243 0F00                M 	andi.w	#$f00,d3
00002CFC E44A                     M 	lsr.w	#2,d2
00002CFE 0242 007C                M 	andi.w	#$7c,d2
00002D02 D443                     M 	add.w	d3,d2
00002D04 8469 0012                M 	or.w	cvdp(a1),d2
00002D08 38C2                       		move.w	d2,(a4)+			; Store it
00002D0A                            
00002D0A 3400                       		move.w	d0,d2				; Get X
00002D0C E44A                       		lsr.w	#2,d2				; Divide X by 4
00002D0E 0242 007C                  		andi.w	#$7C,d2				; Only allow 0-$7C with multiples of 4
00002D12 3A3C 0080                  		move.w	#512/4,d5			; Get max row size in pixels divided by 4
00002D16 9A42                       		sub.w	d2,d5				; Get number of pixels (divided by 4) that the first set of tiles for a row takes up
00002D18 0245 007C                  		andi.w	#$7C,d5				; Only allow 0-$7C with multiples of 4
00002D1C E44D                       		lsr.w	#2,d5				; Divide by 4
00002D1E 1345 0010                  		move.b	d5,cRBlks(a1)			; Set tile count for the first set of tiles for a row
00002D22                            		
00002D22 E648                       		lsr.w	#3,d0				; Get X within chunk data
00002D24 3400                       		move.w	d0,d2				; ''
00002D26 0242 000E                  		andi.w	#$E,d2				; ''
00002D2A 3601                       		move.w	d1,d3				; Get Y within chunk data
00002D2C 0243 0070                  		andi.w	#$70,d3				; ''
00002D30 D443                       		add.w	d3,d2				; Combine X and Y to get chunk offset
00002D32                            		
00002D32 E848                       		lsr.w	#4,d0				; Get X within layout data
00002D34 0240 00FF                  		andi.w	#$FF,d0				; ''
00002D38 0241 0780                  		andi.w	#$780,d1			; Get Y within layout data
00002D3C EC49                       		lsr.w	#6,d1				; ''
00002D3E                            
00002D3E D072 1002                  		add.w	2(a2,d1.w),d0			; Combine X and Y to get layout offset
00002D42                            		getChunk				; Get chunk pointer at current location
00002D42 72FF                     M 	moveq	#-1,d1
00002D44 1232 0000                M 	move.b	(a2,d0.w),d1
00002D48 0241 00FF                M 	andi.w	#$ff,d1
00002D4C EF49                     M 	lsl.w	#7,d1
00002D4E 2C41                     M 	movea.l	d1,a6
00002D50                            
00002D50                            .DrawBlock_Loop:
00002D50 3A36 2000                  		move.w	(a6,d2.w),d5			; Get block properties
00002D54 3C05                       		move.w	d5,d6				; ''
00002D56 0245 03FF                  		andi.w	#$3FF,d5			; Mask off flip bits
00002D5A E74D                       		lsl.w	#3,d5				; Get offset in block data
00002D5C                            		
00002D5C 2E33 5000                  		move.l	(a3,d5.w),d7			; Get block tiles
00002D60 2A33 5004                  		move.l	4(a3,d5.w),d5			; ''
00002D64                            
00002D64 0806 000A                  		btst	#$A,d6				; Is this block flipped horizontally?
00002D68 6700                       		beq.s	.ChkYFlip			; If not, branch
00002D6A 0A87 0800 0800             		eori.l	#$08000800,d7			; Flip the tiles horizontally
00002D70 0A85 0800 0800             		eori.l	#$08000800,d5			; ''
00002D76 4847                       		swap	d7				; ''
00002D78 4845                       		swap	d5				; ''
00002D7A                            
00002D7A                            .ChkYFlip:
00002D7A 0806 000B                  		btst	#$B,d6				; Is this block flipped vertically?
00002D7E 6700                       		beq.s	.DrawBlock			; If not, branch
00002D80 0A87 1000 1000             		eori.l	#$10001000,d7			; Flip the tiles vertically
00002D86 0A85 1000 1000             		eori.l	#$10001000,d5			; ''
00002D8C CF45                       		exg.l	d7,d5				; ''
00002D8E                            
00002D8E                            .DrawBlock:
00002D8E 28C7                       		move.l	d7,(a4)+			; Save the tiles in the plane buffers
00002D90 2AC5                       		move.l	d5,(a5)+			; ''
00002D92                            
00002D92 5442                       		addq.w	#2,d2				; Go to the next block
00002D94 0242 000E                  		andi.w	#$E,d2				; Have we gone outside of the chunk?
00002D98 6600                       		bne.s	.DrawBlock_Cont			; If not, branch
00002D9A                            		
00002D9A 5240                       		addq.w	#1,d0				; Next chunk
00002D9C                            		getChunk				; ''
00002D9C 72FF                     M 	moveq	#-1,d1
00002D9E 1232 0000                M 	move.b	(a2,d0.w),d1
00002DA2 0241 00FF                M 	andi.w	#$ff,d1
00002DA6 EF49                     M 	lsl.w	#7,d1
00002DA8 2C41                     M 	movea.l	d1,a6
00002DAA                            
00002DAA                            .DrawBlock_Cont:
00002DAA D443                       		add.w	d3,d2				; Recombine X and Y to get chunk offset
00002DAC 51CC FFA2                  		dbf	d4,.DrawBlock_Loop		; Loop
00002DB0                            
00002DB0 4E75                       		rts
00002DB2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002DB2                            ; Get a block column and store it in a plane buffer
00002DB2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002DB2                            ; PARAMETERS:
00002DB2                            ;	d0.w	- X position
00002DB2                            ;	d1.w	- Y position
00002DB2                            ;	d4.w	- Number of blocks to draw (minus 1)
00002DB2                            ;	a1.l	- Camera RAM
00002DB2                            ;	a3.l	- Column plane buffer
00002DB2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002DB2                            ; RETURNS:
00002DB2                            ;	Nothing
00002DB2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002DB2                            Level_GetCol:
00002DB2 45F8 E856                  		lea	lvlLayout.w,a2			; Get level layout pointer address
00002DB6 D4E9 0016                  		adda.w	cLayout(a1),a2			; Add camera offset value
00002DBA 2452                       		movea.l	(a2),a2				; Load address stored within the pointer
00002DBC                            		
00002DBC 49F8 C7D2                  		lea	blockData.w,a4			; Get block table address
00002DC0 4BEB 0042                  		lea	$42(a3),a5			; Store plane buffer address for the right tiles in the column
00002DC4                            		
00002DC4                            		calcHiVDP				; Get high VDP command word
00002DC4 3400                     M 	move.w	d0,d2
00002DC6 3601                     M 	move.w	d1,d3
00002DC8 E94B                     M 	lsl.w	#4,d3
00002DCA 0243 0F00                M 	andi.w	#$f00,d3
00002DCE E44A                     M 	lsr.w	#2,d2
00002DD0 0242 007C                M 	andi.w	#$7c,d2
00002DD4 D443                     M 	add.w	d3,d2
00002DD6 8469 0012                M 	or.w	cvdp(a1),d2
00002DDA 36C2                       		move.w	d2,(a3)+			; Store it
00002DDC                            
00002DDC 3601                       		move.w	d1,d3				; Get Y
00002DDE E94B                       		lsl.w	#4,d3				; Multiply by $10
00002DE0 0243 0F00                  		andi.w	#$F00,d3			; Only allow 0-$F00 with multiples of $100
00002DE4 3A3C 1000                  		move.w	#256*16,d5			; Get max column size in pixels times 16
00002DE8 9A43                       		sub.w	d3,d5				; Get number of pixels (times 16) that the first set of tiles for a column takes up
00002DEA 0245 0F00                  		andi.w	#$F00,d5			; Only allow 0-$F00 with multiples of $100
00002DEE E04D                       		lsr.w	#8,d5				; Divide by $100
00002DF0 1345 0011                  		move.b	d5,cCBlks(a1)			; Set tile count for the first set of tiles for a column
00002DF4                            
00002DF4 E648                       		lsr.w	#3,d0				; Get X within chunk data
00002DF6 3400                       		move.w	d0,d2				; ''
00002DF8 0242 000E                  		andi.w	#$E,d2				; ''
00002DFC 3601                       		move.w	d1,d3				; Get Y within chunk data
00002DFE 0243 0070                  		andi.w	#$70,d3				; ''
00002E02 D642                       		add.w	d2,d3				; Combine X and Y to get chunk offset
00002E04                            
00002E04 E848                       		lsr.w	#4,d0				; Get X within layout data
00002E06 0240 00FF                  		andi.w	#$FF,d0				; ''
00002E0A 0241 0780                  		andi.w	#$780,d1			; Get Y within layout data
00002E0E EC49                       		lsr.w	#6,d1				; ''				
00002E10 48A7 C000                  		movem.w	d0-d1,-(sp)			; Backup layout X and Y 
00002E14                            		
00002E14 D072 1002                  		add.w	2(a2,d1.w),d0			; Combine X and Y to get layout offset
00002E18                            		getChunk				; Get chunk pointer at current location
00002E18 72FF                     M 	moveq	#-1,d1
00002E1A 1232 0000                M 	move.b	(a2,d0.w),d1
00002E1E 0241 00FF                M 	andi.w	#$ff,d1
00002E22 EF49                     M 	lsl.w	#7,d1
00002E24 2C41                     M 	movea.l	d1,a6
00002E26                            
00002E26                            .DrawBlock_Loop:
00002E26 3A36 3000                  		move.w	(a6,d3.w),d5			; Get block properties
00002E2A 3C05                       		move.w	d5,d6				; ''
00002E2C 0245 03FF                  		andi.w	#$3FF,d5			; Mask off flip bits
00002E30 E74D                       		lsl.w	#3,d5				; Get offset in block data
00002E32                            		
00002E32 3E05                       		move.w	d5,d7				; Get block tiles
00002E34 2A34 7002                  		move.l	2(a4,d7.w),d5			; ''
00002E38 3A07                       		move.w	d7,d5				; ''
00002E3A 2E34 5000                  		move.l	(a4,d5.w),d7			; ''
00002E3E 3E34 5004                  		move.w	4(a4,d5.w),d7			; ''
00002E42 3A34 5006                  		move.w	6(a4,d5.w),d5			; ''
00002E46                            
00002E46 0806 000A                  		btst	#$A,d6				; Is this block flipped horizontally?
00002E4A 6700                       		beq.s	.ChkYFlip			; If not, branch
00002E4C 0A87 0800 0800             		eori.l	#$08000800,d7			; Flip the tiles horizontally
00002E52 0A85 0800 0800             		eori.l	#$08000800,d5			; ''
00002E58 CF45                       		exg.l	d7,d5				; ''
00002E5A                            
00002E5A                            .ChkYFlip:
00002E5A 0806 000B                  		btst	#$B,d6				; Is this block flipped vertically?
00002E5E 6700                       		beq.s	.DrawBlock			; If not, branch
00002E60 0A87 1000 1000             		eori.l	#$10001000,d7			; Flip the tiles vertically
00002E66 0A85 1000 1000             		eori.l	#$10001000,d5			; ''
00002E6C 4847                       		swap	d7				; ''
00002E6E 4845                       		swap	d5				; ''
00002E70                            
00002E70                            .DrawBlock:
00002E70 26C7                       		move.l	d7,(a3)+			; Save the tiles in the plane buffers
00002E72 2AC5                       		move.l	d5,(a5)+			; ''
00002E74                            
00002E74 0643 0010                  		addi.w	#$10,d3				; Go to the next block
00002E78 0243 0070                  		andi.w	#$70,d3				; Have we gone outside of the chunk?
00002E7C 6600                       		bne.s	.DrawBlock_Cont			; If not, branch
00002E7E                            
00002E7E 4C9F 0003                  		movem.w	(sp)+,d0-d1			; Get saved layout X and Y from the stack
00002E82 5441                       		addq.w	#2,d1				; Increase layout data Y offset to the next pointer
00002E84 48A7 C000                  		movem.w	d0-d1,-(sp)			; Push a backup copy back onto the stack
00002E88                            		
00002E88 D072 1002                  		add.w	2(a2,d1.w),d0			; Next chunk
00002E8C                            		getChunk				; ''
00002E8C 72FF                     M 	moveq	#-1,d1
00002E8E 1232 0000                M 	move.b	(a2,d0.w),d1
00002E92 0241 00FF                M 	andi.w	#$ff,d1
00002E96 EF49                     M 	lsl.w	#7,d1
00002E98 2C41                     M 	movea.l	d1,a6
00002E9A                            
00002E9A                            .DrawBlock_Cont:
00002E9A D642                       		add.w	d2,d3				; Recombine X and Y to get chunk offset
00002E9C 51CC FF88                  		dbf	d4,.DrawBlock_Loop		; Loop
00002EA0                            
00002EA0 4C9F 0003                  		movem.w	(sp)+,d0-d1			; Discard backup layout X and Y from the stack 
00002EA4 4E75                       		rts
00002EA6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002EA6                            ; Refresh a plane
00002EA6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002EA6                            ; PARAMETERS:
00002EA6                            ;	a1.l	- Camera variables
00002EA6                            ;	a4.l	- Row plane buffer
00002EA6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002EA6                            ; RETURNS:
00002EA6                            ;	Nothing
00002EA6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002EA6                            Level_RefreshPlane:
00002EA6 3011                       		move.w	cXPos(a1),d0			; Get X position
00002EA8 3340 0004                  		move.w	d0,cXPrev(a1)			; Store as previous X position
00002EAC 0240 FFF0                  		andi.w	#$FFF0,d0			; Only get multiples of $10
00002EB0 3340 0006                  		move.w	d0,cXPrevR(a1)			; Store as previous X position (rounded)
00002EB4                            		
00002EB4 3229 0008                  		move.w	cYPos(a1),d1			; Get Y position
00002EB8 3341 000C                  		move.w	d1,cYPrev(a1)			; Store as previous Y position
00002EBC 0241 FFF0                  		andi.w	#$FFF0,d1			; Only get multiples of $10
00002EC0 3341 000E                  		move.w	d1,cYPrevR(a1)			; Store as previous Y position (rounded)
00002EC4                            		
00002EC4 781F                       		moveq	#(512/16)-1,d4			; Number of rows to draw
00002EC6 7C0F                       		moveq	#(256/16)-1,d6			; Number of blocks per row
00002EC8                            		
00002EC8                            		push.l	a4				; Save plane buffer address
00002EC8 2F0C                     M 	move.l	a4,-(sp)
00002ECA                            		
00002ECA                            .DrawRows:
00002ECA                            		push.w	d0/d1/d4/d6			; Save registers
00002ECA 48A7 CA00                M 	movem.w	d0/d1/d4/d6,-(sp)
00002ECE 286F 0008                  		movea.l	8(sp),a4			; Get plane buffer address
00002ED2 6100 FE0C                  		bsr.w	Level_GetRow			; Transfer the row to the plane buffer
00002ED6 286F 0008                  		movea.l	8(sp),a4			; Get plane buffer address
00002EDA 4DF9 00C0 0004             		lea	VDP_CTRL,a6			; VDP control port
00002EE0 4BEE FFFC                  		lea	-4(a6),a5			; VDP data port
00002EE4 6100 FD26                  		bsr.w	VInt_DrawLvlRows		; Draw the new row
00002EE8                            		pop.w	d0/d1/d4/d6			; Restore registers
00002EE8 4C9F 0053                M 	movem.w	(sp)+,d0/d1/d4/d6
00002EEC                            		
00002EEC 0641 0010                  		addi.w	#$10,d1				; Increment Y
00002EF0 51CE FFD8                  		dbf	d6,.DrawRows			; Loop
00002EF4                            		
00002EF4                            		pop.l	a4				; Restore a3
00002EF4 285F                     M 	move.l	(sp)+,a4
00002EF6 4E75                       		rts
00002EF8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002EF8                            ; Check if the plane needs to be redrawn
00002EF8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002EF8                            ; PARAMETERS:
00002EF8                            ;	a1.l	- Camera RAM
00002EF8                            ;	a3.l	- Row plane buffer
00002EF8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002EF8                            ; RETURNS:
00002EF8                            ;	Nothing
00002EF8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002EF8                            Level_ChkRedrawPlane:
00002EF8 4A29 001C                  		tst.b	cRedraw(a1)			; Does this plane need to be redrawn?
00002EFC                            		; Comment out the following line to disable blast processing :^)
00002EFC 6700                       		beq.s	.End				; If not, branch
00002EFE 4229 001C                  		clr.b	cRedraw(a1)			; Clear the redraw flag
00002F02 60A2                       		bra.s	Level_RefreshPlane		; Redraw the plane
00002F04                            
00002F04                            .End:
00002F04 4E75                       		rts
00002F06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002F06                            ; Scroll sections macro
00002F06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002F06 =00008000                  SCROLL_AUTOMATIC	EQU	$8000			; Automatic scroll flag
00002F06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002F06                            scrollInit	macro	label
00002F06                            SCROLL_LABEL	equs	"\label"
00002F06                            \label\:	dc.w	((\label\_End-\label\-2)/6)-1	; Number of sections
00002F06                            		endm
00002F06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002F06                            scrollEnd	macro
00002F06                            \SCROLL_LABEL\_End:					; End label
00002F06                            		endm
00002F06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002F06                            scrollSection	macro
00002F06                            	if narg<3
00002F06                            		dc.w	\2, 0, \1			; Speed, 0, Size
00002F06                            	else
00002F06                            		dc.w	\2, \3, \1			; Speed, Flags, Size
00002F06                            	endif
00002F06                            		endm
00002F06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002F06                            ; Do section scrolling
00002F06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002F06                            ; PARAMERERS:
00002F06                            ;	a1.l	- Background camera RAM
00002F06                            ;	a3.l	- Scroll section data
00002F06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002F06                            ; RETURNS:
00002F06                            ;	Nothing
00002F06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002F06                            ScrollSections:
00002F06 45F8 E88A                  		lea	fgCamVars.w,a2			; Get foreground level drawing variables
00002F0A 49F8 E452                  		lea	scrollSects.w,a4		; Deformation offset buffer
00002F0E 4BF8 90FE                  		lea	hScrollBuff.w,a5			; Horizontal scroll buffer
00002F12                            
00002F12 301B                       		move.w	(a3)+,d0			; Get the total number of scroll sections
00002F14                            
00002F14 3812                       		move.w	cXPos(a2),d4			; Get camera speed
00002F16 986A 0004                  		sub.w	cXPrev(a2),d4			; ''
00002F1A 48C4                       		ext.l	d4				; ''
00002F1C E184                       		asl.l	#8,d4				; Shift over to use for calculation speeds
00002F1E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002F1E                            		; Update each section offset
00002F1E                            		push.w	d0/a4				; Save registers
00002F1E 48A7 8008                M 	movem.w	d0/a4,-(sp)
00002F22                            
00002F22                            .ScrollSects:
00002F22 361B                       		move.w	(a3)+,d3			; Get section speed
00002F24 48C3                       		ext.l	d3				; ''
00002F26                            
00002F26 4A5B                       		tst.w	(a3)+				; Is this section set to scroll automatically?
00002F28 6A00                       		bpl.s	.NotAuto			; If not, branch
00002F2A 3C04                       		move.w	d4,d6				; Get camera speed
00002F2C CDC3                       		muls.w	d3,d6				; Multiply by section speed
00002F2E E183                       		asl.l	#8,d3				; Shift section speed
00002F30 D686                       		add.l	d6,d3				; Add camera speed to section speed
00002F32 6000                       		bra.s	.ApplySpeed			; Apply that speed
00002F34                            
00002F34                            .NotAuto:
00002F34 C7C4                       		muls.w	d4,d3				; Multiply the the background's X scroll offset with the speed
00002F36                            
00002F36                            .ApplySpeed:
00002F36 D79C                       		add.l	d3,(a4)+			; Set the new section offset
00002F38 38DB                       		move.w	(a3)+,(a4)+			; Save the section size for later
00002F3A 51C8 FFE6                  		dbf	d0,.ScrollSects			; If there are still sections to check, loop
00002F3E                            
00002F3E                            		pop.w	d0/a4				; Restore registers
00002F3E 4C9F 1001                M 	movem.w	(sp)+,d0/a4
00002F42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002F42                            		; Set the scroll offsets on screen
00002F42 3A3C 00E0                  		move.w	#224,d5				; Scanline counter
00002F46 3C29 0008                  		move.w	cYPos(a1),d6			; Get the background's Y position
00002F4A                            		
00002F4A                            .FindStart:
00002F4A 221C                       		move.l	(a4)+,d1			; Get section offset
00002F4C 9C5C                       		sub.w	(a4)+,d6			; Subtract the size of the section
00002F4E 6B00                       		bmi.s	.FoundStart			; If the current section is on screen, branch
00002F50 51C8 FFF8                  		dbf	d0,.FindStart			; If not, continue the search
00002F54 3212                       		move.w	cXPos(a2),d1			; Get the foreground's X position
00002F56 4441                       		neg.w	d1				; Make it scroll the right direction
00002F58 4841                       		swap	d1				; Fix which planes the scroll values go to
00002F5A 4441                       		neg.w	d1				; Make the background scroll the right direction
00002F5C 6000                       		bra.s	.LastSection			; If there are no more sections to go through, branch
00002F5E                            
00002F5E                            .FoundStart:
00002F5E 4446                       		neg.w	d6				; Get remaining size of the section
00002F60 3212                       		move.w	cXPos(a2),d1			; Get the foreground's X position
00002F62 4441                       		neg.w	d1				; Make it scroll the right direction
00002F64 4841                       		swap	d1				; Fix which planes the scroll values go to
00002F66 4441                       		neg.w	d1				; Make the background scroll the right direction
00002F68 6000                       		bra.s	.CheckScroll			; Go set some scroll offsets
00002F6A                            
00002F6A                            .NextSection:
00002F6A 321C                       		move.w	(a4)+,d1			; Set scroll offset
00002F6C 4441                       		neg.w	d1				; Make the section scroll the correct way
00002F6E 2C1C                       		move.l	(a4)+,d6			; Get section size
00002F70                            		
00002F70                            .CheckScroll:
00002F70 9A46                       		sub.w	d6,d5				; Subtract that from the scanline count
00002F72 6B00                       		bmi.s	.EndSection			; If there is still screen space to cover, loop
00002F74 5346                       		subq.w	#1,d6				; Convert for use with dbf
00002F76                            
00002F76                            .Scroll:
00002F76 2AC1                       		move.l	d1,(a5)+			; Scroll the section
00002F78 51CE FFFC                  		dbf	d6,.Scroll			; Repeat
00002F7C 51C8 FFEC                  		dbf	d0,.NextSection			; If there are any sections left, branch
00002F80 5245                       		addq.w	#1,d5				; Add 1 so that the foreground can still scroll properly
00002F82                            		
00002F82                            .EndSection:
00002F82 DA46                       		add.w	d6,d5				; Get remaining screen space
00002F84                            		
00002F84                            .LastSection:
00002F84 5345                       		subq.w	#1,d5				; Convert to use with dbf
00002F86 6B00                       		bmi.s	.End				; If there are none, exit
00002F88                            
00002F88                            .FillScroll:
00002F88 2AC1                       		move.l	d1,(a5)+			; Set previous scroll values
00002F8A 51CD FFFC                  		dbf	d5,.FillScroll			; Repeat
00002F8E                            
00002F8E                            .End:
00002F8E 4E75                       		rts
00002F90                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002F90                            ; Static background scrolling (no parallax)
00002F90                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002F90                            ; PARAMERERS:
00002F90                            ;	a1.l	- Background camera RAM
00002F90                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002F90                            ; RETURNS:
00002F90                            ;	Nothing
00002F90                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002F90                            ScrollStaticBG:
00002F90 45F8 E88A                  		lea	fgCamVars.w,a2		; Get foreground level drawing variables
00002F94 4BF8 90FE                  		lea	hScrollBuff.w,a5		; Horizontal scroll buffer
00002F98                            		
00002F98 2212                       		move.l	cXPos(a2),d1			; Get foreground X position
00002F9A 4481                       		neg.l	d1				; Negate it so it scrolls properly
00002F9C 3211                       		move.w	cXPos(a1),d1			; Get background X position
00002F9E 4441                       		neg.w	d1				; Negate it so it scrolls properly
00002FA0                            
00002FA0 303C 00DF                  		move.w	#224-1,d0			; Number of scanlines to scroll
00002FA4                            
00002FA4                            .Scroll:
00002FA4 2AC1                       		move.l	d1,(a5)+			; Set the scroll offsets
00002FA6 51C8 FFFC                  		dbf	d0,.Scroll			; Repeat
00002FAA 4E75                       		rts
00002FAC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002FAC                            ; Generate fake layer art
00002FAC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002FAC                            ; PARAMETERS:
00002FAC                            ;	a0.l	- Layer art data pointer
00002FAC                            ;	a1.l	- Layer tile ID mappings pointer
00002FAC                            ;	d0.w	- Layer offset
00002FAC                            ;	d1.l	- Buffer pointer
00002FAC                            ;	d2.w	- VRAM destination address
00002FAC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002FAC                            Level_UpdateLayer:
00002FAC                            		; Prepare for transfer
00002FAC 3619                       		move.w	(a1)+,d3			; Get number of tiles to copy
00002FAE 2441                       		movea.l	d1,a2				; Copy layer buffer pointer
00002FB0                            		
00002FB0                            		; Queue a DMA transfer for later
00002FB0                            		push.l	d0/d3/a1			; Save registers
00002FB0 48E7 9040                M 	movem.l	d0/d3/a1,-(sp)
00002FB4 5243                       		addq.w	#1,d3				; Get size of transfer
00002FB6 E94B                       		lsl.w	#4,d3				; ''
00002FB8 4EB8 0304                  		jsr	QueueDMATransfer.w		; Queue the transfer
00002FBC                            		pop.l	d0/d3/a1			; Restore registers
00002FBC 4CDF 0209                M 	movem.l	(sp)+,d0/d3/a1
00002FC0                            
00002FC0                            		; Copy the tiles for the layer
00002FC0 D040                       		add.w	d0,d0				; Double it
00002FC2 D2F1 0000                  		adda.w	(a1,d0.w),a1			; Get pointer to layer data for the offset
00002FC6                            		
00002FC6                            .CopyTiles:
00002FC6 3219                       		move.w	(a1)+,d1			; Get tile offset
00002FC8 47F0 1000                  		lea	(a0,d1.w),a3			; Get pointer to tile data
00002FCC 24DB                       		move.l	(a3)+,(a2)+			; Copy tile data
00002FCE 24DB                       		move.l	(a3)+,(a2)+			; ''
00002FD0 24DB                       		move.l	(a3)+,(a2)+			; ''
00002FD2 24DB                       		move.l	(a3)+,(a2)+			; ''
00002FD4 24DB                       		move.l	(a3)+,(a2)+			; ''
00002FD6 24DB                       		move.l	(a3)+,(a2)+			; ''
00002FD8 24DB                       		move.l	(a3)+,(a2)+			; ''
00002FDA 24DB                       		move.l	(a3)+,(a2)+			; ''
00002FDC 51CB FFE8                  		dbf	d3,.CopyTiles			; Loop
00002FE0                            
00002FE0                            .End
00002FE0 4E75                       		rts
00002FE2                            ; =========================================================================================================================================================
00002FE2                            		include	"Opmodes/Gameplay/Level Collision.asm"
00002FE2                            ; =========================================================================================================================================================
00002FE2                            ; Level collision functions
00002FE2                            ; =========================================================================================================================================================
00002FE2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002FE2                            ; Check if a player object has touched any level collision
00002FE2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002FE2                            PlayerChkCollision:
00002FE2 21F8 E8E2 E8EA             		move.l	primaryColPtr.w,currentColAddr.w	; Get primary collision address
00002FE8 0C28 000C 0000             		cmpi.b	#$C,_objTopSolid(a0)		; Are we on the primary path?
00002FEE 6700                       		beq.s	.NotPrimary			; If not, branch
00002FF0 21F8 E8E6 E8EA             		move.l	secondaryColPtr.w,currentColAddr.w	; Get secondary collision address
00002FF6                            
00002FF6                            .NotPrimary:
00002FF6 1A28 0000                  		move.b	_objLRBSolid(a0),d5		; Get LRB solid bits
00002FFA                            		
00002FFA 3228 001C                  		move.w	_objXVel(a0),d1			; Get X velocity
00002FFE 3428 001E                  		move.w	_objYVel(a0),d2			; Get Y velocity
00003002 4EB8 1786                  		jsr	CalcArcTan.w			; Get the angle
00003006 0400 0020                  		subi.b	#$20,d0				; Shift it over
0000300A 0200 00C0                  		andi.b	#$C0,d0				; Get the quadrant
0000300E 0C00 0040                  		cmpi.b	#$40,d0				; Are we hitting a left wall?
00003012 6700 0000                  		beq.w	PlayerHitLWall			; If so, branch
00003016 0C00 0080                  		cmpi.b	#$80,d0				; Are we hitting a ceiling?
0000301A 6700 0000                  		beq.w	PlayerHitCeilAndWalls		; If so, branch
0000301E 0C00 00C0                  		cmpi.b	#$C0,d0				; Are we hitting a right wall?
00003022 6700 0000                  		beq.w	PlayerHitRWall			; If so, branch
00003026                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003026                            PlayerHitFloorAndWalls:
00003026 6100 0000                  		bsr.w	PlayerChkLeftWallDist		; Get left wall distance
0000302A 4A41                       		tst.w	d1				; Have we hit the wall?
0000302C 6A00                       		bpl.s	.NoLeftHit			; If not, branch
0000302E 9368 0014                  		sub.w	d1,_objXPos(a0)			; Move out of the wall
00003032 4268 001C                  		clr.w	_objXVel(a0)			; Stop moving
00003036                            
00003036                            .NoLeftHit:
00003036 6100 0000                  		bsr.w	PlayerChkRightWallDist		; Get right wall distance
0000303A 4A41                       		tst.w	d1				; Have we hit the wall?
0000303C 6A00                       		bpl.s	.NoRightHit			; If not, branch
0000303E D368 0014                  		add.w	d1,_objXPos(a0)			; Move out of the wall
00003042 4268 001C                  		clr.w	_objXVel(a0)			; Stop moving
00003046                            
00003046                            .NoRightHit:
00003046 6100 0000                  		bsr.w	PlayerChkFloor			; Get floor distance
0000304A 4A41                       		tst.w	d1				; Have we hit the floor?
0000304C 6A00                       		bpl.s	.End				; If not, branch
0000304E                            
0000304E 1428 001E                  		move.b	_objYVel(a0),d2			; Get the integer part of the Y velocity
00003052 5002                       		addq.b	#8,d2				; Get the max distance we have to have from the floor in order to collide with it
00003054 4402                       		neg.b	d2				; Negate it since we are in the floor
00003056 B202                       		cmp.b	d2,d1				; Is the chosen primary distance small enough?
00003058 6C00                       		bge.s	.TouchFloor			; If so, branch
0000305A B002                       		cmp.b	d2,d0				; What about the other angle that was found?
0000305C 6D00                       		blt.s	.End				; If not, branch
0000305E                            
0000305E                            .TouchFloor:
0000305E 1143 0000                  		move.b	d3,_objAngle(a0)			; Set the angle
00003062 D368 0018                  		add.w	d1,_objYPos(a0)			; Move out of the floor
00003066 1003                       		move.b	d3,d0				; Copy angle
00003068 0600 0020                  		addi.b	#$20,d0				; Shift it
0000306C 0200 0040                  		andi.b	#$40,d0				; Are we on a wall?
00003070 6600                       		bne.s	.HitWall			; If so, branch
00003072 1003                       		move.b	d3,d0				; Copy angle
00003074 0600 0010                  		addi.b	#$10,d0				; Shift it
00003078 0200 0020                  		andi.b	#$20,d0				; Are we on a slope?
0000307C 6700                       		beq.s	.HitFloor			; If not, branch
0000307E E0E8 001E                  		asr	_objYVel(a0)			; Divide the Y velocity by 2
00003082 6000                       		bra.s	.HitSlope			; Continue
00003084                            
00003084                            .HitFloor:
00003084 4268 001E                  		clr.w	_objYVel(a0)			; Stop Y movement
00003088 3168 001C 0000             		move.w	_objXVel(a0),_objGVel(a0)		; Set ground velocity
0000308E 6000 0000                  		bra.w	PlayerResetOnFloor		; Reset status on floor
00003092                            
00003092                            .HitWall:
00003092 4268 001C                  		clr.w	_objXVel(a0)			; Stop X movement
00003096 0C68 0FC0 001E             		cmpi.w	#$FC0,_objYVel(a0)			; Cap the Y velocity at $FC0
0000309C 6F00                       		ble.s	.HitSlope			; ''
0000309E 317C 0FC0 001E             		move.w	#$FC0,_objYVel(a0)			; ''
000030A4                            
000030A4                            .HitSlope:
000030A4 6100 0000                  		bsr.w	PlayerResetOnFloor		; Reset status on floor
000030A8 3168 001E 0000             		move.w	_objYVel(a0),_objGVel(a0)		; Set ground velocity
000030AE 4A03                       		tst.b	d3				; Have we touched a right side angle ($80-$FF)?
000030B0 6A00                       		bpl.s	.End				; If so, branch
000030B2 4468 0000                  		neg.w	_objGVel(a0)			; Negate the ground velocity
000030B6                            
000030B6                            .End:
000030B6 4E75                       		rts
000030B8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000030B8                            PlayerHitLWall:
000030B8 6100 0000                  		bsr.w	PlayerChkLeftWallDist		; Get left wall distance
000030BC 4A41                       		tst.w	d1				; Have we hit the wall?
000030BE 6A00                       		bpl.s	.ChkCeil			; If not, branch
000030C0 9368 0014                  		sub.w	d1,_objXPos(a0)			; Move out of the wall
000030C4 4268 001C                  		clr.w	_objXVel(a0)			; Stop moving
000030C8 3168 001E 0000             		move.w	_objYVel(a0),_objGVel(a0)		; Set ground velocity
000030CE                            
000030CE                            .ChkCeil:
000030CE 6100 0000                  		bsr.w	PlayerChkCeiling		; Get ceiling distance
000030D2 4A41                       		tst.w	d1				; Have we hit the ceiling?
000030D4 6A00                       		bpl.s	.ChkFloor			; If not, branch
000030D6 4441                       		neg.w	d1				; Get the distance inside the ceiling
000030D8 0C41 0014                  		cmpi.w	#$14,d1				; Are we too far into the ceiling?
000030DC 6400                       		bhs.s	.ChkRightWall			; If so, branch
000030DE D368 0018                  		add.w	d1,_objYPos(a0)			; Move out of the ceiling
000030E2 4A68 001E                  		tst.w	_objYVel(a0)			; Are we moving up?
000030E6 6A00                       		bpl.s	.End				; If not, branch
000030E8 4268 001E                  		clr.w	_objYVel(a0)			; Stop Y movement
000030EC                            
000030EC                            .End:
000030EC 4E75                       		rts
000030EE                            
000030EE                            .ChkRightWall:
000030EE 6100 0000                  		bsr.w	PlayerChkRightWallDist		; Get right wall distance
000030F2 4A41                       		tst.w	d1				; Have we hit the wall?
000030F4 6A00                       		bpl.s	.End2				; If not, branch
000030F6 D368 0014                  		add.w	d1,_objXPos(a0)			; Move out of the wall
000030FA 4268 001C                  		clr.w	_objXVel(a0)			; Stop moving
000030FE                            		
000030FE                            .End2:
000030FE 4E75                       		rts
00003100                            
00003100                            .ChkFloor:
00003100 4A68 001E                  		tst.w	_objYVel(a0)			; Are we moving up?
00003104 6B00                       		bmi.s	.End3				; If so, branch
00003106 6100 0000                  		bsr.w	PlayerChkFloor			; Get floor distance
0000310A 4A41                       		tst.w	d1				; Have we hit the ceiling?
0000310C 6A00                       		bpl.s	.End3				; If not, branch
0000310E D368 0018                  		add.w	d1,_objYPos(a0)			; Move out of the ceiling
00003112 1143 0000                  		move.b	d3,_objAngle(a0)			; Set angle
00003116 4268 001E                  		clr.w	_objYVel(a0)			; Stop Y movement
0000311A 3168 001C 0000             		move.w	_objXVel(a0),_objGVel(a0)		; Set ground velocity
00003120 6000 0000                  		bra.w	PlayerResetOnFloor		; Reset status on floor
00003124                            		
00003124                            .End3:
00003124 4E75                       		rts
00003126                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003126                            PlayerHitCeilAndWalls:
00003126 6100 0000                  		bsr.w	PlayerChkLeftWallDist		; Get left wall distance
0000312A 4A41                       		tst.w	d1				; Have we hit the wall?
0000312C 6A00                       		bpl.s	.NoLeftHit			; If not, branch
0000312E 9368 0014                  		sub.w	d1,_objXPos(a0)			; Move out of the wall
00003132 4268 001C                  		clr.w	_objXVel(a0)			; Stop moving
00003136                            
00003136                            .NoLeftHit:
00003136 6100 0000                  		bsr.w	PlayerChkRightWallDist		; Get right wall distance
0000313A 4A41                       		tst.w	d1				; Have we hit the wall?
0000313C 6A00                       		bpl.s	.NoRightHit			; If not, branch
0000313E D368 0014                  		add.w	d1,_objXPos(a0)			; Move out of the wall
00003142 4268 001C                  		clr.w	_objXVel(a0)			; Stop moving
00003146                            
00003146                            .NoRightHit:
00003146 6100 0000                  		bsr.w	PlayerChkCeiling		; Get ceiling distance
0000314A 4A41                       		tst.w	d1				; Have we hit the floor?
0000314C 6A00                       		bpl.s	.End				; If not, branch
0000314E 9368 0018                  		sub.w	d1,_objYPos(a0)			; Move out of ceiling
00003152 1003                       		move.b	d3,d0				; Get angle
00003154 0600 0020                  		addi.b	#$20,d0				; Shift it
00003158 0200 0040                  		andi.b	#$40,d0				; Are we on a wall?
0000315C 6600                       		bne.s	.HitWall			; If so, branch
0000315E 4268 001E                  		clr.w	_objYVel(a0)			; Stop Y movement
00003162 4E75                       		rts
00003164                            
00003164                            .HitWall:
00003164 1143 0000                  		move.b	d3,_objAngle(a0)			; Set angle
00003168 6100 0000                  		bsr.w	PlayerResetOnFloor		; Reset status on floor
0000316C 3168 001E 0000             		move.w	_objYVel(a0),_objGVel(a0)		; Set ground velocity
00003172 4A03                       		tst.b	d3				; Have we touched a right side angle ($80-$FF)?
00003174 6A00                       		bpl.s	.End				; If so, branch
00003176 4468 0000                  		neg.w	_objGVel(a0)			; Negate the ground velocity
0000317A                            
0000317A                            .End:
0000317A 4E75                       		rts
0000317C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000317C                            PlayerHitRWall:
0000317C 6100 0000                  		bsr.w	PlayerChkRightWallDist		; Get right wall distance
00003180 4A41                       		tst.w	d1				; Have we hit the wall?
00003182 6A00                       		bpl.s	.ChkCeil			; If not, branch
00003184 D368 0014                  		add.w	d1,_objXPos(a0)			; Move out of the wall
00003188 4268 001C                  		clr.w	_objXVel(a0)			; Stop moving
0000318C 3168 001E 0000             		move.w	_objYVel(a0),_objGVel(a0)		; Set ground velocity
00003192                            
00003192                            .ChkCeil:
00003192 6100 0000                  		bsr.w	PlayerChkCeiling		; Get ceiling distance
00003196 4A41                       		tst.w	d1				; Have we hit the ceiling?
00003198 6A00                       		bpl.s	.ChkFloor			; If not, branch
0000319A 9368 0018                  		sub.w	d1,_objYPos(a0)			; Move out of the ceiling
0000319E 4A68 001E                  		tst.w	_objYVel(a0)			; Are we moving up?
000031A2 6A00                       		bpl.s	.End				; If not, branch
000031A4 4268 001E                  		clr.w	_objYVel(a0)			; Stop Y movement
000031A8                            
000031A8                            .End:
000031A8 4E75                       		rts
000031AA                            
000031AA                            .ChkFloor:
000031AA 4A68 001E                  		tst.w	_objYVel(a0)			; Are we moving up?
000031AE 6B00                       		bmi.s	.End2				; If so, branch
000031B0 6100 0000                  		bsr.w	PlayerChkFloor			; Get floor distance
000031B4 4A41                       		tst.w	d1				; Have we hit the ceiling?
000031B6 6A00                       		bpl.s	.End2				; If not, branch
000031B8 D368 0018                  		add.w	d1,_objYPos(a0)			; Move out of the ceiling
000031BC 1143 0000                  		move.b	d3,_objAngle(a0)			; Set angle
000031C0 4268 001E                  		clr.w	_objYVel(a0)			; Stop Y movement
000031C4 3168 001C 0000             		move.w	_objXVel(a0),_objGVel(a0)		; Set ground velocity
000031CA 6000                       		bra.s	PlayerResetOnFloor		; Reset status on floor
000031CC                            		
000031CC                            .End2:
000031CC 4E75                       		rts
000031CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000031CE                            ; Reset a player object's status on the floor
000031CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000031CE                            PlayerResetOnFloor:
000031CE                            		playSnd	#sSkid, 2			; Play skid sound
000031CE 11FC 0083 C4BD           M 	move.b	#sskid,(mqueue+((2)-1)).w
000031D4 4A28 0000                  		tst.b	_objBallMode(a0)			; Are we in ball mode?
000031D8 6600                       		bne.s	PlayerResetOnFloorPart3	; If so, branch
000031DA 4228 0020                  		clr.b	_objAnim(a0)			; Set walking animation
000031DE                            		
000031DE                            PlayerResetOnFloorPart2:
000031DE 0828 0002 0028             		btst	#2,_objStatus(a0)			; Was Sonic rolling?
000031E4 6700                       		beq.s	PlayerResetOnFloorPart3	; If so, branch
000031E6 08A8 0002 0028             		bclr	#2,_objStatus(a0)			; Clear roll flag
000031EC 1168 0000 002C             		move.b	_objInitColW(a0),_objColW(a0)		; Reset collision width
000031F2 1168 0000 002D             		move.b	_objInitColH(a0),_objColH(a0)		; Reset collision height
000031F8 4228 0020                  		clr.b	_objAnim(a0)			; Set walking animation
000031FC                            	;	subq.w	#5,_objYPos(a0)			; Align with floor
000031FC                            
000031FC                            PlayerResetOnFloorPart3:
000031FC 0228 00DD 0028             		andi.b	#$DD,_objStatus(a0)		; Clear "pushing", and "jumping" flag
00003202 4228 0000                  		clr.b	_objJumping(a0)			; Clear jumping flag
00003206 4228 0000                  		clr.b	_objFlipAngle(a0)			; Reset flip angle
0000320A 4228 0000                  		clr.b	_objFlipTurned(a0)			; Reset flip inverted flag
0000320E 4228 0000                  		clr.b	_objFlipRemain(a0)			; Reset flips remaining
00003212 4E75                       		rts
00003214                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003214                            ; Calculate the room in front of a player object
00003214                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003214                            PlayerCalcRoomInFront:
00003214 21F8 E8E2 E8EA             		move.l	primaryColPtr.w,currentColAddr.w	; Get primary collision address
0000321A 0C28 000C 0000             		cmpi.b	#$C,_objTopSolid(a0)		; Are we on the primary path?
00003220 6700                       		beq.s	.NotPrimary			; If not, branch
00003222 21F8 E8E6 E8EA             		move.l	secondaryColPtr.w,currentColAddr.w	; Get secondary collision address
00003228                            
00003228                            .NotPrimary:
00003228 1A28 0000                  		move.b	_objLRBSolid(a0),d5		; Get LRB solid bits
0000322C                            		
0000322C 2628 0014                  		move.l	_objXPos(a0),d3			; Get X position
00003230 2428 0018                  		move.l	_objYPos(a0),d2			; Get Y position
00003234 3228 001C                  		move.w	_objXVel(a0),d1			; Get X velocity
00003238 48C1                       		ext.l	d1				; ''
0000323A E181                       		asl.l	#8,d1				; Shift it
0000323C D681                       		add.l	d1,d3				; Add onto X position
0000323E 3228 001E                  		move.w	_objYVel(a0),d1			; Get Y velocity
00003242 48C1                       		ext.l	d1				; ''
00003244 E181                       		asl.l	#8,d1				; Shift it
00003246 D481                       		add.l	d1,d2				; Add onto Y position
00003248 4842                       		swap	d2				; Get actual Y
0000324A 4843                       		swap	d3				; Get actual X
0000324C 1140 002E                  		move.b	d0,_objNextTilt(a0)		; Set primary angle
00003250 1140 002F                  		move.b	d0,_objTilt(a0)			; Set secondary angle
00003254 1200                       		move.b	d0,d1				; Copy angle
00003256 0800 0006                  		btst	#6,d0				; Are we in quadrants 0 or $80? (use 5 instaead of 6 for 8 directions)
0000325A 6700                       		beq.s	.DownUp				; If not, branch
0000325C 5200                       		addq.b	#1,d0				; Shift the angle
0000325E                            
0000325E                            .DownUp:
0000325E 0600 001F                  		addi.b	#$1F,d0				; Shift the angle (use $F instaead of $1F for 8 directions)
00003262 0200 00C0                  		andi.b	#$C0,d0				; Get quadrant
00003266 6700 0000                  		beq.w	PlayerChkFloorDist_Part2	; If quadrant 0, get the floor distance
0000326A 0C00 0080                  		cmpi.b	#$80,d0				; Are we in quadrant $80?
0000326E 6700 0000                  		beq.w	PlayerChkCeilingDist_Part2	; If so, branch
00003272 0201 0038                  		andi.b	#$38,d1				; Are we on a flat enough surface?
00003276 6600                       		bne.s	.ChkWall			; If not, branch
00003278 5042                       		addq.w	#8,d2				; Add 8 to the Y position
0000327A                            
0000327A                            .ChkWall:
0000327A 0C00 0040                  		cmpi.b	#$40,d0				; Are we in quadrant $40?
0000327E 6700 0000                  		beq.w	PlayerChkLeftWallDist_Part2	; If so, branch
00003282 6000 0000                  		bra.w	PlayerChkRightWallDist_Part2	; Get the right wall distance
00003286                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003286                            ; Calculate the room over a player object
00003286                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003286                            PlayerCalcRoomOverHead:
00003286 21F8 E8E2 E8EA             		move.l	primaryColPtr.w,currentColAddr.w	; Get primary collision address
0000328C 0C28 000C 0000             		cmpi.b	#$C,_objTopSolid(a0)		; Are we on the primary path?
00003292 6700                       		beq.s	.NotPrimary			; If not, branch
00003294 21F8 E8E6 E8EA             		move.l	secondaryColPtr.w,currentColAddr.w	; Get secondary collision address
0000329A                            
0000329A                            .NotPrimary:
0000329A 1A28 0000                  		move.b	_objLRBSolid(a0),d5		; Get LRB solid bits
0000329E 1140 002E                  		move.b	d0,_objNextTilt(a0)		; Set primary angle
000032A2 1140 002F                  		move.b	d0,_objTilt(a0)			; Set secondary angle
000032A6                            		
000032A6 0600 0020                  		addi.b	#$20,d0				; Shift the angle
000032AA 0200 00C0                  		andi.b	#$C0,d0				; Get quadrant
000032AE 0C00 0040                  		cmpi.b	#$40,d0				; Are we in quadrant $40?
000032B2 6700 0000                  		beq.w	PlayerChkLeftCeilDist		; If so, branch
000032B6 0C00 0080                  		cmpi.b	#$80,d0				; Are we in quadrant $80?
000032BA 6700 0000                  		beq.w	PlayerChkCeiling		; If so, branch
000032BE 0C00 00C0                  		cmpi.b	#$C0,d0				; Are we in quadrant $C0?
000032C2 6700 0000                  		beq.w	PlayerChkRightCeilDist		; If so, branch
000032C6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000032C6                            ; Get the distance between the floor and a player object (with primary and secondary angles)
000032C6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000032C6                            PlayerChkFloor:
000032C6 21F8 E8E2 E8EA             		move.l	primaryColPtr.w,currentColAddr.w	; Get primary collision address
000032CC 0C28 000C 0000             		cmpi.b	#$C,_objTopSolid(a0)		; Are we on the primary path?
000032D2 6700                       		beq.s	.NotPrimary			; If not, branch
000032D4 21F8 E8E6 E8EA             		move.l	secondaryColPtr.w,currentColAddr.w	; Get secondary collision address
000032DA                            
000032DA                            .NotPrimary:
000032DA 1A28 0000                  		move.b	_objTopSolid(a0),d5		; Get top solid bits
000032DE                            		
000032DE                            		; Get the angle on the bottom right sensor
000032DE 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
000032E2 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
000032E6 7000                       		moveq	#0,d0
000032E8 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
000032EC 4880                       		ext.w	d0				; ''
000032EE D440                       		add.w	d0,d2				; Add onto Y position
000032F0 1028 002C                  		move.b	_objColW(a0),d0			; Get collision width
000032F4 4880                       		ext.w	d0				; ''
000032F6 D640                       		add.w	d0,d3				; Add onto X position
000032F8 49E8 002E                  		lea	_objNextTilt(a0),a4		; Get primary angle
000032FC 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00003300 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
00003302 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
00003306                            		push.w	d1				; Save the primary floor distance
00003306 3F01                     M 	move.w	d1,-(sp)
00003308                            
00003308                            		; Get the angle on the bottom left sensor
00003308 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
0000330C 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
00003310 7000                       		moveq	#0,d0
00003312 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
00003316 4880                       		ext.w	d0				; ''
00003318 D440                       		add.w	d0,d2				; Add onto Y position
0000331A 1028 002C                  		move.b	_objColW(a0),d0			; Get collision width
0000331E 4880                       		ext.w	d0				; ''
00003320 9640                       		sub.w	d0,d3				; Subtract from X position
00003322 49E8 002F                  		lea	_objTilt(a0),a4			; Get secondary angle
00003326 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
0000332A 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
0000332C 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
00003330                            		
00003330                            		; Update the object's angle
00003330                            		pop.w	d0				; Restore the primary floor distance
00003330 301F                     M 	move.w	(sp)+,d0
00003332 4202                       		clr.b	d2				; Angle value for when the object touched an odd angle (usually $FF)
00003334                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003334                            PlayerPickAngle:
00003334 1628 002F                  		move.b	_objTilt(a0),d3			; Get secondary angle
00003338 B240                       		cmp.w	d0,d1				; Is the primary floor distance lower than the secondary?
0000333A 6F00                       		ble.s	.ChkSetAngle			; If not, branch
0000333C 1628 002E                  		move.b	_objNextTilt(a0),d3		; Get primary angle
00003340 C141                       		exg.l	d0,d1				; Switch floor distance values
00003342                            		
00003342                            .ChkSetAngle:
00003342 0803 0000                  		btst	#0,d3				; Is this an odd angle (usually $FF)?
00003346 6700                       		beq.s	.End				; If not, branch
00003348 1602                       		move.b	d2,d3				; Set the new angle value
0000334A                            		
0000334A                            .End:
0000334A 4E75                       		rts
0000334C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000334C                            ; Get the distance between the floor and the player object
0000334C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000334C                            PlayerChkFloorDist:
0000334C 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
00003350 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
00003354                            
00003354                            PlayerChkFloorDist_Part2:
00003354 0642 000A                  		addi.w	#10,d2				; Check 10 pixels down
00003358 49E8 002E                  		lea	_objNextTilt(a0),a4		; Primary angle
0000335C 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00003360 4246                       		clr.w	d6				; No flip bits
00003362 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
00003366 4202                       		clr.b	d2				; Angle value for when the object touched an odd angle (usually $FF)
00003368                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003368                            PlayerGetPrimaryAngle:
00003368 1628 002E                  		move.b	_objNextTilt(a0),d3		; Get primary angle
0000336C 0803 0000                  		btst	#0,d3				; Is this an odd angle (usually $FF)?
00003370 6700                       		beq.s	.End				; If not, branch
00003372 1602                       		move.b	d2,d3				; Set the new angle value
00003374                            		
00003374                            .End:
00003374 4E75                       		rts
00003376                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003376                            sub_F846:
00003376 3628 0014                  		move.w	_objXPos(a0),d3
0000337A 3428 0018                  		move.w	_objYPos(a0),d2
0000337E 5942                       		subq.w	#4,d2
00003380 21F8 E8E2 E8EA             		move.l	primaryColPtr.w,currentColAddr.w	; Get primary collision address
00003386 0C28 000D 0000             		cmpi.b	#$D,_objLRBSolid(a0)		; Are we on the primary path?
0000338C 6700                       		beq.s	.NotPrimary			; If not, branch
0000338E 21F8 E8E6 E8EA             		move.l	secondaryColPtr.w,currentColAddr.w	; Get secondary collision address
00003394                            
00003394                            .NotPrimary:
00003394 49E8 002E                  		lea	_objNextTilt(a0),a4		; Primary angle
00003398 4214                       		clr.b	(a4)				; Clear it
0000339A 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
0000339E 4246                       		clr.w	d6				; No flip bits
000033A0 1A28 0000                  		move.b	_objLRBSolid(a0),d5		; Solidity bits
000033A4 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
000033A8 1628 002E                  		move.b	_objNextTilt(a0),d3		; Get primary angle
000033AC 0803 0000                  		btst	#0,d3				; Are we on an odd angle (usually $FF)?
000033B0 6700                       		beq.s	.End				; If not, branch
000033B2 4203                       		clr.b	d3				; Angle value for when the object touched an odd angle (usually $FF)
000033B4                            
000033B4                            .End:
000033B4 4E75                       		rts
000033B6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000033B6                            ; Check for the edge of a floor
000033B6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000033B6                            PlayerChkFloorEdge:
000033B6 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
000033BA                            
000033BA                            PlayerChkFloorEdge_Part2:
000033BA 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
000033BE 7000                       		moveq	#0,d0
000033C0 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
000033C4 4880                       		ext.w	d0				; ''
000033C6 D440                       		add.w	d0,d2				; Add onto Y position
000033C8                            
000033C8                            PlayerChkFloorEdge_Part3:
000033C8 21F8 E8E2 E8EA             		move.l	primaryColPtr.w,currentColAddr.w	; Get primary collision address
000033CE 0C28 000C 0000             		cmpi.b	#$C,_objTopSolid(a0)		; Are we on the primary path?
000033D4 6700                       		beq.s	.NotPrimary			; If not, branch
000033D6 21F8 E8E6 E8EA             		move.l	secondaryColPtr.w,currentColAddr.w	; Get secondary collision address
000033DC                            
000033DC                            .NotPrimary:
000033DC 49E8 002E                  		lea	_objNextTilt(a0),a4		; Primary angle
000033E0 4214                       		clr.b	(a4)				; Clear it
000033E2 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
000033E6 4246                       		clr.w	d6				; No flip bits
000033E8 1A28 0000                  		move.b	_objTopSolid(a0),d5		; Solidity bits
000033EC 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
000033F0 1628 002E                  		move.b	_objNextTilt(a0),d3		; Get primary angle
000033F4 0803 0000                  		btst	#0,d3				; Are we on an odd angle (usually $FF)?
000033F8 6700                       		beq.s	.End				; If not, branch
000033FA 4203                       		clr.b	d3				; Angle value for when the object touched an odd angle (usually $FF)
000033FC                            
000033FC                            .End:
000033FC 4E75                       		rts
000033FE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000033FE                            ; Get the distance between the floor and an object
000033FE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000033FE                            ObjCheckFloorDist:
000033FE 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
00003402                            		
00003402                            ObjCheckFloorDist_Part2:
00003402 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
00003406                            
00003406                            ObjCheckFloorDist_Part3:
00003406 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
0000340A 4880                       		ext.w	d0				; ''
0000340C D440                       		add.w	d0,d2				; Add onto Y position
0000340E 49E8 002E                  		lea	_objNextTilt(a0),a4		; Primary angle
00003412 4214                       		clr.b	(a4)				; Clear it
00003414 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00003418 4246                       		clr.w	d6				; No flip bits
0000341A 7A0C                       		moveq	#$C,d5				; Solidity bits
0000341C 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
00003420 1628 002E                  		move.b	_objNextTilt(a0),d3		; Get primary angle
00003424 0803 0000                  		btst	#0,d3				; Are we on an odd angle (usually $FF)?
00003428 6700                       		beq.s	.End				; If not, branch
0000342A 4203                       		clr.b	d3				; Angle value for when the object touched an odd angle (usually $FF)
0000342C                            
0000342C                            .End:
0000342C 4E75                       		rts
0000342E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000342E                            ; Get the distance between a right ceiling and a player object
0000342E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000342E                            PlayerChkRightCeilDist:
0000342E                            		; Get the angle on the bottom right (rotated) sensor
0000342E 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
00003432 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
00003436 7000                       		moveq	#0,d0
00003438 1028 002C                  		move.b	_objColW(a0),d0			; Get collision height
0000343C 4880                       		ext.w	d0				; ''
0000343E 9440                       		sub.w	d0,d2				; Subtract from Y position
00003440 1028 002D                  		move.b	_objColH(a0),d0			; Get collision width
00003444 4880                       		ext.w	d0				; ''
00003446 D640                       		add.w	d0,d3				; Add onto X position
00003448 49E8 002E                  		lea	_objNextTilt(a0),a4		; Get primary angle
0000344C 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00003450 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
00003452 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
00003456                            		push.w	d1				; Save the primary floor distance
00003456 3F01                     M 	move.w	d1,-(sp)
00003458                            
00003458                            		; Get the angle on the bottom left (rotated) sensor
00003458 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
0000345C 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
00003460 7000                       		moveq	#0,d0
00003462 1028 002C                  		move.b	_objColW(a0),d0			; Get collision height
00003466 4880                       		ext.w	d0				; ''
00003468 D440                       		add.w	d0,d2				; Add onto Y position
0000346A 1028 002D                  		move.b	_objColH(a0),d0			; Get collision width
0000346E 4880                       		ext.w	d0				; ''
00003470 D640                       		add.w	d0,d3				; Add onto X position
00003472 49E8 002F                  		lea	_objTilt(a0),a4			; Get secondary angle
00003476 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
0000347A 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
0000347C 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
00003480                            
00003480                            		; Update the object's angle
00003480                            		pop.w	d0				; Restore the primary floor distance
00003480 301F                     M 	move.w	(sp)+,d0
00003482 143C 00C0                  		move.b	#-$40,d2			; Angle value for when the object touched an odd angle (usually $FF)
00003486 6000 FEAC                  		bra.w	PlayerPickAngle		; Get the angle
0000348A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000348A                            ; Get the distance between a right wall and a player object
0000348A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000348A                            PlayerChkRightWallDist:
0000348A 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
0000348E 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
00003492                            
00003492                            PlayerChkRightWallDist_Part2:
00003492 0643 000A                  		addi.w	#10,d3				; Check 10 pixels to the right
00003496 49E8 002E                  		lea	_objNextTilt(a0),a4		; Primary angle
0000349A 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
0000349E 4246                       		clr.w	d6				; No flip bits
000034A0 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
000034A4 143C 00C0                  		move.b	#-$40,d2			; Angle value for when the object touched an odd angle (usually $FF)
000034A8 6000 FEBE                  		bra.w	PlayerGetPrimaryAngle		; Get angle
000034AC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000034AC                            ; Get the distance between a right wall and an object
000034AC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000034AC                            ObjCheckRightWallDist:
000034AC D668 0014                  		add.w	_objXPos(a0),d3			; Add X position
000034B0 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
000034B4 49E8 002E                  		lea	_objNextTilt(a0),a4		; Primary angle
000034B8 4214                       		clr.b	(a4)				; Clear it
000034BA 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
000034BE 4246                       		clr.w	d6				; No flip bits
000034C0 7A0D                       		moveq	#$D,d5				; Solidity bits
000034C2 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
000034C6 1628 002E                  		move.b	_objNextTilt(a0),d3		; Get primary angle
000034CA 0803 0000                  		btst	#0,d3				; Are we on an odd angle (usually $FF)?
000034CE 6700                       		beq.s	.End				; If not, branch
000034D0 163C 00C0                  		move.b	#-$40,d3			; Angle value for when the object touched an odd angle (usually $FF)
000034D4                            
000034D4                            .End:
000034D4 4E75                       		rts
000034D6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000034D6                            ; Get the distance between a ceiling and a player object (with primary and secondary angles)
000034D6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000034D6                            PlayerChkCeiling:
000034D6                            		; Get the angle on the bottom right sensor
000034D6 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
000034DA 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
000034DE 7000                       		moveq	#0,d0
000034E0 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
000034E4 4880                       		ext.w	d0				; ''
000034E6 9440                       		sub.w	d0,d2				; Subtract from Y position
000034E8 0A42 000F                  		eori.w	#$F,d2				; Flip it
000034EC 1028 002C                  		move.b	_objColW(a0),d0			; Get collision width
000034F0 4880                       		ext.w	d0				; ''
000034F2 D640                       		add.w	d0,d3				; Add onto X position
000034F4 49E8 002E                  		lea	_objNextTilt(a0),a4		; Get primary angle
000034F8 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
000034FC 3C3C 0800                  		move.w	#$800,d6			; Vertical flip
00003500 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
00003504                            		push.w	d1				; Save the primary floor distance
00003504 3F01                     M 	move.w	d1,-(sp)
00003506                            
00003506                            		; Get the angle on the bottom left sensor
00003506 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
0000350A 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
0000350E 7000                       		moveq	#0,d0
00003510 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
00003514 4880                       		ext.w	d0				; ''
00003516 9440                       		sub.w	d0,d2				; Subtract from Y position
00003518 0A42 000F                  		eori.w	#$F,d2				; Flip it
0000351C 1028 002C                  		move.b	_objColW(a0),d0			; Get collision width
00003520 4880                       		ext.w	d0				; ''
00003522 9640                       		sub.w	d0,d3				; Subtract from X position
00003524 49E8 002F                  		lea	_objTilt(a0),a4			; Get secondary angle
00003528 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
0000352C 3C3C 0800                  		move.w	#$800,d6			; Vertical flip
00003530 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
00003534                            		
00003534                            		; Update the object's angle
00003534                            		pop.w	d0				; Restore the primary floor distance
00003534 301F                     M 	move.w	(sp)+,d0
00003536 143C 0080                  		move.b	#$80,d2				; Angle value for when the object touched an odd angle (usually $FF)
0000353A 6000 FDF8                  		bra.w	PlayerPickAngle		; Get the angle
0000353E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000353E                            ; Get the distance between a ceiling and a player object
0000353E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000353E                            PlayerChkCeilingDist:
0000353E 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
00003542 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
00003546                            
00003546                            PlayerChkCeilingDist_Part2:
00003546 0442 000A                  		subi.w	#10,d2				; Check 10 pixels up
0000354A 0A42 000F                  		eori.w	#$F,d2				; Flip it
0000354E 49E8 002E                  		lea	_objNextTilt(a0),a4		; Primary angle
00003552 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
00003556 3C3C 0800                  		move.w	#$800,d6			; Vertical flip
0000355A 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
0000355E 143C 0080                  		move.b	#$80,d2				; Angle value for when the object touched an odd angle (usually $FF)
00003562 6000 FE04                  		bra.w	PlayerGetPrimaryAngle		; Get angle
00003566                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003566                            ; Get the distance between a ceiling and an object
00003566                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003566                            ObjCheckCeilingDist:
00003566 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
0000356A 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
0000356E 7000                       		moveq	#0,d0
00003570 1028 002D                  		move.b	_objColH(a0),d0		; Get collision height
00003574 4880                       		ext.w	d0				; ''
00003576 9440                       		sub.w	d0,d2				; Subtract it from Y position
00003578 0A42 000F                  		eori.w	#$F,d2				; Flip it
0000357C 49E8 002E                  		lea	_objNextTilt(a0),a4		; Primary angle
00003580 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
00003584 3C3C 0800                  		move.w	#$800,d6			; Vertical flip
00003588 7A0D                       		moveq	#$D,d5				; Solidity bits
0000358A 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
0000358E 1628 002E                  		move.b	_objNextTilt(a0),d3		; Get primary angle
00003592 0803 0000                  		btst	#0,d3				; Are we on an odd angle (usually $FF)?
00003596 6700                       		beq.s	.End				; If not, branch
00003598 163C 0080                  		move.b	#$80,d3				; Angle value for when the object touched an odd angle (usually $FF)
0000359C                            
0000359C                            .End:
0000359C 4E75                       		rts
0000359E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000359E                            ; Get the distance between a left ceiling and a player object
0000359E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000359E                            PlayerChkLeftCeilDist:
0000359E                            		; Get the angle on the bottom right (rotated) sensor
0000359E 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
000035A2 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
000035A6 7000                       		moveq	#0,d0
000035A8 1028 002C                  		move.b	_objColW(a0),d0			; Get collision width
000035AC 4880                       		ext.w	d0				; ''
000035AE 9440                       		sub.w	d0,d2				; Subtract from Y position
000035B0 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
000035B4 4880                       		ext.w	d0				; ''
000035B6 9640                       		sub.w	d0,d3				; Subtract from X position
000035B8 0A43 000F                  		eori.w	#$F,d3				; Flip it
000035BC 49E8 002E                  		lea	_objNextTilt(a0),a4		; Get primary angle
000035C0 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
000035C4 3C3C 0400                  		move.w	#$400,d6			; Horizontal flip
000035C8 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
000035CC                            		push.w	d1				; Save the primary floor distance
000035CC 3F01                     M 	move.w	d1,-(sp)
000035CE                            
000035CE                            		; Get the angle on the bottom left (rotated) sensor
000035CE 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
000035D2 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
000035D6 7000                       		moveq	#0,d0
000035D8 1028 002C                  		move.b	_objColW(a0),d0			; Get collision width
000035DC 4880                       		ext.w	d0				; ''
000035DE D440                       		add.w	d0,d2				; Add onto Y position
000035E0 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
000035E4 4880                       		ext.w	d0				; ''
000035E6 9640                       		sub.w	d0,d3				; Subtract from X position
000035E8 0A43 000F                  		eori.w	#$F,d3				; Flip it
000035EC 49E8 002F                  		lea	_objTilt(a0),a4			; Get secondary angle
000035F0 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
000035F4 3C3C 0400                  		move.w	#$400,d6			; Horizontal flip
000035F8 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
000035FC                            
000035FC                            		; Update the object's angle
000035FC                            		pop.w	d0				; Restore the primary floor distance
000035FC 301F                     M 	move.w	(sp)+,d0
000035FE 143C 0040                  		move.b	#$40,d2				; Angle value for when the object touched an odd angle (usually $FF)
00003602 6000 FD30                  		bra.w	PlayerPickAngle		; Get the angle
00003606                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003606                            ; Get the distance between a left wall and a player object
00003606                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003606                            PlayerChkLeftWallDist:
00003606 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
0000360A 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
0000360E                            
0000360E                            PlayerChkLeftWallDist_Part2:
0000360E 0443 000A                  		subi.w	#10,d3				; Check 10 pixels to the left
00003612 0A43 000F                  		eori.w	#$F,d3				; Flip it
00003616 49E8 002E                  		lea	_objNextTilt(a0),a4		; Primary angle
0000361A 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
0000361E 3C3C 0400                  		move.w	#$400,d6			; Horizontal flip
00003622 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
00003626 143C 0040                  		move.b	#$40,d2				; Angle value for when the object touched an odd angle (usually $FF)
0000362A 6000 FD3C                  		bra.w	PlayerGetPrimaryAngle		; Get angle
0000362E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000362E                            ; Get the distance between a left wall and an object
0000362E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000362E                            ObjCheckLeftWallDist:
0000362E D668 0014                  		add.w	_objXPos(a0),d3			; Add X position
00003632 0A43 000F                  		eori.w	#$F,d3				; Flip it
00003636 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
0000363A 49E8 002E                  		lea	_objNextTilt(a0),a4		; Primary angle
0000363E 4214                       		clr.b	(a4)				; Clear it
00003640 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
00003644 3C3C 0400                  		move.w	#$400,d6			; Horizontal flip
00003648 7A0D                       		moveq	#$D,d5				; Solidity bits
0000364A 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
0000364E 1628 002E                  		move.b	_objNextTilt(a0),d3		; Get primary angle
00003652 0803 0000                  		btst	#0,d3				; Are we on an odd angle (usually $FF)?
00003656 6700                       		beq.s	.End				; If not, branch
00003658 163C 0040                  		move.b	#$40,d3				; Angle value for when the object touched an odd angle (usually $FF)
0000365C                            
0000365C                            .End:
0000365C 4E75                       		rts
0000365E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000365E                            ; Move a player object along on the ground
0000365E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000365E                            PlayerAnglePos:
0000365E 21F8 E8E2 E8EA             		move.l	primaryColPtr.w,currentColAddr.w	; Get primary collision address
00003664 0C28 000C 0000             		cmpi.b	#$C,_objTopSolid(a0)		; Are we on the primary path?
0000366A 6700                       		beq.s	.NotPrimary			; If not, branch
0000366C 21F8 E8E6 E8EA             		move.l	secondaryColPtr.w,currentColAddr.w	; Get secondary collision address
00003672                            
00003672                            .NotPrimary:
00003672 1A28 0000                  		move.b	_objTopSolid(a0),d5		; Get top solid bits
00003676 0828 0003 0028             		btst	#3,_objStatus(a0)			; Are we standing on a player object?
0000367C 6700                       		beq.s	.NotOnObj			; If not, branch
0000367E 4268 002E                  		clr.w	_objNextTilt(a0)			; Set the angles to 0
00003682 4E75                       		rts
00003684                            
00003684                            .NotOnObj:
00003684 317C 0303 002E             		move.w	#$0303,_objNextTilt(a0)		; Set the angles to 3
0000368A                            		
0000368A                            		; Get which quadrant the object is in on the ground
0000368A                            		; This makes it so that angles:
0000368A                            		; 	$E0-$20 = Quadrant 0 (floor)
0000368A                            		;	$1F-$5F = Quadrant $40 (left wall)
0000368A                            		;	$60-$A0 = Quadrant $80 (ceiling)
0000368A                            		;	$A1-$DF = Quadrant $C0 (right wall)
0000368A 1028 0000                  		move.b	_objAngle(a0),d0			; Get the angle
0000368E 0800 0006                  		btst	#6,d0				; Are we in quadrants 0 or $80? (use 5 instaead of 6 for 8 directions)
00003692 6700                       		beq.s	.DownUp				; If not, branch
00003694 5200                       		addq.b	#1,d0				; Shift the angle
00003696                            
00003696                            .DownUp:
00003696 0600 001F                  		addi.b	#$1F,d0				; Shift the angle (use $F instaead of $1F for 8 directions)
0000369A 0200 00C0                  		andi.b	#$C0,d0				; Get which quadrant we are in (use $E0 instaead of $C0 for 8 directions)
0000369E 0C00 0040                  		cmpi.b	#$40,d0				; Are we in quadrant $40 (left wall)?
000036A2 6700 0000                  		beq.w	PlayerMoveLWall		; If so, branch
000036A6 0C00 0080                  		cmpi.b	#$80,d0				; Are we in quadrant $80 (ceiling)?
000036AA 6700 0000                  		beq.w	PlayerMoveCeiling		; Is so, branch
000036AE 0C00 00C0                  		cmpi.b	#$C0,d0				; Are we in quadrant $C0 (right wall)?
000036B2 6700 0000                  		beq.w	PlayerMoveRWall		; If so, branch
000036B6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000036B6                            ; Move the object along the floor
000036B6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000036B6                            PlayerMoveFloor:
000036B6                            		; Get the angle on the bottom right sensor
000036B6 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
000036BA 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
000036BE 7000                       		moveq	#0,d0
000036C0 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
000036C4 4880                       		ext.w	d0				; ''
000036C6 D440                       		add.w	d0,d2				; Add onto Y position
000036C8 1028 002C                  		move.b	_objColW(a0),d0			; Get collision width
000036CC 4880                       		ext.w	d0				; ''
000036CE D640                       		add.w	d0,d3				; Add onto X position
000036D0 49E8 002E                  		lea	_objNextTilt(a0),a4		; Get primary angle
000036D4 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
000036D8 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
000036DA 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
000036DE                            		push.w	d1				; Save the primary floor distance
000036DE 3F01                     M 	move.w	d1,-(sp)
000036E0                            
000036E0                            		; Get the angle on the bottom left sensor
000036E0 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
000036E4 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
000036E8 7000                       		moveq	#0,d0
000036EA 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
000036EE 4880                       		ext.w	d0				; ''
000036F0 D440                       		add.w	d0,d2				; Add onto Y position
000036F2 1028 002C                  		move.b	_objColW(a0),d0			; Get collision width
000036F6 4880                       		ext.w	d0				; ''
000036F8 9640                       		sub.w	d0,d3				; Add onto X position
000036FA 49E8 002F                  		lea	_objTilt(a0),a4			; Get secondary angle
000036FE 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00003702 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
00003704 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
00003708                            		
00003708                            		; Update the object's angle
00003708                            		pop.w	d0				; Restore the primary floor distance
00003708 301F                     M 	move.w	(sp)+,d0
0000370A 6100 0000                  		bsr.w	PlayerSetAngle			; Set the new angle
0000370E                            		
0000370E                            		; Check if the object has hit a wall or is about to fall
0000370E 4A41                       		tst.w	d1				; Is we already perfectly standing on the surface?
00003710 6700                       		beq.s	.End				; If so, branch
00003712 6A00                       		bpl.s	.ChkFall			; If the there's possibly a floor below us, branch
00003714 0C41 FFF2                  		cmpi.w	#-$E,d1				; Have we hit a wall?
00003718 6D00                       		blt.s	.End				; If so, branch
0000371A D368 0018                  		add.w	d1,_objYPos(a0)			; Move us on to the surface
0000371E                            
0000371E                            .End:
0000371E 4E75                       		rts
00003720                            
00003720                            .ChkFall:
00003720 1028 001C                  		move.b	_objXVel(a0),d0			; Get the integer part of the X velocity
00003724 6A00                       		bpl.s	.GetMinDist			; If it's already positive, branch
00003726 4400                       		neg.b	d0				; Force it to be positive
00003728                            
00003728                            .GetMinDist:
00003728 5800                       		addq.b	#4,d0				; The Y distance must be at least 4 pixels down
0000372A 0C00 000E                  		cmpi.b	#$E,d0				; ...but cannot be more than 14 pixels down
0000372E 6500                       		blo.s	.ChkDist			; ...for us to not fall off the surface
00003730 103C 000E                  		move.b	#$E,d0				; ''
00003734                            
00003734                            .ChkDist:
00003734 B200                       		cmp.b	d0,d1				; Are we about to fall off?
00003736 6E00                       		bgt.s	.SetAir				; If so, branch
00003738 D368 0018                  		add.w	d1,_objYPos(a0)			; Move us on to the surface
0000373C 4E75                       		rts
0000373E                            
0000373E                            .SetAir:
0000373E 08E8 0001 0028             		bset	#1,_objStatus(a0)			; Set "in air" flag
00003744 08A8 0005 0028             		bclr	#5,_objStatus(a0)			; Clear "pushing" flag
0000374A 117C 0001 0021             		move.b	#1,_objPrevAnim(a0)			; Reset the animation
00003750 4E75                       		rts
00003752                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003752                            ; Set the objects's angle
00003752                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003752                            PlayerSetAngle:
00003752 1428 002F                  		move.b	_objTilt(a0),d2			; Get secondary angle
00003756 B240                       		cmp.w	d0,d1				; Is the primary floor distance lower than the secondary?
00003758 6F00                       		ble.s	.ChkSetAngle			; If not, branch
0000375A 1428 002E                  		move.b	_objNextTilt(a0),d2		; Get primary angle
0000375E 3200                       		move.w	d0,d1				; Get primary floor distance
00003760                            		
00003760                            .ChkSetAngle:
00003760 0802 0000                  		btst	#0,d2				; Is this an odd angle (usually $FF)?
00003764 6600                       		bne.s	.LatchOnFlat			; If so, branch
00003766 1002                       		move.b	d2,d0				; Get angle change
00003768 9028 0000                  		sub.b	_objAngle(a0),d0			; ''
0000376C 6A00                       		bpl.s	.ChkDist			; ''
0000376E 4400                       		neg.b	d0				; ''
00003770                            
00003770                            .ChkDist:
00003770 0C00 0020                  		cmpi.b	#$20,d0				; Has the player moved $20 degrees or more?
00003774 6400                       		bhs.s	.LatchOnFlat			; If so, branch
00003776 1142 0000                  		move.b	d2,_objAngle(a0)			; Set the new angle value
0000377A 4E75                       		rts
0000377C                            
0000377C                            .LatchOnFlat:
0000377C 1428 0000                  		move.b	_objAngle(a0),d2			; Get old angle value
00003780 0602 0020                  		addi.b	#$20,d2				; Shift the angle
00003784 0202 00C0                  		andi.b	#$C0,d2				; Flatten the angle
00003788 1142 0000                  		move.b	d2,_objAngle(a0)			; Set the new angle value
0000378C 4E75                       		rts
0000378E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000378E                            ; Move the object along the right wall
0000378E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000378E                            PlayerMoveRWall:
0000378E                            		; Get the angle on the bottom right (rotated) sensor
0000378E 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
00003792 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
00003796 7000                       		moveq	#0,d0
00003798 1028 002C                  		move.b	_objColW(a0),d0			; Get collision width
0000379C 4880                       		ext.w	d0				; ''
0000379E 9440                       		sub.w	d0,d2				; Add onto Y position
000037A0 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
000037A4 4880                       		ext.w	d0				; ''
000037A6 D640                       		add.w	d0,d3				; Add onto X position
000037A8 49E8 002E                  		lea	_objNextTilt(a0),a4		; Get primary angle
000037AC 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
000037B0 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
000037B2 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
000037B6                            		push.w	d1				; Save the primary floor distance
000037B6 3F01                     M 	move.w	d1,-(sp)
000037B8                            
000037B8                            		; Get the angle on the bottom left (rotated) sensor
000037B8 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
000037BC 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
000037C0 7000                       		moveq	#0,d0
000037C2 1028 002C                  		move.b	_objColW(a0),d0			; Get collision width
000037C6 4880                       		ext.w	d0				; ''
000037C8 D440                       		add.w	d0,d2				; Add onto Y position
000037CA 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
000037CE 4880                       		ext.w	d0				; ''
000037D0 D640                       		add.w	d0,d3				; Add onto X position
000037D2 49E8 002F                  		lea	_objTilt(a0),a4			; Get secondary angle
000037D6 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
000037DA 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
000037DC 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
000037E0                            		
000037E0                            		; Update the object's angle
000037E0                            		pop.w	d0				; Restore the primary floor distance
000037E0 301F                     M 	move.w	(sp)+,d0
000037E2 6100 FF6E                  		bsr.w	PlayerSetAngle			; Set the new angle
000037E6                            
000037E6                            		; Check if the object has hit a wall or is about to fall
000037E6 4A41                       		tst.w	d1				; Is we already perfectly standing on the surface?
000037E8 6700                       		beq.s	.End				; If so, branch
000037EA 6A00                       		bpl.s	.ChkFall			; If the there's possibly a floor below us, branch
000037EC 0C41 FFF2                  		cmpi.w	#-$E,d1				; Have we hit a wall?
000037F0 6D00                       		blt.s	.End				; If so, branch
000037F2 D368 0014                  		add.w	d1,_objXPos(a0)			; Move us on to the surface
000037F6                            
000037F6                            .End:
000037F6 4E75                       		rts
000037F8                            
000037F8                            .ChkFall:
000037F8 1028 001E                  		move.b	_objYVel(a0),d0			; Get the integer part of the Y velocity
000037FC 6A00                       		bpl.s	.GetMinDist			; If it's already positive, branch
000037FE 4400                       		neg.b	d0				; Force it to be positive
00003800                            
00003800                            .GetMinDist:
00003800 5800                       		addq.b	#4,d0				; The X distance must be at least 4 pixels down
00003802 0C00 000E                  		cmpi.b	#$E,d0				; ...but cannot be more than 14 pixels down
00003806 6500                       		blo.s	.ChkDist			; ...for us to not fall off the surface
00003808 103C 000E                  		move.b	#$E,d0				; ''
0000380C                            
0000380C                            .ChkDist:
0000380C B200                       		cmp.b	d0,d1				; Are we about to fall off?
0000380E 6E00                       		bgt.s	.SetAir				; If so, branch
00003810 D368 0014                  		add.w	d1,_objXPos(a0)			; Move us on to the surface
00003814 4E75                       		rts
00003816                            
00003816                            .SetAir:
00003816 08E8 0001 0028             		bset	#1,_objStatus(a0)			; Set "in air" flag
0000381C 08A8 0005 0028             		bclr	#5,_objStatus(a0)			; Clear "pushing" flag
00003822 117C 0001 0021             		move.b	#1,_objPrevAnim(a0)			; Reset the animation
00003828 4E75                       		rts
0000382A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000382A                            ; Move the object along the ceiling
0000382A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000382A                            PlayerMoveCeiling:
0000382A                            		; Get the angle on the bottom right (rotated) sensor
0000382A 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
0000382E 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
00003832 7000                       		moveq	#0,d0
00003834 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
00003838 4880                       		ext.w	d0				; ''
0000383A 9440                       		sub.w	d0,d2				; Subtract from the Y position
0000383C 0A42 000F                  		eori.w	#$F,d2				; Flip it
00003840 1028 002C                  		move.b	_objColW(a0),d0			; Get collision width
00003844 4880                       		ext.w	d0				; ''
00003846 D640                       		add.w	d0,d3				; Add onto X position
00003848 49E8 002E                  		lea	_objNextTilt(a0),a4		; Get primary angle
0000384C 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
00003850 3C3C 0800                  		move.w	#$800,d6			; Vertical flip
00003854 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
00003858                            		push.w	d1				; Save the primary floor distance
00003858 3F01                     M 	move.w	d1,-(sp)
0000385A                            
0000385A                            		; Get the angle on the bottom left (rotated) sensor
0000385A 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
0000385E 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
00003862 7000                       		moveq	#0,d0
00003864 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
00003868 4880                       		ext.w	d0				; ''
0000386A 9440                       		sub.w	d0,d2				; Subtract from the Y position
0000386C 0A42 000F                  		eori.w	#$F,d2				; Flip it
00003870 1028 002C                  		move.b	_objColW(a0),d0			; Get collision width
00003874 4880                       		ext.w	d0				; ''
00003876 9640                       		sub.w	d0,d3				; Subtract from the X position
00003878 49E8 002F                  		lea	_objTilt(a0),a4			; Get secondary angle
0000387C 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
00003880 3C3C 0800                  		move.w	#$800,d6			; Vertical flip
00003884 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
00003888                            		
00003888                            		; Update the object's angle
00003888                            		pop.w	d0				; Restore the primary floor distance
00003888 301F                     M 	move.w	(sp)+,d0
0000388A 6100 FEC6                  		bsr.w	PlayerSetAngle			; Set the new angle
0000388E                            		
0000388E                            		; Check if the object has hit a wall or is about to fall
0000388E 4A41                       		tst.w	d1				; Is we already perfectly standing on the surface?
00003890 6700                       		beq.s	.End				; If so, branch
00003892 6A00                       		bpl.s	.ChkFall			; If the there's possibly a floor below us, branch
00003894 0C41 FFF2                  		cmpi.w	#-$E,d1				; Have we hit a wall?
00003898 6D00                       		blt.s	.End				; If so, branch
0000389A 9368 0018                  		sub.w	d1,_objYPos(a0)			; Move us on to the surface
0000389E                            
0000389E                            .End:
0000389E 4E75                       		rts
000038A0                            
000038A0                            .ChkFall:
000038A0 1028 001C                  		move.b	_objXVel(a0),d0			; Get the integer part of the X velocity
000038A4 6A00                       		bpl.s	.GetMinDist			; If it's already positive, branch
000038A6 4400                       		neg.b	d0				; Force it to be positive
000038A8                            
000038A8                            .GetMinDist:
000038A8 5800                       		addq.b	#4,d0				; The Y distance must be at least 4 pixels down
000038AA 0C00 000E                  		cmpi.b	#$E,d0				; ...but cannot be more than 14 pixels down
000038AE 6500                       		blo.s	.ChkDist			; ...for us to not fall off the surface
000038B0 103C 000E                  		move.b	#$E,d0				; ''
000038B4                            
000038B4                            .ChkDist:
000038B4 B200                       		cmp.b	d0,d1				; Are we about to fall off?
000038B6 6E00                       		bgt.s	.SetAir				; If so, branch
000038B8 9368 0018                  		sub.w	d1,_objYPos(a0)			; Move us on to the surface
000038BC 4E75                       		rts
000038BE                            
000038BE                            .SetAir:
000038BE 08E8 0001 0028             		bset	#1,_objStatus(a0)			; Set "in air" flag
000038C4 08A8 0005 0028             		bclr	#5,_objStatus(a0)			; Clear "pushing" flag
000038CA 117C 0001 0021             		move.b	#1,_objPrevAnim(a0)			; Reset the animation
000038D0 4E75                       		rts
000038D2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000038D2                            ; Move the object along the left wall
000038D2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000038D2                            PlayerMoveLWall:
000038D2                            		; Get the angle on the bottom right (rotated) sensor
000038D2 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
000038D6 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
000038DA 7000                       		moveq	#0,d0
000038DC 1028 002C                  		move.b	_objColW(a0),d0			; Get collision width
000038E0 4880                       		ext.w	d0				; ''
000038E2 9440                       		sub.w	d0,d2				; Subtract from the Y position
000038E4 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
000038E8 4880                       		ext.w	d0				; ''
000038EA 9640                       		sub.w	d0,d3				; Subtract from X position
000038EC 0A43 000F                  		eori.w	#$F,d3				; Flip it
000038F0 49E8 002E                  		lea	_objNextTilt(a0),a4		; Get primary angle
000038F4 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
000038F8 3C3C 0400                  		move.w	#$400,d6			; Horizontal flip
000038FC 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
00003900                            		push.w	d1				; Save the primary floor distance
00003900 3F01                     M 	move.w	d1,-(sp)
00003902                            
00003902                            		; Get the angle on the bottom left (rotated) sensor
00003902 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y position
00003906 3628 0014                  		move.w	_objXPos(a0),d3			; Get X position
0000390A 7000                       		moveq	#0,d0
0000390C 1028 002C                  		move.b	_objColW(a0),d0			; Get collision width
00003910 4880                       		ext.w	d0				; ''
00003912 D440                       		add.w	d0,d2				; Add onto Y position
00003914 1028 002D                  		move.b	_objColH(a0),d0			; Get collision height
00003918 4880                       		ext.w	d0				; ''
0000391A 9640                       		sub.w	d0,d3				; Subtract from X position
0000391C 0A43 000F                  		eori.w	#$F,d3				; Flip it
00003920 49E8 002F                  		lea	_objTilt(a0),a4			; Get secondary angle
00003924 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
00003928 3C3C 0400                  		move.w	#$400,d6			; Horizontal flip
0000392C 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
00003930                            		
00003930                            		; Update the object's angle
00003930                            		pop.w	d0				; Restore the primary floor distance
00003930 301F                     M 	move.w	(sp)+,d0
00003932 6100 FE1E                  		bsr.w	PlayerSetAngle			; Set the new angle
00003936                            		
00003936                            		; Check if the object has hit a wall or is about to fall
00003936 4A41                       		tst.w	d1				; Is we already perfectly standing on the surface?
00003938 6700                       		beq.s	.End				; If so, branch
0000393A 6A00                       		bpl.s	.ChkFall			; If the there's possibly a floor below us, branch
0000393C 0C41 FFF2                  		cmpi.w	#-$E,d1				; Have we hit a wall?
00003940 6D00                       		blt.s	.End				; If so, branch
00003942 9368 0014                  		sub.w	d1,_objXPos(a0)			; Move us on to the surface
00003946                            
00003946                            .End:
00003946 4E75                       		rts
00003948                            
00003948                            .ChkFall:
00003948 1028 001E                  		move.b	_objYVel(a0),d0			; Get the integer part of the Y velocity
0000394C 6A00                       		bpl.s	.GetMinDist			; If it's already positive, branch
0000394E 4400                       		neg.b	d0				; Force it to be positive
00003950                            
00003950                            .GetMinDist:
00003950 5800                       		addq.b	#4,d0				; The X distance must be at least 4 pixels down
00003952 0C00 000E                  		cmpi.b	#$E,d0				; ...but cannot be more than 14 pixels down
00003956 6500                       		blo.s	.ChkDist			; ...for us to not fall off the surface
00003958 103C 000E                  		move.b	#$E,d0				; ''
0000395C                            
0000395C                            .ChkDist:
0000395C B200                       		cmp.b	d0,d1				; Are we about to fall off?
0000395E 6E00                       		bgt.s	.SetAir				; If so, branch
00003960 9368 0014                  		sub.w	d1,_objXPos(a0)			; Move us on to the surface
00003964 4E75                       		rts
00003966                            
00003966                            .SetAir:
00003966 08E8 0001 0028             		bset	#1,_objStatus(a0)			; Set "in air" flag
0000396C 08A8 0005 0028             		bclr	#5,_objStatus(a0)			; Clear "pushing" flag
00003972 117C 0001 0021             		move.b	#1,_objPrevAnim(a0)			; Reset the animation
00003978 4E75                       		rts
0000397A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000397A                            ; Find the nearest floor from the object's position
0000397A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000397A                            ; PARAMETERS:
0000397A                            ;	d2.w	- Y position of the object's bottom sensor
0000397A                            ;	d3.w	- X position of the object's bottom sensor
0000397A                            ;	d5.w	- Bit to chect for solidity
0000397A                            ;	d6.w	- Flip bits (for walls and ceilings)
0000397A                            ;	a3.w	- Distance in pixels to check for blocks above or below the sensor
0000397A                            ;	a4.w	- Pointer to where the angle value will be stored
0000397A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000397A                            ; RETURNS:
0000397A                            ;	d1.w	- The distance from the object to the floor
0000397A                            ;	(a1).w	- The block ID in the chunk where the object is standing
0000397A                            ;	(a4).w	- The floor angle
0000397A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000397A                            Level_FindFloor:
0000397A 6100 0000                  		bsr.w	Level_FindBlock			; Find the nearest tile
0000397E 3011                       		move.w	(a1),d0				; Get block ID
00003980 3800                       		move.w	d0,d4				; Copy that
00003982 0240 03FF                  		andi.w	#$3FF,d0			; Get only the block ID
00003986 6700                       		beq.s	.IsBlank			; If it's blank, branch
00003988 0B04                       		btst	d5,d4				; Is the block solid?
0000398A 6600                       		bne.s	.IsSolid			; If so, branch
0000398C                            
0000398C                            .IsBlank:
0000398C D44B                       		add.w	a3,d2				; Check below the sensor
0000398E 6100 0000                  		bsr.w	Level_FindFloor2		; Try to find a solid block there
00003992 944B                       		sub.w	a3,d2				; Restore Y position of sensor
00003994 0641 0010                  		addi.w	#$10,d1				; Return distance to floor
00003998 4E75                       		rts
0000399A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000399A                            .IsSolid:
0000399A 2478 E8EA                  		movea.l	currentColAddr.w,a2			; Get collision data pointer
0000399E D040                       		add.w	d0,d0				; Turn ID into offset
000039A0 1032 0000                  		move.b	(a2,d0.w),d0			; Get collision block ID
000039A4 0240 00FF                  		andi.w	#$FF,d0				; ''
000039A8 67E2                       		beq.s	.IsBlank			; If the angle is 0, branch
000039AA                            
000039AA 2478 E8F0                  		movea.l	angleValPtr.w,a2		; Angle value array
000039AE 18B2 0000                  		move.b	(a2,d0.w),(a4)			; Get angle value and store it
000039B2 E948                       		lsl.w	#4,d0				; Turn collision block ID into offset
000039B4                            
000039B4 3203                       		move.w	d3,d1				; Get the object's X position
000039B6 0804 000A                  		btst	#$A,d4				; Is the block flipped horizontally?
000039BA 6700                       		beq.s	.NoXFlip			; If not, branch
000039BC 4641                       		not.w	d1				; Flip the X position
000039BE 4414                       		neg.b	(a4)				; Flip the angle
000039C0                            		
000039C0                            .NoXFlip:
000039C0 0804 000B                  		btst	#$B,d4				; Is the block vertically flipped?
000039C4 6700                       		beq.s	.NoYFlip			; If not, branch
000039C6 0614 0040                  		addi.b	#$40,(a4)			; Flip the angle
000039CA 4414                       		neg.b	(a4)				; ''
000039CC 0414 0040                  		subi.b	#$40,(a4)			; ''
000039D0                            
000039D0                            .NoYFlip:
000039D0 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the collsion block
000039D4 D240                       		add.w	d0,d1				; Add the collision block's offset
000039D6                            
000039D6 2478 E8F4                  		movea.l	normColArrayPtr.w,a2		; Get the normal collision array
000039DA 1032 1000                  		move.b	(a2,d1.w),d0			; Get height value
000039DE 4880                       		ext.w	d0				; ''
000039E0 BD44                       		eor.w	d6,d4				; Flip the flip bits from the block
000039E2 0804 000B                  		btst	#$B,d4				; Is the block vertically flipped?
000039E6 6700                       		beq.s	.NoYFlip2			; If not, branch
000039E8 4440                       		neg.w	d0				; Flip the height
000039EA                            
000039EA                            .NoYFlip2:
000039EA 4A40                       		tst.w	d0				; Check the height
000039EC 679E                       		beq.s	.IsBlank			; If the height is 0, branch
000039EE 6B00                       		bmi.s	.NegHeight			; If the height is negative, branch
000039F0 0C00 0010                  		cmpi.b	#$10,d0				; Is the height 16 (the max height)?
000039F4 6700                       		beq.s	.MaxFloor			; If so, branch
000039F6 3202                       		move.w	d2,d1				; Get the object's Y position
000039F8 0241 000F                  		andi.w	#$F,d1				; Get the Y offset in the height
000039FC D041                       		add.w	d1,d0				; Add onto the height
000039FE 323C 000F                  		move.w	#$F,d1				; Get actual distance
00003A02 9240                       		sub.w	d0,d1				; ''
00003A04 4E75                       		rts
00003A06                            
00003A06                            .NegHeight:
00003A06 3202                       		move.w	d2,d1				; Get the object's Y position
00003A08 0241 000F                  		andi.w	#$F,d1				; Get the Y offset in the height
00003A0C D041                       		add.w	d1,d0				; Add onto the height
00003A0E 6A00 FF7C                  		bpl.w	.IsBlank			; If the object is outside of the collision, branch
00003A12                            
00003A12                            .MaxFloor:
00003A12 944B                       		sub.w	a3,d2				; Check above the sensor
00003A14 6100                       		bsr.s	Level_FindFloor2		; Try to find a solid block there
00003A16 D44B                       		add.w	a3,d2				; Restore Y position of sensor
00003A18 0441 0010                  		subi.w	#$10,d1				; Return distance to floor
00003A1C 4E75                       		rts
00003A1E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003A1E                            Level_FindFloor2:
00003A1E 6100 0000                  		bsr.w	Level_FindBlock			; Find the nearest tile
00003A22 3011                       		move.w	(a1),d0				; Get block ID
00003A24 3800                       		move.w	d0,d4				; Copy that
00003A26 0240 03FF                  		andi.w	#$3FF,d0			; Get only the block ID
00003A2A 6700                       		beq.s	.IsBlank			; If it's blank, branch
00003A2C 0B04                       		btst	d5,d4				; Is the block solid?
00003A2E 6600                       		bne.s	.IsSolid			; If so, branch
00003A30                            
00003A30                            .IsBlank:
00003A30 323C 000F                  		move.w	#$F,d1				; Get max distance
00003A34 3002                       		move.w	d2,d0				; Get the object's Y position
00003A36 0240 000F                  		andi.w	#$F,d0				; Get the Y offset in the height
00003A3A 9240                       		sub.w	d0,d1				; Get actual distance
00003A3C 4E75                       		rts
00003A3E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003A3E                            .IsSolid:
00003A3E 2478 E8EA                  		movea.l	currentColAddr.w,a2			; Get collision data pointer
00003A42 D040                       		add.w	d0,d0				; Turn ID into offset
00003A44 1032 0000                  		move.b	(a2,d0.w),d0			; Get collision block ID
00003A48 0240 00FF                  		andi.w	#$FF,d0				; ''
00003A4C 67E2                       		beq.s	.IsBlank			; If the angle is 0, branch
00003A4E                            
00003A4E 2478 E8F0                  		movea.l	angleValPtr.w,a2		; Angle value array
00003A52 18B2 0000                  		move.b	(a2,d0.w),(a4)			; Get angle value and store it
00003A56 E948                       		lsl.w	#4,d0				; Turn collision block ID into offset
00003A58                            
00003A58 3203                       		move.w	d3,d1				; Get the object's X position
00003A5A 0804 000A                  		btst	#$A,d4				; Is the block flipped horizontally?
00003A5E 6700                       		beq.s	.NoXFlip			; If not, branch
00003A60 4641                       		not.w	d1				; Flip the X position
00003A62 4414                       		neg.b	(a4)				; Flip the angle
00003A64                            
00003A64                            .NoXFlip:
00003A64 0804 000B                  		btst	#$B,d4				; Is the block vertically flipped?
00003A68 6700                       		beq.s	.NoYFlip			; If not, branch
00003A6A 0614 0040                  		addi.b	#$40,(a4)			; Flip the angle
00003A6E 4414                       		neg.b	(a4)				; ''
00003A70 0414 0040                  		subi.b	#$40,(a4)			; ''
00003A74                            
00003A74                            .NoYFlip:
00003A74 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the collsion block
00003A78 D240                       		add.w	d0,d1				; Add the collision block's offset
00003A7A                            
00003A7A 2478 E8F4                  		movea.l	normColArrayPtr.w,a2		; Get the normal collision array
00003A7E 1032 1000                  		move.b	(a2,d1.w),d0			; Get height value
00003A82 4880                       		ext.w	d0				; ''
00003A84 BD44                       		eor.w	d6,d4				; Flip the flip bits from the block
00003A86 0804 000B                  		btst	#$B,d4				; Is the block vertically flipped?
00003A8A 6700                       		beq.s	.NoYFlip2			; If not, branch
00003A8C 4440                       		neg.w	d0				; Flip the height
00003A8E                            
00003A8E                            .NoYFlip2:
00003A8E 4A40                       		tst.w	d0				; Check the height
00003A90 679E                       		beq.s	.IsBlank			; If the height is 0, branch
00003A92 6B00                       		bmi.s	.NegHeight			; If the height is negative, branch
00003A94 3202                       		move.w	d2,d1				; Get the object's Y position
00003A96 0241 000F                  		andi.w	#$F,d1				; Get the Y offset in the height
00003A9A D041                       		add.w	d1,d0				; Add onto the height
00003A9C 323C 000F                  		move.w	#$F,d1				; Get actual distance
00003AA0 9240                       		sub.w	d0,d1				; ''
00003AA2 4E75                       		rts
00003AA4                            
00003AA4                            .NegHeight:
00003AA4 3202                       		move.w	d2,d1				; Get the object's Y position
00003AA6 0241 000F                  		andi.w	#$F,d1				; Get the Y offset in the height
00003AAA D041                       		add.w	d1,d0				; Add onto the height
00003AAC 6A00 FF82                  		bpl.w	.IsBlank			; If the object is outside of the collision, branch
00003AB0 4641                       		not.w	d1				; Flip the height
00003AB2 4E75                       		rts
00003AB4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003AB4                            ; Find the nearest wall from the object's position
00003AB4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003AB4                            ; PARAMETERS:
00003AB4                            ;	d2.w	- Y position of the object's bottom sensor
00003AB4                            ;	d3.w	- X position of the object's bottom sensor
00003AB4                            ;	d5.w	- Bit to chect for solidity
00003AB4                            ;	d6.w	- Flip bits (for walls and ceilings)
00003AB4                            ;	a3.w	- Distance in pixels to check for blocks left of or right of the sensor
00003AB4                            ;	a4.w	- Pointer to where the angle value will be stored
00003AB4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003AB4                            ; RETURNS:
00003AB4                            ;	d1.w	- The distance from the object to the floor
00003AB4                            ;	(a1).w	- The block ID in the chunk where the object is standing
00003AB4                            ;	(a4).w	- The floor angle
00003AB4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003AB4                            Level_FindWall:
00003AB4 6100 0000                  		bsr.w	Level_FindBlock			; Find the nearest tile
00003AB8 3011                       		move.w	(a1),d0				; Get block ID
00003ABA 3800                       		move.w	d0,d4				; Copy that
00003ABC 0240 03FF                  		andi.w	#$3FF,d0			; Get only the block ID
00003AC0 6700                       		beq.s	.IsBlank			; If it's blank, branch
00003AC2 0B04                       		btst	d5,d4				; Is the block solid?
00003AC4 6600                       		bne.s	.IsSolid			; If so, branch
00003AC6                            
00003AC6                            .IsBlank:
00003AC6 D64B                       		add.w	a3,d3				; Check right to the sensor
00003AC8 6100 0000                  		bsr.w	Level_FindWall2			; Try to find a solid block there
00003ACC 964B                       		sub.w	a3,d3				; Restore X position of sensor
00003ACE 0641 0010                  		addi.w	#$10,d1				; Return distance to floor
00003AD2 4E75                       		rts
00003AD4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003AD4                            .IsSolid:
00003AD4 2478 E8EA                  		movea.l	currentColAddr.w,a2			; Get collision data pointer
00003AD8 D040                       		add.w	d0,d0				; Turn ID into offset
00003ADA 1032 0000                  		move.b	(a2,d0.w),d0			; Get collision block ID
00003ADE 0240 00FF                  		andi.w	#$FF,d0				; ''
00003AE2 67E2                       		beq.s	.IsBlank			; If the angle is 0, branch
00003AE4                            
00003AE4 2478 E8F0                  		movea.l	angleValPtr.w,a2		; Angle value array
00003AE8 18B2 0000                  		move.b	(a2,d0.w),(a4)			; Get angle value and store it
00003AEC E948                       		lsl.w	#4,d0				; Turn collision block ID into offset
00003AEE                            
00003AEE 3202                       		move.w	d2,d1				; Get the object's Y position
00003AF0 0804 000B                  		btst	#$B,d4				; Is the block vertically flipped?
00003AF4 6700                       		beq.s	.NoYFlip			; If not, branch
00003AF6 4641                       		not.w	d1				; Flip the Y position
00003AF8 0614 0040                  		addi.b	#$40,(a4)			; Flip the angle
00003AFC 4414                       		neg.b	(a4)				; ''
00003AFE 0414 0040                  		subi.b	#$40,(a4)			; ''
00003B02                            
00003B02                            .NoYFlip:
00003B02 0804 000A                  		btst	#$A,d4				; Is the block flipped horizontally?
00003B06 6700                       		beq.s	.NoXFlip			; If not, branch
00003B08 4414                       		neg.b	(a4)				; Flip the angle
00003B0A                            
00003B0A                            .NoXFlip:
00003B0A 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the collsion block
00003B0E D240                       		add.w	d0,d1				; Add the collision block's offset
00003B10                            
00003B10 2478 E8F8                  		movea.l	rotColArrayPtr.w,a2		; Get the normal collision array
00003B14 1032 1000                  		move.b	(a2,d1.w),d0			; Get height value
00003B18 4880                       		ext.w	d0				; ''
00003B1A BD44                       		eor.w	d6,d4				; Flip the flip bits from the block
00003B1C 0804 000A                  		btst	#$A,d4				; Is the block horizontally flipped?
00003B20 6700                       		beq.s	.NoYFlip2			; If not, branch
00003B22 4440                       		neg.w	d0				; Flip the height
00003B24                            
00003B24                            .NoYFlip2:
00003B24 4A40                       		tst.w	d0				; Check the height
00003B26 679E                       		beq.s	.IsBlank			; If the height is 0, branch
00003B28 6B00                       		bmi.s	.NegHeight			; If the height is negative, branch
00003B2A 0C00 0010                  		cmpi.b	#$10,d0				; Is the height 16 (the max height)?
00003B2E 6700                       		beq.s	.MaxFloor			; If so, branch
00003B30 3203                       		move.w	d3,d1				; Get the object's X position
00003B32 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the height
00003B36 D041                       		add.w	d1,d0				; Add onto the height
00003B38 323C 000F                  		move.w	#$F,d1				; Get actual distance
00003B3C 9240                       		sub.w	d0,d1				; ''
00003B3E 4E75                       		rts
00003B40                            
00003B40                            .NegHeight:
00003B40 3203                       		move.w	d3,d1				; Get the object's X position
00003B42 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the height
00003B46 D041                       		add.w	d1,d0				; Add onto the height
00003B48 6A00 FF7C                  		bpl.w	.IsBlank			; If the object is outside of the collision, branch
00003B4C                            
00003B4C                            .MaxFloor:
00003B4C 964B                       		sub.w	a3,d3				; Check left to the sensor
00003B4E 6100                       		bsr.s	Level_FindWall2			; Try to find a solid block there
00003B50 D64B                       		add.w	a3,d3				; Restore X position of sensor
00003B52 0441 0010                  		subi.w	#$10,d1				; Return distance to floor
00003B56 4E75                       		rts
00003B58                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003B58                            Level_FindWall2:
00003B58 6100 0000                  		bsr.w	Level_FindBlock			; Find the nearest tile
00003B5C 3011                       		move.w	(a1),d0				; Get block ID
00003B5E 3800                       		move.w	d0,d4				; Copy that
00003B60 0240 03FF                  		andi.w	#$3FF,d0			; Get only the block ID
00003B64 6700                       		beq.s	.IsBlank			; If it's blank, branch
00003B66 0B04                       		btst	d5,d4				; Is the block solid?
00003B68 6600                       		bne.s	.IsSolid			; If so, branch
00003B6A                            
00003B6A                            .IsBlank:
00003B6A 323C 000F                  		move.w	#$F,d1				; Get max distance
00003B6E 3003                       		move.w	d3,d0				; Get the object's X position
00003B70 0240 000F                  		andi.w	#$F,d0				; Get the X offset in the height
00003B74 9240                       		sub.w	d0,d1				; Get actual distance
00003B76 4E75                       		rts
00003B78                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003B78                            .IsSolid:
00003B78 2478 E8EA                  		movea.l	currentColAddr.w,a2			; Get collision data pointer
00003B7C D040                       		add.w	d0,d0				; Turn ID into offset
00003B7E 1032 0000                  		move.b	(a2,d0.w),d0			; Get collision block ID
00003B82 0240 00FF                  		andi.w	#$FF,d0				; ''
00003B86 67E2                       		beq.s	.IsBlank			; If the angle is 0, branch
00003B88                            
00003B88 2478 E8F0                  		movea.l	angleValPtr.w,a2		; Angle value array
00003B8C 18B2 0000                  		move.b	(a2,d0.w),(a4)			; Get angle value and store it
00003B90 E948                       		lsl.w	#4,d0				; Turn collision block ID into offset
00003B92                            
00003B92 3202                       		move.w	d2,d1				; Get the object's Y position
00003B94 0804 000B                  		btst	#$B,d4				; Is the block vertically flipped?
00003B98 6700                       		beq.s	.NoYFlip			; If not, branch
00003B9A 4641                       		not.w	d1				; Flip the Y position
00003B9C 0614 0040                  		addi.b	#$40,(a4)			; Flip the angle
00003BA0 4414                       		neg.b	(a4)				; ''
00003BA2 0414 0040                  		subi.b	#$40,(a4)			; ''
00003BA6                            
00003BA6                            .NoYFlip:
00003BA6 0804 000A                  		btst	#$A,d4				; Is the block flipped horizontally?
00003BAA 6700                       		beq.s	.NoXFlip			; If not, branch
00003BAC 4414                       		neg.b	(a4)				; Flip the angle
00003BAE                            
00003BAE                            .NoXFlip:
00003BAE 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the collsion block
00003BB2 D240                       		add.w	d0,d1				; Add the collision block's offset
00003BB4                            
00003BB4 2478 E8F8                  		movea.l	rotColArrayPtr.w,a2		; Get the normal collision array
00003BB8 1032 1000                  		move.b	(a2,d1.w),d0			; Get height value
00003BBC 4880                       		ext.w	d0				; ''
00003BBE BD44                       		eor.w	d6,d4				; Flip the flip bits from the block
00003BC0 0804 000A                  		btst	#$A,d4				; Is the block horizontally flipped?
00003BC4 6700                       		beq.s	.NoYFlip2			; If not, branch
00003BC6 4440                       		neg.w	d0				; Flip the height
00003BC8                            
00003BC8                            .NoYFlip2:
00003BC8 4A40                       		tst.w	d0				; Check the height
00003BCA 679E                       		beq.s	.IsBlank			; If the height is 0, branch
00003BCC 6B00                       		bmi.s	.NegHeight			; If the height is negative, branch
00003BCE 3203                       		move.w	d3,d1				; Get the object's X position
00003BD0 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the height
00003BD4 D041                       		add.w	d1,d0				; Add onto the height
00003BD6 323C 000F                  		move.w	#$F,d1				; Get actual distance
00003BDA 9240                       		sub.w	d0,d1				; ''
00003BDC 4E75                       		rts
00003BDE                            
00003BDE                            .NegHeight:
00003BDE 3203                       		move.w	d3,d1				; Get the object's X position
00003BE0 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the height
00003BE4 D041                       		add.w	d1,d0				; Add onto the height
00003BE6 6A00 FF82                  		bpl.w	.IsBlank			; If the object is outside of the collision, branch
00003BEA 4641                       		not.w	d1				; Flip the height
00003BEC 4E75                       		rts
00003BEE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003BEE                            ; Find the nearest block in the level from the player
00003BEE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003BEE                            ; PARAMETERS:
00003BEE                            ;	d2.w	- Y position of the object's sensor
00003BEE                            ;	d3.w	- X position of the object's sensor
00003BEE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003BEE                            ; RETURNS:
00003BEE                            ;	(a1).w	- The block ID in the chunk where the object is standing
00003BEE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003BEE                            Level_FindBlock:
00003BEE 2278 E856                  		movea.l	lvlLayout.w,a1			; Get level layout pointer address
00003BF2                            
00003BF2 3002                       		move.w	d2,d0				; Get the object's Y position
00003BF4 0240 0780                  		andi.w	#$780,d0			; Get Y within layout data
00003BF8 EC48                       		lsr.w	#6,d0				; ''						
00003BFA 3031 0002                  		move.w	2(a1,d0.w),d0			; Get chunk row offset
00003BFE                            		
00003BFE 3203                       		move.w	d3,d1				; Get the object's X position
00003C00 E649                       		lsr.w	#3,d1				; Divide by 8
00003C02 3801                       		move.w	d1,d4				; Save for later
00003C04                            		
00003C04 E849                       		lsr.w	#4,d1				; Divide by 16 to get the offset of the chunk in the chunk row
00003C06 0241 00FF                  		andi.w	#$FF,d1				; Only 256 chunks per row
00003C0A D041                       		add.w	d1,d0				; Get offset in the level layout
00003C0C                            
00003C0C 72FF                       		moveq	#-1,d1				; Prepare the chunk table pointer
00003C0E 4241                       		clr.w	d1				; ''
00003C10                            		
00003C10 1231 0000                  		move.b	(a1,d0.w),d1			; Get chunk ID
00003C14 D241                       		add.w	d1,d1				; Turn into offset
00003C16 323B 1000                  		move.w	.ChunkOffsets(pc,d1.w),d1	; Get offset in chunk table
00003C1A 3002                       		move.w	d2,d0				; Get the object's Y position
00003C1C                            		
00003C1C 0240 0070                  		andi.w	#$70,d0				; Get Y position within chunk
00003C20 D240                       		add.w	d0,d1				; Add onto the offset
00003C22 0244 000E                  		andi.w	#$E,d4				; Get the previously saved X position divided by 8 (for the row offset)
00003C26 D244                       		add.w	d4,d1				; Add onto the offset
00003C28                            		
00003C28 2241                       		movea.l	d1,a1				; Get pointer in chunk table
00003C2A 4E75                       		rts
00003C2C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003C2C                            .ChunkOffsets:
00003C2C =00000000                  c		= 0
00003C2C                            		rept	256
00003C2C                            			dc.w	c
00003C2C                            c			= c+$80
00003C2C                            		endr
00003C2C 0000                     M 	dc.w	c
00003C2E =00000080                M c	=	c+$80
00003C2E 0080                     M 	dc.w	c
00003C30 =00000100                M c	=	c+$80
00003C30 0100                     M 	dc.w	c
00003C32 =00000180                M c	=	c+$80
00003C32 0180                     M 	dc.w	c
00003C34 =00000200                M c	=	c+$80
00003C34 0200                     M 	dc.w	c
00003C36 =00000280                M c	=	c+$80
00003C36 0280                     M 	dc.w	c
00003C38 =00000300                M c	=	c+$80
00003C38 0300                     M 	dc.w	c
00003C3A =00000380                M c	=	c+$80
00003C3A 0380                     M 	dc.w	c
00003C3C =00000400                M c	=	c+$80
00003C3C 0400                     M 	dc.w	c
00003C3E =00000480                M c	=	c+$80
00003C3E 0480                     M 	dc.w	c
00003C40 =00000500                M c	=	c+$80
00003C40 0500                     M 	dc.w	c
00003C42 =00000580                M c	=	c+$80
00003C42 0580                     M 	dc.w	c
00003C44 =00000600                M c	=	c+$80
00003C44 0600                     M 	dc.w	c
00003C46 =00000680                M c	=	c+$80
00003C46 0680                     M 	dc.w	c
00003C48 =00000700                M c	=	c+$80
00003C48 0700                     M 	dc.w	c
00003C4A =00000780                M c	=	c+$80
00003C4A 0780                     M 	dc.w	c
00003C4C =00000800                M c	=	c+$80
00003C4C 0800                     M 	dc.w	c
00003C4E =00000880                M c	=	c+$80
00003C4E 0880                     M 	dc.w	c
00003C50 =00000900                M c	=	c+$80
00003C50 0900                     M 	dc.w	c
00003C52 =00000980                M c	=	c+$80
00003C52 0980                     M 	dc.w	c
00003C54 =00000A00                M c	=	c+$80
00003C54 0A00                     M 	dc.w	c
00003C56 =00000A80                M c	=	c+$80
00003C56 0A80                     M 	dc.w	c
00003C58 =00000B00                M c	=	c+$80
00003C58 0B00                     M 	dc.w	c
00003C5A =00000B80                M c	=	c+$80
00003C5A 0B80                     M 	dc.w	c
00003C5C =00000C00                M c	=	c+$80
00003C5C 0C00                     M 	dc.w	c
00003C5E =00000C80                M c	=	c+$80
00003C5E 0C80                     M 	dc.w	c
00003C60 =00000D00                M c	=	c+$80
00003C60 0D00                     M 	dc.w	c
00003C62 =00000D80                M c	=	c+$80
00003C62 0D80                     M 	dc.w	c
00003C64 =00000E00                M c	=	c+$80
00003C64 0E00                     M 	dc.w	c
00003C66 =00000E80                M c	=	c+$80
00003C66 0E80                     M 	dc.w	c
00003C68 =00000F00                M c	=	c+$80
00003C68 0F00                     M 	dc.w	c
00003C6A =00000F80                M c	=	c+$80
00003C6A 0F80                     M 	dc.w	c
00003C6C =00001000                M c	=	c+$80
00003C6C 1000                     M 	dc.w	c
00003C6E =00001080                M c	=	c+$80
00003C6E 1080                     M 	dc.w	c
00003C70 =00001100                M c	=	c+$80
00003C70 1100                     M 	dc.w	c
00003C72 =00001180                M c	=	c+$80
00003C72 1180                     M 	dc.w	c
00003C74 =00001200                M c	=	c+$80
00003C74 1200                     M 	dc.w	c
00003C76 =00001280                M c	=	c+$80
00003C76 1280                     M 	dc.w	c
00003C78 =00001300                M c	=	c+$80
00003C78 1300                     M 	dc.w	c
00003C7A =00001380                M c	=	c+$80
00003C7A 1380                     M 	dc.w	c
00003C7C =00001400                M c	=	c+$80
00003C7C 1400                     M 	dc.w	c
00003C7E =00001480                M c	=	c+$80
00003C7E 1480                     M 	dc.w	c
00003C80 =00001500                M c	=	c+$80
00003C80 1500                     M 	dc.w	c
00003C82 =00001580                M c	=	c+$80
00003C82 1580                     M 	dc.w	c
00003C84 =00001600                M c	=	c+$80
00003C84 1600                     M 	dc.w	c
00003C86 =00001680                M c	=	c+$80
00003C86 1680                     M 	dc.w	c
00003C88 =00001700                M c	=	c+$80
00003C88 1700                     M 	dc.w	c
00003C8A =00001780                M c	=	c+$80
00003C8A 1780                     M 	dc.w	c
00003C8C =00001800                M c	=	c+$80
00003C8C 1800                     M 	dc.w	c
00003C8E =00001880                M c	=	c+$80
00003C8E 1880                     M 	dc.w	c
00003C90 =00001900                M c	=	c+$80
00003C90 1900                     M 	dc.w	c
00003C92 =00001980                M c	=	c+$80
00003C92 1980                     M 	dc.w	c
00003C94 =00001A00                M c	=	c+$80
00003C94 1A00                     M 	dc.w	c
00003C96 =00001A80                M c	=	c+$80
00003C96 1A80                     M 	dc.w	c
00003C98 =00001B00                M c	=	c+$80
00003C98 1B00                     M 	dc.w	c
00003C9A =00001B80                M c	=	c+$80
00003C9A 1B80                     M 	dc.w	c
00003C9C =00001C00                M c	=	c+$80
00003C9C 1C00                     M 	dc.w	c
00003C9E =00001C80                M c	=	c+$80
00003C9E 1C80                     M 	dc.w	c
00003CA0 =00001D00                M c	=	c+$80
00003CA0 1D00                     M 	dc.w	c
00003CA2 =00001D80                M c	=	c+$80
00003CA2 1D80                     M 	dc.w	c
00003CA4 =00001E00                M c	=	c+$80
00003CA4 1E00                     M 	dc.w	c
00003CA6 =00001E80                M c	=	c+$80
00003CA6 1E80                     M 	dc.w	c
00003CA8 =00001F00                M c	=	c+$80
00003CA8 1F00                     M 	dc.w	c
00003CAA =00001F80                M c	=	c+$80
00003CAA 1F80                     M 	dc.w	c
00003CAC =00002000                M c	=	c+$80
00003CAC 2000                     M 	dc.w	c
00003CAE =00002080                M c	=	c+$80
00003CAE 2080                     M 	dc.w	c
00003CB0 =00002100                M c	=	c+$80
00003CB0 2100                     M 	dc.w	c
00003CB2 =00002180                M c	=	c+$80
00003CB2 2180                     M 	dc.w	c
00003CB4 =00002200                M c	=	c+$80
00003CB4 2200                     M 	dc.w	c
00003CB6 =00002280                M c	=	c+$80
00003CB6 2280                     M 	dc.w	c
00003CB8 =00002300                M c	=	c+$80
00003CB8 2300                     M 	dc.w	c
00003CBA =00002380                M c	=	c+$80
00003CBA 2380                     M 	dc.w	c
00003CBC =00002400                M c	=	c+$80
00003CBC 2400                     M 	dc.w	c
00003CBE =00002480                M c	=	c+$80
00003CBE 2480                     M 	dc.w	c
00003CC0 =00002500                M c	=	c+$80
00003CC0 2500                     M 	dc.w	c
00003CC2 =00002580                M c	=	c+$80
00003CC2 2580                     M 	dc.w	c
00003CC4 =00002600                M c	=	c+$80
00003CC4 2600                     M 	dc.w	c
00003CC6 =00002680                M c	=	c+$80
00003CC6 2680                     M 	dc.w	c
00003CC8 =00002700                M c	=	c+$80
00003CC8 2700                     M 	dc.w	c
00003CCA =00002780                M c	=	c+$80
00003CCA 2780                     M 	dc.w	c
00003CCC =00002800                M c	=	c+$80
00003CCC 2800                     M 	dc.w	c
00003CCE =00002880                M c	=	c+$80
00003CCE 2880                     M 	dc.w	c
00003CD0 =00002900                M c	=	c+$80
00003CD0 2900                     M 	dc.w	c
00003CD2 =00002980                M c	=	c+$80
00003CD2 2980                     M 	dc.w	c
00003CD4 =00002A00                M c	=	c+$80
00003CD4 2A00                     M 	dc.w	c
00003CD6 =00002A80                M c	=	c+$80
00003CD6 2A80                     M 	dc.w	c
00003CD8 =00002B00                M c	=	c+$80
00003CD8 2B00                     M 	dc.w	c
00003CDA =00002B80                M c	=	c+$80
00003CDA 2B80                     M 	dc.w	c
00003CDC =00002C00                M c	=	c+$80
00003CDC 2C00                     M 	dc.w	c
00003CDE =00002C80                M c	=	c+$80
00003CDE 2C80                     M 	dc.w	c
00003CE0 =00002D00                M c	=	c+$80
00003CE0 2D00                     M 	dc.w	c
00003CE2 =00002D80                M c	=	c+$80
00003CE2 2D80                     M 	dc.w	c
00003CE4 =00002E00                M c	=	c+$80
00003CE4 2E00                     M 	dc.w	c
00003CE6 =00002E80                M c	=	c+$80
00003CE6 2E80                     M 	dc.w	c
00003CE8 =00002F00                M c	=	c+$80
00003CE8 2F00                     M 	dc.w	c
00003CEA =00002F80                M c	=	c+$80
00003CEA 2F80                     M 	dc.w	c
00003CEC =00003000                M c	=	c+$80
00003CEC 3000                     M 	dc.w	c
00003CEE =00003080                M c	=	c+$80
00003CEE 3080                     M 	dc.w	c
00003CF0 =00003100                M c	=	c+$80
00003CF0 3100                     M 	dc.w	c
00003CF2 =00003180                M c	=	c+$80
00003CF2 3180                     M 	dc.w	c
00003CF4 =00003200                M c	=	c+$80
00003CF4 3200                     M 	dc.w	c
00003CF6 =00003280                M c	=	c+$80
00003CF6 3280                     M 	dc.w	c
00003CF8 =00003300                M c	=	c+$80
00003CF8 3300                     M 	dc.w	c
00003CFA =00003380                M c	=	c+$80
00003CFA 3380                     M 	dc.w	c
00003CFC =00003400                M c	=	c+$80
00003CFC 3400                     M 	dc.w	c
00003CFE =00003480                M c	=	c+$80
00003CFE 3480                     M 	dc.w	c
00003D00 =00003500                M c	=	c+$80
00003D00 3500                     M 	dc.w	c
00003D02 =00003580                M c	=	c+$80
00003D02 3580                     M 	dc.w	c
00003D04 =00003600                M c	=	c+$80
00003D04 3600                     M 	dc.w	c
00003D06 =00003680                M c	=	c+$80
00003D06 3680                     M 	dc.w	c
00003D08 =00003700                M c	=	c+$80
00003D08 3700                     M 	dc.w	c
00003D0A =00003780                M c	=	c+$80
00003D0A 3780                     M 	dc.w	c
00003D0C =00003800                M c	=	c+$80
00003D0C 3800                     M 	dc.w	c
00003D0E =00003880                M c	=	c+$80
00003D0E 3880                     M 	dc.w	c
00003D10 =00003900                M c	=	c+$80
00003D10 3900                     M 	dc.w	c
00003D12 =00003980                M c	=	c+$80
00003D12 3980                     M 	dc.w	c
00003D14 =00003A00                M c	=	c+$80
00003D14 3A00                     M 	dc.w	c
00003D16 =00003A80                M c	=	c+$80
00003D16 3A80                     M 	dc.w	c
00003D18 =00003B00                M c	=	c+$80
00003D18 3B00                     M 	dc.w	c
00003D1A =00003B80                M c	=	c+$80
00003D1A 3B80                     M 	dc.w	c
00003D1C =00003C00                M c	=	c+$80
00003D1C 3C00                     M 	dc.w	c
00003D1E =00003C80                M c	=	c+$80
00003D1E 3C80                     M 	dc.w	c
00003D20 =00003D00                M c	=	c+$80
00003D20 3D00                     M 	dc.w	c
00003D22 =00003D80                M c	=	c+$80
00003D22 3D80                     M 	dc.w	c
00003D24 =00003E00                M c	=	c+$80
00003D24 3E00                     M 	dc.w	c
00003D26 =00003E80                M c	=	c+$80
00003D26 3E80                     M 	dc.w	c
00003D28 =00003F00                M c	=	c+$80
00003D28 3F00                     M 	dc.w	c
00003D2A =00003F80                M c	=	c+$80
00003D2A 3F80                     M 	dc.w	c
00003D2C =00004000                M c	=	c+$80
00003D2C 4000                     M 	dc.w	c
00003D2E =00004080                M c	=	c+$80
00003D2E 4080                     M 	dc.w	c
00003D30 =00004100                M c	=	c+$80
00003D30 4100                     M 	dc.w	c
00003D32 =00004180                M c	=	c+$80
00003D32 4180                     M 	dc.w	c
00003D34 =00004200                M c	=	c+$80
00003D34 4200                     M 	dc.w	c
00003D36 =00004280                M c	=	c+$80
00003D36 4280                     M 	dc.w	c
00003D38 =00004300                M c	=	c+$80
00003D38 4300                     M 	dc.w	c
00003D3A =00004380                M c	=	c+$80
00003D3A 4380                     M 	dc.w	c
00003D3C =00004400                M c	=	c+$80
00003D3C 4400                     M 	dc.w	c
00003D3E =00004480                M c	=	c+$80
00003D3E 4480                     M 	dc.w	c
00003D40 =00004500                M c	=	c+$80
00003D40 4500                     M 	dc.w	c
00003D42 =00004580                M c	=	c+$80
00003D42 4580                     M 	dc.w	c
00003D44 =00004600                M c	=	c+$80
00003D44 4600                     M 	dc.w	c
00003D46 =00004680                M c	=	c+$80
00003D46 4680                     M 	dc.w	c
00003D48 =00004700                M c	=	c+$80
00003D48 4700                     M 	dc.w	c
00003D4A =00004780                M c	=	c+$80
00003D4A 4780                     M 	dc.w	c
00003D4C =00004800                M c	=	c+$80
00003D4C 4800                     M 	dc.w	c
00003D4E =00004880                M c	=	c+$80
00003D4E 4880                     M 	dc.w	c
00003D50 =00004900                M c	=	c+$80
00003D50 4900                     M 	dc.w	c
00003D52 =00004980                M c	=	c+$80
00003D52 4980                     M 	dc.w	c
00003D54 =00004A00                M c	=	c+$80
00003D54 4A00                     M 	dc.w	c
00003D56 =00004A80                M c	=	c+$80
00003D56 4A80                     M 	dc.w	c
00003D58 =00004B00                M c	=	c+$80
00003D58 4B00                     M 	dc.w	c
00003D5A =00004B80                M c	=	c+$80
00003D5A 4B80                     M 	dc.w	c
00003D5C =00004C00                M c	=	c+$80
00003D5C 4C00                     M 	dc.w	c
00003D5E =00004C80                M c	=	c+$80
00003D5E 4C80                     M 	dc.w	c
00003D60 =00004D00                M c	=	c+$80
00003D60 4D00                     M 	dc.w	c
00003D62 =00004D80                M c	=	c+$80
00003D62 4D80                     M 	dc.w	c
00003D64 =00004E00                M c	=	c+$80
00003D64 4E00                     M 	dc.w	c
00003D66 =00004E80                M c	=	c+$80
00003D66 4E80                     M 	dc.w	c
00003D68 =00004F00                M c	=	c+$80
00003D68 4F00                     M 	dc.w	c
00003D6A =00004F80                M c	=	c+$80
00003D6A 4F80                     M 	dc.w	c
00003D6C =00005000                M c	=	c+$80
00003D6C 5000                     M 	dc.w	c
00003D6E =00005080                M c	=	c+$80
00003D6E 5080                     M 	dc.w	c
00003D70 =00005100                M c	=	c+$80
00003D70 5100                     M 	dc.w	c
00003D72 =00005180                M c	=	c+$80
00003D72 5180                     M 	dc.w	c
00003D74 =00005200                M c	=	c+$80
00003D74 5200                     M 	dc.w	c
00003D76 =00005280                M c	=	c+$80
00003D76 5280                     M 	dc.w	c
00003D78 =00005300                M c	=	c+$80
00003D78 5300                     M 	dc.w	c
00003D7A =00005380                M c	=	c+$80
00003D7A 5380                     M 	dc.w	c
00003D7C =00005400                M c	=	c+$80
00003D7C 5400                     M 	dc.w	c
00003D7E =00005480                M c	=	c+$80
00003D7E 5480                     M 	dc.w	c
00003D80 =00005500                M c	=	c+$80
00003D80 5500                     M 	dc.w	c
00003D82 =00005580                M c	=	c+$80
00003D82 5580                     M 	dc.w	c
00003D84 =00005600                M c	=	c+$80
00003D84 5600                     M 	dc.w	c
00003D86 =00005680                M c	=	c+$80
00003D86 5680                     M 	dc.w	c
00003D88 =00005700                M c	=	c+$80
00003D88 5700                     M 	dc.w	c
00003D8A =00005780                M c	=	c+$80
00003D8A 5780                     M 	dc.w	c
00003D8C =00005800                M c	=	c+$80
00003D8C 5800                     M 	dc.w	c
00003D8E =00005880                M c	=	c+$80
00003D8E 5880                     M 	dc.w	c
00003D90 =00005900                M c	=	c+$80
00003D90 5900                     M 	dc.w	c
00003D92 =00005980                M c	=	c+$80
00003D92 5980                     M 	dc.w	c
00003D94 =00005A00                M c	=	c+$80
00003D94 5A00                     M 	dc.w	c
00003D96 =00005A80                M c	=	c+$80
00003D96 5A80                     M 	dc.w	c
00003D98 =00005B00                M c	=	c+$80
00003D98 5B00                     M 	dc.w	c
00003D9A =00005B80                M c	=	c+$80
00003D9A 5B80                     M 	dc.w	c
00003D9C =00005C00                M c	=	c+$80
00003D9C 5C00                     M 	dc.w	c
00003D9E =00005C80                M c	=	c+$80
00003D9E 5C80                     M 	dc.w	c
00003DA0 =00005D00                M c	=	c+$80
00003DA0 5D00                     M 	dc.w	c
00003DA2 =00005D80                M c	=	c+$80
00003DA2 5D80                     M 	dc.w	c
00003DA4 =00005E00                M c	=	c+$80
00003DA4 5E00                     M 	dc.w	c
00003DA6 =00005E80                M c	=	c+$80
00003DA6 5E80                     M 	dc.w	c
00003DA8 =00005F00                M c	=	c+$80
00003DA8 5F00                     M 	dc.w	c
00003DAA =00005F80                M c	=	c+$80
00003DAA 5F80                     M 	dc.w	c
00003DAC =00006000                M c	=	c+$80
00003DAC 6000                     M 	dc.w	c
00003DAE =00006080                M c	=	c+$80
00003DAE 6080                     M 	dc.w	c
00003DB0 =00006100                M c	=	c+$80
00003DB0 6100                     M 	dc.w	c
00003DB2 =00006180                M c	=	c+$80
00003DB2 6180                     M 	dc.w	c
00003DB4 =00006200                M c	=	c+$80
00003DB4 6200                     M 	dc.w	c
00003DB6 =00006280                M c	=	c+$80
00003DB6 6280                     M 	dc.w	c
00003DB8 =00006300                M c	=	c+$80
00003DB8 6300                     M 	dc.w	c
00003DBA =00006380                M c	=	c+$80
00003DBA 6380                     M 	dc.w	c
00003DBC =00006400                M c	=	c+$80
00003DBC 6400                     M 	dc.w	c
00003DBE =00006480                M c	=	c+$80
00003DBE 6480                     M 	dc.w	c
00003DC0 =00006500                M c	=	c+$80
00003DC0 6500                     M 	dc.w	c
00003DC2 =00006580                M c	=	c+$80
00003DC2 6580                     M 	dc.w	c
00003DC4 =00006600                M c	=	c+$80
00003DC4 6600                     M 	dc.w	c
00003DC6 =00006680                M c	=	c+$80
00003DC6 6680                     M 	dc.w	c
00003DC8 =00006700                M c	=	c+$80
00003DC8 6700                     M 	dc.w	c
00003DCA =00006780                M c	=	c+$80
00003DCA 6780                     M 	dc.w	c
00003DCC =00006800                M c	=	c+$80
00003DCC 6800                     M 	dc.w	c
00003DCE =00006880                M c	=	c+$80
00003DCE 6880                     M 	dc.w	c
00003DD0 =00006900                M c	=	c+$80
00003DD0 6900                     M 	dc.w	c
00003DD2 =00006980                M c	=	c+$80
00003DD2 6980                     M 	dc.w	c
00003DD4 =00006A00                M c	=	c+$80
00003DD4 6A00                     M 	dc.w	c
00003DD6 =00006A80                M c	=	c+$80
00003DD6 6A80                     M 	dc.w	c
00003DD8 =00006B00                M c	=	c+$80
00003DD8 6B00                     M 	dc.w	c
00003DDA =00006B80                M c	=	c+$80
00003DDA 6B80                     M 	dc.w	c
00003DDC =00006C00                M c	=	c+$80
00003DDC 6C00                     M 	dc.w	c
00003DDE =00006C80                M c	=	c+$80
00003DDE 6C80                     M 	dc.w	c
00003DE0 =00006D00                M c	=	c+$80
00003DE0 6D00                     M 	dc.w	c
00003DE2 =00006D80                M c	=	c+$80
00003DE2 6D80                     M 	dc.w	c
00003DE4 =00006E00                M c	=	c+$80
00003DE4 6E00                     M 	dc.w	c
00003DE6 =00006E80                M c	=	c+$80
00003DE6 6E80                     M 	dc.w	c
00003DE8 =00006F00                M c	=	c+$80
00003DE8 6F00                     M 	dc.w	c
00003DEA =00006F80                M c	=	c+$80
00003DEA 6F80                     M 	dc.w	c
00003DEC =00007000                M c	=	c+$80
00003DEC 7000                     M 	dc.w	c
00003DEE =00007080                M c	=	c+$80
00003DEE 7080                     M 	dc.w	c
00003DF0 =00007100                M c	=	c+$80
00003DF0 7100                     M 	dc.w	c
00003DF2 =00007180                M c	=	c+$80
00003DF2 7180                     M 	dc.w	c
00003DF4 =00007200                M c	=	c+$80
00003DF4 7200                     M 	dc.w	c
00003DF6 =00007280                M c	=	c+$80
00003DF6 7280                     M 	dc.w	c
00003DF8 =00007300                M c	=	c+$80
00003DF8 7300                     M 	dc.w	c
00003DFA =00007380                M c	=	c+$80
00003DFA 7380                     M 	dc.w	c
00003DFC =00007400                M c	=	c+$80
00003DFC 7400                     M 	dc.w	c
00003DFE =00007480                M c	=	c+$80
00003DFE 7480                     M 	dc.w	c
00003E00 =00007500                M c	=	c+$80
00003E00 7500                     M 	dc.w	c
00003E02 =00007580                M c	=	c+$80
00003E02 7580                     M 	dc.w	c
00003E04 =00007600                M c	=	c+$80
00003E04 7600                     M 	dc.w	c
00003E06 =00007680                M c	=	c+$80
00003E06 7680                     M 	dc.w	c
00003E08 =00007700                M c	=	c+$80
00003E08 7700                     M 	dc.w	c
00003E0A =00007780                M c	=	c+$80
00003E0A 7780                     M 	dc.w	c
00003E0C =00007800                M c	=	c+$80
00003E0C 7800                     M 	dc.w	c
00003E0E =00007880                M c	=	c+$80
00003E0E 7880                     M 	dc.w	c
00003E10 =00007900                M c	=	c+$80
00003E10 7900                     M 	dc.w	c
00003E12 =00007980                M c	=	c+$80
00003E12 7980                     M 	dc.w	c
00003E14 =00007A00                M c	=	c+$80
00003E14 7A00                     M 	dc.w	c
00003E16 =00007A80                M c	=	c+$80
00003E16 7A80                     M 	dc.w	c
00003E18 =00007B00                M c	=	c+$80
00003E18 7B00                     M 	dc.w	c
00003E1A =00007B80                M c	=	c+$80
00003E1A 7B80                     M 	dc.w	c
00003E1C =00007C00                M c	=	c+$80
00003E1C 7C00                     M 	dc.w	c
00003E1E =00007C80                M c	=	c+$80
00003E1E 7C80                     M 	dc.w	c
00003E20 =00007D00                M c	=	c+$80
00003E20 7D00                     M 	dc.w	c
00003E22 =00007D80                M c	=	c+$80
00003E22 7D80                     M 	dc.w	c
00003E24 =00007E00                M c	=	c+$80
00003E24 7E00                     M 	dc.w	c
00003E26 =00007E80                M c	=	c+$80
00003E26 7E80                     M 	dc.w	c
00003E28 =00007F00                M c	=	c+$80
00003E28 7F00                     M 	dc.w	c
00003E2A =00007F80                M c	=	c+$80
00003E2A 7F80                     M 	dc.w	c
00003E2C =00008000                M c	=	c+$80
00003E2C                            ; =========================================================================================================================================================
00003E2C                            		include	"Opmodes/Gameplay/Level Functions.asm"
00003E2C                            ; =========================================================================================================================================================
00003E2C                            ; General level functions
00003E2C                            ; =========================================================================================================================================================
00003E2C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003E2C                            ; Load level data
00003E2C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003E2C                            Level_LoadData:
00003E2C                            		; --- Initialize the start position and camera ---
00003E2C                            
00003E2C 47F9 0000 0000             		lea	Level_SizeStartPos,a3		; Get size and start position data
00003E32 3038 C7AE                  		move.w	levelID.w,d0			; Get level ID
00003E36 E218                       		ror.b	#1,d0				; Turn into offset
00003E38 E848                       		lsr.w	#4,d0				; ''
00003E3A 47F3 0000                  		lea	(a3,d0.w),a3			; Get pointer to the correct pointers
00003E3E                            
00003E3E 42B8 E8CE                  		clr.l	targetMinCamPos.w		; Set target minimum camera values
00003E42 42B8 E8D2                  		clr.l	minCamPos.w			; Set minimum camera values
00003E46 21D3 E8C6                  		move.l	(a3),targetMaxCamPos.w		; Set target maximum camera values
00003E4A 21DB E8CA                  		move.l	(a3)+,maxCamPos.w		; Set maximum camera values
00003E4E                            
00003E4E 31FC 0060 E8D8             		move.w	#(224/2)-16,panCamYPos.w	; Set camera Y distance
00003E54                            
00003E54 3078 E876                  		movea.w	playerPtrP1.w,a0		; Player object
00003E58 321B                       		move.w	(a3)+,d1			; Get starting X position
00003E5A 3141 0014                  		move.w	d1,_objXPos(a0)			; Set the player's X position
00003E5E 3013                       		move.w	(a3),d0				; Get starting Y position
00003E60 3140 0018                  		move.w	d0,_objYPos(a0)			; Set the player's Y position
00003E64                            
00003E64 4A38 C7B7                  		tst.b	rStartFall.w			; Should we start the level by falling?
00003E68 6700                       		beq.s	.InitCam			; If not, branch
00003E6A 08E8 0002 000C             		bset	#2,_objFlags(a0)
00003E70 7272                       		moveq	#$72,d1				; Reset Sonic's X position
00003E72 3141 0014                  		move.w	d1,_objXPos(a0)			; ''
00003E76 70E0                       		moveq	#-32,d0				; Reset Sonic's Y position
00003E78 3140 0018                  		move.w	d0,_objYPos(a0)			; ''
00003E7C                            
00003E7C                            .InitCam:
00003E7C 4A38 C7B0                  		tst.b	chkIDLast.w		; Has a checkpoint been hit?
00003E80 6700                       		beq.s	.SetCam				; If not, branch
00003E82 6100 0000                  		bsr.w	Level_LoadSavedInfo		; Load data
00003E86 3228 0014                  		move.w	_objXPos(a0),d1			; Get X position
00003E8A 3028 0018                  		move.w	_objYPos(a0),d0			; Get Y position
00003E8E                            
00003E8E                            .SetCam:
00003E8E 0441 00A0                  		subi.w	#320/2,d1			; Get camera's X position
00003E92 6C00                       		bge.s	.ChkMaxX			; If it doesn't go beyond the left boundary, branch
00003E94 7200                       		moveq	#0,d1				; Cap it
00003E96                            
00003E96                            .ChkMaxX:
00003E96 3438 E8CA                  		move.w	maxCamXPos.w,d2		; Get max camera X position
00003E9A B242                       		cmp.w	d2,d1				; Have we gone beyond it?
00003E9C 6500                       		bcs.s	.SetCamX			; If not, branch
00003E9E 3202                       		move.w	d2,d1				; Cap it
00003EA0                            
00003EA0                            .SetCamX:	
00003EA0 31C1 E88A                  		move.w	d1,fgCamXPos.w			; Set the camera's X position
00003EA4                            
00003EA4 0440 0060                  		subi.w	#(224/2)-16,d0			; Get camera's Y position
00003EA8 6C00                       		bge.s	.ChkMaxY			; If it doesn't go beyond the upper boundary, branch
00003EAA 7000                       		moveq	#0,d0				; Cap it
00003EAC                            
00003EAC                            .ChkMaxY:
00003EAC 3438 E8CC                  		move.w	maxCamYPos.w,d2		; Get max camera Y position
00003EB0 B042                       		cmp.w	d2,d0				; Have we gone beyond it?
00003EB2 6D00                       		blt.s	.SetCamY			; If not, branch
00003EB4 3002                       		move.w	d2,d0				; Cap it
00003EB6                            
00003EB6                            .SetCamY:	
00003EB6 31C0 E892                  		move.w	d0,fgCamYPos.w			; Set the camera's Y position
00003EBA                            
00003EBA                            		; --- Load level data ---
00003EBA                            
00003EBA 47F9 0000 0000             		lea	Level_DataPointers,a3		; Level data pointers
00003EC0 3038 C7AE                  		move.w	levelID.w,d0			; Get level ID
00003EC4 E218                       		ror.b	#1,d0				; Turn into offset
00003EC6 E448                       		lsr.w	#2,d0				; ''
00003EC8 47F3 0000                  		lea	(a3,d0.w),a3			; Get pointer to the correct pointers
00003ECC                            
00003ECC 205B                       		movea.l	(a3)+,a0			; Get chunk data pointer
00003ECE 43F9 00FF 0000             		lea	chunkData,a1			; Decompress into chunk table
00003ED4 4EB8 0B06                  		jsr	KosDec.w			; ''
00003ED8                            
00003ED8 205B                       		movea.l	(a3)+,a0			; Get block data pointer
00003EDA 43F8 C7D2                  		lea	blockData.w,a1			; Decompress into block table
00003EDE 4EB8 0B06                  		jsr	KosDec.w			; ''
00003EE2                            
00003EE2 225B                       		movea.l	(a3)+,a1			; Get tile data pointer
00003EE4 7400                       		moveq	#0,d2				; Store in the beginning of VRAM
00003EE6 4EB8 0F5C                  		jsr	QueueKosMData.w			; Queue for decompression
00003EEA                            
00003EEA 205B                       		movea.l	(a3)+,a0			; Get palette data pointer
00003EEC 3018                       		move.w	(a0)+,d0			; Size of palette data
00003EEE 4EB8 053A                  		jsr	LoadTargetPal.w			; Load the palette
00003EF2                            
00003EF2 21DB E856                  		move.l	(a3)+,lvlLayoutFG.w		; Move layout addresses to variables
00003EF6 21DB E85A                  		move.l	(a3)+,lvlLayoutBG.w
00003EFA                            
00003EFA 21DB C7B8                  		move.l	(a3)+,objMgrLayout.w		; Set object position data pointer
00003EFE 21DB E868                  		move.l	(a3)+,ringMgrLayout.w		; Set ring position data pointer
00003F02 265B                       		movea.l	(a3)+,a3			; Get collision data pointers
00003F04 201B                       		move.l	(a3)+,d0			; Get collision data address
00003F06 21C0 E8EA                  		move.l	d0,currentColAddr.w			; Set collision address to primary
00003F0A 21C0 E8E2                  		move.l	d0,primaryColPtr.w			; Set primary collision data pointer
00003F0E 5280                       		addq.l	#1,d0				; Increment address for secondary collision
00003F10 21C0 E8E6                  		move.l	d0,secondaryColPtr.w			; Set secondary collision data pointer
00003F14 43F8 E8F0                  		lea	angleValPtr.w,a1		; Collision pointers
00003F18 22DB                       		move.l	(a3)+,(a1)+			; Set angle value array pointer
00003F1A 22DB                       		move.l	(a3)+,(a1)+			; Set normal hiehgt map array pointer
00003F1C 229B                       		move.l	(a3)+,(a1)			; Set rotated hiehgt map array pointer
00003F1E                            
00003F1E 47F9 0000 0000             		lea	Level_PLCs,a3			; Get PLC list pointer
00003F24 3038 C7AE                  		move.w	levelID.w,d0			; Get level ID
00003F28 E218                       		ror.b	#1,d0				; Turn into offset
00003F2A EA48                       		lsr.w	#5,d0				; ''
00003F2C 2673 0000                  		movea.l	(a3,d0.w),a3			; Get pointer to the correct pointers
00003F30 4EF8 0F4C                  		jmp	LoadKosMQueue.w			; Load the PLCs
00003F34                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003F34                            ; Update the water surface
00003F34                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003F34                            Level_UpdateWaterSurface:
00003F34 4A38 E8FE                  		tst.b	lvlHasWater.w			; Does the level have water?
00003F38 6700                       		beq.s	.End				; If not, branch
00003F3A 3238 E88A                  		move.w	fgCamXPos.w,d1			; Get camera X position
00003F3E 0838 0000 E905             		btst	#0,(lvlFrameCnt+1).w		; Are we on an odd frame?
00003F44 6700                       		beq.s	.SetXPos			; If not, branch
00003F46 0641 0020                  		addi.w	#$20,d1				; Shift X position
00003F4A                            
00003F4A                            .SetXPos:
00003F4A 3001                       		move.w	d1,d0				; Copy X postion
00003F4C 0640 0060                  		addi.w	#$60,d0				; Add surface #1's X position
00003F50 3078 E886                  		movea.w	waterObjPtr1.w,a0
00003F54 3140 0014                  		move.w	d0,_objXPos(a0)			; Set it
00003F58 0641 0120                  		addi.w	#$120,d1			; Add surface #2's X position
00003F5C 3078 E888                  		movea.w	waterObjPtr2.w,a0
00003F60 3141 0014                  		move.w	d1,_objXPos(a0)			; Set it
00003F64                            
00003F64                            .End:
00003F64 4E75                       		rts
00003F66                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003F66                            ; Handle water height
00003F66                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003F66                            Level_WaterHeight:
00003F66 4A38 E8FE                  		tst.b	lvlHasWater.w			; Does the level have water?
00003F6A 6700                       		beq.s	.End				; If not, branch
00003F6C 6100 0000                  		bsr.w	Level_MoveWater			; Move the water when appropriate
00003F70 4238 E8FF                  		clr.b	waterFullscr.w		; Clear water fullscreen flag
00003F74                            
00003F74 7201                       		moveq	#1,d1				; Water movement speed
00003F76 3038 E902                  		move.w	destWaterYPos.w,d0		; Get destination water level
00003F7A 9078 E900                  		sub.w	waterYPos.w,d0		; Is the current water level at that destination?
00003F7E 6700                       		beq.s	.ChkOnScr			; If so, branch
00003F80 6400                       		bcc.s	.MoveDown			; If it needs to go down, branch
00003F82 4441                       		neg.w	d1				; Go up
00003F84                            
00003F84                            .MoveDown:
00003F84 D378 E900                  		add.w	d1,waterYPos.w		; Move water
00003F88                            
00003F88                            .ChkOnScr:
00003F88 3038 E900                  		move.w	waterYPos.w,d0		; Get water height
00003F8C 9078 E892                  		sub.w	fgCamYPos.w,d0			; Get camera's Y position
00003F90 6700                       		beq.s	.Fullscreen			; If they are the same, branch
00003F92 6400                       		bcc.s	.ChkBottom			; If the water height is below the top of the camera, branch
00003F94                            		
00003F94                            .Fullscreen:
00003F94 50F8 E8FF                  		st	waterFullscr.w		; Set water fullscreen flag
00003F98 50F8 C761                  		st	hIntCntValue.w			; Set H-INT counter to be offscreen
00003F9C 4E75                       		rts
00003F9E                            
00003F9E                            .ChkBottom:
00003F9E 0C40 00DF                  		cmpi.w	#224-1,d0			; Is the water below the camera?
00003FA2 6500                       		blo.s	.SetCounter			; If not, branch
00003FA4 70FF                       		moveq	#-1,d0				; Set H-INT counter to be offscreen
00003FA6                            
00003FA6                            .SetCounter:
00003FA6 11C0 C761                  		move.b	d0,hIntCntValue.w			; Set H-INT counter
00003FAA                            
00003FAA                            .End:
00003FAA 4E75                       		rts
00003FAC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003FAC                            Level_MoveWater:
00003FAC 4E75                       		rts
00003FAE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003FAE                            ; Do level palette cycling
00003FAE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003FAE                            Level_PalCycle:
00003FAE 41F9 0000 0000             		lea	Level_PalCycRouts,a0		; Palette cycle routines
00003FB4 3038 C7AE                  		move.w	levelID.w,d0			; Get level ID
00003FB8 E218                       		ror.b	#1,d0				; Turn into offset
00003FBA EA48                       		lsr.w	#5,d0				; ''
00003FBC 2070 0000                  		movea.l	(a0,d0.w),a0			; Get correct routine pointer
00003FC0 4ED0                       		jmp	(a0)				; Jump to it
00003FC2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003FC2                            ; Do level art animation
00003FC2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003FC2                            Level_AnimateArt:
00003FC2 41F9 0000 0000             		lea	Level_AniArtRouts,a0		; Animated art routines
00003FC8 3038 C7AE                  		move.w	levelID.w,d0			; Get level ID
00003FCC E218                       		ror.b	#1,d0				; Turn into offset
00003FCE EA48                       		lsr.w	#5,d0				; ''
00003FD0 2070 0000                  		movea.l	(a0,d0.w),a0			; Get correct routine pointer
00003FD4 4ED0                       		jmp	(a0)				; Jump to it
00003FD6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003FD6                            ; Do dynamic events
00003FD6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003FD6                            Level_DynEvents:
00003FD6 41F9 0000 0000             		lea	Level_DynEvenRouts,a0		; Dynamic events routines
00003FDC 3038 C7AE                  		move.w	levelID.w,d0			; Get level ID
00003FE0 E218                       		ror.b	#1,d0				; Turn into offset
00003FE2 EA48                       		lsr.w	#5,d0				; ''
00003FE4 2070 0000                  		movea.l	(a0,d0.w),a0			; Get correct routine pointer
00003FE8 4ED0                       		jmp	(a0)				; Jump to it
00003FEA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003FEA                            ; Handle the camera
00003FEA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003FEA                            Level_HandleCamera:
00003FEA 3078 E876                  		movea.w	playerPtrP1.w,a0		; Get player object
00003FEE                            		
00003FEE 4A38 E8DA                  		tst.b	camLockX.w			; Is the camera locked horizontally?
00003FF2 6600                       		bne.s	.ChkY				; If so, branch
00003FF4 43F8 E88A                  		lea	fgCamXPos.w,a1			; Get foreground level variables
00003FF8 6100                       		bsr.s	Level_MoveCameraX		; Move the camera horiozntally
00003FFA                            		
00003FFA                            .ChkY:
00003FFA 4A38 E8DB                  		tst.b	camLockY.w			; Is the camera locked vertically?
00003FFE 6600                       		bne.s	.ChkMaxY			; If not, branch
00004000 43F8 E892                  		lea	fgCamYPos.w,a1			; Get foreground level variables
00004004 3638 E8D8                  		move.w	panCamYPos.w,d3		; Get camera Y distance
00004008 6100 0000                  		bsr.w	Level_MoveCameraY		; Move the camera vertically
0000400C                            
0000400C                            .ChkMaxY:
0000400C 7202                       		moveq	#2,d1				; Target camera scroll speed
0000400E 3038 E8C8                  		move.w	targetMaxCamY.w,d0		; Get distance between target and actual target max camera Y position
00004012 9078 E8CC                  		sub.w	maxCamYPos.w,d0		; ''
00004016 6700                       		beq.s	.End				; If it's 0, branch
00004018 6400                       		bcc.s	.MoveDown			; If it's positive, branch
0000401A 3038 E892                  		move.w	fgCamYPos.w,d0			; Get current camera Y position
0000401E B078 E8C8                  		cmp.w	targetMaxCamY.w,d0		; Is it past the boundary?
00004022 6300                       		bls.s	.ScrollUp			; If not, branch
00004024 31C0 E8CC                  		move.w	d0,maxCamYPos.w		; Set max camera Y position
00004028 0278 FFFE E8CC             		andi.w	#$FFFE,maxCamYPos.w		; Keep it a multiple of 2
0000402E                            
0000402E                            .ScrollUp:
0000402E 9378 E8CC                  		sub.w	d1,maxCamYPos.w		; Scroll up
00004032 50F8 E8DC                  		st	chgCamMaxY.w			; Indicate that the max Y boundary is changing
00004036                            
00004036                            
00004036                            .End:
00004036 4E75                       		rts
00004038                            
00004038                            .MoveDown:
00004038 3038 E892                  		move.w	fgCamYPos.w,d0			; Get current camera Y position
0000403C 5040                       		addq.w	#8,d0				; ''
0000403E B078 E8CC                  		cmp.w	maxCamYPos.w,d0		; Is it past the boundary?
00004042 6500                       		bcs.s	.ScrollDown			; If not, branch
00004044 0828 0001 0028             		btst	#1,_objStatus(a0)		; Is the player in the air?
0000404A 6700                       		beq.s	.ScrollDown			; If not, branch
0000404C D241                       		add.w	d1,d1				; Scroll down faster
0000404E D241                       		add.w	d1,d1				; ''
00004050                            
00004050                            .ScrollDown:
00004050 D378 E8CC                  		add.w	d1,maxCamYPos.w		; Scroll down
00004054 50F8 E8DC                  		st	chgCamMaxY.w			; Indicate that the max Y boundary is changing
00004058 4E75                       		rts
0000405A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000405A                            Level_MoveCameraX:
0000405A 3028 0014                  		move.w	_objXPos(a0),d0			; Get the player's X position
0000405E 9051                       		sub.w	(a1),d0				; Get distance from the camera's X position
00004060 9078 E8D6                  		sub.w	panCamXPos.w,d0		; Subtract center
00004064 6D00                       		blt.s	.MoveLeft			; If we are going left, branch
00004066 6C00                       		bge.s	.MoveRight			; If we are going right, branch
00004068 4E75                       		rts
0000406A                            
0000406A                            .MoveLeft:
0000406A 0C40 FFF0                  		cmpi.w	#-16,d0				; Is the camera moving more than 16 pixels per frame?
0000406E 6E00                       		bgt.s	.ChkLeftBound			; If not, branch
00004070 303C FFF0                  		move.w	#-16,d0				; Keep the camera from moving too fast
00004074                            
00004074                            .ChkLeftBound:
00004074 D051                       		add.w	(a1),d0				; Add back the camera's X position
00004076 B078 E8D2                  		cmp.w	minCamXPos.w,d0		; Have we gone past the left boundary?
0000407A 6E00                       		bgt.s	.SetCamX			; If not, branch
0000407C 3038 E8D2                  		move.w	minCamXPos.w,d0		; Cap at the left boundary
00004080 6000                       		bra.s	.SetCamX			; Continue
00004082                            
00004082                            .MoveRight:
00004082 0C40 0010                  		cmpi.w	#16,d0				; Is the camera moving more than 16 pixels per frame?
00004086 6500                       		blo.s	.ChkRightBound			; If not, branch
00004088 303C 0010                  		move.w	#16,d0				; Keep the camera from moving too fast
0000408C                            
0000408C                            .ChkRightBound:
0000408C D051                       		add.w	(a1),d0				; Add back the camera's X position
0000408E B078 E8CA                  		cmp.w	maxCamXPos.w,d0		; Has the camera gone beyond the right boundary?
00004092 6D00                       		blt.s	.SetCamX			; If not, branch
00004094 3038 E8CA                  		move.w	maxCamXPos.w,d0		; Cap at the right boundary
00004098                            
00004098                            .SetCamX:
00004098 3280                       		move.w	d0,(a1)				; Set the new camera X position
0000409A 4E75                       		rts
0000409C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000409C                            Level_MoveCameraY:
0000409C 7200                       		moveq	#0,d1
0000409E 3028 0018                  		move.w	_objYPos(a0),d0			; Get the player's Y position
000040A2 9051                       		sub.w	(a1),d0				; Get distance from the camera's Y position
000040A4                            
000040A4 0828 0002 0028             		btst	#2,_objStatus(a0)			; Is the player rolling?
000040AA 6700                       		beq.s	.NoRoll				; If not, branch
000040AC 5B40                       		subq.w	#5,d0				; Move up some
000040AE                            
000040AE                            .NoRoll:
000040AE 0828 0001 0028             		btst	#1,_objStatus(a0)			; Is the player in the air?
000040B4 6700                       		beq.s	.ChkBoundCross_Ground		; If not, branch
000040B6                            
000040B6                            .ChkBoundCross_Air:
000040B6 0640 0020                  		addi.w	#$20,d0				; You have 32 pixels above and below to move without disturbing the camera
000040BA 9043                       		sub.w	d3,d0				; Subtract camera Y distance
000040BC 6500                       		bcs.s	.ScrollFast			; If the player is above the boundary, branch
000040BE 0440 0040                  		subi.w	#$40,d0				; Subtract 64
000040C2 6400                       		bcc.s	.ScrollFast			; If the player is below the boundary, branch
000040C4                            
000040C4 4A38 E8DC                  		tst.b	chgCamMaxY.w			; Is the max Y boundary changing?
000040C8 6600                       		bne.s	.ScrollMaxYChange		; If so, branch
000040CA 6000                       		bra.s	.NoScroll			; Continue
000040CC                            
000040CC                            .ChkBoundCross_Ground:
000040CC 9043                       		sub.w	d3,d0				; Subtract camera Y distance
000040CE 6600                       		bne.s	.DecideScrollType		; If the player moved, branch
000040D0 4A38 E8DC                  		tst.b	chgCamMaxY.w			; Is the max Y boundary changing?
000040D4 6600                       		bne.s	.ScrollMaxYChange		; If so, branch
000040D6                            
000040D6                            .NoScroll:
000040D6 4E75                       		rts		
000040D8                            
000040D8                            .DecideScrollType:
000040D8 0C43 0060                  		cmpi.w	#(224/2)-16,d3			; Is the camera Y distance normal?
000040DC 6600                       		bne.s	.ScrollSlow			; If not, branch
000040DE                            
000040DE 3228 0000                  		move.w	_objGVel(a0),d1			; Get the players' ground velocity
000040E2 6A00                       		bpl.s	.Positive			; If it's positive, branch
000040E4 4441                       		neg.w	d1				; Force it to be positive
000040E6                            
000040E6                            .Positive:
000040E6 0C41 0800                  		cmpi.w	#$800,d1			; Is the player travelling very fast?
000040EA 6400                       		bhs.s	.ScrollFast			; If so, branch
000040EC                            
000040EC                            .ScrollMedium:
000040EC 323C 0600                  		move.w	#6<<8,d1			; Cap camera movement at 6 if going too fast
000040F0 0C40 0006                  		cmpi.w	#6,d0				; Is the player going down too fast?
000040F4 6E00                       		bgt.s	.ScrollDownMax			; If so, branch
000040F6 0C40 FFFA                  		cmpi.w	#-6,d0				; Is the player going up too fast?
000040FA 6D00                       		blt.s	.ScrollUpMax			; If so, branch
000040FC 6000                       		bra.s	.ScrollUpOrDown			; Continue
000040FE                            
000040FE                            .ScrollSlow:
000040FE 323C 0200                  		move.w	#2<<8,d1			; Cap camera movement at 2 if going too fast
00004102 0C40 0002                  		cmpi.w	#2,d0				; Is the player going down too fast?
00004106 6E00                       		bgt.s	.ScrollDownMax			; If so, branch
00004108 0C40 FFFE                  		cmpi.w	#-2,d0				; Is the player going up too fast?
0000410C 6D00                       		blt.s	.ScrollUpMax			; If so, branch
0000410E 6000                       		bra.s	.ScrollUpOrDown			; Continue
00004110                            
00004110                            .ScrollFast:
00004110 323C 1000                  		move.w	#16<<8,d1			; Cap camera movement at 16 if going too fast
00004114 0C40 0010                  		cmpi.w	#16,d0				; Is the player going down too fast?
00004118 6E00                       		bgt.s	.ScrollDownMax			; If so, branch
0000411A 0C40 FFF0                  		cmpi.w	#-16,d0				; Is the player going up too fast?
0000411E 6D00                       		blt.s	.ScrollUpMax			; If so, branch
00004120 6000                       		bra.s	.ScrollUpOrDown			; Continue
00004122                            
00004122                            .ScrollMaxYChange:
00004122 7000                       		moveq	#0,d0				; Distance for the camera to move = 0
00004124 11C0 E8DC                  		move.b	d0,chgCamMaxY.w		; Clear the max Y boundary changing flag
00004128                            		
00004128                            .ScrollUpOrDown:
00004128 7200                       		moveq	#0,d1
0000412A 3200                       		move.w	d0,d1				; Get position difference
0000412C D251                       		add.w	(a1),d1				; Add old camera Y position
0000412E 4A40                       		tst.w	d0				; Is the camera to scroll down?
00004130 6A00                       		bpl.s	.ScrollDown			; If so, branch
00004132 6000 0000                  		bra.w	.ScrollUp			; Scroll up
00004136                            
00004136                            .ScrollUpMax:
00004136 4441                       		neg.w	d1				; Make the value negative, since we are going up
00004138 48C1                       		ext.l	d1
0000413A E181                       		asl.l	#8,d1				; Move into upper word tp lie up with the actual value for the Y position
0000413C D291                       		add.l	(a1),d1				; Add the camera's Y position
0000413E 4841                       		swap	d1				; Get the actual Y position
00004140                            
00004140                            .ScrollUp:
00004140 B278 E8D4                  		cmp.w	minCamYPos.w,d1		; Has the camera gone beyond the upper boundary?
00004144 6E00                       		bgt.s	.DoScroll			; If not, branch
00004146 3238 E8D4                  		move.w	minCamYPos.w,d1		; Cap at upper boundary
0000414A 6000                       		bra.s	.DoScroll			; Continue
0000414C                            
0000414C                            .ScrollDownMax:
0000414C 48C1                       		ext.l	d1
0000414E E181                       		asl.l	#8,d1				; Move into upper word tp lie up with the actual value for the Y position
00004150 D291                       		add.l	(a1),d1				; Add the camera's Y position
00004152 4841                       		swap	d1				; Get the actual Y position
00004154                            
00004154                            .ScrollDown:
00004154 B278 E8CC                  		cmp.w	maxCamYPos.w,d1		; Has the camera gone beyond the lower boundary?
00004158 6D00                       		blt.s	.DoScroll			; If not, branch
0000415A 3238 E8CC                  		move.w	maxCamYPos.w,d1		; Cap at lower boundary
0000415E                            
0000415E                            .DoScroll:
0000415E 4841                       		swap	d1				; Put Y coordinate in the higher word
00004160 2281                       		move.l	d1,(a1)				; Set Y position
00004162 4E75                       		rts
00004164                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004164                            ; Level ring manager
00004164                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004164                            Level_RingsManager:
00004164 7000                       		moveq	#0,d0
00004166 1038 E866                  		move.b	ringMgrRoutine.w,d0		; Get routine
0000416A 303B 0000                  		move.w	.Routines(pc,d0.w),d0		; Get offset
0000416E 4EFB 0000                  		jmp	.Routines(pc,d0.w)		; Jump to the right routine
00004172                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004172                            .Routines:
00004172 0000                       		dc.w	Level_RingsManagerInit-.Routines
00004174 0000                       		dc.w	Level_RingsManagerMain-.Routines
00004176                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004176                            ; Ring manager initialization
00004176                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004176                            Level_RingsManagerInit:
00004176 5438 E866                  		addq.b	#2,ringMgrRoutine.w		; The next time the manager is run, only go to the main routine
0000417A                            		
0000417A 6100 0000                  		bsr.w	Level_RingsManagerSetup	; Prepare the tables and load the ring data
0000417E                            
0000417E                            		; Set up the addresses to use in the current location of the level
0000417E                            
0000417E                            		; Start at the left side of the screen
0000417E                            		; We get the location of the first ring that shows up at the left side of the screen in the data and store that
0000417E                            
0000417E 2278 E86C                  		movea.l	ringMgrLoadL.w,a1		; Get current ring data address for the left side of the screen
00004182 45F8 DFD2                  		lea	ringStatus.w,a2		; Ring status table
00004186 3838 E88A                  		move.w	fgCamXPos.w,d4			; Get camera's X position
0000418A 5144                       		subq.w	#8,d4				; Check 8 pixels to the left of it
0000418C 6200                       		bhi.s	.CheckLeftSide			; Branch if not beyond 0
0000418E 7801                       		moveq	#1,d4				; Cap left side to 1
00004190 6000                       		bra.s	.CheckLeftSide			; Start checking
00004192                            
00004192                            .NextLeftRing:
00004192 5849                       		addq.w	#4,a1				; Next ring in ring data
00004194 544A                       		addq.w	#2,a2				; Next ring in status table
00004196                            
00004196                            .CheckLeftSide:
00004196 B851                       		cmp.w	(a1),d4				; Is this ring located to the right of the left boundary?
00004198 62F8                       		bhi.s	.NextLeftRing			; If not, get the next ring
0000419A 21C9 E86C                  		move.l	a1,ringMgrLoadL.w		; Store starting ring data address
0000419E 31CA E874                  		move.w	a2,ringMgrStatPtr.w		; Store ring status address
000041A2                            
000041A2                            		; Now the right side of the screen
000041A2                            		; We get the location of the first ring that goes beyond the right side of the screen in the data and store that
000041A2                            
000041A2 0644 0150                  		addi.w	#320+16,d4			; Right boundary
000041A6 6000                       		bra.s	.CheckRightSide			; Start checking
000041A8                            
000041A8                            .NextRightRing:
000041A8 5849                       		addq.w	#4,a1				; Next ring in ring data
000041AA                            
000041AA                            .CheckRightSide:
000041AA B851                       		cmp.w	(a1),d4				; Is this ring located to the right of the right boundary?
000041AC 62FA                       		bhi.s	.NextRightRing			; If not, get the next ring
000041AE 21C9 E870                  		move.l	a1,ringMgrLoadR.w		; Store ending ring data address
000041B2 4E75                       		rts
000041B4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000041B4                            ; Ring manager main routine
000041B4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000041B4                            Level_RingsManagerMain:
000041B4 6100 0000                  		bsr.w	Level_RingsManagerDoCollect	; Handle ring collection
000041B8                            
000041B8 2278 E86C                  		movea.l	ringMgrLoadL.w,a1		; Get the current starting address for the ring data
000041BC 3478 E874                  		movea.w	ringMgrStatPtr.w,a2		; Get the current starting address for the status table
000041C0                            		
000041C0                            		; Get the new starting addresses for ring data
000041C0                            		; This is done by getting to a point from the current starting address where there's a ring onscreen
000041C0                            		; and then going back to get the very first ring that's on screen
000041C0                            
000041C0 3838 E88A                  		move.w	fgCamXPos.w,d4			; Get camera's X position
000041C4 5144                       		subq.w	#8,d4				; Check 8 pixels to the left of it
000041C6 6200                       		bhi.s	.CheckNewLeftSide		; Branch if not beyond 0
000041C8 7801                       		moveq	#1,d4				; Cap left side to 1
000041CA 6000                       		bra.s	.CheckNewLeftSide		; Start checking
000041CC                            
000041CC                            .NextNewLeftRing:
000041CC 5849                       		addq.w	#4,a1				; Next ring in ring data
000041CE 544A                       		addq.w	#2,a2				; Next ring in status table
000041D0                            
000041D0                            .CheckNewLeftSide:
000041D0 B851                       		cmp.w	(a1),d4				; Is this ring located to the right of the left boundary?
000041D2 62F8                       		bhi.s	.NextNewLeftRing		; If not, get the next ring
000041D4 6000                       		bra.s	.CheckNewLeftSide2		; Start checking
000041D6                            
000041D6                            .NextNewLeftRing2:
000041D6 5949                       		subq.w	#4,a1				; Previous ring in ring data
000041D8 554A                       		subq.w	#2,a2				; Previous ring in status table
000041DA                            
000041DA                            .CheckNewLeftSide2:
000041DA B869 FFFC                  		cmp.w	-4(a1),d4			; Is this ring located to the left of the left boundary?
000041DE 63F6                       		bls.s	.NextNewLeftRing2		; If not, get the next ring
000041E0 21C9 E86C                  		move.l	a1,ringMgrLoadL.w		; Store starting ring data address
000041E4 31CA E874                  		move.w	a2,ringMgrStatPtr.w		; Store ring status address
000041E8                            
000041E8                            		; Now get the new ending addresses for ring data
000041E8                            		; This is done by getting to a point from the current starting address where there's a ring at the right of the left boundary
000041E8                            		; and then going back to get the very first ring that's on screen on the left side
000041E8                            
000041E8 2278 E870                  		movea.l	ringMgrLoadR.w,a1		; Get the current ending address for the ring data
000041EC                            
000041EC 0644 0150                  		addi.w	#320+16,d4			; Right boundary
000041F0 6000                       		bra.s	.CheckNewRightSide		; Start checking
000041F2                            
000041F2                            .NextNewRightRing:
000041F2 5849                       		addq.w	#4,a1				; Next ring in ring data
000041F4                            
000041F4                            .CheckNewRightSide:
000041F4 B851                       		cmp.w	(a1),d4				; Is this ring located to the right of the right boundary?
000041F6 62FA                       		bhi.s	.NextNewRightRing		; If not, get the next ring
000041F8 6000                       		bra.s	.CheckNewRightSide2		; Start checking
000041FA                            
000041FA                            .NextNewRightRing2:
000041FA 5949                       		subq.w	#4,a1				; Previous ring in ring data
000041FC                            
000041FC                            .CheckNewRightSide2:
000041FC B869 FFFC                  		cmp.w	-4(a1),d4			; Is this ring located to the left of the right boundary?
00004200 63F8                       		bls.s	.NextNewRightRing2		; If not, get the next ring
00004202 21C9 E870                  		move.l	a1,ringMgrLoadR.w		; Store ending ring data address
00004206 4E75                       		rts
00004208                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004208                            ; Handle ring collection
00004208                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004208                            Level_RingsManagerDoCollect:
00004208 45F8 E3D2                  		lea	ringCollect.w,a2			; Ring collection table
0000420C 321A                       		move.w	(a2)+,d1			; Get consumed ring count
0000420E 5341                       		subq.w	#1,d1				; SutbactID 1
00004210 6500                       		bcs.s	.End				; If there are no consumed rings to handle, branch
00004212                            
00004212                            .Loop:
00004212 301A                       		move.w	(a2)+,d0			; Get ring status address
00004214 67FC                       		beq.s	.Loop				; If 0, get the next ring
00004216 3240                       		movea.w	d0,a1				; Save in a1
00004218 5311                       		subq.b	#1,(a1)				; Decrement timer
0000421A 6600                       		bne.s	.Next				; If nonzero, branch
0000421C 12BC 0006                  		move.b	#6,(a1)				; Reset timer
00004220 5229 0001                  		addq.b	#1,1(a1)			; Increment frame
00004224                            							; Is it the last frame?
00004224 0C29 0000 0001             		cmpi.b	#(CMap_Ring_Sparkle_Last-CMap_Ring)/8,1(a1)
0000422A 6600                       		bne.s	.Next				; If not, branch
0000422C 32BC FFFF                  		move.w	#-1,(a1)			; Set timer and frame to -1
00004230 426A FFFE                  		clr.w	-2(a2)				; Set address in collection table to 0
00004234 5378 E3D2                  		subq.w	#1,ringColCount.w		; Decrement collection table count
00004238                            
00004238                            .Next:
00004238 51C9 FFD8                  		dbf	d1,.Loop			; Loop
0000423C                            
0000423C                            .End:
0000423C 4E75                       		rts
0000423E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000423E                            ; Set up the tables and load ring data
0000423E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000423E                            Level_RingsManagerSetup:
0000423E                            		; Clear tables
0000423E                            		clrRAM	ringStatus
0000423E                          M 	local	endaddr
0000423E                          M endaddr	equs	"ringstatus_End"
0000423E 7000                     M 	moveq	#0,d0
00004240 43F8 DFD2                M 	lea	(ringstatus).w,a1
00004244 323C 00FF                M 	move.w	#(((ringstatus_end)-(ringstatus))-((ringstatus)&1))>>2-1,d1
00004248 22C0                     M .clear_182:	move.l	d0,(a1)+
0000424A 51C9 FFFC                M 	dbf	d1,.clear_182
0000424E                            		clrRAM	ringCollect
0000424E                          M 	local	endaddr
0000424E                          M endaddr	equs	"ringcollect_End"
0000424E 7000                     M 	moveq	#0,d0
00004250 43F8 E3D2                M 	lea	(ringcollect).w,a1
00004254 323C 001F                M 	move.w	#(((ringcollect_end)-(ringcollect))-((ringcollect)&1))>>2-1,d1
00004258 22C0                     M .clear_183:	move.l	d0,(a1)+
0000425A 51C9 FFFC                M 	dbf	d1,.clear_183
0000425E                            
0000425E 2278 E868                  		movea.l	ringMgrLayout.w,a1		; Get ring data pointer
00004262 21C9 E86C                  		move.l	a1,ringMgrLoadL.w		; Store address
00004266 5849                       		addq.w	#4,a1				; Increment address by 4
00004268 7A00                       		moveq	#0,d5				; Initialize the ring counter
0000426A 303C 01FE                  		move.w	#$1FE,d0			; Max number of ring
0000426E                            
0000426E                            .GetRingCount:
0000426E 4A99                       		tst.l	(a1)+				; Have all the ring been counted?
00004270 6B00                       		bmi.s	.Exit				; If so, branch
00004272 5245                       		addq.w	#1,d5				; Increment ring counter
00004274 51C8 FFF8                  		dbf	d0,.GetRingCount		; Loop
00004278                            
00004278                            .Exit:
00004278 4E75                       		rts
0000427A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000427A                            ; Do ring collision for the player
0000427A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000427A                            PlayeringCollectlision:
0000427A 0C28 0069 0000             		cmpi.b	#105,_objInvulTime(a0)		; Is the player able to collect rings while hurt?
00004280 6400 0000                  		bhs.w	.End				; If it hasn't been long enough, branch
00004284 2278 E86C                  		movea.l	ringMgrLoadL.w,a1		; Get starting address of ring data
00004288 2478 E870                  		movea.l	ringMgrLoadR.w,a2		; Get starting address of status table
0000428C B5C9                       		cmpa.l	a1,a2				; Are there any rings to test collision with?
0000428E 6700 0000                  		beq.w	.End				; If not, branch
00004292 3878 E874                  		movea.w	ringMgrStatPtr.w,a4
00004296 3428 0014                  		move.w	_objXPos(a0),d2			; Player's X position
0000429A 3628 0018                  		move.w	_objYPos(a0),d3			; Player's Y position
0000429E 5142                       		subq.w	#8,d2				; Subtract 8 from X
000042A0 7A00                       		moveq	#0,d5
000042A2 1A28 002D                  		move.b	_objColH(a0),d5			; Player's collision height
000042A6 5705                       		subq.b	#3,d5				; Subtract 3 from collision height
000042A8 9645                       		sub.w	d5,d3				; Subtract from Y
000042AA 323C 0006                  		move.w	#6,d1
000042AE 3C3C 000C                  		move.w	#$C,d6
000042B2 383C 0010                  		move.w	#$10,d4				; Width
000042B6 DA45                       		add.w	d5,d5				; Double the height
000042B8                            
000042B8                            .NextRing:
000042B8 4A54                       		tst.w	(a4)				; Is the current ring already consumed?
000042BA 6600                       		bne.s	.GetNext			; If so, get the next ring
000042BC 3011                       		move.w	(a1),d0				; Get ring's X position
000042BE 9041                       		sub.w	d1,d0				; Subtract the player's X from the ring's X
000042C0 9042                       		sub.w	d2,d0				; Check collision
000042C2 6400                       		bcc.s	.ChkCol
000042C4 D046                       		add.w	d6,d0
000042C6 6500                       		bcs.s	.ChkCol2
000042C8 6000 0000                  		bra.w	.GetNext			; If no collision, get the next ring
000042CC                            
000042CC                            .ChkCol:
000042CC B044                       		cmp.w	d4,d0				; Check collision
000042CE 6200 0000                  		bhi.w	.GetNext			; If no collision, get the next ring
000042D2                            
000042D2                            .ChkCol2:
000042D2 3029 0002                  		move.w	2(a1),d0			; Do Y collision check
000042D6 9041                       		sub.w	d1,d0
000042D8 9043                       		sub.w	d3,d0
000042DA 6400                       		bcc.s	.ChkCol3
000042DC D046                       		add.w	d6,d0
000042DE 6500                       		bcs.s	.Collect
000042E0 6000 0000                  		bra.w	.GetNext			; If no collision, get the next ring
000042E4                            
000042E4                            .ChkCol3:
000042E4 B045                       		cmp.w	d5,d0
000042E6 6200 0000                  		bhi.w	.GetNext			; If no collision, get the next ring
000042EA                            
000042EA                            .Collect:
000042EA                            							; Consume the ring
000042EA 38BC 0000                  		move.w	#(6<<8)|((CMap_Ring_Sparkle-CMap_Ring)/8),(a4)
000042EE 6100                       		bsr.s	CollectRing			; Collect it
000042F0 47F8 E3D4                  		lea	ringColList.w,a3		; Get collection list
000042F4                            
000042F4                            .Consume:
000042F4 4A5B                       		tst.w	(a3)+				; Has this slot been used up?
000042F6 66FC                       		bne.s	.Consume			; If not, get the next one
000042F8 370C                       		move.w	a4,-(a3)			; Save the status table RAM address for the current ring
000042FA 5278 E3D2                  		addq.w	#1,ringColCount.w		; Add to the number of rings consumed
000042FE                            
000042FE                            .GetNext:
000042FE 5849                       		addq.w	#4,a1				; Next ring in ring data
00004300 544C                       		addq.w	#2,a4				; Next ring in status table
00004302 B5C9                       		cmpa.l	a1,a2				; Have we reached the end?
00004304 6600 FFB2                  		bne.w	.NextRing			; If not, loop
00004308                            
00004308                            .End:
00004308 4E75                       		rts
0000430A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000430A                            ; Collect a ring
0000430A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000430A                            CollectRing:
0000430A 5278 E85E                  		addq.w	#1,ringCount.w			; Incremment ring count
0000430E 50F8 E867                  		st	hudUpdateRings.w			; Update ring counter in HUD
00004312                            		playSnd	#sRing, 2			; Play ring sound
00004312 11FC 008C C4BD           M 	move.b	#sring,(mqueue+((2)-1)).w
00004318 4E75                       		rts
0000431A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000431A                            ; Render the HUD
0000431A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000431A                            Level_RenderHUDAndRings:
0000431A 7C00                       		moveq	#0,d6				; Clear render flags
0000431C 7802                       		moveq	#1*2,d4				; Standard frame
0000431E 4A78 E85E                  		tst.w	ringCount.w			; Do we have 0 rings?
00004322 6600                       		bne.s	.Not0Rings			; If not, branch
00004324 0838 0003 E905             		btst	#3,(lvlFrameCnt+1).w		; Can the timer blink?
0000432A 6600                       		bne.s	.Not0Rings			; If not, branch
0000432C 7800                       		moveq	#0*2,d4				; Set frame to blink the timer
0000432E                            
0000432E                            .Not0Rings:
0000432E 3A3C 8680                  		move.w	#$8680,d5			; Tile properties
00004332                            		
00004332 303C 0090                  		move.w	#16+128,d0			; X position
00004336 323C 0088                  		move.w	#8+128,d1			; Y position
0000433A 43FA 0000                  		lea	Map_HUD(pc),a1			; Mappings
0000433E D2F1 4000                  		adda.w	(a1,d4.w),a1			; Get address of frame
00004342 3819                       		move.w	(a1)+,d4			; Get number of sprites in the frame
00004344 5344                       		subq.w	#1,d4				; Subtract 1 from sprite count
00004346 4EB8 0852                  		jsr	DrawSprite.w			; Draw the HUD frame
0000434A                            
0000434A                            .RenderingCount:
0000434A 2078 E86C                  		movea.l	ringMgrLoadL.w,a0			; Get starting address of ring data
0000434E 2438 E870                  		move.l	ringMgrLoadR.w,d2			; Get ending address of ring data
00004352 9488                       		sub.l	a0,d2				; Get length of the data to read
00004354 6700                       		beq.s	.End				; If zero length, branch
00004356 3878 E874                  		movea.w	ringMgrStatPtr.w,a4		; Get starting address of status table
0000435A 43FA 0000                  		lea	CMap_Ring(pc),a1		; Get mappings pointer
0000435E 3A3C 00F0                  		move.w	#224+16,d5			; Get bottom screen boundary
00004362                            		
00004362                            .Loop:
00004362 4A5C                       		tst.w	(a4)+				; Is this ring collected?
00004364 6B00                       		bmi.s	.Next				; If so, branch
00004366 3228 0002                  		move.w	2(a0),d1			; Get Y position
0000436A 926B 0008                  		sub.w	cYPos(a3),d1			; Subtract camera's Y position to get screen position
0000436E 5041                       		addq.w	#8,d1				; Add 8
00004370 B245                       		cmp.w	d5,d1				; Is it below the bottom of the screen?
00004372 6400                       		bhs.s	.Next				; If so, branch
00004374 0641 0078                  		addi.w	#120,d1				; Add 120 to move it within screen space
00004378 3010                       		move.w	(a0),d0				; Get X position
0000437A 9053                       		sub.w	cXPos(a3),d0			; Subtract camera's X position to get screen position
0000437C 0640 0080                  		addi.w	#128,d0				; Add 128 to move it within screen space
00004380 7C00                       		moveq	#0,d6
00004382 1C2C FFFF                  		move.b	-1(a4),d6			; Get frame
00004386                            
00004386                            .Draw:
00004386 E74E                       		lsl.w	#3,d6				; Turn frame ID into offset
00004388 45F1 6000                  		lea	(a1,d6.w),a2			; Get address of frame map data
0000438C D25A                       		add.w	(a2)+,d1			; Add Y offset
0000438E 3CC1                       		move.w	d1,(a6)+			; Save Y position
00004390 3C1A                       		move.w	(a2)+,d6			; Get sprite size
00004392 1C86                       		move.b	d6,(a6)				; Save it
00004394 544E                       		addq.w	#2,a6				; Skip link value
00004396 3CDA                       		move.w	(a2)+,(a6)+			; Save base tile ID and properites
00004398 D05A                       		add.w	(a2)+,d0			; Add X offset
0000439A 3CC0                       		move.w	d0,(a6)+			; Save X position
0000439C 5347                       		subq.w	#1,d7				; Decrement the number of sprites left available
0000439E                            
0000439E                            .Next:
0000439E 5848                       		addq.w	#4,a0				; Next ring in ring data
000043A0 5942                       		subq.w	#4,d2				; Decrement the ring count
000043A2 66BE                       		bne.s	.Loop				; If there are still rings to check, loop
000043A4                            
000043A4                            .End:
000043A4 4E75                       		rts
000043A6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000043A6                            ; Custom mappings format.
000043A6                            ; Differences include...
000043A6                            ;	No offset table (each sprite assumed to be 8 bytes)
000043A6                            ;	No 'sprite pieces per frame' value (hardcoded to 1)
000043A6                            ;	Sign-extended Y-pos value
000043A6                            ;	Sign-extended sprite size value
000043A6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000043A6                            CMap_Ring:
000043A6                            		; Main ring frame
000043A6 FFF8                       		dc.w	$FFF8
000043A8 0005                       		dc.w	$0005
000043AA 26BC                       		dc.w	$0000+$26BC
000043AC FFF8                       		dc.w	$FFF8
000043AE                            
000043AE                            CMap_Ring_Sparkle:
000043AE                            		; Ring sparkle frame 1
000043AE FFF8                       		dc.w	$FFF8
000043B0 0005                       		dc.w	$0005
000043B2 26B8                       		dc.w	$0000+$26B8
000043B4 FFF8                       		dc.w	$FFF8
000043B6                            		; Ring sparkle frame 2
000043B6 FFF8                       		dc.w	$FFF8
000043B8 0005                       		dc.w	$0005
000043BA 3EB8                       		dc.w	($0000+$26B8)|$1800
000043BC FFF8                       		dc.w	$FFF8
000043BE                            		; Ring sparkle frame 3
000043BE FFF8                       		dc.w	$FFF8
000043C0 0005                       		dc.w	$0005
000043C2 2EB8                       		dc.w	($0000+$26B8)|$800
000043C4 FFF8                       		dc.w	$FFF8
000043C6                            		; Ring sparkle frame 4
000043C6 FFF8                       		dc.w	$FFF8
000043C8 0005                       		dc.w	$0005
000043CA 36B8                       		dc.w	($0000+$26B8)|$1000
000043CC FFF8                       		dc.w	$FFF8
000043CE                            CMap_Ring_Sparkle_Last:
000043CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000043CE                            ; HUD mappings
000043CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000043CE                            Map_HUD:	
000043CE 0000 0000                  		dc.w Map_HUD_4-Map_HUD, Map_HUD_18-Map_HUD	
000043D2                            
000043D2 0003                       Map_HUD_4:	dc.b 0, 3	
000043D4 000D 0002 0000             		dc.b 0, $D, 0, 2, 0, 0	
000043DA 0001 0000 0020             		dc.b 0, 1, 0, 0, 0, $20	
000043E0 0009 000A 0030             		dc.b 0, 9, 0, $A, 0, $30
000043E6                            
000043E6 0003                       Map_HUD_18:	dc.b 0, 3	
000043E8 000D 2002 0000             		dc.b 0, $D, $20, 2, 0, 0	
000043EE 0001 2000 0020             		dc.b 0, 1, $20, 0, 0, $20	
000043F4 0009 000A 0030             		dc.b 0, 9, 0, $A, 0, $30	
000043FA                            		even
000043FA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000043FA                            ; Update the HUD
000043FA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000043FA                            ; PARAMETERS:
000043FA                            ;	a5.l	- VDP data port
000043FA                            ;	a6.l	- VDP control port
000043FA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000043FA                            ; RETURNS:
000043FA                            ;	Nothing
000043FA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000043FA                            Level_UpdateHUD:
000043FA 4A38 E867                  		tst.b	hudUpdateRings.w		; Does the ring counter need to be updated?
000043FE 6700                       		beq.s	.End				; If not, branch
00004400 6B00                       		bmi.s	.DontZero			; If the flag is negative, branch
00004402 6100 0000                  		bsr.w	Level_HUDResetRings		; Reset the ring counter
00004406                            
00004406                            .DontZero:
00004406 4238 E867                  		clr.b	hudUpdateRings.w		; Clear update value
0000440A                            		vdpCmd	move.l,$D140,VRAM,WRITE,d0	; Set VDP command
0000440A 203C 5140 0003           M 	move.l	#((((vram&write)&3)<<30)|(($d140&$3fff)<<16)|(((vram&write)&$fc)<<2)|(($d140&$c000)>>14)),d0
00004410 7200                       		moveq	#0,d1
00004412 3238 E85E                  		move.w	ringCount.w,d1			; Ring count
00004416 6000                       		bra.s	.UpdateRings			; Update the rings counter
00004418                            
00004418                            .End
00004418 4E75                       		rts
0000441A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000441A                            .UpdateRings:
0000441A 7800                       		moveq	#0,d4				; Reset the "draw digit" flag
0000441C 45F9 0000 0000             		lea	HUDMod_100,a2			; Start with the 100s digit
00004422 7C02                       		moveq	#3-1,d6				; Number of digits to draw
00004424 43F9 0000 0000             		lea	ArtUnc_HUDNumbers.l,a1		; HUD numbers
0000442A                            		
0000442A                            .LoadDigit_Loop:
0000442A 7400                       		moveq	#0,d2				; Reset the digit
0000442C 261A                       		move.l	(a2)+,d3			; Get the number that's used to calculute what the current digit is
0000442E                            		
0000442E                            .GetDigit:
0000442E 9283                       		sub.l	d3,d1				; Subtract
00004430 6500                       		bcs.s	.InitDrawDigit			; If it's gone below 0, branch
00004432 5242                       		addq.w	#1,d2				; Increment digit
00004434 60F8                       		bra.s	.GetDigit			; Loop until the digit is corret
00004436                            
00004436                            .InitDrawDigit:
00004436 D283                       		add.l	d3,d1				; Add back
00004438 4A42                       		tst.w	d2				; Is the digit 0?
0000443A 6700                       		beq.s	.DrawDigit			; If so, branch
0000443C 50C4                       		st	d4				; Set the "draw digit" flag
0000443E                            
0000443E                            .DrawDigit:
0000443E 4A04                       		tst.b	d4				; Should we draw the digit?
00004440 6700                       		beq.s	.NextDigit			; If not, branch
00004442 ED4A                       		lsl.w	#6,d2				; Multiply the digit by $40
00004444 2C80                       		move.l	d0,(a6)				; Set the VDP command
00004446 47F1 2000                  		lea	(a1,d2.w),a3			; Get address of the digit art
0000444A                            		rept	16
0000444A                            			move.l	(a3)+,(a5)		; Load the digit art
0000444A                            		endr
0000444A 2A9B                     M 	move.l	(a3)+,(a5)
0000444C 2A9B                     M 	move.l	(a3)+,(a5)
0000444E 2A9B                     M 	move.l	(a3)+,(a5)
00004450 2A9B                     M 	move.l	(a3)+,(a5)
00004452 2A9B                     M 	move.l	(a3)+,(a5)
00004454 2A9B                     M 	move.l	(a3)+,(a5)
00004456 2A9B                     M 	move.l	(a3)+,(a5)
00004458 2A9B                     M 	move.l	(a3)+,(a5)
0000445A 2A9B                     M 	move.l	(a3)+,(a5)
0000445C 2A9B                     M 	move.l	(a3)+,(a5)
0000445E 2A9B                     M 	move.l	(a3)+,(a5)
00004460 2A9B                     M 	move.l	(a3)+,(a5)
00004462 2A9B                     M 	move.l	(a3)+,(a5)
00004464 2A9B                     M 	move.l	(a3)+,(a5)
00004466 2A9B                     M 	move.l	(a3)+,(a5)
00004468 2A9B                     M 	move.l	(a3)+,(a5)
0000446A                            		
0000446A                            .NextDigit:
0000446A 0680 0040 0000             		addi.l	#$400000,d0			; Next digit
00004470 51CE FFB8                  		dbf	d6,.LoadDigit_Loop		; Loop
00004474 4E75                       		rts
00004476                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004476 0000 0064                  HUDMod_100:	dc.l	100
0000447A 0000 000A                  HUDMod_10:	dc.l	10
0000447E 0000 0001                  HUDMod_1:	dc.l	1
00004482                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004482                            ; Initialize the HUD
00004482                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004482                            Level_InitHUD:
00004482 4DF9 00C0 0004             		lea	VDP_CTRL,a6			; VDP data port
00004488 4BEE FFFC                  		lea	-4(a6),a5			; VDP control port
0000448C                            		
0000448C                            Level_HUDResetRings:
0000448C                            		vdpCmd	move.l,$D140,VRAM,WRITE,(a6)	; Set VDP command
0000448C 2CBC 5140 0003           M 	move.l	#((((vram&write)&3)<<30)|(($d140&$3fff)<<16)|(((vram&write)&$fc)<<2)|(($d140&$c000)>>14)),(a6)
00004492 45FA 0000                  		lea	HUD_RingsBase(pc),a2		; Tile base
00004496 343C 0002                  		move.w	#3-1,d2				; Length
0000449A                            
0000449A 43F9 0000 0000             		lea	ArtUnc_HUDNumbers.l,a1		; HUD numbers art
000044A0                            
000044A0                            .LoadTiles:
000044A0 101A                       		move.b	(a2)+,d0			; Get digit
000044A2 4880                       		ext.w	d0
000044A4 ED48                       		lsl.w	#6,d0				; Turn into offset
000044A6 47F1 0000                  		lea	(a1,d0.w),a3			; Get address of digit art
000044AA                            
000044AA                            		rept	8*2
000044AA                            			move.l	(a3)+,(a5)		; Load art
000044AA                            		endr
000044AA 2A9B                     M 	move.l	(a3)+,(a5)
000044AC 2A9B                     M 	move.l	(a3)+,(a5)
000044AE 2A9B                     M 	move.l	(a3)+,(a5)
000044B0 2A9B                     M 	move.l	(a3)+,(a5)
000044B2 2A9B                     M 	move.l	(a3)+,(a5)
000044B4 2A9B                     M 	move.l	(a3)+,(a5)
000044B6 2A9B                     M 	move.l	(a3)+,(a5)
000044B8 2A9B                     M 	move.l	(a3)+,(a5)
000044BA 2A9B                     M 	move.l	(a3)+,(a5)
000044BC 2A9B                     M 	move.l	(a3)+,(a5)
000044BE 2A9B                     M 	move.l	(a3)+,(a5)
000044C0 2A9B                     M 	move.l	(a3)+,(a5)
000044C2 2A9B                     M 	move.l	(a3)+,(a5)
000044C4 2A9B                     M 	move.l	(a3)+,(a5)
000044C6 2A9B                     M 	move.l	(a3)+,(a5)
000044C8 2A9B                     M 	move.l	(a3)+,(a5)
000044CA                            
000044CA 51CA FFD4                  		dbf	d2,.LoadTiles			; Loop
000044CE                            
000044CE 4E75                       		rts
000044D0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000044D0                            HUD_RingsBase:
000044D0 0A0A 00                    		dc.b	$A, $A, 0			; Ring count
000044D4 00                         		even
000044D4                            
000044D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000044D4                            ; Animate the level art
000044D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000044D4                            ; LEVEL ANIMATION SCRIPTS
000044D4                            ;
000044D4                            ; The AniArt_D_objAnimmate subroutine uses these scripts to reload certain tiles,
000044D4                            ; thus animating them. All the relevant art must be uncompressed, because
000044D4                            ; otherwise the subroutine would spend so much time waiting for the art to be
000044D4                            ; decompressed that the VBLANK window would close before all the animating was done.
000044D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000044D4                            ;	zoneanimdecl -1, ArtUnc_Flowers1, ArtTile_ArtUnc_Flowers1, 6, 2
000044D4                            ;		-1			Global frame duration. If -1, then each frame will use its own duration, instead
000044D4                            ;		ArtUnc_Flowers1		Source address
000044D4                            ;		ArtTile_ArtUnc_Flowers1	Destination VRAM address
000044D4                            ;		6			Number of frames
000044D4                            ;		2			Number of tiles to load into VRAM for each frame
000044D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000044D4                            ;	dc.b   0,$7F			Start of the script proper
000044D4                            ;		0			Tile ID of first tile in ArtUnc_Flowers1 to transfer
000044D4                            ;		$7F			Frame duration. Only here if global duration is -1
000044D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000044D4                            AniArt_D_objAnimmate:
000044D4 47F8 E90C                  		lea	lvlAnimCntrs.w,a3		; Level art animation counters
000044D8 3C1A                       		move.w	(a2)+,d6			; Get number of scripts in list
000044DA 6A00                       		bpl.s	.ListNotEmpty			; If there are any, continue
000044DC 4E75                       		rts
000044DE                            
000044DE                            .ListNotEmpty:
000044DE                            .Loop:
000044DE 5313                       		subq.b	#1,(a3)				; Tick down frame duration
000044E0 6400                       		bcc.s	.NextScript			; If frame isn't over, move on to next script
000044E2                            
000044E2                            .NextFrame:
000044E2 7000                       		moveq	#0,d0
000044E4 102B 0001                  		move.b	1(a3),d0			; Get current frame
000044E8 B02A 0006                  		cmp.b	6(a2),d0			; Have we processed the last frame in the script?
000044EC 6500                       		blo.s	.NotLastFrame			; If not, branch
000044EE 7000                       		moveq	#0,d0				; If so, reset to first frame
000044F0 1740 0001                  		move.b	d0,1(a3)			; ''
000044F4                            
000044F4                            .NotLastFrame:
000044F4 522B 0001                  		addq.b	#1,1(a3)			; Consider this frame processed; set counter to next frame
000044F8 1692                       		move.b	(a2),(a3)			; Set frame duration to global duration value
000044FA 6A00                       		bpl.s	.GlobalDuration
000044FC D040                       		add.w	d0,d0				; If script uses per-frame durations, use those instead
000044FE 16B2 0009                  		move.b	9(a2,d0.w),(a3)			; Set frame duration to current frame's duration value
00004502                            
00004502                            .GlobalDuration:
00004502 1032 0008                  		move.b	8(a2,d0.w),d0			; Get tile ID
00004506 EB48                       		lsl.w	#5,d0				; Turn it into an offset
00004508 342A 0004                  		move.w	4(a2),d2			; Get VRAM destination address
0000450C 2212                       		move.l	(a2),d1				; Get ROM source address
0000450E 0281 00FF FFFF             		andi.l	#$FFFFFF,d1			; ''
00004514 D280                       		add.l	d0,d1				; Offset into art, to get the address of new frame
00004516 7600                       		moveq	#0,d3
00004518 162A 0007                  		move.b	7(a2),d3			; Get size of art to be transferred 
0000451C E94B                       		lsl.w	#4,d3				; Turn it into actual size (in words)
0000451E 4EB8 0304                  		jsr	QueueDMATransfer.w		; Queue a DMA transfer
00004522                            
00004522                            .NextScript:
00004522 102A 0006                  		move.b	6(a2),d0			; Get total size of frame data
00004526 4A12                       		tst.b	(a2)				; Is per-frame duration data present?
00004528 6A00                       		bpl.s	.GlobalDuration2		; If not, keep the current size; it's correct
0000452A D000                       		add.b	d0,d0				; Double size to account for the additional frame duration data
0000452C                            
0000452C                            .GlobalDuration2:
0000452C 5200                       		addq.b	#1,d0
0000452E 0240 00FE                  		andi.w	#$FE,d0				; Round to next even address, if it isn't already
00004532 45F2 0008                  		lea	8(a2,d0.w),a2			; Advance to next script in list
00004536 544B                       		addq.w	#2,a3				; Advance to next script's slot in a3 (usually Anim_Counters)
00004538 51CE FFA4                  		dbf	d6,.Loop			; Loop
0000453C 4E75                       		rts
0000453E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000453E                            ; Set an object as solid and check for collision
0000453E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000453E                            ; RETURNING SOLID OBJECT COLLISION BIT FORMAT (For _objStatus):
0000453E                            ;	XXPXSXAX
0000453E                            ;	X	- Unused
0000453E                            ;	P	- Pushing flag
0000453E                            ;	S	- Standing on flag
0000453E                            ;	A	- In air flag (for the player)
0000453E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000453E                            ; RETURNING SOLID OBJECT COLLISION BIT FORMAT (For d6):
0000453E                            ;	XXXTXBXS
0000453E                            ;	X	- Unused
0000453E                            ;	T	- Touch top flag
0000453E                            ;	B	- Touch bottom flag
0000453E                            ;	S	- Touch side flag
0000453E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000453E                            ; PARAMETERS:
0000453E                            ;	d1.w	- Object width
0000453E                            ;	d2.w	- Object height / 2 (when jumping)
0000453E                            ;	d3.w	- Object height / 2 (when walking)
0000453E                            ;	d4.w	- Object x-axis position
0000453E                            ;	a0.l	- Object space pointer
0000453E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000453E                            ; RETURNS:
0000453E                            ;	See object collision return values above
0000453E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000453E                            SolidObject:
0000453E 7C00                       		moveq	#0,d6				; Clear collision flag register
00004540 3278 E876                  		movea.w	playerPtrP1.w,a1		; Set player object RAM
00004544 0828 0003 0028             		btst	#cStandBit,_objStatus(a0)		; Is the player standing on the current object?
0000454A 6700 0000                  		beq.w	SolidObject_ChkColOnScr		; If not, branch
0000454E 3401                       		move.w	d1,d2				; Copy object width
00004550 D442                       		add.w	d2,d2				; Double it
00004552 0829 0001 0028             		btst	#1,_objStatus(a1)			; Is the player in midair?
00004558 6600                       		bne.s	.NotOnTop			; If so, branch
0000455A 3029 0014                  		move.w	_objXPos(a1),d0			; Get player's X position
0000455E 9068 0014                  		sub.w	_objXPos(a0),d0			; Subtract the current object's X position
00004562 D041                       		add.w	d1,d0				; Add width
00004564 6B00                       		bmi.s	.NotOnTop			; If not colliding, branch
00004566 B042                       		cmp.w	d2,d0				; Compare with the width
00004568 6500                       		bcs.s	.IsOnTop			; If not colliding, branch
0000456A                            
0000456A                            .NotOnTop:
0000456A 08A9 0003 0028             		bclr	#cStandBit,_objStatus(a1)		; Clear the standing on object bit for the player
00004570 08E9 0001 0028             		bset	#1,_objStatus(a1)			; Make the player be in midair
00004576 08A8 0003 0028             		bclr	#cStandBit,_objStatus(a0)		; Clear the player standing on this object bit
0000457C 4269 0000                  		clr.w	_objInteract(a1)			; Clear the player's interact object pointer
00004580 7800                       		moveq	#0,d4				; Set collision status to 0
00004582 4E75                       		rts
00004584                            
00004584                            .IsOnTop:
00004584 3404                       		move.w	d4,d2				; Copy X position to d2
00004586 6100 0000                  		bsr.w	PlayerMoveOnPtfm		; Move the player on top of the current object
0000458A 7800                       		moveq	#0,d4				; Set collision status to 0
0000458C 4E75                       		rts
0000458E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000458E                            ; Set an object as solid and check for collision (even if off screen)
0000458E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000458E                            ; PARAMETERS:
0000458E                            ;	d1.w	- Object width
0000458E                            ;	d2.w	- Object height / 2 (when jumping)
0000458E                            ;	d3.w	- Object height / 2 (when walking)
0000458E                            ;	d4.w	- Object x-axis position
0000458E                            ;	a0.l	- Object space pointer
0000458E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000458E                            ; RETURNS:
0000458E                            ;	See object collision return values above
0000458E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000458E                            SolidObject_Always:
0000458E 7C00                       		moveq	#0,d6				; Clear collision flag register
00004590 3278 E876                  		movea.w	playerPtrP1.w,a1		; Set player object RAM
00004594 0828 0003 0028             		btst	#cStandBit,_objStatus(a0)		; Is the player standing on the current object?
0000459A 6700 0000                  		beq.w	SolidObject_ChkCollision	; If not, branch
0000459E 3401                       		move.w	d1,d2				; Copy object width
000045A0 D442                       		add.w	d2,d2				; Double it
000045A2 0829 0001 0028             		btst	#1,_objStatus(a1)			; Is the player in midair?
000045A8 6600                       		bne.s	.NotOnTop			; If so, branch
000045AA 3029 0014                  		move.w	_objXPos(a1),d0			; Get player's X position
000045AE 9068 0014                  		sub.w	_objXPos(a0),d0			; Subtract the current object's X position
000045B2 D041                       		add.w	d1,d0				; Add width
000045B4 6B00                       		bmi.s	.NotOnTop			; If not colliding, branch
000045B6 B042                       		cmp.w	d2,d0				; Compare with the width
000045B8 6500                       		bcs.s	.IsOnTop			; If not colliding, branch
000045BA                            
000045BA                            .NotOnTop:
000045BA 08A9 0003 0028             		bclr	#cStandBit,_objStatus(a1)		; Clear the standing on object bit for the player
000045C0 08E9 0001 0028             		bset	#1,_objStatus(a1)			; Make the player be in midair
000045C6 08A8 0003 0028             		bclr	#cStandBit,_objStatus(a0)		; Clear the player standing on this object bit
000045CC 4269 0000                  		clr.w	_objInteract(a1)			; Clear the player's interact object pointer
000045D0 7800                       		moveq	#0,d4				; Set collision status to 0
000045D2 4E75                       		rts
000045D4                            
000045D4                            .IsOnTop:
000045D4 3404                       		move.w	d4,d2				; Copy X position to d2
000045D6 6100 0000                  		bsr.w	PlayerMoveOnPtfm		; Move the player on top of the current object
000045DA 7800                       		moveq	#0,d4				; Set collision status to 0
000045DC 4E75                       		rts
000045DE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000045DE                            ; Set an object as a solid slope and check for collision
000045DE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000045DE                            ; PARAMETERS:
000045DE                            ;	d1.w	- Object width
000045DE                            ;	d2.w	- Object height / 2 (when jumping)
000045DE                            ;	d3.w	- Object height / 2 (when walking)
000045DE                            ;	d4.w	- Object x-axis position
000045DE                            ;	a0.l	- Object space pointer
000045DE                            ;	a2.l	- Slope height data pointer
000045DE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000045DE                            ; RETURNS:
000045DE                            ;	See object collision return values above
000045DE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000045DE                            SlopedSolid:
000045DE 7C00                       		moveq	#0,d6				; Clear collision flag register
000045E0 3278 E876                  		movea.w	playerPtrP1.w,a1		; Set player object RAM
000045E4 0828 0003 0028             		btst	#cStandBit,_objStatus(a0)		; Is the player standing on the current object?
000045EA 6700 0000                  		beq.w	SlopedSolid_ChkCollision	; If not, branch
000045EE 3401                       		move.w	d1,d2				; Copy object width
000045F0 D442                       		add.w	d2,d2				; Double it
000045F2 0829 0001 0028             		btst	#1,_objStatus(a1)			; Is the player in midair?
000045F8 6600                       		bne.s	.NotOnTop			; If so, branch
000045FA 3029 0014                  		move.w	_objXPos(a1),d0			; Get player's X position
000045FE 9068 0014                  		sub.w	_objXPos(a0),d0			; Subtract the current object's X position
00004602 D041                       		add.w	d1,d0				; Add width
00004604 6B00                       		bmi.s	.NotOnTop			; If not colliding, branch
00004606 B042                       		cmp.w	d2,d0				; Compare with the width
00004608 6500                       		bcs.s	.IsOnTop			; If not colliding, branch
0000460A                            
0000460A                            .NotOnTop:
0000460A 08A9 0003 0028             		bclr	#cStandBit,_objStatus(a1)		; Clear the standing on object bit for the player
00004610 08E9 0001 0028             		bset	#1,_objStatus(a1)			; Make the player be in midair
00004616 08A8 0003 0028             		bclr	#cStandBit,_objStatus(a0)		; Clear the player standing on this object bit
0000461C 4269 0000                  		clr.w	_objInteract(a1)			; Clear the player's interact object pointer
00004620 7800                       		moveq	#0,d4				; Set collision status to 0
00004622 4E75                       		rts
00004624                            
00004624                            .IsOnTop:
00004624 3404                       		move.w	d4,d2				; Copy X position to d2
00004626 6100 0000                  		bsr.w	PlayerMoveOnSlope		; Move the player on top of the current object
0000462A 7800                       		moveq	#0,d4				; Set collision status to 0
0000462C 4E75                       		rts
0000462E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000462E                            SlopedSolid_ChkCollision:
0000462E 3029 0014                  		move.w	_objXPos(a1),d0			; Get player's X position
00004632 9068 0014                  		sub.w	_objXPos(a0),d0			; Subtract current object's X position
00004636 D041                       		add.w	d1,d0				; Add width to it
00004638 6B00 0000                  		bmi.w	SolidObject_TestClearPush	; If not colliding, branch
0000463C 3601                       		move.w	d1,d3				; Copy width to d3
0000463E D643                       		add.w	d3,d3				; Double it
00004640 B043                       		cmp.w	d3,d0				; Compare to the X position
00004642 6200 0000                  		bhi.w	SolidObject_TestClearPush	; If not colliding, branch
00004646 3A00                       		move.w	d0,d5				; Copy the X position to d5
00004648 0828 0000 000D             		btst	#0,_objRender(a0)			; Is the object X-flipped?
0000464E 6700                       		beq.s	.NoFlip				; If not, branch
00004650 4645                       		not.w	d5				; Logical notation on d5
00004652 DA43                       		add.w	d3,d5				; Add width
00004654                            
00004654                            .NoFlip:
00004654 E24D                       		lsr.w	#1,d5				; Divide by 2
00004656 1632 5000                  		move.b	(a2,d5.w),d3			; Get height of this segment
0000465A 9612                       		sub.b	(a2),d3				; Subtract first bytes from the value
0000465C 4883                       		ext.w	d3				; Sign extend to word
0000465E 3A28 0018                  		move.w	_objYPos(a0),d5			; Get the current object's Y position
00004662 9A43                       		sub.w	d3,d5				; Subtract the height from the Y position
00004664 1629 002D                  		move.b	_objColH(a1),d3			; Get the player's collision height
00004668 4883                       		ext.w	d3				; Sign extend to word
0000466A D443                       		add.w	d3,d2				; Add collision height to the object height
0000466C 3629 0018                  		move.w	_objYPos(a1),d3			; Get the player's Y position
00004670 9645                       		sub.w	d5,d3				; Subtract d5
00004672 5843                       		addq.w	#4,d3				; Add 4
00004674 D642                       		add.w	d2,d3				; Add height and collision height
00004676 6B00 0000                  		bmi.w	SolidObject_TestClearPush	; If not colliding, branch
0000467A 3802                       		move.w	d2,d4				; Copy height and collision height
0000467C D844                       		add.w	d4,d4				; Double it
0000467E B644                       		cmp.w	d4,d3				; Compare to Y position
00004680 6400 0000                  		bcc.w	SolidObject_TestClearPush	; If not colliding, branch
00004684 6000 0000                  		bra.w	SolidObject_ChkBounds		; If anything else, we are colliding
00004688                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004688                            SolidObject_ChkColOnScr:
00004688 4A28 000D                  		tst.b	_objRender(a0)			; Is the object on screen?
0000468C 6A00 0000                  		bpl.w	SolidObject_TestClearPush	; If not, branch
00004690                            
00004690                            SolidObject_ChkCollision:
00004690 3029 0014                  		move.w	_objXPos(a1),d0			; Get player's X position
00004694 9068 0014                  		sub.w	_objXPos(a0),d0			; Subtract the current object's X position
00004698 D041                       		add.w	d1,d0				; Add width
0000469A 3601                       		move.w	d1,d3				; Copy width
0000469C D643                       		add.w	d3,d3				; Double it
0000469E B043                       		cmp.w	d3,d0				; Compare with the X position
000046A0 6200 0000                  		bhi.w	SolidObject_TestClearPush	; If not colliding, branch
000046A4                            		
000046A4 1829 0000                  		move.b	_objInitColH(a1),d4		; Get the player's default collision height
000046A8 4884                       		ext.w	d4				; Sign extend to word
000046AA D842                       		add.w	d2,d4				; Add height
000046AC 1629 002D                  		move.b	_objColH(a1),d3			; Get the player's collision height
000046B0 4883                       		ext.w	d3				; Sign extend to word
000046B2 D443                       		add.w	d3,d2				; Add to height
000046B4 3629 0018                  		move.w	_objYPos(a1),d3			; Get player's Y position
000046B8 9668 0018                  		sub.w	_objYPos(a0),d3			; Subtract the current object's Y position
000046BC 5843                       		addq.w	#4,d3				; Add 4
000046BE D642                       		add.w	d2,d3				; Add height
000046C0 0243 0FFF                  		andi.w	#$FFF,d3			; Keep in range
000046C4 D842                       		add.w	d2,d4				; Add height
000046C6 B644                       		cmp.w	d4,d3				; Compare with the Y position
000046C8 6400 0000                  		bcc.w	SolidObject_TestClearPush	; If not colliding, branch
000046CC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000046CC                            SolidObject_ChkBounds:
000046CC 4A29 000C                  		tst.b	_objFlags(a1)			; Is the player being carried by another object?
000046D0 6B00 0000                  		bmi.w	SolidObject_TestClearPush	; If so, branch
000046D4 0C29 000C 0025             		cmpi.b	#$C,_objRoutine(a1)			; Is the player dead?
000046DA 6400 0000                  		bcc.w	SolidObject_End			; If so, branch
000046DE 4A38 E8DD                  		tst.b	debugMode.w			; Is debug mode active?
000046E2 6600 0000                  		bne.w	SolidObject_End			; If so, branch
000046E6                            
000046E6 3A00                       		move.w	d0,d5				; Copy X offset
000046E8 B240                       		cmp.w	d0,d1				; Check against the "middle" of the object
000046EA 6400                       		bcc.s	.IsLeft				; If the player is left of the middle, branch
000046EC D241                       		add.w	d1,d1				; Double collision width
000046EE 9041                       		sub.w	d1,d0				; Subtract from X offset
000046F0 3A00                       		move.w	d0,d5				; Copy X offset
000046F2 4445                       		neg.w	d5				; Negate offset
000046F4                            
000046F4                            .IsLeft:
000046F4 3203                       		move.w	d3,d1				; Copy Y offset
000046F6 B443                       		cmp.w	d3,d2				; Check against the "middle" of the object
000046F8 6400                       		bcc.s	.IsAbove			; If the player is above of the middle, branch
000046FA 5943                       		subq.w	#4,d3				; Subtract 4 from the collision height
000046FC 9644                       		sub.w	d4,d3				; Subtract height from the collision height
000046FE 3203                       		move.w	d3,d1				; Copy Y offset
00004700 4441                       		neg.w	d1				; Negate offset
00004702                            
00004702                            .IsAbove:
00004702 BA41                       		cmp.w	d1,d5
00004704 6200 0000                  		bhi.w	SolidObject_UpDown		; Branch if we are in the object less vertically than horizontally(?)
00004708 0C41 0004                  		cmpi.w	#4,d1
0000470C 6300 0000                  		bls.w	SolidObject_UpDown		; I assume this ensures the corners are not solid until some point
00004710                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004710                            SolidObject_Sides:
00004710 4A40                       		tst.w	d0
00004712 6700                       		beq.s	.AlignPlayer			; Branch if we are in the middle of the object?
00004714 6B00                       		bmi.s	.ChkRight			; Branch if we are right of the object
00004716 4A69 001C                  		tst.w	_objXVel(a1)			; Is the player moving left?
0000471A 6B00                       		bmi.s	.AlignPlayer			; If so, branch
0000471C 6000                       		bra.s	.ClearGroundVel			; If else player is moving right, branch
0000471E                            
0000471E                            .ChkRight:
0000471E 4A69 001C                  		tst.w	_objXVel(a1)
00004722 6A00                       		bpl.s	.AlignPlayer			; Branch if player is moving right
00004724                            
00004724                            .ClearGroundVel:
00004724 4269 0000                  		clr.w	_objGVel(a1)			; Stop the player from moving
00004728 4269 001C                  		clr.w	_objXVel(a1)			; Clear the player's X velocity
0000472C                            
0000472C                            .AlignPlayer:
0000472C 9169 0014                  		sub.w	d0,_objXPos(a1)			; Align player to the side of the object
00004730 0829 0001 0028             		btst	#1,_objStatus(a1)			; Is the player in midair?
00004736 6600                       		bne.s	.InAir				; If so, branch
00004738 08E8 0005 0028             		bset	#cPushBit,_objStatus(a0)		; Set the pushing bit
0000473E 08E9 0005 0028             		bset	#cPushBit,_objStatus(a1)		; Set the player's pushing bit
00004744 08C6 0000                  		bset	#cTouchSideBit,d6		; Set "touch side" flag
00004748 7801                       		moveq	#1,d4				; Set collision status to 1
0000474A 4E75                       		rts
0000474C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000474C                            .InAir:
0000474C 6100                       		bsr.s	SolidObject_ClearPush		; Clear pushing bits
0000474E 08C6 0000                  		bset	#cTouchSideBit,d6		; Set "touch side" flag
00004752 7801                       		moveq	#1,d4				; Set collision status to 1
00004754 4E75                       		rts
00004756                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004756                            SolidObject_TestClearPush:
00004756 0828 0005 0028             		btst	#cPushBit,_objStatus(a0)		; Is the player pushing this object?
0000475C 6700                       		beq.s	SolidObject_End			; If not, branch
0000475E 0C29 0002 0020             		cmpi.b	#2,_objAnim(a1)			; Is the player jumping/rolling?
00004764 6700                       		beq.s	SolidObject_ClearPush		; If so, branch
00004766 0C29 0017 0020             		cmpi.b	#$17,_objAnim(a1)			; Is the player in using the drowning animation
0000476C 6700                       		beq.s	SolidObject_ClearPush		; If so, branch
0000476E 0C29 001A 0020             		cmpi.b	#$1A,_objAnim(a1)			; Is the player in using the hurt animation
00004774 6700                       		beq.s	SolidObject_ClearPush		; If so, branch
00004776 337C 0001 0020             		move.w	#1,_objAnim(a1)			; Make the player use the walking animation
0000477C                            
0000477C                            SolidObject_ClearPush:
0000477C 08A8 0005 0028             		bclr	#cPushBit,_objStatus(a0)		; Clear the pushing bit
00004782 08A9 0005 0028             		bclr	#cPushBit,_objStatus(a1)		; Clear the player's pushing bit
00004788                            
00004788                            SolidObject_End:
00004788 7800                       		moveq	#0,d4				; Set collision status to 0
0000478A 4E75                       		rts
0000478C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000478C                            SolidObject_UpDown:
0000478C 4A43                       		tst.w	d3				; Is the player below the middle of the object?
0000478E 6B00                       		bmi.s	SolidObject_Below		; If so, branch
00004790 0C43 0010                  		cmpi.w	#$10,d3				; Is the player 16 pixels or less above the middle of the object?
00004794 6500                       		bcs.s	SolidObject_Above		; If so, branch
00004796 60BE                       		bra.s	SolidObject_TestClearPush	; If not, the player is not colliding
00004798                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004798                            SolidObject_Below:
00004798 4A69 001E                  		tst.w	_objYVel(a1)			; Is the player moving vertically?
0000479C 6700                       		beq.s	.CheckCrush			; If so, branch
0000479E 6A00                       		bpl.s	.SetY				; If the player's moving down, branch
000047A0 4A43                       		tst.w	d3				; Is the player above the middle of the object?
000047A2 6A00                       		bpl.s	.SetY				; If so, branch
000047A4 4269 001E                  		clr.w	_objYVel(a1)			; Clear the player's Y velocity
000047A8                            
000047A8                            .SetY:
000047A8 9769 0018                  		sub.w	d3,_objYPos(a1)			; Push the player below the object
000047AC 08C6 0002                  		bset	#cTouchBtmBit,d6		; Set "touch bottom" flag
000047B0 78FE                       		moveq	#-2,d4				; Set the collision status to -2
000047B2 4E75                       		rts
000047B4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000047B4                            .CheckCrush:
000047B4 0829 0001 0028             		btst	#1,_objStatus(a1)			; Is the player in midair?
000047BA 66EC                       		bne.s	.SetY				; If so, branch
000047BC 3800                       		move.w	d0,d4				; Get x offset
000047BE 6A00                       		bpl.s	.NoNeg				; If it's positive branch
000047C0 4444                       		neg.w	d4				; Negate it (absolute value)
000047C2                            
000047C2                            .NoNeg:
000047C2 0C44 0010                  		cmpi.w	#$10,d4				; Is the player near the edge of object collision?
000047C6 6500 FF48                  		blo.w	SolidObject_Sides		; If so, branch
000047CA                            		
000047CA                            		push.l	a0				; Store the current object's address
000047CA 2F08                     M 	move.l	a0,-(sp)
000047CC 2049                       		movea.l	a1,a0				; Replace with the player's address
000047CE 4EB9 0000 0000             		jsr	ObjPlayer_GetKilled		; Kill the player
000047D4                            		pop.l	a0				; Restore the current object's address
000047D4 205F                     M 	move.l	(sp)+,a0
000047D6 08C6 0002                  		bset	#cTouchBtmBit,d6		; Set "touch bottom" flag
000047DA 78FE                       		moveq	#-2,d4				; Set collision status to -2
000047DC 4E75                       		rts
000047DE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000047DE                            SolidObject_Above:
000047DE 5943                       		subq.w	#4,d3				; Get the sub Y offset
000047E0                            		
000047E0                            		; This next bit ensures the player does not collide with the top when next to the walls
000047E0                            		; recalculates object width.
000047E0                            
000047E0 7200                       		moveq	#0,d1
000047E2 1228 002C                  		move.b	_objColW(a0),d1			; Get the current object's width
000047E6 3401                       		move.w	d1,d2				; Copy it
000047E8 D442                       		add.w	d2,d2				; Double it
000047EA                            		
000047EA D269 0014                  		add.w	_objXPos(a1),d1			; Add the player's X position
000047EE 9268 0014                  		sub.w	_objXPos(a0),d1			; Subtract the current object's X position
000047F2 6B00                       		bmi.s	.NoCollision			; If the player is not colliding, branch
000047F4                            		
000047F4 B242                       		cmp.w	d2,d1				; Is the plauer colliding from the right?
000047F6 6400                       		bcc.s	.NoCollision			; If the player is not colliding, branch
000047F8                            		
000047F8 5369 0018                  		subq.w	#1,_objYPos(a1)			; Subtract 1 from the player's Y position
000047FC 9769 0018                  		sub.w	d3,_objYPos(a1)			; Move the player above the object
00004800 4A69 001E                  		tst.w	_objYVel(a1)			; Is the player moving up?
00004804 6B00                       		bmi.s	.NoCollision			; If so, branch
00004806 6100 0000                  		bsr.w	RideObject_SetRide		; Allow the player to stand on top (and set the "ride" bit)
0000480A 08C6 0004                  		bset	#cTouchTopBit,d6		; Set "touch top" flag
0000480E 78FF                       		moveq	#-1,d4				; Set collision status to -1
00004810 4E75                       		rts
00004812                            
00004812                            .NoCollision:
00004812 7800                       		moveq	#0,d4				; Set collision status to 0
00004814 4E75                       		rts
00004816                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004816                            ; Set an object as a platform and check for collision
00004816                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004816                            ; PARAMETERS:
00004816                            ;	d1.w	- Object's width
00004816                            ;	d2.w	- Object's width*2 (only for Platform_ChkBridgeCol)
00004816                            ;	d3.w	- Object's height
00004816                            ;	d4.w	- Object x-axis position
00004816                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004816                            ; RETURNS:
00004816                            ;	See object collision return values above (side and bottom collision doesn't apply here)
00004816                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004816                            PlatformObject:
00004816 7C00                       		moveq	#0,d6				; Clear collision flag register
00004818 3278 E876                  		movea.w	playerPtrP1.w,a1		; Get the player RAM
0000481C 0828 0003 0028             		btst	#cStandBit,_objStatus(a0)		; Is the player standing on the object?
00004822 6700 0000                  		beq.w	Platform_ChkCollision		; If not, branch
00004826 3401                       		move.w	d1,d2				; Copy the object's width
00004828 D442                       		add.w	d2,d2				; Double it
0000482A 0829 0001 0028             		btst	#1,_objStatus(a1)			; Is the player in midair?
00004830 6600                       		bne.s	.NotOnTop			; If so, branch
00004832 3029 0014                  		move.w	_objXPos(a1),d0			; Get the player's X position
00004836 9068 0014                  		sub.w	_objXPos(a0),d0			; Subtract the object's X position
0000483A D041                       		add.w	d1,d0				; Add width
0000483C 6B00                       		bmi.s	.NotOnTop			; If the player is not colliding, branch
0000483E B042                       		cmp.w	d2,d0				; Compare with the width
00004840 6500                       		blo.s	.OnTop				; If the player is not colliding, branch
00004842                            
00004842                            .NotOnTop:
00004842 08A9 0003 0028             		bclr	#cStandBit,_objStatus(a1)		; Clear the player's standing on object bit
00004848 08E9 0001 0028             		bset	#1,_objStatus(a1)			; Make the player be in midair
0000484E 08A8 0003 0028             		bclr	#cStandBit,_objStatus(a0)		; Clear the player standing on this object bit
00004854 4269 0000                  		clr.w	_objInteract(a1)			; Clear the player's interact object pointer
00004858 7800                       		moveq	#0,d4				; Set the collision status to 0
0000485A 4E75                       		rts
0000485C                            
0000485C                            .OnTop:
0000485C 3404                       		move.w	d4,d2				; Copy X position
0000485E 6100 0000                  		bsr.w	PlayerMoveOnPtfm		; Make the player stand on top of this object
00004862 7800                       		moveq	#0,d4				; Set the collision status to 0
00004864 4E75                       		rts
00004866                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004866                            Platform_ChkBridgeCol:
00004866 4A69 001E                  		tst.w	_objYVel(a1)			; Is the player moving up?
0000486A 6B00 0000                  		bmi.w	PlatformObject_End		; If so, branch
0000486E 3029 0014                  		move.w	_objXPos(a1),d0			; Get the player's X position
00004872 9068 0014                  		sub.w	_objXPos(a0),d0			; Subtract the object's X position
00004876 D041                       		add.w	d1,d0				; Add width
00004878 6B00 0000                  		bmi.w	PlatformObject_End		; If the player is not colliding, branch
0000487C B042                       		cmp.w	d2,d0				; Compare with width
0000487E 6400 0000                  		bcc.w	PlatformObject_End		; If the player is not colliding, branch
00004882 6000                       		bra.s	Platform_ChkCol_Cont		; Continue
00004884                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004884                            Platform_ChkCollision:
00004884 4A69 001E                  		tst.w	_objYVel(a1)			; Is the player moving up?
00004888 6B00 0000                  		bmi.w	PlatformObject_End		; If so, branch
0000488C 3029 0014                  		move.w	_objXPos(a1),d0			; Get the player's X position
00004890 9068 0014                  		sub.w	_objXPos(a0),d0			; Subtract the object's X position
00004894 D041                       		add.w	d1,d0				; Add width
00004896 6B00 0000                  		bmi.w	PlatformObject_End		; If the player is not colliding, branch
0000489A D241                       		add.w	d1,d1				; Double width
0000489C B041                       		cmp.w	d1,d0				; Compare with width
0000489E 6400 0000                  		bcc.w	PlatformObject_End		; If the player is not colliding, branch
000048A2                            
000048A2                            Platform_ChkCol_Cont:
000048A2 3028 0018                  		move.w	_objYPos(a0),d0			; Get the object's Y position
000048A6 9043                       		sub.w	d3,d0				; Subtract the height from it
000048A8                            
000048A8                            PlatformObject_ChkYRange:
000048A8 3429 0018                  		move.w	_objYPos(a1),d2			; Get the player's Y position
000048AC 1229 002D                  		move.b	_objColH(a1),d1			; Get the player's collision height
000048B0 4881                       		ext.w	d1				; Sign extend it
000048B2 D242                       		add.w	d2,d1				; Add the Y position to the collision height
000048B4 5841                       		addq.w	#4,d1				; Add 4
000048B6 9041                       		sub.w	d1,d0				; SubactID the result from the Y position
000048B8 6200 0000                  		bhi.w	PlatformObject_End		; If it's greater than 0, branch
000048BC 0C40 FFF0                  		cmpi.w	#-$10,d0			; Is the result less than -16?
000048C0 6500 0000                  		bcs.w	PlatformObject_End		; If so, branch
000048C4 4A38 E8DD                  		tst.b	debugMode.w			; Is debug mode active?
000048C8 6600 0000                  		bne.w	PlatformObject_End		; If so, branch
000048CC 4A29 000C                  		tst.b	_objFlags(a1)			; Is the player being carried by another object?
000048D0 6B00 0000                  		bmi.w	PlatformObject_End		; If so, branch
000048D4 0C29 000C 0025             		cmpi.b	#$C,_objRoutine(a1)		; Is the player dead?
000048DA 6400 0000                  		bcc.w	PlatformObject_End		; If so, branch
000048DE D440                       		add.w	d0,d2				; Add the previous result to the Y position
000048E0 5642                       		addq.w	#3,d2				; Add 3
000048E2 3342 0018                  		move.w	d2,_objYPos(a1)			; Add to the player's Y position
000048E6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000048E6                            ; Set the player on top of the object
000048E6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000048E6                            ; PARAMETERS:
000048E6                            ;	a0.l	- Object space pointer
000048E6                            ;	a1.l	- Player object space pointer
000048E6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000048E6                            ; RETURNS:
000048E6                            ;	Nothing
000048E6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000048E6                            RideObject_SetRide:
000048E6 0829 0003 0028             		btst	#cStandBit,_objStatus(a1)		; Is the player standing on the object?
000048EC 6700                       		beq.s	.IsStanding			; If not, branch
000048EE 3669 0000                  		movea.w	_objInteract(a1),a3		; Get the object the player is standing on
000048F2 08AB 0003 0028             		bclr	#cStandBit,_objStatus(a3)		; Clear its standing on object bit
000048F8 4269 0000                  		clr.w	_objInteract(a1)			; Clear the player's interact object pointer
000048FC                            
000048FC                            .IsStanding:
000048FC 3348 0000                  		move.w	a0,_objInteract(a1)		; Set it as the object the player is standing on
00004900 4229 0000                  		clr.b	_objAngle(a1)			; Clear the player's angle
00004904 4269 001E                  		clr.w	_objYVel(a1)			; Clear the player's Y velocity
00004908 3369 001C 0000             		move.w	_objXVel(a1),_objGVel(a1)		; Set the player's X velocity as its ground velocity
0000490E 08E9 0003 0028             		bset	#cStandBit,_objStatus(a1)		; Set the player's standing on object bit
00004914 08E8 0003 0028             		bset	#cStandBit,_objStatus(a0)		; Set the player standing on this object bir
0000491A 08A9 0001 0028             		bclr	#1,_objStatus(a1)			; Clear the player's in midair bit
00004920 6700                       		beq.s	PlatformObject_End		; If it was already clear, branch
00004922 2F08                       		move.l	a0,-(sp)			; Store the current object's address
00004924 2049                       		movea.l	a1,a0				; Replace it with the player's address
00004926 6100 E8A6                  		bsr.w	PlayerResetOnFloor		; Reset the player's variables to make it touch the floor
0000492A 205F                       		movea.l	(sp)+,a0			; Restore the current object's address
0000492C                            
0000492C                            PlatformObject_End:
0000492C 4E75                       		rts
0000492E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000492E                            ; Set an object as a solid slope and check for collision
0000492E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000492E                            ; PARAMETERS:
0000492E                            ;	d1.w	- Object width
0000492E                            ;	d3.w	- Object height
0000492E                            ;	d4.w	- Object x-axis position
0000492E                            ;	a0.l	- Object space pointer
0000492E                            ;	a2.l	- Slope height data pointer
0000492E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000492E                            ; RETURNS:
0000492E                            ;	See object collision return values above (side and bottom collision doesn't apply here)
0000492E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000492E                            SlopedPlatform:
0000492E 7C00                       		moveq	#0,d6				; Clear collision flag register
00004930 3278 E876                  		movea.w	playerPtrP1.w,a1		; Get the player RAM
00004934 0828 0003 0028             		btst	#cStandBit,_objStatus(a0)		; Is the player standing on the object?
0000493A 6700 0000                  		beq.w	SlopedPlarform_ChkCol		; If not branch
0000493E 3401                       		move.w	d1,d2				; Copy the object's width
00004940 D442                       		add.w	d2,d2				; Double it
00004942 0829 0001 0028             		btst	#1,_objStatus(a1)			; Is the player in midair?
00004948 6600                       		bne.s	.NotOnTop			; If so, branch
0000494A 3029 0014                  		move.w	_objXPos(a1),d0			; Get the player's X position
0000494E 9068 0014                  		sub.w	_objXPos(a0),d0			; Subtract the object's X position
00004952 D041                       		add.w	d1,d0				; Add width
00004954 6B00                       		bmi.s	.NotOnTop			; If the player is not colliding, branch
00004956 B042                       		cmp.w	d2,d0				; Compare with the width
00004958 6500                       		blo.s	.OnTop				; If the player is not colliding, branch
0000495A                            
0000495A                            .NotOnTop:
0000495A 08A9 0003 0028             		bclr	#cStandBit,_objStatus(a1)		; Clear the player's standing on object bit
00004960 08E9 0001 0028             		bset	#1,_objStatus(a1)			; Make the player be in midair
00004966 08A8 0003 0028             		bclr	#cStandBit,_objStatus(a0)		; Clear the player standing on this object bit
0000496C 4269 0000                  		clr.w	_objInteract(a1)			; Clear the player's interact object pointer
00004970 7800                       		moveq	#0,d4				; Set the collision status to 0
00004972 4E75                       		rts
00004974                            
00004974                            .OnTop:
00004974 3404                       		move.w	d4,d2				; Copy X position
00004976 6100 0000                  		bsr.w	PlayerMoveOnSlope		; Make the player stand on top of this object
0000497A 7800                       		moveq	#0,d4				; Set the collision status to 0
0000497C 4E75                       		rts
0000497E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000497E                            SlopedPlarform_ChkCol:
0000497E 4A69 001E                  		tst.w	_objYVel(a1)			; Is the player moving up?
00004982 6B00 FFA8                  		bmi.w	PlatformObject_End		; If so, branch
00004986 3029 0014                  		move.w	_objXPos(a1),d0			; Get the player's X position
0000498A 9068 0014                  		sub.w	_objXPos(a0),d0			; Subtract the object's X position
0000498E D041                       		add.w	d1,d0				; Add width
00004990 6B00 FF9A                  		bmi.w	PlatformObject_End		; If the player is not colliding, branch
00004994 D241                       		add.w	d1,d1				; Double width
00004996 B041                       		cmp.w	d1,d0				; Compare with width
00004998 6400 FF92                  		bcc.w	PlatformObject_End		; If the player is not colliding, branch
0000499C 0828 0000 000D             		btst	#0,_objRender(a0)			; Is the object X flipped?
000049A2 6700                       		beq.s	.NoXFlip			; If not, skip
000049A4 4640                       		not.w	d0				; Logical notation
000049A6 D041                       		add.w	d1,d0				; Add width
000049A8                            
000049A8                            .NoXFlip:
000049A8 E248                       		lsr.w	#1,d0				; Divide by 2 (by shifting right once)
000049AA 1632 0000                  		move.b	(a2,d0.w),d3			; Get height of the next segment
000049AE 4883                       		ext.w	d3				; Sign extend to word
000049B0 3028 0018                  		move.w	_objYPos(a0),d0			; Get the current object's Y position
000049B4 9043                       		sub.w	d3,d0				; Subtract the height from the Y position
000049B6 6000 FEF0                  		bra.w	PlatformObject_ChkYRange	; Check the Y range
000049BA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049BA                            ; Move the player along a platform/solid object
000049BA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049BA                            ; PARAMETERS:
000049BA                            ;	d2.w	- X position of the platform
000049BA                            ;	d3.w	- Height of the platform
000049BA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049BA                            ; RETURNS:
000049BA                            ;	Nothing
000049BA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049BA                            PlayerMoveOnPtfm:
000049BA 3028 0018                  		move.w	_objYPos(a0),d0			; Get the current object's Y position
000049BE 9043                       		sub.w	d3,d0				; Subtract height
000049C0 4A29 000C                  		tst.b	_objFlags(a1)			; Is the player being carried by another object?
000049C4 6B00                       		bmi.s	.End				; If so, branch
000049C6 0C29 000C 0025             		cmpi.b	#$C,_objRoutine(a1)			; Is the player dead?
000049CC 6400                       		bcc.s	.End				; If so, branch
000049CE 4A38 E8DD                  		tst.b	debugMode.w			; Is debug mode active?
000049D2 6600                       		bne.s	.End				; If so, branch
000049D4 7200                       		moveq	#0,d1
000049D6 1229 002D                  		move.b	_objColH(a1),d1			; Get the player's collision height
000049DA 9041                       		sub.w	d1,d0				; Subtract from the Y position
000049DC 3340 0018                  		move.w	d0,_objYPos(a1)			; Set as the player's Y position
000049E0 9468 0014                  		sub.w	_objXPos(a0),d2			; Subtract the current object's X position from the suggest X position
000049E4 9569 0014                  		sub.w	d2,_objXPos(a1)			; Subtract the difference from the X position of the player
000049E8                            		;tst.b	(Shield_Flag).w			; Does the player have a shield?
000049E8                            		;beq.s	.End				; If not branch
000049E8                            		;move.w	d0,(Object_Space_7+oY).w	; Apply to the shield's Y position
000049E8                            		;sub.w	d2,(Object_Space_7+oX).w	; Apply to the shield's X position
000049E8                            
000049E8                            .End:
000049E8 4E75                       		rts
000049EA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049EA                            ; Move the player along a sloped platform/solid object
000049EA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049EA                            ; PARAMETERS:
000049EA                            ;	d3.w	- Height of the platform
000049EA                            ;	d4.w	- X position of the platform
000049EA                            ;	a2.l	- Slope height data pointer
000049EA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049EA                            ; RETURNS:
000049EA                            ;	Nothing
000049EA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049EA                            PlayerMoveOnSlope:
000049EA 0829 0003 0028             		btst	#cStandBit,_objStatus(a1)		; Is the player standing on the object?
000049F0 6700                       		beq.s	.End				; If not, branch
000049F2 3029 0014                  		move.w	_objXPos(a1),d0			; Get the player's X position
000049F6 9068 0014                  		sub.w	_objXPos(a0),d0			; Subtract the current object's X position
000049FA D041                       		add.w	d1,d0				; Add width
000049FC E248                       		lsr.w	#1,d0				; Divide by 2 (by shifting right once)
000049FE 0828 0000 000D             		btst	#0,_objRender(a0)			; Is the object X flipped?
00004A04 6700                       		beq.s	.NoXFlip			; If not, branch
00004A06 4640                       		not.w	d0				; Logical notation on d0
00004A08 D041                       		add.w	d1,d0				; Add width
00004A0A                            
00004A0A                            .NoXFlip:
00004A0A 1232 0000                  		move.b	(a2,d0.w),d1			; Get Y offset
00004A0E 4881                       		ext.w	d1				; Sign extend to word
00004A10 3028 0018                  		move.w	_objYPos(a0),d0			; Get current object's Y position
00004A14 9041                       		sub.w	d1,d0				; Subtract the Y offset
00004A16 7200                       		moveq	#0,d1
00004A18 1229 002D                  		move.b	_objColH(a1),d1			; Get the player's collision height
00004A1C 9041                       		sub.w	d1,d0				; Subtract from the Y position
00004A1E 3340 0018                  		move.w	d0,_objYPos(a1)			; Set as the player's Y position
00004A22 9468 0014                  		sub.w	_objXPos(a0),d2			; Subtract the current object's X position from the suggest X position
00004A26 9569 0014                  		sub.w	d2,_objXPos(a1)			; Subtract the difference from the X position of the player
00004A2A                            
00004A2A                            .End:
00004A2A 4E75                       		rts
00004A2C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A2C                            ; Do object collision for the player object
00004A2C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A2C                            PlayerDoObjCollision:
00004A2C 4EB8 427A                  		jsr	PlayeringCollectlision		; Do ring collision
00004A30                            		
00004A30 3428 0014                  		move.w	_objXPos(a0),d2			; Get X position
00004A34 3628 0018                  		move.w	_objYPos(a0),d3			; Get Y position
00004A38 5142                       		subq.w	#8,d2				; Get left sensor X
00004A3A 7A00                       		moveq	#0,d5
00004A3C 1A28 002D                  		move.b	_objColH(a0),d5			; Get collision height
00004A40 5705                       		subq.b	#3,d5				; Subtract 3
00004A42 9645                       		sub.w	d5,d3				; Get left sensor Y
00004A44 383C 0010                  		move.w	#$10,d4				; Get right sensor delta X
00004A48 DA45                       		add.w	d5,d5				; Get right sensor delta Y
00004A4A                            
00004A4A 49F8 E7D6                  		lea	collideList.w,a4			; Get collision response list
00004A4E 3C1C                       		move.w	(a4)+,d6			; Get count
00004A50 6700                       		beq.s	.End				; If there are no objects to test, branch
00004A52                            
00004A52                            .ObjLoop:
00004A52 325C                       		movea.w	(a4)+,a1			; Get object
00004A54 1029 002A                  		move.b	_objColType(a1),d0			; Does touching it do anything?
00004A58 6600                       		bne.s	.ChkPosition			; If so, branch
00004A5A                            
00004A5A                            .NextObj:
00004A5A 5546                       		subq.w	#2,d6				; Decrement count
00004A5C 66F4                       		bne.s	.ObjLoop			; Branch if there are still objects to check
00004A5E 7000                       		moveq	#0,d0				; Reset d0
00004A60                            
00004A60                            .End:
00004A60 4278 E7D6                  		clr.w	collideList.w			; Clear the collision response list count
00004A64 4E75                       		rts
00004A66                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A66                            .ChkPosition:
00004A66 7200                       		moveq	#0,d1
00004A68 1229 002C                  		move.b	_objColW(a1),d1			; Get object width
00004A6C 3029 0014                  		move.w	_objXPos(a1),d0			; Get object X position
00004A70 9041                       		sub.w	d1,d0				; Get left side of object
00004A72 9042                       		sub.w	d2,d0				; Is the player right of the left side of the object?
00004A74 6400                       		bcc.s	.ChkRightSide			; If so, branch
00004A76 D241                       		add.w	d1,d1				; Get right side delta X
00004A78 D041                       		add.w	d1,d0				; Is the player right of the right side of the object?
00004A7A 6500                       		bcs.s	.ChkHeight			; If not, branch
00004A7C 60DC                       		bra.s	.NextObj			; The player isn't touching the object horizontally; check the next object
00004A7E                            
00004A7E                            .ChkRightSide:
00004A7E B044                       		cmp.w	d4,d0				; Is the player inside the object horizontally?
00004A80 62D8                       		bhi.s	.NextObj			; If not, branch
00004A82                            
00004A82                            .ChkHeight:
00004A82 7200                       		moveq	#0,d1
00004A84 1229 002D                  		move.b	_objColH(a1),d1			; Get object height
00004A88 3029 0018                  		move.w	_objYPos(a1),d0			; Get object Y position
00004A8C 9041                       		sub.w	d1,d0				; Get top of object
00004A8E 9043                       		sub.w	d3,d0				; Is the player below the top of the object?
00004A90 6400                       		bcc.s	.ChkBottom			; If so, branch
00004A92 D241                       		add.w	d1,d1				; Get bottom delta Y
00004A94 D240                       		add.w	d0,d1				; Is the player below the bottom of the object?
00004A96 6500                       		bcs.s	.ChkType			; If not, branch
00004A98 60C0                       		bra.s	.NextObj			; The player isn't touching the object vertically; check the next object
00004A9A                            
00004A9A                            .ChkBottom:
00004A9A B045                       		cmp.w	d5,d0				; Is the player inside the object vertically?
00004A9C 62BC                       		bhi.s	.NextObj			; If not, branch
00004A9E                            
00004A9E                            .ChkType:
00004A9E 7000                       		moveq	#0,d0
00004AA0 1029 002A                  		move.b	_objColType(a1),d0			; Get collision type
00004AA4 4EFB 0000                  		jmp	.CollisionTypes-2(pc,d0.w)	; Go to the appropriate routine
00004AA8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004AA8                            .CollisionTypes:
00004AA8 6000                       		bra.s	.Enemy				; Enemy
00004AAA 6000                       		bra.s	.Indestructable			; Indestructable
00004AAC                            
00004AAC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004AAC                            .Enemy:
00004AAC 0C28 0002 0020             		cmpi.b	#2,_objAnim(a0)			; Are we rolling?
00004AB2 6600 0000                  		bne.w	.ChkHurt			; If not, branch
00004AB6                            
00004AB6                            .ChkBoss:
00004AB6 4A29 002B                  		tst.b	_objHitCnt(a1)			; Do we have a hit count?
00004ABA 6700                       		beq.s	.Kill				; If not, branch
00004ABC 4468 001C                  		neg.w	_objXVel(a0)			; Bounce backwards
00004AC0 4468 001E                  		neg.w	_objYVel(a0)			; ''
00004AC4 4229 002A                  		clr.b	_objColType(a1)			; Indicate that we have hit the boss
00004AC8 5329 002B                  		subq.b	#1,_objHitCnt(a1)			; Decrement hit count
00004ACC 6600                       		bne.s	.BossEnd			; If it hasn't reached 0, branch
00004ACE 08E9 0007 0028             		bset	#7,_objStatus(a1)			; Set the "killed" flag
00004AD4                            
00004AD4                            .BossEnd:
00004AD4 4E75                       		rts
00004AD6                            
00004AD6                            .Kill:
00004AD6 08E9 0007 0028             		bset	#7,_objStatus(a1)			; Set the "killed" flag
00004ADC 22BC 0000 0000             		move.l	#ObjExplosion,_objAddress(a1)		; Change into an explosion
00004AE2 4229 002A                  		clr.b	_objColType(a1)			; Indicate that we have hit the boss
00004AE6 4229 0025                  		clr.b	_objRoutine(a1)			; Reset the routine ID
00004AEA 4A68 001E                  		tst.w	_objYVel(a0)			; Are we going up?
00004AEE 6B00                       		bmi.s	.MoveDown			; If so, branch
00004AF0 3028 0018                  		move.w	_objYPos(a0),d0			; Are we below the object?
00004AF4 B069 0018                  		cmp.w	_objYPos(a1),d0			; ''
00004AF8 6400                       		bhs.s	.MoveUp				; If so, branch
00004AFA 4468 001E                  		neg.w	_objYVel(a0)			; Bounce up
00004AFE 4E75                       		rts
00004B00                            
00004B00                            .MoveDown:
00004B00 0668 0100 001E             		addi.w	#$100,_objYVel(a0)			; Move down
00004B06 4E75                       		rts
00004B08                            
00004B08                            .MoveUp:
00004B08 0468 0100 001E             		subi.w	#$100,_objYVel(a0)			; Move up
00004B0E 4E75                       		rts
00004B10                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B10                            .Indestructable: 
00004B10                            ;---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B10                            .ChkHurt:
00004B10 4A68 0000                  		tst.w	_objInvulTime(a0)			; Are we invulnerable?
00004B14 6600                       		bne.s	.NoHurt				; If so, branch
00004B16 2449                       		movea.l	a1,a2				; Copy harmful object's pointer
00004B18 4EF9 0000 0000             		jmp	ObjPlayer_GetHurt		; Get hurts
00004B1E                            
00004B1E                            .NoHurt:
00004B1E 4E75                       		rts
00004B20                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B20                            ; Add a new entry to the collision response list
00004B20                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B20                            AddToColResponse:
00004B20 43F8 E7D6                  		lea	collideList.w,a1			; Get collision response list
00004B24 0C51 007E                  		cmpi.w	#$7E,(a1)			; Is it full?
00004B28 6400                       		bhs.s	.End				; If so, branch
00004B2A 5451                       		addq.w	#2,(a1)				; Add a new entry
00004B2C D2D1                       		adda.w	(a1),a1				; Get entry pointer
00004B2E 3288                       		move.w	a0,(a1)				; Store entry
00004B30                            
00004B30                            .End:
00004B30 4E75                       		rts
00004B32                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B32                            ; Save some info in a level (mainly for checkpoints)
00004B32                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B32                            ; PARAMETERS:
00004B32                            ;	a0.l	- Object space pointer
00004B32                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B32                            ; RETURNS:
00004B32                            ;	Nothing
00004B32                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B32                            Level_SaveInfo:
00004B32 31E8 0014 C7B2             		move.w	_objXPos(a0),chkSavedXPos.w		; Save X position
00004B38 31E8 0018 C7B4             		move.w	_objYPos(a0),chkSavedYPos.w		; Save Y position
00004B3E 4E75                       		rts
00004B40                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B40                            ; Load some info in a level (mainly for checkpoints)
00004B40                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B40                            ; PARAMETERS:
00004B40                            ;	a0.l	- Object space pointer
00004B40                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B40                            ; RETURNS:
00004B40                            ;	Nothing
00004B40                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B40                            Level_LoadSavedInfo:
00004B40 3178 C7B2 0014             		move.w	chkSavedXPos.w,_objXPos(a0)		; Load X position
00004B46 3178 C7B4 0018             		move.w	chkSavedYPos.w,_objYPos(a0)		; Load Y position
00004B4C 4E75                       		rts
00004B4E                            ; =========================================================================================================================================================
00004B4E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B4E                            ; Music IDs
00004B4E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B4E                            Level_MusicIDs:
00004B4E 0B0B                       		dc.b	mWWZ, mWWZ
00004B50                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B50                            ; Level water heights (-1 for no water)
00004B50                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B50                            Level_WatelevelIDs:
00004B50                            		;dc.w	$490, -1			; Wacky Workbench
00004B50 FFFF FFFF                  		dc.w	-1, -1
00004B54                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B54                            ; Level data pointers
00004B54                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B54                            ; FORMAT:
00004B54                            ;	dc.l	CHUNKS, BLOCKS, TILES, PALETTE
00004B54                            ;	dc.l	FG LAYOUT, BG LAYOUT 
00004B54                            ;	dc.l	OBJECTS, RINGS, COLLISION
00004B54                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B54                            Level_DataPointers:
00004B54 0000 0000 0000 0000 0000+  		dc.l	WWZ_Chunks, WWZ_Blocks, WWZ_Tiles, WWZ_Pal
00004B64 0000 0000 0000 0000        		dc.l	WWZ_FGLayout, WWZ_BGLayout
00004B6C 0000 0000 0000 0000 0000+  		dc.l	WWZ_Objects, WWZ_Rings, WWZ_Collision
00004B78                            
00004B78 0000 0000 0000 0000 0000+  		dc.l	WWZ_Chunks, WWZ_Blocks, WWZ_Tiles, WWZ_Pal
00004B88 0000 0000 0000 0000        		dc.l	WWZ_FGLayout, WWZ_BGLayout
00004B90 0000 0000 0000 0000 0000+  		dc.l	WWZ_Objects, WWZ_Rings, WWZ_Collision
00004B9C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B9C                            ; Size and start position data
00004B9C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B9C                            Level_SizeStartPos:
00004B9C 3000 0580                  		dc.w	$3000, $580
00004BA0                            		incbin	"Zones/Wacky Workbench/Start Position.bin"
00004BA4 3000 0580                  		dc.w	$3000, $580
00004BA8                            		incbin	"Zones/Wacky Workbench/Start Position.bin"
00004BAC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004BAC                            ; Dynamic events routines
00004BAC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004BAC                            Level_DynEvenRouts:
00004BAC 0000 0000                  		dc.l	DynEv_WWZ			; Wacky Workbench
00004BB0 0000 0000                  		dc.l	DynEv_WWZ
00004BB4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004BB4                            ; Wacky Workbench dynamic events routine
00004BB4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004BB4                            DynEv_WWZ:
00004BB4 31FC 0000 E8CA             		move.w	#0,	maxCamXPos
00004BBA 31FC 0000 E8CC             		move.w	#0,	maxCamYPos
00004BC0 7000                       		moveq	#0,d0
00004BC2 1038 E908                  		move.b	dynEventRout.w,d0
00004BC6 303B 0000                  		move.w	.Index(pc,d0.w),d0
00004BCA 4EFB 0000                  		jmp	.Index(pc,d0.w)
00004BCE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004BCE                            .Index:
00004BCE 0000                       		dc.w	.WaitBoss-.Index
00004BD0 0000                       		dc.w	.Done-.Index
00004BD2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004BD2                            .WaitBoss:
00004BD2                            
00004BD2                            
00004BD2                            .Done:
00004BD2 4E75                       		rts
00004BD4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004BD4                            ; Palette cycle routines
00004BD4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004BD4                            Level_PalCycRouts:
00004BD4 0000 0000                  		dc.l	PalCycle_WWZ			; Wacky Workbench
00004BD8 0000 0000                  		dc.l	PalCycle_WWZ
00004BDC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004BDC                            ; Wacky Workbench palette cycle routine
00004BDC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004BDC                            PalCycle_WWZ:
00004BDC 4A38 E909                  		tst.b	rFlooactIDive.w		; Is the floor active?
00004BE0 6600                       		bne.s	.Flash				; If so, branch
00004BE2                            
00004BE2 5378 E90A                  		subq.w	#1,rFloorTimer.w		; Decrement the floor timer
00004BE6 6A00                       		bpl.s	.ResetPal			; If it hasn't run out, branch
00004BE8 50F8 E909                  		st	rFlooactIDive.w		; Set the floor active flag
00004BEC 31FC 00B4 E90A             		move.w	#180,rFloorTimer.w		; Set the floor timer
00004BF2                            
00004BF2                            .ResetPal:
00004BF2 4278 C7D0                  		clr.w	palCycTimer.w		; Reset the palette cycle
00004BF6 31FC 0C28 9930             		move.w	#$C28,(paletteBuff+$62).w		; Set the floor color to be deactivated
00004BFC 31FC 0E48 98B0             		move.w	#$E48,(paletteBuffAlt+$62).w	; ''
00004C02 4E75                       		rts
00004C04                            
00004C04                            .Flash:
00004C04 5378 E90A                  		subq.w	#1,rFloorTimer.w		; Decrement the floor timer
00004C08 6A00                       		bpl.s	.UpdatePal			; If it hasn't run out, branch
00004C0A 4238 E909                  		clr.b	rFlooactIDive.w		; Clear the floor active flag
00004C0E 31FC 001E E90A             		move.w	#30,rFloorTimer.w		; Set the floor timer
00004C14                            
00004C14                            .UpdatePal:
00004C14 5338 C7D0                  		subq.b	#1,palCycTimer.w		; Decrement the palette cycle timer
00004C18 6A00                       		bpl.s	.End				; If it hasn't run out, branch
00004C1A 11FC 0001 C7D0             		move.b	#1,palCycTimer.w		; Reset the palette cycle timer
00004C20                            
00004C20 7000                       		moveq	#0,d0
00004C22 1038 C7D1                  		move.b	palCycIndex.w,d0		; Get the palette cycle index
00004C26 D040                       		add.w	d0,d0				; Turn into offset
00004C28                            							; Set the floor color
00004C28 31FB 0000 9930             		move.w	PalCyc_WWZFloor(pc,d0.w),(paletteBuff+$62).w
00004C2E 31FB 0000 98B0             		move.w	PalCyc_WWZFloorUW(pc,d0.w),(paletteBuffAlt+$62).w
00004C34                            
00004C34 5238 C7D1                  		addq.b	#1,palCycIndex.w		; Increment the palette cycle index
00004C38 0C38 0005 C7D1             		cmpi.b	#5,palCycIndex.w		; Has it reached the end of the cycle?
00004C3E 6500                       		bcs.s	.End				; If not, branch
00004C40 4238 C7D1                  		clr.b	palCycIndex.w		; Reset the palette cycle index
00004C44                            
00004C44                            .End:
00004C44 4E75                       		rts
00004C46                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C46                            PalCyc_WWZFloor:
00004C46 0C28 0000 00EE 0000 0EEE   		dc.w	$C28, $000, $0EE, $000, $EEE
00004C50                            PalCyc_WWZFloorUW:
00004C50 0E48 0220 02EE 0220 0EEE   		dc.w	$E48, $220, $2EE, $220, $EEE
00004C5A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C5A                            ; Animated art routines
00004C5A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C5A                            Level_AniArtRouts:
00004C5A 0000 0000                  		dc.l	AniArt_WWZ			; Wacky Workbench
00004C5E 0000 0000                  		dc.l	AniArt_WWZ
00004C62                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C62                            ; Wacky Workbench animated art routine
00004C62                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C62                            AniArt_WWZ:
00004C62 45FA 0000                  		lea	.AniData(pc),a2			; Tutorial animated art data
00004C66 6000 F86C                  		bra.w	AniArt_D_objAnimmate		; Handle animations
00004C6A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C6A                            .AniData:
00004C6A 0002                       		dc.w	2
00004C6C                            
00004C6C                            		lvlAniDat 3, ArtUnc_Electricity, $162, 4, 8
00004C6C 0000 0000                M 	dc.l	(3&$ff)<<24|artunc_electricity
00004C70 2C40                     M 	dc.w	(($162&$7ff)<<5)
00004C72 0408                     M 	dc.b	4,8
00004C74 0008 1018                  		dc.b	0, 8, $10, $18
00004C78                            
00004C78                            		lvlAniDat 1, ArtUnc_ElectricOrbs, $15E, $E, 4
00004C78 0000 0000                M 	dc.l	(1&$ff)<<24|artunc_electricorbs
00004C7C 2BC0                     M 	dc.w	(($15e&$7ff)<<5)
00004C7E 0E04                     M 	dc.b	$e,4
00004C80 0004 0400 0404 0804 0408+  		dc.b	0, 4, 4, 0, 4, 4, 8, 4, 4, 8, $C, 4, 4, $C
00004C8E                            
00004C8E                            		lvlAniDat 4, ArtUnc_Sirens, $A8, 8, 4
00004C8E 0000 0000                M 	dc.l	(4&$ff)<<24|artunc_sirens
00004C92 1500                     M 	dc.w	(($a8&$7ff)<<5)
00004C94 0804                     M 	dc.b	8,4
00004C96 0004 0408 0C0C 0C0C        		dc.b	0, 4, 4, 8, $C, $C, $C, $C
00004C9E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C9E                            ; Level drawing initialization and update routines
00004C9E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C9E                            ; PARAMETERS:
00004C9E                            ;	a1.l	- Camera RAM
00004C9E                            ;	a3.l	- Row plane buffer
00004C9E                            ;	a4.l	- Column plane buffer
00004C9E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C9E                            ; RETURNS:
00004C9E                            ;	Nothing
00004C9E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C9E                            Level_RenderRouts:
00004C9E 0000 2B4E                  		dc.l	General_InitFG			; Wacky Workbench
00004CA2 0000 0000                  		dc.l	WWZ_InitBG
00004CA6 0000 2B6E                  		dc.l	General_UpdateFG
00004CAA 0000 0000                  		dc.l	WWZ_UpdateBG
00004CAE 0000 2B4E                  		dc.l	General_InitFG
00004CB2 0000 0000                  		dc.l	WWZ_InitBG
00004CB6 0000 2B6E                  		dc.l	General_UpdateFG
00004CBA 0000 0000                  		dc.l	WWZ_UpdateBG
00004CBE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004CBE                            ; Wacky Workbench background initialization
00004CBE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004CBE                            WWZ_InitBG:
00004CBE 45F8 E88A                  		lea	fgCamVars.w,a2			; Get foreground camera RAM
00004CC2 302A 0008                  		move.w	cYPos(a2),d0			; Get foreground Y position
00004CC6 E440                       		asr.w	#2,d0				; Divide by $20
00004CC8 3340 0008                  		move.w	d0,cYPos(a1)			; Set as background Y position
00004CCC                            
00004CCC 6100 E1D8                  		bsr.w	Level_RefreshPlane		; Refresh the plane
00004CD0                            
00004CD0 47FA 0000                  		lea	WWZ_Scroll(pc),a3		; Get background scroll data
00004CD4 6000 E230                  		bra.w	ScrollSections			; Scroll the planes
00004CD8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004CD8                            ; Wacky Workbench background update
00004CD8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004CD8                            WWZ_UpdateBG:
00004CD8 45F8 E88A                  		lea	fgCamVars.w,a2			; Get foreground camera RAM
00004CDC 302A 0008                  		move.w	cYPos(a2),d0			; Get foreground Y position
00004CE0 E440                       		asr.w	#2,d0				; Divide by $20
00004CE2 3340 0008                  		move.w	d0,cYPos(a1)			; Set as background Y position
00004CE6                            
00004CE6 6100 E210                  		bsr.w	Level_ChkRedrawPlane		; Check if the plane needs to be redrawn
00004CEA 781F                       		moveq	#(512/16)-1,d4			; Number of blocks per column
00004CEC 6100 DF92                  		bsr.w	Level_UpdatePlaney		; Update the plane
00004CF0                            
00004CF0 47FA 0000                  		lea	WWZ_Scroll(pc),a3		; Get background scroll data
00004CF4 6000 E210                  		bra.w	ScrollSections			; Scroll the planes
00004CF8                            ; --------------------------------------------------------------------------------------------------------------------------------------
00004CF8                            		scrollInit WWZ_Scroll
00004CF8                          M scroll_label	equs	"wwz_scroll"
00004CF8 0000                     M wwz_scroll:	dc.w	((wwz_scroll_end-wwz_scroll-2)/6)-1
00004CFA                            
00004CFA                            		; CEILING LIGHTS
00004CFA                            		scrollSection	 48, $80
00004CFA 0080 0000 0030           M 	dc.w	$80,0,48
00004D00                            		scrollSection	 32, $60
00004D00 0060 0000 0020           M 	dc.w	$60,0,32
00004D06                            		scrollSection	 32, $50
00004D06 0050 0000 0020           M 	dc.w	$50,0,32
00004D0C                            		scrollSection	 24, $40
00004D0C 0040 0000 0018           M 	dc.w	$40,0,24
00004D12                            		scrollSection	 24, $38
00004D12 0038 0000 0018           M 	dc.w	$38,0,24
00004D18                            		scrollSection	 16, $30
00004D18 0030 0000 0010           M 	dc.w	$30,0,16
00004D1E                            		scrollSection	 16, $2C
00004D1E 002C 0000 0010           M 	dc.w	$2c,0,16
00004D24                            		scrollSection	 16, $28
00004D24 0028 0000 0010           M 	dc.w	$28,0,16
00004D2A                            		scrollSection	 16, $24
00004D2A 0024 0000 0010           M 	dc.w	$24,0,16
00004D30                            		scrollSection	 16, $20
00004D30 0020 0000 0010           M 	dc.w	$20,0,16
00004D36                            
00004D36                            		; BACK WALL
00004D36                            		scrollSection	160, $40
00004D36 0040 0000 00A0           M 	dc.w	$40,0,160
00004D3C                            
00004D3C                            		; FRONT WALL
00004D3C                            		scrollSection	368, $80
00004D3C 0080 0000 0170           M 	dc.w	$80,0,368
00004D42                            
00004D42                            		scrollEnd
00004D42                          M wwz_scroll_end:
00004D42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004D42                            ; Main level PLCs
00004D42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004D42                            PLC_LevelMain:
00004D42 000A                       		dc.w	$A
00004D44 0000 0000                  		dc.l	ArtKosM_Chkpoint
00004D48 AFC0                       		dc.w	$AFC0
00004D4A 0000 0000                  		dc.l	ArtKosM_Monitor
00004D4E B100                       		dc.w	$B100
00004D50 0000 0000                  		dc.l	ArtKosM_SpringH
00004D54 B740                       		dc.w	$B740
00004D56 0000 0000                  		dc.l	ArtKosM_SpringV
00004D5A B940                       		dc.w	$B940
00004D5C 0000 0000                  		dc.l	ArtKosM_SpringD
00004D60 BB20                       		dc.w	$BB20
00004D62 0000 0000                  		dc.l	ArtKosM_HUD
00004D66 D000                       		dc.w	$D000
00004D68 0000 0000                  		dc.l	ArtKosM_WaterSurface
00004D6C D200                       		dc.w	$D200
00004D6E 0000 0000                  		dc.l	ArtKosM_SpikesN
00004D72 D500                       		dc.w	$D500
00004D74 0000 0000                  		dc.l	ArtKosM_SpikesS
00004D78 D580                       		dc.w	$D580
00004D7A 0000 0000                  		dc.l	ArtKosM_RingSparkle
00004D7E D700                       		dc.w	$D700
00004D80 0000 0000                  		dc.l	ArtKosM_Explosion
00004D84 D800                       		dc.w	$D800
00004D86                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004D86                            ; Level PLCs
00004D86                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004D86                            Level_PLCs:
00004D86 0000 0000                  		dc.l	PLC_WWZ
00004D8A 0000 0000                  		dc.l	PLC_WWZ
00004D8E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004D8E                            ; Wacky Workbench PLCs
00004D8E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004D8E                            PLC_WWZ:
00004D8E 0000                       		dc.w	0
00004D90 0000 0000                  		dc.l	ArtKosM_Bumper
00004D94 6B60                       		dc.w	$6B60
00004D96                            	;	dc.l	ArtKosM_Orbinaut
00004D96                            	;	dc.w	$71A0
00004D96                            	;	dc.l	ArtKosM_Diamond
00004D96                            	;	dc.w	$7580
00004D96                            	;	dc.l	ArtKosM_CNZBarrel
00004D96                            	;	dc.w	$7A00
00004D96                            	;	dc.l	ArtKosM_Slicer
00004D96                            	;	dc.w	$8000
00004D96                            	;	dc.l	ArtKosM_ShlCrker
00004D96                            	;	dc.w	$8400
00004D96                            	;	dc.l	ArtKosM_Asteron
00004D96                            	;	dc.w	$8880
00004D96                            	;	dc.l	ArtKosM_Harpoon
00004D96                            	;	dc.w	$8A60
00004D96                            	;	dc.l	ArtKosM_WFZBoss
00004D96                            	;	dc.w	$9000
00004D96                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004D96                            ; Object index
00004D96                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004D96                            Level_ObjIndex:
00004D96 0000 0000                  		dc.l	ObjEnemy
00004D9A 0000 0000                  		dc.l	ObjSpike
00004D9E 0000 0000                  		dc.l	ObjSpring
00004DA2 0000 0000                  		dc.l	ObjCheckpoint
00004DA6 0000 0000                  		dc.l	ObjNull			;ObjSlicer
00004DAA 0000 0000                  		dc.l	ObjNull			;ObjShlCrker
00004DAE 0000 0000                  		dc.l	ObjNull			;ObjAsteron
00004DB2 0000 0000                  		dc.l	ObjNull			;ObjWFZBoss
00004DB6 0000 0000                  		dc.l	ObjWallSpring
00004DBA 0000 0000                  		dc.l	ObjNull			;ObjHarpoon
00004DBE 0000 0000                  		dc.l	ObjBallMode
00004DC2 0000 0000                  		dc.l	ObjAttack
00004DC6 0000 0000                  		dc.l	ObjNull			;ObjCNZBarrel
00004DCA 0000 0000                  		dc.l	ObjNull			;ObjDiamond
00004DCE 0000 0000                  		dc.l	ObjNull			;ObjOrbinaut
00004DD2                            
00004DD2                            ; =========================================================================================================================================================
00004DD2                            		include	"Opmodes/Ending/Main.asm"
00004DD2                            ; =========================================================================================================================================================
00004DD2                            ; End splash screen
00004DD2                            ; =========================================================================================================================================================
00004DD2                            
00004DD2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004DD2                            Ending:
00004DD2 60FE                       		bra.s	Ending
00004DD4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004DD4                            ;		playSnd	#Mus_Stop, 1			; Stop sound
00004DD4                            ;
00004DD4                            ;		intsOff					; Disable interrupts
00004DD4                            ;
00004DD4                            ;		lea	VDP_CTRL,a5
00004DD4                            ;		move.w	#$8004,(a5)			; $8004 - Disable H-INT, H/V Counter
00004DD4                            ;		move.w	#$8134,(a5)			; $8134 - Disable display, enable V-INT, enable DMA, V28
00004DD4                            ;		move.w	#$8230,(a5)			; $8230 - Plane A at $C000
00004DD4                            ;		move.w	#$8407,(a5)			; $8407 - Plane B at $E000
00004DD4                            ;		move.w	#$9001,(a5)			; $9001 - 64x32 cell plane area
00004DD4                            ;		move.w	#$9200,(a5)			; $9200 - Window V position at default
00004DD4                            ;		move.w	#$8B00,(a5)			; $8B03 - V-Scroll by screen, H-Scroll by screen
00004DD4                            ;		move.w	#$8700,(a5)			; $8700 - BG color pal 0 color 0
00004DD4                            ;		clr.w	dmaQueue.w			; Set stop token at the beginning of the DMA queue
00004DD4                            ;		move.w	#dmaQueue,dmaSlot.w	; Reset the DMA queue slot
00004DD4                            ;
00004DD4                            ;		jsr	ClearScreen.w			; Clear screen
00004DD4                            ;
00004DD4                            ;		lea	MapEni_End(pc),a0		; Decompress background mappings
00004DD4                            ;		lea	miscBuff,a1			; Decompress into RAM
00004DD4                            ;		moveq	#1,d0				; Base tile properties: Tile ID 1, no flags
00004DD4                            ;		jsr	EniDec.w			; Decompress!
00004DD4                            ;
00004DD4                            ;		lea	miscBuff,a1			; Load mappings
00004DD4                            ;		move.l	#$60000003,d0			; At (0, 0) on plane A
00004DD4                            ;		moveq	#$27,d1				; $28x$1C tiles
00004DD4                            ;		moveq	#$1B,d2				; ''
00004DD4                            ;		moveq	#0,d3				; Base tile properties: Tile ID 0, no flags
00004DD4                            ;		jsr	LoadPlaneMap.w			; Load the map
00004DD4                            ;
00004DD4                            ;		lea	ArtKosM_End,a1			; Load background art
00004DD4                            ;		move.w	#$20,d2				; ''
00004DD4                            ;		jsr	QueueKosMData.w			; ''
00004DD4                            ;
00004DD4                            ;.WaitPLCs:
00004DD4                            ;		move.b	#vGeneral,vIntRoutine.w		; Level load V-INT routine
00004DD4                            ;		jsr	ProcessKos.w			; Process Kosinski queue
00004DD4                            ;		jsr	VSync_Routine.w			; V-SYNC
00004DD4                            ;		jsr	ProcessKosM.w			; Process Kosinski Moduled queue
00004DD4                            ;		tst.b	kosMModules.w			; Are there still modules left?
00004DD4                            ;		bne.s	.WaitPLCs			; If so, branch
00004DD4                            ;		move.b	#vGeneral,vIntRoutine.w		; Level load V-INT routine
00004DD4                            ;		jsr	VSync_Routine.w			; V-SYNC
00004DD4                            ;
00004DD4                            ;		lea	SampleList+$F0,a3
00004DD4                            ;		jsr	PlayDAC1
00004DD4                            ;
00004DD4                            ;		lea	Pal_End(pc),a0			; Load palette to target buffer
00004DD4                            ;		move.w	#(Pal_End_End-Pal_End)>>1-1,d0	; ''
00004DD4                            ;		jsr	LoadPalette.w			; ''
00004DD4                            ;
00004DD4                            ;		displayOn
00004DD4                            ;
00004DD4                            ;.Loop:
00004DD4                            ;		move.b	#vTitle,vIntRoutine.w		; V-SYNC
00004DD4                            ;		jsr	VSync_Routine.w			; ''
00004DD4                            ;		bra.s	.Loop
00004DD4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004DD4                            ; Art
00004DD4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004DD4                            ;ArtKosM_End:
00004DD4                            ;		incbin	"Ending/Data/Art - Background.kosm.bin"
00004DD4                            ;		even
00004DD4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004DD4                            ; Plane mappings
00004DD4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004DD4                            ;MapEni_End:
00004DD4                            ;		incbin	"Ending/Data/Map - Background.eni.bin"
00004DD4                            ;		even
00004DD4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004DD4                            ; Palette
00004DD4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004DD4                            ;Pal_End:
00004DD4                            ;		incbin	"Ending/Data/Palette.pal.bin"
00004DD4                            ;Pal_End_End:
00004DD4                            ;		even
00004DD4                            ; =========================================================================================================================================================
00004DD4                            
00004DD4                            ; =========================================================================================================================================================
00004DD4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004DD4                            ; Object Code
00004DD4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004DD4                            ObjNull:
00004DD4 4EF8 1A4C                  		jmp	DeleteObject
00004DD8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004DD8                            		include	"Objects/Player/Code.asm"		; Player object
00004DD8                            ; =========================================================================================================================================================
00004DD8                            ; Sonic object
00004DD8                            ; =========================================================================================================================================================
00004DD8 =00000300                  TOP_SPD		EQU	$300				; Top speed
00004DD8 =0000000C                  ACC_SPD		EQU	$C				; Acceleration
00004DD8 =00000080                  DEC_SPD		EQU	$80				; Deceleration
00004DD8 =00000180                  JUMP_HEIGHT	EQU	$180				; Jump height
00004DD8 =00000180                  MIN_JMP_HEIGHT	EQU	$180				; Minimum jump height
00004DD8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004DD8                            		rsset	_objLvlSSTs
00004DD8 =00000030                  _objInitColH	rs.b	1				; Initial collision height
00004DD8 =00000031                  _objInitColW	rs.b	1				; Initial collision width
00004DD8 =00000032                  _objTopSolid	rs.b	1				; Top solid bit
00004DD8 =00000033                  _objLRBSolid	rs.b	1				; LRB solid bit
00004DD8 =00000034                  _objTopSpd	rs.w	1				; Top speed
00004DD8 =00000036                  _objAccel	rs.w	1				; Acceleration
00004DD8 =00000038                  _objDecel	rs.w	1				; Deceleration
00004DD8 =0000003A                  _objFlipDir	rs.w	0				; Flip direction
00004DD8 =0000003A                  _objGVel	rs.w	1				; Ground velocity
00004DD8 =0000003C                  _objInteract	rs.w	1				; Interacted object space pointer
00004DD8 =0000003E                  _objAirTimer	rs.b	1				; Air timer
00004DD8 =0000003F                  _objMoveLock	rs.b	1				; Move lock timer
00004DD8 =00000040                  _objJumping	rs.b	1				; Jumping flag
00004DD8 =00000041                  _objAngle	rs.b	1				; Angle
00004DD8 =00000042                  _objInvulTime	rs.b	1				; Invulnerability timer
00004DD8 =00000043                  _objDeathTimer	rs.b	1				; Death timer
00004DD8 =00000044                  _objScrlDelay	rs.b	1				; Look up and down scroll delay counter
00004DD8 =00000045                  _objDashFlag	rs.b	1				; Dash flags
00004DD8 =00000046                  _objDashTimer	rs.b	1				; Dash timer
00004DD8 =00000047                  _objFlipAngle	rs.b	1				; Flip angle about the X axis
00004DD8 =00000048                  _objFlipTurned	rs.b	1				; Inverted flip flag
00004DD8 =00000049                  _objFlipRemain	rs.b	1				; Remaining flips to do
00004DD8 =0000004A                  _objFlipSpeed	rs.b	1				; Flip speed
00004DD8 =0000004B                  _objBallMode	rs.b	1				; Ball mode flag
00004DD8 =0000004C                  _objHangAniTime	rs.b	1				; Hang animation timer
00004DD8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004DD8                            ObjPlayer:
00004DD8 7000                       		moveq	#0,d0
00004DDA 1028 0025                  		move.b	_objRoutine(a0),d0			; Get routine ID
00004DDE 4EBB 0000                  		jsr	.Index(pc,d0.w)			; Jump to it
00004DE2                            	nextObject
00004DE2 3068 0004                M 	movea.w	_objnext(a0),a0
00004DE6 2250                     M 	move.l	_objaddress(a0),a1
00004DE8 4ED1                     M 	jmp	(a1)
00004DEA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004DEA                            .Index:
00004DEA 6000 0000                  		bra.w	ObjPlayer_Init			; Initialization(00)
00004DEE 6000 0000                  		bra.w	ObjPlayer_Main			; Main		(04)
00004DF2 6000 0000                  		bra.w	ObjPlayer_Hurt			; Hurt		(08)
00004DF6 6000 0000                  		bra.w	ObjPlayer_Dead			; Dead		(0C)
00004DFA 6000 0000                  		bra.w	ObjPlayer_Gone			; Gone		(10)
00004DFE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004DFE                            ; Initialization routine
00004DFE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004DFE                            ObjPlayer_Init:
00004DFE 5828 0025                  		addq.b	#4,_objRoutine(a0)			; Next routine
00004E02                            
00004E02 117C 0007 002C             		move.b	#7,_objColW(a0)			; Collision width
00004E08 117C 0008 002D             		move.b	#$8,_objColH(a0)			; Collision height
00004E0E 1168 002C 0031             		move.b	_objColW(a0),_objInitColW(a0)		; Set initial collision width
00004E14 1168 002D 0030             		move.b	_objColH(a0),_objInitColH(a0)		; Set initial collision height
00004E1A 217C 0000 0000 0010        		move.l	#Map_ObjPlayer,_objMapping(a0)		; Mappings
00004E22 317C 0780 000E             		move.w	#$780,_objVRAM(a0)			; Sprite tile properties
00004E28                            	displaySprite	2,a0,a1,0			; Priority
00004E28 317C C16A 0008           M 	move.w	#objdisplay+(2*dsize),_objdrawnext(a0)
00004E2E 3278 C174                M 	move.w	objdisplay+dprev+(2*dsize).w,a1
00004E32 3149 000A                M 	move.w	a1,_objdrawprev(a0)
00004E36 3348 0008                M 	move.w	a0,_objdrawnext(a1)
00004E3A 31C8 C174                M 	move.w	a0,objdisplay+dprev+(2*dsize).w
00004E3E                          M .no_207
00004E3E 117C 0018 0017             		move.b	#$18,_objDrawW(a0)			; Sprite width
00004E44 117C 0018 001B             		move.b	#$18,_objDrawH(a0)			; Sprite height
00004E4A 117C 0004 000D             		move.b	#4,_objRender(a0)			; Render flags
00004E50                            
00004E50 117C 000C 0032             		move.b	#$C,_objTopSolid(a0)		; Top solid bit
00004E56 117C 000D 0033             		move.b	#$D,_objLRBSolid(a0)		; LRB solid bit
00004E5C 117C 001E 003E             		move.b	#$1E,_objAirTimer(a0)		; Set air timer
00004E62 50D0                       		st	_objPrevDPLC(a0)			; Reset saved DPLC frame
00004E64 4228 0049                  		clr.b	_objFlipRemain(a0)			; No flips remaining
00004E68 117C 0004 004A             		move.b	#4,_objFlipSpeed(a0)		; Flip speed
00004E6E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004E6E                            ; Main routine
00004E6E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004E6E                            ObjPlayer_Main:
00004E6E 4A38 C76A                  		tst.b	moveCheat.w
00004E72 6700                       		beq.s	.NoPlacementEnter
00004E74 0838 0004 C743             		btst	#4,ctrlPressP1.w			; Has the B button been pressed?
00004E7A 6700                       		beq.s	.NoPlacementEnter		; If not, branch
00004E7C 11FC 0001 E8DD             		move.b	#1,debugMode.w		; Enable debug placement mode
00004E82 20BC 0000 0000             		move.l	#DebugPlacement,_objAddress(a0)	; Set to debug placement mode
00004E88 4E75                       		rts
00004E8A                            
00004E8A                            .NoPlacementEnter:
00004E8A 0828 0002 000C             		btst	#2,_objFlags(a0)			; Are the controls locked?
00004E90 6600                       		bne.s	.Update				; If so, branch
00004E92 31F8 C742 E8DE             		move.w	ctrlDataP1.w,plrCtrlData.w		; Set the player's control data
00004E98                            
00004E98                            .Update:
00004E98                            	;	btst	#1,_objStatus(a0)
00004E98                            	;	bne.s	.NotOnGround
00004E98                            
00004E98                            ;.NotOnGround:
00004E98 6100 0000                  		bsr.w	ObjPlayer_Water			; Handle Sonic in water
00004E9C 6100 0000                  		bsr.w	ObjPlayer_GetPhysics		; Update Sonic's physics
00004EA0 6100 0000                  		bsr.w	ObjPlayer_DoModes		; Do modes
00004EA4 6100 0000                  		bsr.w	ObjPlayer_LvlBound		; Handle level boundaries
00004EA8 4EB8 4A2C                  		jsr	PlayerDoObjCollision		; Do object collision
00004EAC                            
00004EAC 6100 0000                  		bsr.w	ObjPlayer_Animate		; Animate sprite
00004EB0 6100 0000                  		bsr.w	ObjPlayer_Display		; Display sprite
00004EB4 6000 0000                  		bra.w	ObjPlayer_LoadDPLCs		; Load DPLCs
00004EB8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004EB8                            ; Handle the extended camera
00004EB8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004EB8                            ObjPlayer_ExtendedCam:
00004EB8 3238 E8D6                  		move.w	panCamXPos.w,d1		; Get camera X center
00004EBC 3028 003A                  		move.w	_objGVel(a0),d0			; Get ground velocity
00004EC0 6A00                       		bpl.s	.PosGVel			; Get absolute value
00004EC2 4440                       		neg.w	d0				; ''
00004EC4                            
00004EC4                            .PosGVel:
00004EC4 0C40 0600                  		cmpi.w	#$600,d0			; Is Sonic going at 6 pixels/frame?
00004EC8 6500                       		bcs.s	.ResetXShift			; If not, branch
00004ECA 4A68 003A                  		tst.w	_objGVel(a0)			; Is Sonic moving right?
00004ECE 6A00                       		bpl.s	.MoveRight			; If so, branch
00004ED0 5441                       		addq.w	#2,d1				; Move right
00004ED2 0C41 00E0                  		cmpi.w	#$E0,d1				; Cap it
00004ED6 6500                       		bcs.s	.SetShift			; ''
00004ED8 323C 00E0                  		move.w	#$E0,d1				; ''
00004EDC 6000                       		bra.s	.SetShift			; Continue
00004EDE                            
00004EDE                            .MoveRight:
00004EDE 5541                       		subq.w	#2,d1				; Move left
00004EE0 0C41 0060                  		cmpi.w	#$60,d1				; Cap it
00004EE4 6400                       		bcc.s	.SetShift			; ''
00004EE6 323C 0060                  		move.w	#$60,d1				; ''
00004EEA 6000                       		bra.s	.SetShift			; Continue
00004EEC                            
00004EEC                            .ResetXShift:
00004EEC 0C41 00A0                  		cmpi.w	#$A0,d1				; Are we already back at the center?
00004EF0 6700                       		beq.s	.SetShift			; If so, branch
00004EF2 6400                       		bcc.s	.ReduceShift			; If we have to go back left, branch
00004EF4 5441                       		addq.w	#2,d1				; Move back right
00004EF6 6000                       		bra.s	.SetShift			; Continue
00004EF8                            
00004EF8                            .ReduceShift:
00004EF8 5541                       		subq.w	#2,d1				; Move back left
00004EFA                            
00004EFA                            .SetShift:
00004EFA 31C1 E8D6                  		move.w	d1,panCamXPos.w		; Set camera X center
00004EFE 4E75                       		rts
00004F00                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004F00                            ; Update Sonic's physics
00004F00                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004F00                            ObjPlayer_GetPhysics:
00004F00 7000                       		moveq	#0,d0
00004F02 0828 0006 0028             		btst	#6,_objStatus(a0)			; Is Sonic underwater?
00004F08 6700                       		beq.s	.GetOffset			; If not, branch
00004F0A 7008                       		moveq	#8,d0				; Set the underwater bit
00004F0C                            
00004F0C                            .GetOffset:
00004F0C 43FB 0000                  		lea	ObjPlayer_Physics(pc,d0.w),a1	; Get pointer to correct physics values
00004F10 2159 0034                  		move.l	(a1)+,_objTopSpd(a0)		; Set top speed and acceleration
00004F14 3151 0038                  		move.w	(a1),_objDecel(a0)			; Set deceleration
00004F18 4E75                       		rts
00004F1A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004F1A                            ; Physics values
00004F1A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004F1A                            ; FORMAT:
00004F1A                            ;	dc.w	TOP SPEED, ACCELERATION, DECELERATION, 0
00004F1A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004F1A                            ObjPlayer_Physics:
00004F1A 0300 000C 0080 0000        		dc.w	TOP_SPD,     ACC_SPD,     DEC_SPD,     0; Normal
00004F22 0180 0006 0040 0000        		dc.w	TOP_SPD/2,   ACC_SPD/2,   DEC_SPD/2,   0; Underwater
00004F2A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004F2A                            ; Handle Sonic in the water
00004F2A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004F2A                            ObjPlayer_Water:
00004F2A 4A38 E8FE                  	tst.b	lvlHasWater.w			; Is there water in the level?
00004F2E 6600                       	bne.s	.HandleWater			; If so, branch
00004F30                            
00004F30                            .End:
00004F30 4E75                       	rts
00004F32                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004F32                            .HandleWater:
00004F32 3038 E900                  		move.w	waterYPos.w,d0		; Get water height
00004F36 B068 0018                  		cmp.w	_objYPos(a0),d0			; Is Lover in the water?
00004F3A 6C00                       		bge.s	.NotInWater			; If not, branch
00004F3C                            
00004F3C 08E8 0006 0028             		bset	#6,_objStatus(a0)			; Set the "in water" flag
00004F42 66EC                       		bne.s	.End				; If Lover is already in the water, branch
00004F44                            
00004F44 E0E8 001C                  		asr.w	_objXVel(a0)			; Make Lover move slower
00004F48 E0E8 001E                  		asr.w	_objYVel(a0)
00004F4C E0E8 001E                  		asr.w	_objYVel(a0)
00004F50 67DE                       		beq.s	.End				; If a splash doesn't need to be created, branch
00004F52                            
00004F52                            		playSnd	#sSplash, 2			; Play splash sound
00004F52 11FC 0090 C4BD           M 	move.b	#ssplash,(mqueue+((2)-1)).w
00004F58 4E75                       		rts
00004F5A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004F5A                            .NotInWater:
00004F5A 08A8 0006 0028             		bclr	#6,_objStatus(a0)			; Clear "in water" flag
00004F60 67CE                       		beq.s	.End				; If Lover was already out of the water, branch
00004F62                            
00004F62 0C28 0010 0025             		cmpi.b	#$10,_objRoutine(a0)			; Is Lover falling back from getting hurt?
00004F68 6700                       		beq.s	.ChkSplash			; If so, branch
00004F6A E1E8 001E                  		asl	_objYVel(a0)			; Make Lover move faster vertically
00004F6E                            
00004F6E                            .ChkSplash:
00004F6E 4A68 001E                  		tst.w	_objYVel(a0)			; Does a splash need to be created?
00004F72 67BC                       		beq.s	.End				; If not, branch
00004F74                            
00004F74 0C68 F000 001E             		cmpi.w	#-$1000,_objYVel(a0)		; Is Lover moving more than -$10 pixels per frame?
00004F7A 6E00                       		bgt.s	.PlaySplashSnd			; If not, branch
00004F7C 317C F000 001E             		move.w	#-$1000,_objYVel(a0)		; Cap the speed
00004F82                            
00004F82                            .PlaySplashSnd:
00004F82                            		playSnd	#sSplash, 2			; Play splash sound
00004F82 11FC 0090 C4BD           M 	move.b	#ssplash,(mqueue+((2)-1)).w
00004F88 4E75                       		rts
00004F8A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004F8A                            ; Do Sonic's modes
00004F8A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004F8A                            ObjPlayer_DoModes:
00004F8A 0828 0000 000C             		btst	#0,_objFlags(a0)			; Is running Sonic's mode disabled?
00004F90 6600                       		bne.s	.NoMode				; If so, branch
00004F92                            
00004F92 7000                       		moveq	#0,d0
00004F94 1028 0028                  		move.b	_objStatus(a0),d0			; Get status
00004F98 0240 0006                  		andi.w	#6,d0				; Only get mode bits
00004F9C D040                       		add.w	d0,d0
00004F9E 4EBB 0000                  		jsr	ObjPlayer_Modes(pc,d0.w)	; Jump to the right routine
00004FA2                            
00004FA2 6100 FF14                  		bsr.w	ObjPlayer_ExtendedCam		; Handle extended camera
00004FA6 6100 0000                  		bsr.w	ObjPlayer_ChkBounce		; Check for bouncy floor collision
00004FAA 6100 0000                  		bsr.w	ObjPlayer_ChkHang		; Check for hanging
00004FAE 6000 0000                  		bra.w	ObjPlayer_ChkElectric		; Check for electricity
00004FB2                            
00004FB2                            .NoMode:
00004FB2 4E75                       		rts
00004FB4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004FB4                            ; Sonic's modes
00004FB4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004FB4                            ObjPlayer_Modes:
00004FB4 6000 0000                  		bra.w	ObjPlayer_MdGround		; Ground
00004FB8 6000 0000                  		bra.w	ObjPlayer_MdAir			; Air
00004FBC 6000 0000                  		bra.w	ObjPlayer_MdRoll		; Roll
00004FC0 6000 0000                  		bra.w	ObjPlayer_MdJump		; Jumping
00004FC4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004FC4                            ; Ground mode
00004FC4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004FC4                            ObjPlayer_MdGround:
00004FC4                            ;		bsr.w	ObjPlayer_Peelout		; Handle the peelout
00004FC4                            ;		bsr.w	ObjPlayer_Spindash		; Handle the spindash
00004FC4 6100 0000                  		bsr.w	ObjPlayer_ChkJump		; Check for jumping
00004FC8 6100 0000                  		bsr.w	ObjPlayer_ChkAttack		; Check for attack
00004FCC                            ;		bsr.w	ObjPlayer_ChkRoll		; Check for rolling
00004FCC 6100 0000                  		bsr.w	ObjPlayer_MoveGround		; Do movement on the ground
00004FD0 4EB8 1D28                  		jsr	ObjectMove.w			; Allow movement
00004FD4 4EB8 365E                  		jsr	PlayerAnglePos			; Update position and angle along the ground
00004FD8                            
00004FD8 6100 0000                  		bsr.w	ObjPlayer_SlopePush		; Affect Sonic's speed on a slope
00004FDC 6100 0000                  		bsr.w	ObjPlayer_FallOffSlope		; Check if Sonic is going to fall off the slope
00004FE0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004FE0                            ; Misc. updates
00004FE0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004FE0                            ObjPlayer_MiscUpdates:
00004FE0 4A28 003F                  		tst.b	_objMoveLock(a0)			; Is the move lock timer finished?
00004FE4 6700                       		beq.s	.NoMoveLock			; If so, branch
00004FE6 5328 003F                  		subq.b	#1,_objMoveLock(a0)		; Decrement the timer
00004FEA                            
00004FEA                            .NoMoveLock:
00004FEA 4EB8 3376                  		jsr	sub_F846
00004FEE 4A41                       		tst.w	d1
00004FF0 6B00 0000                  		bmi.w	ObjPlayer_GetKilled
00004FF4 4EB8 3606                  		jsr	PlayerChkLeftWallDist		; Check for left wall collision
00004FF8 4A41                       		tst.w	d1				; Has Sonic entered the wall?
00004FFA 6A00                       		bpl.s	.ChkRight			; If not, branch
00004FFC 9368 0014                  		sub.w	d1,_objXPos(a0)			; Fix Sonic's X position
00005000                            
00005000                            .ChkRight:
00005000 4EB8 348A                  		jsr	PlayerChkRightWallDist		; Check for right wall collision
00005004 4A41                       		tst.w	d1				; Has Sonic entered the wall?
00005006 6A00                       		bpl.s	.End				; If not, branch
00005008 D368 0014                  		add.w	d1,_objXPos(a0)			; Fix Sonic's X position
0000500C                            
0000500C                            .End:
0000500C 4E75                       		rts
0000500E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000500E                            ; Air and jump modes
0000500E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000500E                            ObjPlayer_MdJump:
0000500E                            ObjPlayer_MdAir:
0000500E 6100 0000                  		bsr.w	ObjPlayer_ChkJump		; Check for jumping
00005012 6100 0000                  		bsr.w	ObjPlayer_ChkAttack		; Check for attack
00005016                            
00005016 4268 003C                  		clr.w	_objInteract(a0)			; Sonic cannot be interacting with objects while in midair
0000501A 08A8 0003 0028             		bclr	#cStandBit,_objStatus(a0)		; ''
00005020                            
00005020 0828 0003 000C             		btst	#3,_objFlags(a0)			; Is Sonic hanging?
00005026 6700                       		beq.s	.DoModes			; If not, branch
00005028 6100 0000                  		bsr.w	ObjPlayer_Hang			; Hang
0000502C 6000                       		bra.s	.DoCol				; Continue
0000502E                            
0000502E                            .DoModes:
0000502E 6100 0000                  		bsr.w	ObjPlayer_JumpHeight		; Handle jump height
00005032 6100 0000                  		bsr.w	ObjPlayer_MoveAir		; Do movement
00005036 4EB8 1D42                  		jsr	ObjectMoveAndFall.w		; Allow movement
0000503A 0C68 1000 001E             		cmpi.w	#$1000,_objYVel(a0)		; Is Sonic moving down too fasr?
00005040 6F00                       		ble.s	.NoCap				; If not, branch
00005042 317C 1000 001E             		move.w	#$1000,_objYVel(a0)		; Cap the downward speed
00005048                            
00005048                            .NoCap:
00005048 6100 0000                  		bsr.w	ObjPlayer_JumpAngle		; Reset Sonic's angle in mid air
0000504C                            
0000504C                            .DoCol:
0000504C 0828 0006 0028             		btst	#6,_objStatus(a0)
00005052 6700                       		beq.s	.NoWater
00005054 0468 0028 001E             		subi.w	#$28,_objYVel(a0)
0000505A                            
0000505A                            .NoWater:
0000505A 4EB8 2FE2                  		jsr	PlayerChkCollision		; Check for level collision
0000505E 6080                       		bra.s	ObjPlayer_MiscUpdates
00005060                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005060                            ; Roll mode
00005060                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005060                            ObjPlayer_MdRoll:
00005060 6100 0000                  		bsr.w	ObjPlayer_ChkJump		; Check for jumping
00005064 6100 0000                  		bsr.w	ObjPlayer_ChkAttack		; Check for attack
00005068                            
00005068                            .NoJump:
00005068 6100 0000                  		bsr.w	ObjPlayer_RollSlopePush		; Push Sonic on a slope while rolling
0000506C 6100 0000                  		bsr.w	ObjPlayer_MoveRoll		; Do movement
00005070 4EB8 1D28                  		jsr	ObjectMove.w			; Allow movement
00005074 4EB8 365E                  		jsr	PlayerAnglePos			; Update position and angle along the ground
00005078                            
00005078 6100 0000                  		bsr.w	ObjPlayer_FallOffSlope		; Check if Sonic is going to fall off the slope
0000507C 6000 FF62                  		bra.w	ObjPlayer_MiscUpdates		; Do misc. updates
00005080                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005080                            ; Do movement on the ground
00005080                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005080                            ObjPlayer_MoveGround:
00005080 3C28 0034                  		move.w	_objTopSpd(a0),d6			; Get top speed
00005084 3A28 0036                  		move.w	_objAccel(a0),d5			; Get acceleration
00005088 3828 0038                  		move.w	_objDecel(a0),d4			; Get deceleration
0000508C                            
0000508C 4A28 003F                  		tst.b	_objMoveLock(a0)			; Is the move lock timer active?
00005090 6600 0000                  		bne.w	.ResetScr			; If so, branch
00005094                            
00005094 0838 0002 E8DE             		btst	#2,plrCtrlHold.w		; Is left held?
0000509A 6700                       		beq.s	.NotLeft			; If so, branch
0000509C 6100 0000                  		bsr.w	ObjPlayer_MoveLeft		; Move left
000050A0                            
000050A0                            .NotLeft:
000050A0 0838 0003 E8DE             		btst	#3,plrCtrlHold.w		; Is right held?
000050A6 6700                       		beq.s	.NotRight			; If so, branch
000050A8 6100 0000                  		bsr.w	ObjPlayer_MoveRight		; Move right
000050AC                            
000050AC                            .NotRight:
000050AC 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
000050B0 0600 0020                  		addi.b	#$20,d0				; Shift it
000050B4 0200 00C0                  		andi.b	#$C0,d0				; Get quadrant
000050B8 6600 0000                  		bne.w	.ResetScr			; If Sonic is not on the floor, branch
000050BC 4A68 003A                  		tst.w	_objGVel(a0)			; Has Sonic already been halted?
000050C0 6600 0000                  		bne.w	.ResetScr			; If not, branch
000050C4                            
000050C4 08A8 0005 0028             		bclr	#5,_objStatus(a0)			; Stop pushing
000050CA 117C 0005 0020             		move.b	#5,_objAnim(a0)			; Set to ducking animation
000050D0                            
000050D0 0828 0003 0028             		btst	#cStandBit,_objStatus(a0)		; Is Sonic standing on an object?
000050D6 6700 0000                  		beq.w	.ChkBalance			; If not, branch
000050DA 3268 003C                  		movea.w	_objInteract(a0),a1		; Get interacted object
000050DE 4A29 0028                  		tst.b	_objStatus(a1)			; Is Sonic standing on it?
000050E2 6B00                       		bmi.s	.ChkLookUp			; If not, branch
000050E4 7200                       		moveq	#0,d1
000050E6 1229 002C                  		move.b	_objColW(a1),d1			; Get width of object
000050EA 3401                       		move.w	d1,d2				; Copy it
000050EC D442                       		add.w	d2,d2				; Double the copy
000050EE 5942                       		subq.w	#4,d2				; Subtract 4 from the copy
000050F0 D268 0014                  		add.w	_objXPos(a0),d1			; Add Sonic's X position
000050F4 9269 0014                  		sub.w	_objXPos(a1),d1			; Subtract the object's X position
000050F8 0C41 0004                  		cmpi.w	#4,d1				; Is Sonic balancing on the left side of it?
000050FC 6D00                       		blt.s	.BalanceOnObjLeft		; If so, branch
000050FE B242                       		cmp.w	d2,d1				; Is Sonic balacning on the right side of it?
00005100 6C00                       		bge.s	.BalanceOnObjRight		; If so, branch
00005102 6000                       		bra.s	.ChkLookUp			; Continue
00005104                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005104                            .ChkBalance:
00005104 4EB8 334C                  		jsr	PlayerChkFloorDist		; Get floor distance
00005108 0C41 000C                  		cmpi.w	#$C,d1				; Is Sonic balancing?
0000510C 6D00                       		blt.s	.ChkLookUp			; If not, branch
0000510E 0C28 0003 002E             		cmpi.b	#3,_objNextTilt(a0)		; Is Sonic balancing on the right side?
00005114 6600                       		bne.s	.ChkLeftBalance			; If not, branch
00005116                            
00005116                            .BalanceOnObjRight:
00005116 08A8 0000 0028             		bclr	#0,_objStatus(a0)			; Face right
0000511C 6000                       		bra.s	.SetBalanceAnim			; Set the animation
0000511E                            
0000511E                            .ChkLeftBalance:
0000511E 0C28 0003 002F             		cmpi.b	#3,_objTilt(a0)			; Is Sonic balancing on the left side?
00005124 6600                       		bne.s	.ChkLookUp			; If not, branch
00005126                            
00005126                            .BalanceOnObjLeft:
00005126 08E8 0000 0028             		bset	#0,_objStatus(a0)			; Face left
0000512C                            
0000512C                            .SetBalanceAnim:
0000512C 117C 0006 0020             		move.b	#6,_objAnim(a0)			; Set balancing animation
00005132 6000                       		bra.s	.ResetScr			; Continue
00005134                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005134                            .ChkLookUp:
00005134 0838 0000 E8DE             		btst	#0,plrCtrlHold.w		; Is the up button being held?
0000513A 6700                       		beq.s	.ChkDown			; If not, branch
0000513C 117C 0007 0020             		move.b	#7,_objAnim(a0)			; Set to looking up animation
00005142                            
00005142 5228 0044                  		addq.b	#1,_objScrlDelay(a0)		; Increment scroll delay counter
00005146 0C28 0078 0044             		cmpi.b	#$78,_objScrlDelay(a0)		; Has it reached $78?
0000514C 6500                       		blo.s	.ResetScrPart2			; If not, branch
0000514E 117C 0078 0044             		move.b	#$78,_objScrlDelay(a0)		; Cap at $78
00005154 0C78 00C8 E8D8             		cmpi.w	#200,panCamYPos.w		; Has the camera finished scrolling?
0000515A 6700                       		beq.s	.UpdateSpdOnGround		; If so, branch
0000515C 5478 E8D8                  		addq.w	#2,panCamYPos.w		; Scroll the camera
00005160 6000                       		bra.s	.UpdateSpdOnGround		; Continue
00005162                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005162                            .ChkDown:
00005162 0838 0001 E8DE             		btst	#1,plrCtrlHold.w		; Is the down button being held?
00005168 6700                       		beq.s	.ResetScr			; If not, branch
0000516A 117C 0008 0020             		move.b	#8,_objAnim(a0)			; Set to ducking animation
00005170                            
00005170 5228 0044                  		addq.b	#1,_objScrlDelay(a0)		; Increment scroll delay counter
00005174 0C28 0078 0044             		cmpi.b	#$78,_objScrlDelay(a0)		; Has it reached $78?
0000517A 6500                       		blo.s	.ResetScrPart2			; If not, branch
0000517C 117C 0078 0044             		move.b	#$78,_objScrlDelay(a0)		; Cap at $78
00005182 0C78 0008 E8D8             		cmpi.w	#8,panCamYPos.w		; Has the camera finished scrolling?
00005188 6700                       		beq.s	.UpdateSpdOnGround		; If so, branch
0000518A 5578 E8D8                  		subq.w	#2,panCamYPos.w		; Scroll the camera
0000518E 6000                       		bra.s	.UpdateSpdOnGround		; Continue
00005190                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005190                            .ResetScr:
00005190 4228 0044                  		clr.b	_objScrlDelay(a0)			; Reset scroll delay counter
00005194                            
00005194                            .ResetScrPart2:
00005194 0C78 0060 E8D8             		cmpi.w	#(224/2)-16,panCamYPos.w	; Is the camera centered vertically?
0000519A 6700                       		beq.s	.UpdateSpdOnGround		; If so, branch
0000519C 6400                       		bhs.s	.ScrollUp			; If it's below the center, branch
0000519E 5878 E8D8                  		addq.w	#4,panCamYPos.w		; Scroll the camera up
000051A2                            
000051A2                            .ScrollUp:
000051A2 5578 E8D8                  		subq.w	#2,panCamYPos.w		; Scroll the camera down
000051A6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000051A6                            .UpdateSpdOnGround:
000051A6 1038 E8DE                  		move.b	plrCtrlHold.w,d0		; Get held buttons
000051AA 0200 000C                  		andi.b	#$C,d0				; Are left or right held?
000051AE 6600                       		bne.s	.ApplySpeed			; If so, branch
000051B0                            
000051B0 3028 003A                  		move.w	_objGVel(a0),d0			; Get current ground velocity
000051B4 6700                       		beq.s	.ApplySpeed			; If it's already 0, branch
000051B6 6B00                       		bmi.s	.SettleLeft			; Settle left if going left
000051B8                            
000051B8                            .SettleRight:
000051B8 9045                       		sub.w	d5,d0				; Slow down
000051BA 6A00                       		bpl.s	.SetSpeed			; If it's not done, branch
000051BC 7000                       		moveq	#0,d0				; Stop the movement
000051BE 6000                       		bra.s	.SetSpeed			; Continue
000051C0                            
000051C0                            .SettleLeft:
000051C0 D045                       		add.w	d5,d0				; Slow down
000051C2 6B00                       		bmi.s	.SetSpeed			; If it's not done, branch
000051C4 7000                       		moveq	#0,d0				; Stop the movement
000051C6                            
000051C6                            .SetSpeed:
000051C6 3140 003A                  		move.w	d0,_objGVel(a0)			; Set ground velocity
000051CA                            
000051CA                            .ApplySpeed:
000051CA 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
000051CE 4EB8 1374                  		jsr	CalcSine.w			; Get the sine and cosine
000051D2 C3E8 003A                  		muls.w	_objGVel(a0),d1			; Multiply cosine with ground velocity
000051D6 C1E8 003A                  		muls.w	_objGVel(a0),d0			; Multiply sine with ground velocity
000051DA E081                       		asr.l	#8,d1				; Shift the values over
000051DC E080                       		asr.l	#8,d0				; ''
000051DE 3141 001C                  		move.w	d1,_objXVel(a0)			; Set the X velocity
000051E2 3140 001E                  		move.w	d0,_objYVel(a0)			; Set the Y velocity
000051E6                            
000051E6                            ObjPlayer_CheckWalls:
000051E6 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
000051EA 0200 003F                  		andi.b	#$3F,d0				; Is Sonic on an angle?
000051EE 6700                       		beq.s	.Skip				; If not, branch
000051F0 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
000051F4 0600 0040                  		addi.b	#$40,d0				; Is Sonic on an upwards wall or ceiling?
000051F8 6B00                       		bmi.s	.End				; If so, branch
000051FA                            
000051FA                            .Skip:
000051FA 7240                       		moveq	#$40,d1				; If going left, make the modifier $40
000051FC 4A68 003A                  		tst.w	_objGVel(a0)			; Check speed
00005200 6700                       		beq.s	.End				; Branch if not moving
00005202 6B00                       		bmi.s	.CheckPush			; Branch if going left
00005204 4441                       		neg.w	d1				; Negate the modifier
00005206                            
00005206                            .CheckPush:
00005206 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
0000520A D001                       		add.b	d1,d0				; Add modifier
0000520C                            		push.w	d0				; Save it
0000520C 3F00                     M 	move.w	d0,-(sp)
0000520E 4EB8 3214                  		jsr	PlayerCalcRoomInFront		; Calculate the distance in front of Sonic
00005212                            		pop.w	d0				; Restore angle
00005212 301F                     M 	move.w	(sp)+,d0
00005214 4A41                       		tst.w	d1				; Is Sonic pushing into anything?
00005216 6A00                       		bpl.s	.End				; If not, branch
00005218 E141                       		asl.w	#8,d1				; Shift distance inside the collision
0000521A 0600 0020                  		addi.b	#$20,d0				; Add $20 to the angle
0000521E 0200 00C0                  		andi.b	#$C0,d0				; Is Sonic pushing on a ceiling?
00005222 6700                       		beq.s	.PushCeiling			; If so, branch
00005224 0C00 0040                  		cmpi.b	#$40,d0				; Is Sonic pushing on a right wall?
00005228 6700                       		beq.s	.PushRightWall			; If so, branch
0000522A 0C00 0080                  		cmpi.b	#$80,d0				; Is Sonic pushing on a floor?
0000522E 6700                       		beq.s	.PushFloor			; If so, branch
00005230 D368 001C                  		add.w	d1,_objXVel(a0)			; Push out to the right
00005234 4268 003A                  		clr.w	_objGVel(a0)			; Stop moving
00005238 0828 0000 0028             		btst	#0,_objStatus(a0)			; Is Sonic facing right?
0000523E 6600                       		bne.s	.End				; If not, branch
00005240 08E8 0005 0028             		bset	#5,_objStatus(a0)			; Start pushing
00005246 4E75                       		rts
00005248                            
00005248                            .PushFloor:
00005248 9368 001E                  		sub.w	d1,_objYVel(a0)			; Push out upwards
0000524C 4E75                       		rts
0000524E                            
0000524E                            .PushRightWall:
0000524E 9368 001C                  		sub.w	d1,_objXVel(a0)			; Push out to the left
00005252 4268 003A                  		clr.w	_objGVel(a0)			; Stop moving
00005256 0828 0000 0028             		btst	#0,_objStatus(a0)			; Is Sonic facing left?
0000525C 6700                       		beq.s	.End				; If not, branch
0000525E 08E8 0005 0028             		bset	#5,_objStatus(a0)			; Start pushing
00005264 4E75                       		rts
00005266                            
00005266                            .PushCeiling:
00005266 D368 001E                  		add.w	d1,_objYVel(a0)			; Push out downwards
0000526A                            
0000526A                            .End:
0000526A 4E75                       		rts
0000526C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000526C                            ; Move left on the ground
0000526C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000526C                            ObjPlayer_MoveLeft:
0000526C 3028 003A                  		move.w	_objGVel(a0),d0			; Get current speed
00005270 6700                       		beq.s	.SetFlip			; If not moving yet, branch
00005272 6A00                       		bpl.s	.Skid				; If moving right, check for skidding
00005274                            
00005274                            .SetFlip:
00005274 08E8 0000 0028             		bset	#0,_objStatus(a0)			; Set flip flag
0000527A 6600                       		bne.s	.MoveLeft			; If it was already set, branch
0000527C 08A8 0005 0028             		bclr	#5,_objStatus(a0)			; Stop pushing
00005282 117C 0001 0021             		move.b	#1,_objPrevAnim(a0)			; Reset the animation
00005288                            
00005288                            .MoveLeft:
00005288 9045                       		sub.w	d5,d0				; Subtract acceleration
0000528A 3206                       		move.w	d6,d1				; Get top speed
0000528C 4441                       		neg.w	d1				; Negate it
0000528E B041                       		cmp.w	d1,d0				; Is Sonic moving faster than the top speed?
00005290 6E00                       		bgt.s	.SetSpeed			; If not, branch
00005292 D045                       		add.w	d5,d0				; Add acceleration back
00005294 B041                       		cmp.w	d1,d0				; Is Sonic still moving faster than the top speed?
00005296 6F00                       		ble.s	.SetSpeed			; If not, branch
00005298 3001                       		move.w	d1,d0				; Cap at the top speed
0000529A                            
0000529A                            .SetSpeed:
0000529A 3140 003A                  		move.w	d0,_objGVel(a0)			; Set speed
0000529E 4228 0020                  		clr.b	_objAnim(a0)			; Set animation to moving
000052A2                            
000052A2                            .End:
000052A2 4E75                       		rts
000052A4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000052A4                            .Skid:
000052A4 9044                       		sub.w	d4,d0				; Subtract deceleration
000052A6 7200                       		moveq	#0,d1				; The speed in which Sonic stops skidding
000052A8                            
000052A8                            .Compare:
000052A8 B041                       		cmp.w	d1,d0				; Has Sonic gotten to that speed yet?
000052AA 6C00                       		bge.s	.SetSkidSpeed			; If not branch
000052AC 7080                       		moveq	#-$80,d0			; Set speed to -$80
000052AE                            
000052AE                            .SetSkidSpeed:
000052AE 3140 003A                  		move.w	d0,_objGVel(a0)			; Set speed
000052B2 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
000052B6 0600 0020                  		addi.b	#$20,d0				; Shift it
000052BA 0200 00C0                  		andi.b	#$C0,d0				; Is Sonic on a slope?
000052BE 66E2                       		bne.s	.End				; If so, branch
000052C0 0C40 0400                  		cmpi.w	#$400,d0			; Is Sonic's speed at least 4 pixels per frame?
000052C4 6DDC                       		blt.s	.End				; If not, branch
000052C6 117C 000D 0020             		move.b	#$D,_objAnim(a0)			; Set animation to skidding
000052CC 08A8 0000 0028             		bclr	#0,_objStatus(a0)			; Clear flip flag
000052D2                            		playSnd	#sSkid, 2			; Play skid sound
000052D2 11FC 0083 C4BD           M 	move.b	#sskid,(mqueue+((2)-1)).w
000052D8 4E75                       		rts
000052DA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000052DA                            ; Move right on the ground
000052DA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000052DA                            ObjPlayer_MoveRight:
000052DA 3028 003A                  		move.w	_objGVel(a0),d0			; Get current speed
000052DE 6B00                       		bmi.s	.Skid				; If it's negative, skid
000052E0 08A8 0000 0028             		bclr	#0,_objStatus(a0)			; Clear flip flag
000052E6 6700                       		beq.s	.MoveRight			; Branch if it was already cleared
000052E8 08A8 0005 0028             		bclr	#5,_objStatus(a0)			; Stop pushing
000052EE 117C 0001 0021             		move.b	#1,_objPrevAnim(a0)			; Reset the animation
000052F4                            
000052F4                            .MoveRight:
000052F4 D045                       		add.w	d5,d0				; Add acceleration
000052F6 B046                       		cmp.w	d6,d0				; Has Sonic reached the top speed?
000052F8 6D00                       		blt.s	.SetSpeed			; If not, branch
000052FA 9045                       		sub.w	d5,d0				; Subtract acceleration back
000052FC B046                       		cmp.w	d6,d0				; Is Sonic still going at the top speed?
000052FE 6C00                       		bge.s	.SetSpeed			; If not, branch
00005300 3006                       		move.w	d6,d0				; Cap at top speed
00005302                            
00005302                            .SetSpeed:
00005302 3140 003A                  		move.w	d0,_objGVel(a0)			; Set speed
00005306 4228 0020                  		clr.b	_objAnim(a0)			; Set animation to moving
0000530A                            
0000530A                            .End:
0000530A 4E75                       		rts
0000530C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000530C                            .Skid:
0000530C D044                       		add.w	d4,d0				; Add deceleration
0000530E 7200                       		moveq	#0,d1				; The speed in which Sonic stops skidding
00005310                            
00005310                            .Compare:
00005310 B041                       		cmp.w	d1,d0				; Has Sonic gotten to that speed yet?
00005312 6F00                       		ble.s	.SetSkidSpeed			; If not, branch
00005314 303C 0080                  		move.w	#$80,d0				; Set speed to $80
00005318                            
00005318                            .SetSkidSpeed:
00005318 3140 003A                  		move.w	d0,_objGVel(a0)			; Set speed
0000531C 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
00005320 0600 0020                  		addi.b	#$20,d0				; Shift it
00005324 0200 00C0                  		andi.b	#$C0,d0				; Is Sonic on a slope?
00005328 66E0                       		bne.s	.End				; If so, branch
0000532A 0C40 FC00                  		cmpi.w	#-$400,d0			; Is Sonic's speed at least -4 pixels per frame?
0000532E 6EDA                       		bgt.s	.End				; If not, branch
00005330 117C 000D 0020             		move.b	#$D,_objAnim(a0)			; Set animation to skidding
00005336 08E8 0000 0028             		bset	#0,_objStatus(a0)			; Set flip flag
0000533C                            
0000533C 4E75                       		rts
0000533E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000533E                            ; Do movement while rolling
0000533E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000533E                            ObjPlayer_MoveRoll:
0000533E 3C28 0034                  		move.w	_objTopSpd(a0),d6			; Get top speed
00005342 E346                       		asl.w	#1,d6				; ''
00005344 3A28 0036                  		move.w	_objAccel(a0),d5			; Get acceleration
00005348 E245                       		asr.w	#1,d5				; ''
0000534A 3828 0038                  		move.w	_objDecel(a0),d4			; Get deceleration
0000534E E444                       		asr.w	#2,d4				; ''
00005350                            
00005350 4A28 003F                  		tst.b	_objMoveLock(a0)			; Is the move lock timer active?
00005354 6600 0000                  		bne.w	.UpdateSpd			; If so, branch
00005358                            
00005358 0838 0002 E8DE             		btst	#2,plrCtrlHold.w		; Is left being held?
0000535E 6700                       		beq.s	.ChkRight			; If not, branch
00005360 6100 0000                  		bsr.w	ObjPlayer_RollLeft		; Handle left movement
00005364                            
00005364                            .ChkRight:
00005364 0838 0003 E8DE             		btst	#3,plrCtrlHold.w		; Is right being held?
0000536A 6700                       		beq.s	.Decelerate			; If not, branch
0000536C 6100 0000                  		bsr.w	ObjPlayer_RollRight		; Handle right movement
00005370                            
00005370                            .Decelerate:
00005370 3028 003A                  		move.w	_objGVel(a0),d0			; Get ground velocity
00005374 6700                       		beq.s	.ChkStop			; If Sonic isn't moving, branch
00005376 6B00                       		bmi.s	.DecLeft			; If Sonic is moving left, branch
00005378                            
00005378 9045                       		sub.w	d5,d0				; Decelerate
0000537A 6400                       		bcc.s	.SetGVel			; If Sonic hasn't stopped yet, branch
0000537C 7000                       		moveq	#0,d0				; Cap at 0
0000537E                            
0000537E                            .SetGVel:
0000537E 3140 003A                  		move.w	d0,_objGVel(a0)			; Set ground velocity
00005382 6000                       		bra.s	.ChkStop			; Continue
00005384                            
00005384                            .DecLeft:
00005384 D045                       		add.w	d5,d0				; Decelerate
00005386 6400                       		bcc.s	.SetGVel2			; If Sonic hasn't stopped yet, branch
00005388 7000                       		moveq	#0,d0				; Cap at 0
0000538A                            
0000538A                            .SetGVel2:
0000538A 3140 003A                  		move.w	d0,_objGVel(a0)			; Set ground velocity
0000538E                            
0000538E                            .ChkStop:
0000538E 4A68 003A                  		tst.w	_objGVel(a0)			; Is Sonic still moving?
00005392 6600                       		bne.s	.UpdateSpd			; If so, branch
00005394                            
00005394 4A28 004B                  		tst.b	_objBallMode(a0)			; Are we in ball mode?
00005398 6600                       		bne.s	.KeepRoll			; If so, branch
0000539A 08A8 0002 0028             		bclr	#2,_objStatus(a0)			; Stop rolling
000053A0 1168 0030 002D             		move.b	_objInitColH(a0),_objColH(a0)		; Reset collision height
000053A6 1168 0031 002C             		move.b	_objInitColW(a0),_objColW(a0)		; Reset collision width
000053AC 117C 0005 0020             		move.b	#5,_objAnim(a0)			; Use standing animation
000053B2                            	;	subq.w	#5,_objYPos(a0)			; Align Sonic with the ground
000053B2 6000                       		bra.s	.UpdateSpd			; Continue
000053B4                            
000053B4                            .KeepRoll:
000053B4 317C 0400 003A             		move.w	#$400,_objGVel(a0)			; Speed up again
000053BA 0828 0000 0028             		btst	#0,_objStatus(a0)			; Are we facing right?
000053C0 6700                       		beq.s	.UpdateSpd			; If so, branch
000053C2 4468 003A                  		neg.w	_objGVel(a0)			; Go the other way
000053C6                            
000053C6                            .UpdateSpd:
000053C6 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
000053CA 4EB8 1374                  		jsr	CalcSine.w			; Get sine and cosine
000053CE C1E8 003A                  		muls.w	_objGVel(a0),d0			; Multiply sine with ground velocity
000053D2 E080                       		asr.l	#8,d0				; Shift over
000053D4 3140 001E                  		move.w	d0,_objYVel(a0)			; Set Y velocity
000053D8 C3E8 003A                  		muls.w	_objGVel(a0),d1			; Multiply cosine with ground velocity
000053DC E081                       		asr.l	#8,d1				; Shift over
000053DE                            
000053DE 0C41 1000                  		cmpi.w	#$1000,d1			; Is the speed > $10 pixels per frame?
000053E2 6F00                       		ble.s	.ChkLeftSpd			; If not, branch
000053E4 323C 1000                  		move.w	#$1000,d1			; Cap the speed
000053E8                            
000053E8                            .ChkLeftSpd:
000053E8 0C41 F000                  		cmpi.w	#-$1000,d1			; Is the speed < -$10 pixels per frame?
000053EC 6C00                       		bge.s	.SetXVel			; If not, branch
000053EE 323C F000                  		move.w	#-$1000,d1			; Cap the speed
000053F2                            
000053F2                            .SetXVel:
000053F2 3141 001C                  		move.w	d1,_objXVel(a0)			; Set X velocity
000053F6 6000 FDEE                  		bra.w	ObjPlayer_CheckWalls		; Check wall collision
000053FA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000053FA                            ; Handle left movement for rolling
000053FA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000053FA                            ObjPlayer_RollLeft:
000053FA 3028 003A                  		move.w	_objGVel(a0),d0			; Get ground velocity
000053FE 6700                       		beq.s	.SetLeft			; If Sonic isn't moving, branch
00005400 6A00                       		bpl.s	.Dec				; If Sonic is moving right, branch
00005402                            
00005402                            .SetLeft:
00005402 08E8 0000 0028             		bset	#0,_objStatus(a0)			; Face left
00005408 117C 0002 0020             		move.b	#2,_objAnim(a0)			; Use rolling animation
0000540E 4E75                       		rts
00005410                            
00005410                            .Dec:
00005410 9044                       		sub.w	d4,d0				; Decelerate
00005412 6400                       		bcc.s	.SetGVel			; If Sonic hasn't stopped yet, branch
00005414 303C FF80                  		move.w	#-$80,d0			; Set new speed
00005418                            
00005418                            .SetGVel:
00005418 3140 003A                  		move.w	d0,_objGVel(a0)			; Set ground velocity
0000541C 4E75                       		rts
0000541E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000541E                            ; Handle left movement for rolling
0000541E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000541E                            ObjPlayer_RollRight:
0000541E 3028 003A                  		move.w	_objGVel(a0),d0			; Get ground velocity
00005422 6B00                       		bmi.s	.Dec				; If Sonic is moving left, branch
00005424 08A8 0000 0028             		bclr	#0,_objStatus(a0)			; Face right
0000542A 117C 0002 0020             		move.b	#2,_objAnim(a0)			; Use rolling animation
00005430 4E75                       		rts
00005432                            
00005432                            .Dec:
00005432 D044                       		add.w	d4,d0				; Decelerate
00005434 6400                       		bcc.s	.SetGVel			; If Sonic hasn't stopped yet, branch
00005436 303C 0080                  		move.w	#$80,d0				; Set new speed
0000543A                            
0000543A                            .SetGVel:
0000543A 3140 003A                  		move.w	d0,_objGVel(a0)			; Set ground velocity
0000543E 4E75                       		rts
00005440                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005440                            ; Do movement in the air
00005440                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005440                            ObjPlayer_MoveAir:
00005440 3C28 0034                  		move.w	_objTopSpd(a0),d6			; Get top speed
00005444 3A28 0036                  		move.w	_objAccel(a0),d5			; Get accleration
00005448 DA45                       		add.w	d5,d5				; Double it
0000544A 3028 001C                  		move.w	_objXVel(a0),d0			; Get X velocity
0000544E                            
0000544E 0838 0002 E8DE             		btst	#2,plrCtrlHold.w		; Is left being held?
00005454 6700                       		beq.s	.NotLeft			; If not, branch
00005456 08E8 0000 0028             		bset	#0,_objStatus(a0)			; Face left
0000545C 9045                       		sub.w	d5,d0				; Subtract acceleration
0000545E 3206                       		move.w	d6,d1				; Get top speed
00005460 4441                       		neg.w	d1				; Negate it
00005462 B041                       		cmp.w	d1,d0				; Has Sonic reached the top speed?
00005464 6E00                       		bgt.s	.NotLeft			; If not, branch
00005466 D045                       		add.w	d5,d0				; Add acceleration back
00005468 B041                       		cmp.w	d1,d0				; Is Sonic still at top speed?
0000546A 6F00                       		ble.s	.NotLeft			; If not, branch
0000546C 3001                       		move.w	d1,d0				; Cap at top speed
0000546E                            
0000546E                            .NotLeft:
0000546E 0838 0003 E8DE             		btst	#3,plrCtrlHold.w		; Is right being held?
00005474 6700                       		beq.s	.NotRight			; If not, branch
00005476 08A8 0000 0028             		bclr	#0,_objStatus(a0)			; Face right
0000547C D045                       		add.w	d5,d0				; Add acceleration
0000547E B046                       		cmp.w	d6,d0				; Has Sonic reached the top speed?
00005480 6D00                       		blt.s	.NotRight			; If not, branch
00005482 9045                       		sub.w	d5,d0				; Subtract acceleration back
00005484 B046                       		cmp.w	d6,d0				; Is Sonic still at top speed?
00005486 6C00                       		bge.s	.NotRight			; If not, branch
00005488 3006                       		move.w	d6,d0				; Cap at top speed
0000548A                            
0000548A                            .NotRight:
0000548A 3140 001C                  		move.w	d0,_objXVel(a0)			; Set X velocity
0000548E                            
0000548E                            .ResetScr
0000548E 0C78 0060 E8D8             		cmpi.w	#(224/2)-16,panCamYPos.w	; Is the camera centered vertically?
00005494 6700                       		beq.s	.DecelerateAtPeak		; If so, branch
00005496 6400                       		bhs.s	.ScrollUp			; If it's below the center, branch
00005498 5878 E8D8                  		addq.w	#4,panCamYPos.w		; Scroll the camera up
0000549C                            
0000549C                            .ScrollUp:
0000549C 5578 E8D8                  		subq.w	#2,panCamYPos.w		; Scroll the camera down
000054A0                            
000054A0                            .DecelerateAtPeak:
000054A0 0C68 FC00 001E             		cmpi.w	#-$400,_objYVel(a0)		; Is Sonic at least going -4 pixels per frame up?
000054A6 6500                       		bcs.s	.End				; If not, branch
000054A8 3028 001C                  		move.w	_objXVel(a0),d0			; Get X velocity
000054AC 3200                       		move.w	d0,d1				; Save it
000054AE EA41                       		asr.w	#5,d1				; Turn it into the acceleration
000054B0 6700                       		beq.s	.End				; If it's 0, branch
000054B2 6B00                       		bmi.s	.DecLeft			; If it's negative, branch
000054B4                            
000054B4                            .DecRight:
000054B4 9041                       		sub.w	d1,d0				; Subtract accleration
000054B6 6400                       		bcc.s	.DecSetSpeed			; If it's not negative, branch
000054B8 7000                       		moveq	#0,d0				; Cap at 0
000054BA 6000                       		bra.s	.DecSetSpeed			; Continue
000054BC                            
000054BC                            .DecLeft:
000054BC 9041                       		sub.w	d1,d0				; Subtract acceleration
000054BE 6500                       		bcs.s	.DecSetSpeed			; If it's not positive, branch
000054C0 7000                       		moveq	#0,d0				; Cap at 0
000054C2                            
000054C2                            .DecSetSpeed:
000054C2 3140 001C                  		move.w	d0,_objXVel(a0)			; Set thhe X velocity
000054C6                            
000054C6                            .End:
000054C6 4E75                       		rts
000054C8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000054C8                            ; Handle level boundaries
000054C8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000054C8                            ObjPlayer_LvlBound:
000054C8 4A68 001E                  		tst.w	_objYVel(a0)
000054CC 6A00                       		bpl.s	.XBound
000054CE 3228 0018                  		move.w	_objYPos(a0),d1
000054D2 0641 0010                  		addi.w	#$10,d1
000054D6 3038 E8D4                  		move.w	minCamYPos.w,d0		; Get upper boundary position
000054DA B041                       		cmp.w	d1,d0				; Has Sonic touched the upper boundary?
000054DC 6F00                       		ble.s	.XBound				; If so, branch
000054DE 3140 0018                  		move.w	d0,_objYPos(a0)
000054E2 4268 001E                  		clr.w	_objYVel(a0)
000054E6 4268 003A                  		clr.w	_objGVel(a0)
000054EA                            
000054EA                            .XBound:
000054EA 2228 0014                  		move.l	_objXPos(a0),d1			; Get X position
000054EE 3028 001C                  		move.w	_objXVel(a0),d0			; Get X velocity
000054F2 48C0                       		ext.l	d0
000054F4 E180                       		asl.l	#8,d0				; Shift it
000054F6 D280                       		add.l	d0,d1				; Add to X position
000054F8 4841                       		swap	d1				; Get actual X position
000054FA 3038 E8D2                  		move.w	minCamXPos.w,d0		; Get left boundary position
000054FE 0640 0010                  		addi.w	#$10,d0				; ''
00005502 B041                       		cmp.w	d1,d0				; Has Sonic touched the left boundary?
00005504 6E00                       		bgt.s	.TouchedSide			; If so, branch
00005506 3038 E8CA                  		move.w	maxCamXPos.w,d0		; Get max camera X position
0000550A 0640 0128                  		addi.w	#320-24,d0			; Get right boundary position
0000550E B041                       		cmp.w	d1,d0				; Has Sonic touched the right boundary?
00005510 6F00                       		ble.s	.TouchedSide			; If so, branch
00005512                            
00005512                            .ChkBottom:
00005512 3038 E8CC                  		move.w	maxCamYPos.w,d0		; Get max camera Y position
00005516 0640 00E0                  		addi.w	#224,d0				; Get bottom boundary position
0000551A B068 0018                  		cmp.w	_objYPos(a0),d0			; Has Sonic touched the bottom boundary?
0000551E 6D00                       		blt.s	.TouchedBottom			; If so, branch
00005520 4E75                       		rts
00005522                            
00005522                            .TouchedBottom:
00005522 3038 E8C8                  		move.w	targetMaxCamY.w,d0		; Get target max camera Y position
00005526 3238 E8CC                  		move.w	maxCamYPos.w,d1		; Get current max camera Y position
0000552A B240                       		cmp.w	d0,d1				; Are they the same?
0000552C 6D00                       		blt.s	.NoKill				; If not, branch
0000552E 6000 0000                  		bra.w	ObjPlayer_GetKilled		; Get Sonic killed
00005532                            
00005532                            .NoKill:
00005532 4E75                       		rts
00005534                            
00005534                            .TouchedSide:
00005534 4268 001C                  		clr.w	_objXVel(a0)			; Stop X movement
00005538 3140 0014                  		move.w	d0,_objXPos(a0)			; Move Sonic out of the boundary
0000553C 4228 0016                  		clr.b	_objXPos+2(a0)			; Clear the subpixel of the X position
00005540 4268 003A                  		clr.w	_objGVel(a0)			; Stop ground movement
00005544 60CC                       		bra.s	.ChkBottom			; Continue
00005546                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005546                            ; Handle peelout
00005546                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005546                            ObjPlayer_Peelout:
00005546 4A28 0045                  		tst.b	_objDashFlag(a0)			; Is Sonic doing the peelout?
0000554A 6700                       		beq.s	.ChkUp				; If not, branch
0000554C 6B00                       		bmi.s	.ChkLaunch			; If so, branch
0000554E 4E75                       		rts
00005550                            
00005550                            .ChkUp:
00005550 0C28 0007 0020             		cmpi.b	#7,_objAnim(a0)			; Is Sonic looking up?
00005556 6600 0000                  		bne.w	.End				; If not, branch
0000555A 1038 E8DF                  		move.b	plrCtrlPress.w,d0		; Get controller bits
0000555E 0200 0070                  		andi.b	#$70,d0				; Are A, B, or C pressed?
00005562 6700 0000                  		beq.w	.End				; If not, branch
00005566                            
00005566 4228 0020                  		clr.b	_objAnim(a0)			; Set to peelout charge animation
0000556A 4228 0046                  		clr.b	_objDashTimer(a0)			; Reset the dash timer
0000556E 317C 000C 003A             		move.w	#$C,_objGVel(a0)			; Reset ground velocity
00005574 0828 0000 0028             		btst	#0,_objStatus(a0)			; Is Sonic facing left?
0000557A 6700                       		beq.s	.SetAni				; If so, branch
0000557C 4468 003A                  		neg.w	_objGVel(a0)			; Go the other way
00005580                            
00005580                            .SetAni:
00005580                            		playSnd	#sCharge, 2			; Play charge sound
00005580 11FC 009C C4BD           M 	move.b	#scharge,(mqueue+((2)-1)).w
00005586                            
00005586 588F                       		addq.l	#4,sp				; Don't return to caller
00005588 50E8 0045                  		st	_objDashFlag(a0)			; Set the peelout flag
0000558C 4EF8 365E                  		jmp	PlayerAnglePos			; Update position and angle along the ground
00005590                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005590                            .ChkLaunch:
00005590 0838 0000 E8DE             		btst	#0,plrCtrlHold.w		; Is up being held?
00005596 6600 0000                  		bne.w	.Charge				; If so, branch
0000559A 4228 0045                  		clr.b	_objDashFlag(a0)			; Clear the dash flag
0000559E                            
0000559E 0C28 001E 0046             		cmpi.b	#30,_objDashTimer(a0)		; Has Sonic charged up enough?
000055A4 6600                       		bne.s	.StopSound			; If not, branch
000055A6                            
000055A6 4228 0020                  		clr.b	_objAnim(a0)			; Reset animation
000055AA 317C 0C00 003A             		move.w	#$C00,_objGVel(a0)			; Set ground velocity
000055B0 0828 0006 0028             		btst	#6,_objStatus(a0)
000055B6 6700                       		beq.s	.NoWater
000055B8 E2E8 003A                  		lsr.w	_objGVel(a0)
000055BC                            
000055BC                            .NoWater:
000055BC 0828 0000 0028             		btst	#0,_objStatus(a0)			; Is Sonic facing left?
000055C2 6700                       		beq.s	.FinishDash			; If not, branch
000055C4 4468 003A                  		neg.w	_objGVel(a0)			; Go the other way
000055C8                            
000055C8                            .FinishDash:
000055C8                            		playSnd	#sChargeRelease, 2		; Play charge release sound
000055C8 11FC 009E C4BD           M 	move.b	#schargerelease,(mqueue+((2)-1)).w
000055CE                            
000055CE 6000                       		bra.s	.DoUpdates			; Continue
000055D0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000055D0                            .Charge:
000055D0 0C28 001E 0046             		cmpi.b	#30,_objDashTimer(a0)		; Has Sonic charged enough?
000055D6 6700                       		beq.s	.DoUpdates			; If so, branch
000055D8 5228 0046                  		addq.b	#1,_objDashTimer(a0)		; Increment the timer
000055DC 0668 0066 003A             		addi.w	#$66,_objGVel(a0)			; Increment ground velocity to handle animation and extended camera
000055E2 0828 0000 0028             		btst	#0,_objStatus(a0)			; Is Sonic facing left?
000055E8 6700                       		beq.s	.DoUpdates			; If so, branch
000055EA 0468 00CC 003A             		subi.w	#$66*2,_objGVel(a0)		; Go the other way
000055F0 6000                       		bra.s	.DoUpdates			; Continue
000055F2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000055F2                            .StopSound:
000055F2 4268 003A                  		clr.w	_objGVel(a0)			; Stop ground movement
000055F6                            
000055F6                            		playSnd	#sChargeStop, 2			; Play charge stop sound
000055F6 11FC 009D C4BD           M 	move.b	#schargestop,(mqueue+((2)-1)).w
000055FC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000055FC                            .DoUpdates:
000055FC 588F                       		addq.l	#4,sp				; Don't return to caller
000055FE 0C78 0060 E8D8             		cmpi.w	#(224/2)-16,panCamYPos.w	; Is the camera centered vertically?
00005604 6700                       		beq.s	.FinishUpdates			; If so, branch
00005606 6400                       		bhs.s	.ScrollUp			; If it's below the center, branch
00005608 5878 E8D8                  		addq.w	#4,panCamYPos.w		; Scroll the camera up
0000560C                            
0000560C                            .ScrollUp:
0000560C 5578 E8D8                  		subq.w	#2,panCamYPos.w		; Scroll the camera down
00005610                            
00005610                            .FinishUpdates:
00005610 4EF8 365E                  		jmp	PlayerAnglePos			; Update position and angle along the ground
00005614                            
00005614                            .End:
00005614 4E75                       		rts
00005616                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005616                            ; Handle spindash
00005616                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005616                            ObjPlayer_Spindash:
00005616 4A28 0045                  		tst.b	_objDashFlag(a0)			; Is Sonic doing the spindash?
0000561A 6700                       		beq.s	.ChkDown			; If not, branch
0000561C 6A00                       		bpl.s	.ChkLaunch			; If so, branch
0000561E 4E75                       		rts
00005620                            
00005620                            .ChkDown:
00005620 0C28 0008 0020             		cmpi.b	#8,_objAnim(a0)			; Is Sonic ducking?
00005626 6600 0000                  		bne.w	.End				; If not, branch
0000562A 1038 E8DF                  		move.b	plrCtrlPress.w,d0		; Get controller bits
0000562E 0200 0070                  		andi.b	#$70,d0				; Are A, B, or C pressed?
00005632 6700 0000                  		beq.w	.End				; If not, branch
00005636                            
00005636 4228 0046                  		clr.b	_objDashTimer(a0)			; Reset the dash timer
0000563A 317C 000C 003A             		move.w	#$C,_objGVel(a0)			; Reset ground velocity
00005640 0828 0000 0028             		btst	#0,_objStatus(a0)			; Is Sonic facing left?
00005646 6700                       		beq.s	.SetAni				; If so, branch
00005648 4468 003A                  		neg.w	_objGVel(a0)			; Go the other way
0000564C                            
0000564C                            .SetAni:
0000564C 117C 0008 002D             		move.b	#$8,_objColH(a0)			; Reduce Sonic's hitbox
00005652 117C 0007 002C             		move.b	#7,_objColW(a0)			; ''
00005658                            	;	addq.w	#5,_objYPos(a0)			; Align Sonic to the ground
00005658 117C 0002 0020             		move.b	#2,_objAnim(a0)			; Set to spin animation
0000565E                            
0000565E                            		playSnd	#sCharge, 2			; Play charge sound
0000565E 11FC 009C C4BD           M 	move.b	#scharge,(mqueue+((2)-1)).w
00005664                            
00005664 588F                       		addq.l	#4,sp				; Don't return to caller
00005666 117C 0001 0045             		move.b	#1,_objDashFlag(a0)		; Set the spindash flag
0000566C 4EF8 365E                  		jmp	PlayerAnglePos			; Update position and angle along the ground
00005670                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005670                            .ChkLaunch:
00005670 0838 0001 E8DE             		btst	#1,plrCtrlHold.w		; Is down being held?
00005676 6600 0000                  		bne.w	.Charge				; If so, branch
0000567A 4228 0045                  		clr.b	_objDashFlag(a0)			; Clear the dash flag
0000567E                            
0000567E 0C28 002D 0046             		cmpi.b	#45,_objDashTimer(a0)		; Has Sonic charged up enough?
00005684 6600                       		bne.s	.StopSound			; If not, branch
00005686                            
00005686 08E8 0002 0028             		bset	#2,_objStatus(a0)			; Set the roll flag
0000568C 317C 0C00 003A             		move.w	#$C00,_objGVel(a0)			; Set ground velocity
00005692 0828 0006 0028             		btst	#6,_objStatus(a0)
00005698 6700                       		beq.s	.NoWater
0000569A E2E8 003A                  		lsr.w	_objGVel(a0)
0000569E                            
0000569E                            .NoWater:
0000569E 0828 0000 0028             		btst	#0,_objStatus(a0)			; Is Sonic facing left?
000056A4 6700                       		beq.s	.FinishDash			; If not, branch
000056A6 4468 003A                  		neg.w	_objGVel(a0)			; Go the other way
000056AA                            
000056AA                            .FinishDash:
000056AA                            		playSnd	#sChargeRelease, 2		; Play charge release sound
000056AA 11FC 009E C4BD           M 	move.b	#schargerelease,(mqueue+((2)-1)).w
000056B0                            
000056B0 6000                       		bra.s	.DoUpdates			; Continue
000056B2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000056B2                            .Charge:
000056B2 0C28 002D 0046             		cmpi.b	#45,_objDashTimer(a0)		; Has Sonic charged enough?
000056B8 6700                       		beq.s	.DoUpdates			; If so, branch
000056BA 5228 0046                  		addq.b	#1,_objDashTimer(a0)		; Increment the timer
000056BE 0668 0046 003A             		addi.w	#$46,_objGVel(a0)			; Increment ground velocity to handle animation and extended camera
000056C4 0828 0000 0028             		btst	#0,_objStatus(a0)			; Is Sonic facing left?
000056CA 6700                       		beq.s	.DoUpdates			; If so, branch
000056CC 0468 008C 003A             		subi.w	#$46*2,_objGVel(a0)		; Go the other way
000056D2 6000                       		bra.s	.DoUpdates			; Continue
000056D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000056D4                            .StopSound:
000056D4 4268 003A                  		clr.w	_objGVel(a0)			; Stop ground movement
000056D8 1168 0030 002D             		move.b	_objInitColH(a0),_objColH(a0)		; Reset collision height
000056DE 1168 0031 002C             		move.b	_objInitColW(a0),_objColW(a0)		; Reset collision width
000056E4                            	;	subq.w	#5,_objYPos(a0)			; Align Sonic with the ground
000056E4                            
000056E4                            		playSnd	#sChargeStop, 2			; Play charge stop sound
000056E4 11FC 009D C4BD           M 	move.b	#schargestop,(mqueue+((2)-1)).w
000056EA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000056EA                            .DoUpdates:
000056EA 588F                       		addq.l	#4,sp				; Don't return to caller
000056EC 0C78 0060 E8D8             		cmpi.w	#(224/2)-16,panCamYPos.w	; Is the camera centered vertically?
000056F2 6700                       		beq.s	.FinishUpdates			; If so, branch
000056F4 6400                       		bhs.s	.ScrollUp			; If it's below the center, branch
000056F6 5878 E8D8                  		addq.w	#4,panCamYPos.w		; Scroll the camera up
000056FA                            
000056FA                            .ScrollUp:
000056FA 5578 E8D8                  		subq.w	#2,panCamYPos.w		; Scroll the camera down
000056FE                            
000056FE                            .FinishUpdates:
000056FE 4EF8 365E                  		jmp	PlayerAnglePos			; Update position and angle along the ground
00005702                            
00005702                            .End:
00005702 4E75                       		rts
00005704                            		
00005704                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005704                            ; Check for fire attack
00005704                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005704                            ObjPlayer_ChkAttack:
00005704 1038 E8DF                  		move.b	plrCtrlPress.w,d0		; Get pressed buttons
00005708 0200 0010                  		andi.b	#$10,d0				; Are B pressed?
0000570C 4A00                       		tst.b	d0
0000570E 6700 0000                  		beq.w	.End				; If not, branch
00005712                            		
00005712 4EB8 1A1C                  		jsr	FindFreeObj.w
00005716 6700                       		beq.s	.End
00005718 22BC 0000 0000             		move.l	#ObjAttack,_objAddress(a1)
0000571E 137C 001E 0017             		move.b	#30,_objDrawW(a1)
00005724 0828 0000 0028             		btst	#0,_objStatus(a0)			; Is Sonic facing left?
0000572A 6700                       		beq.s	.cont			; If so, branch
0000572C 337C 0001 0024             		move.w	#1,	_objSubtype(a1)
00005732                            	.cont:
00005732 3368 0014 0014             		move.w	_objXPos(a0),_objXPos(a1)
00005738 3368 0018 0018             		move.w	_objYPos(a0),_objYPos(a1)
0000573E                            		playSnd	#sCheckpoint, 2			; Play checkpoint sound
0000573E 11FC 008A C4BD           M 	move.b	#scheckpoint,(mqueue+((2)-1)).w
00005744                            		
00005744                            .End:
00005744 4E75                       		rts
00005746                            		
00005746                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005746                            ; Check for jumping
00005746                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005746                            ObjPlayer_ChkJump:
00005746 1038 E8DF                  		move.b	plrCtrlPress.w,d0		; Get pressed buttons
0000574A 0200 0020                  		andi.b	#$20,d0				; Are C pressed?
0000574E 4A38 C76A                  		tst.b	moveCheat.w
00005752 6700                       		beq.s	.NoDebug
00005754 0200 0060                  		andi.b	#$60,d0				; Are A or C pressed?
00005758                            
00005758                            .NoDebug:
00005758 4A00                       		tst.b	d0
0000575A 6700 0000                  		beq.w	.End				; If not, branch
0000575E                            
0000575E 7000                       		moveq	#0,d0
00005760 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
00005764 0600 0080                  		addi.b	#$80,d0				; Shift it to check the ceiling
00005768 4EB8 3286                  		jsr	PlayerCalcRoomOverHead		; Get room over Sonic's head
0000576C 0C41 0006                  		cmpi.w	#6,d1				; Is it at least 6 pixels?
00005770 6D00 0000                  		blt.w	.End				; If not, branch
00005774                            
00005774 343C 0180                  		move.w	#JUMP_HEIGHT,d2			; Standard jump height
00005778 0828 0006 0028             		btst	#6,_objStatus(a0)
0000577E 6700                       		beq.s	.NoWater
00005780 0442 0300                  		subi.w	#$300,d2
00005784                            
00005784                            .NoWater:
00005784 7000                       		moveq	#0,d0
00005786 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
0000578A 0400 0040                  		subi.b	#$40,d0				; Shift it
0000578E 4EB8 1374                  		jsr	CalcSine.w			; Get the sine and cosine
00005792 C3C2                       		muls.w	d2,d1				; Mutliply cosine with jump height
00005794 C1C2                       		muls.w	d2,d0				; Mutliply sine with jump height
00005796 E081                       		asr.l	#8,d1				; Shift the values over
00005798 E080                       		asr.l	#8,d0				; ''
0000579A D368 001C                  		add.w	d1,_objXVel(a0)			; Add to X velocity
0000579E D168 001E                  		add.w	d0,_objYVel(a0)			; Add to Y velocity
000057A2 0028 0006 0028             		ori.b	#6,_objStatus(a0)			; Set "in air" and roll flags
000057A8 08A8 0005 0028             		bclr	#5,_objStatus(a0)			; Clear "pushing" flag
000057AE 584F                       		addq.w	#4,sp				; Do not return to collaer
000057B0 50E8 0040                  		st	_objJumping(a0)			; Set the jumping flag
000057B4                            		playSnd	#sLeap, 2			; Play jump sound
000057B4 11FC 0082 C4BD           M 	move.b	#sleap,(mqueue+((2)-1)).w
000057BA 117C 0008 002D             		move.b	#$8,_objColH(a0)			; Reduce Sonic's hitbox
000057C0 117C 0007 002C             		move.b	#7,_objColW(a0)			; ''
000057C6                            	;	addq.w	#5,_objYPos(a0)			; Align Sonic to the ground
000057C6 117C 0002 0020             		move.b	#2,_objAnim(a0)			; Set jumping animation
000057CC                            
000057CC                            .End:
000057CC 4E75                       		rts
000057CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000057CE                            ; Handle variable jumping
000057CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000057CE                            ObjPlayer_JumpHeight:
000057CE                            	;	tst.b	_objJumping(a0)			; Is Sonic jumping?
000057CE                            	;	beq.s	.UpVelCap			; If not, branch
000057CE                            
000057CE 323C FE80                  		move.w	#-MIN_JMP_HEIGHT,d1		; Standard minimum height
000057D2 B268 001E                  		cmp.w	_objYVel(a0),d1			; Is Sonic jumping at least hte minimum height?
000057D6 6F00                       		ble.s	.End				; If not, branch
000057D8 1038 E8DE                  		move.b	plrCtrlHold.w,d0		; Get held buttons
000057DC 0200 0020                  		andi.b	#$20,d0				; Are A, B, or C pressed?
000057E0 4A38 C76A                  		tst.b	moveCheat.w
000057E4 6700                       		beq.s	.NoDebug
000057E6 0200 0060                  		andi.b	#$60,d0				; Are A or C pressed?
000057EA                            
000057EA                            .NoDebug:
000057EA 4A00                       		tst.b	d0
000057EC 6600                       		bne.s	.End				; If not, branch
000057EE 3141 001E                  		move.w	d1,_objYVel(a0)			; Set to minimum height
000057F2                            
000057F2                            .End:
000057F2 4E75                       		rts
000057F4                            
000057F4                            .UpVelCap:
000057F4 4A28 004B                  		tst.b	_objBallMode(a0)			; Are we in ball mode?
000057F8 66F8                       		bne.s	.End				; If so, branch
000057FA 0C68 F040 001E             		cmpi.w	#-$FC0,_objYVel(a0)		; Cap Y velocity at -$FC0 when going up
00005800 6CF0                       		bge.s	.End				; ''
00005802 317C F040 001E             		move.w	#-$FC0,_objYVel(a0)		; ''
00005808 4E75                       		rts
0000580A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000580A                            ; Gradually reset Sonic's angle in mid air
0000580A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000580A                            ObjPlayer_JumpAngle:
0000580A 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
0000580E 6700                       		beq.s	ObjPlayer_JumpFlip		; If it's already reset, branch
00005810 6A00                       		bpl.s	.Decrease			; If it's positive, branch
00005812                            
00005812                            .Increase:
00005812 5400                       		addq.b	#2,d0				; Increase angle
00005814 6B00                       		bmi.s	.SetAngle			; If it's not reset, branch
00005816 7000                       		moveq	#0,d0				; Reset the angle
00005818 6000                       		bra.s	.SetAngle
0000581A                            
0000581A                            .Decrease:
0000581A 5500                       		subq.b	#2,d0				; Decrease angle
0000581C 6A00                       		bpl.s	.SetAngle			; If it's not reset, branch
0000581E 7000                       		moveq	#0,d0				; Reset the angle
00005820                            
00005820                            .SetAngle:
00005820 1140 0041                  		move.b	d0,_objAngle(a0)			; Set the new angle
00005824                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005824                            ; Update Sonic's angle while he's tumbling in the air
00005824                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005824                            ObjPlayer_JumpFlip:
00005824 1028 0047                  		move.b	_objFlipAngle(a0),d0		; Get flip angle
00005828 6700                       		beq.s	.End				; If it's 0, branch
0000582A 4A68 003A                  		tst.w	_objFlipDir(a0)			; Is Sonic flipping left?
0000582E 6B00                       		bmi.s	.FlipLeft			; IF so, branch
00005830                            
00005830                            .FlipRight:
00005830 1228 004A                  		move.b	_objFlipSpeed(a0),d1		; Get flip speed
00005834 D001                       		add.b	d1,d0				; Add to angle
00005836 6400                       		bcc.s	.FlipSet			; If it hasn't wrapped over, branch
00005838 5328 0049                  		subq.b	#1,_objFlipRemain(a0)		; Decrement flips remaining
0000583C 6400                       		bcc.s	.FlipSet			; If there are still some left
0000583E 4228 0049                  		clr.b	_objFlipRemain(a0)			; Clear flips remaining
00005842 7000                       		moveq	#0,d0				; Reset angle
00005844 6000                       		bra.s	.FlipSet			; Continue
00005846                            
00005846                            .FlipLeft:
00005846 4A28 0048                  		tst.b	_objFlipTurned(a0)			; Is the flipping inverted?
0000584A 66E4                       		bne.s	.FlipRight			; If so, branch
0000584C 1228 004A                  		move.b	_objFlipSpeed(a0),d1		; Get flip speed
00005850 9001                       		sub.b	d1,d0				; Subtract from angle
00005852 6400                       		bcc.s	.FlipSet			; If it hasn't wrapped over, branch
00005854 5328 0049                  		subq.b	#1,_objFlipRemain(a0)		; Decrement flips remaining
00005858 6400                       		bcc.s	.FlipSet			; If there are still some left
0000585A 4228 0049                  		clr.b	_objFlipRemain(a0)			; Clear flips remaining
0000585E 7000                       		moveq	#0,d0				; Reset angle
00005860                            
00005860                            .FlipSet:
00005860 1140 0047                  		move.b	d0,_objFlipAngle(a0)		; Update the angle
00005864                            
00005864                            .End:
00005864 4E75                       		rts
00005866                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005866                            ; Check for rolling
00005866                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005866                            ObjPlayer_ChkRoll:
00005866 3028 003A                  		move.w	_objGVel(a0),d0			; Get ground velocity
0000586A 6A00                       		bpl.s	.ChkSpd				; Get absolute value
0000586C 4440                       		neg.w	d0				; ''
0000586E                            
0000586E                            .ChkSpd:
0000586E 0C40 0080                  		cmpi.w	#$80,d0				; Is Sonic going fast enough?
00005872 6500                       		bcs.s	.NoRoll				; If not, branch
00005874 1038 E8DE                  		move.b	plrCtrlHold.w,d0		; Get held buttons
00005878 0200 000C                  		andi.b	#$C,d0				; Are left or right held?
0000587C 6600                       		bne.s	.NoRoll				; If not, branch
0000587E 0838 0001 E8DE             		btst	#1,plrCtrlHold.w		; Is down being held?
00005884 6600                       		bne.s	ObjPlayer_DoRoll			; If so, branch
00005886                            
00005886                            .NoRoll:
00005886 4E75                       		rts
00005888                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005888                            ; Make Sonic roll
00005888                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005888                            ObjPlayer_DoRoll:
00005888 0828 0002 0028             		btst	#2,_objStatus(a0)			; Is Sonic already rolling?
0000588E 6600                       		bne.s	.End				; If so, branch
00005890 08E8 0002 0028             		bset	#2,_objStatus(a0)			; Set roll flag
00005896                            
00005896 117C 0008 002D             		move.b	#$8,_objColH(a0)			; Reduce Sonic's hitbox
0000589C 117C 0007 002C             		move.b	#7,_objColW(a0)			; ''
000058A2                            	;	addq.w	#5,_objYPos(a0)			; Align Sonic to the ground
000058A2 117C 0002 0020             		move.b	#2,_objAnim(a0)			; Set rolling animation
000058A8                            
000058A8 4A68 003A                  		tst.w	_objGVel(a0)			; Is Sonic moving already?
000058AC 6600                       		bne.s	.End				; IF not, branch
000058AE 317C 0200 003A             		move.w	#$200,_objGVel(a0)			; Set speed
000058B4                            
000058B4                            .End:
000058B4 4E75                       		rts
000058B6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000058B6                            ; Slow Sonic down as he goes up a slope or speed him up when he does down one
000058B6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000058B6                            ObjPlayer_SlopePush:
000058B6 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
000058BA 0600 0060                  		addi.b	#$60,d0				; Shift it
000058BE 0C00 00C0                  		cmpi.b	#$C0,d0				; Is Sonic on a steep slope or ceiling?
000058C2 6400                       		bcc.s	.End				; If not, branch
000058C4 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
000058C8 4EB8 1374                  		jsr	CalcSine.w			; Get the sine of it
000058CC C1FC 0020                  		muls.w	#$20,d0				; Multiple it by $20
000058D0 E080                       		asr.l	#8,d0				; Shift it
000058D2 4A68 003A                  		tst.w	_objGVel(a0)			; Check speed
000058D6 6700                       		beq.s	.End				; If Sonic is not moving, branch
000058D8 D168 003A                  		add.w	d0,_objGVel(a0)			; Add to ground velocity
000058DC                            
000058DC                            .End:
000058DC 4E75                       		rts
000058DE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000058DE                            ; Check if Sonic is to fall off a slope
000058DE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000058DE                            ObjPlayer_FallOffSlope:
000058DE 4A28 003F                  		tst.b	_objMoveLock(a0)			; Is the move lock timer, active?
000058E2 6600                       		bne.s	.End				; If so, branch
000058E4 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
000058E8 0600 0020                  		addi.b	#$20,d0				; Shift it
000058EC 0200 00C0                  		andi.b	#$C0,d0				; Get quadrant
000058F0 6700                       		beq.s	.End				; If Sonic is on the floor, branch
000058F2 3028 003A                  		move.w	_objGVel(a0),d0			; Get speed
000058F6 6A00                       		bpl.s	.ChkSpeed			; If it's already positive, branch
000058F8 4440                       		neg.w	d0				; Force it to be positive
000058FA                            
000058FA                            .ChkSpeed:
000058FA 0C40 0280                  		cmpi.w	#$280,d0			; Is Sonic going at least 2.5 pixels per frame?
000058FE 6400                       		bcc.s	.End				; If so, branch
00005900 4268 003A                  		clr.w	_objGVel(a0)			; Stop movement
00005904 08E8 0001 0028             		bset	#1,_objStatus(a0)			; Set "in air" flag
0000590A 117C 001E 003F             		move.b	#$1E,_objMoveLock(a0)		; Set move lock timer
00005910                            
00005910                            .End:
00005910 4E75                       		rts
00005912                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005912                            ; Affect Sonic's speed on slopes while rolling
00005912                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005912                            ObjPlayer_RollSlopePush:
00005912 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
00005916 0600 0060                  		addi.b	#$60,d0				; ''
0000591A 0C00 00C0                  		cmpi.b	#$C0,d0				; Is Sonic on a steep enough slope?
0000591E 6400                       		bcc.s	.End				; If not, branch
00005920                            
00005920 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
00005924 4EB8 1374                  		jsr	CalcSine.w			; Get sine
00005928 C1FC 0050                  		muls.w	#$50,d0				; Multiply sine by $50
0000592C E080                       		asr.l	#8,d0				; Shift over
0000592E                            
0000592E 4A68 003A                  		tst.w	_objGVel(a0)			; Is Sonic moving right?
00005932 6B00                       		bmi.s	.PushLeft			; If not, branch
00005934 4A40                       		tst.w	d0				; Is the push speed positive?
00005936 6A00                       		bpl.s	.Push				; If so, branch
00005938 E480                       		asr.l	#2,d0				; Shift over more
0000593A                            
0000593A                            .Push:
0000593A D168 003A                  		add.w	d0,_objGVel(a0)			; Add push speed
0000593E 4E75                       		rts
00005940                            
00005940                            .PushLeft:
00005940 4A40                       		tst.w	d0				; Is the push speed negative?
00005942 6B00                       		bmi.s	.Push2				; If so, branch
00005944 E480                       		asr.l	#2,d0				; Shift over more
00005946                            
00005946                            .Push2:
00005946 D168 003A                  		add.w	d0,_objGVel(a0)			; Add push speed
0000594A                            
0000594A                            .End:
0000594A 4E75                       		rts
0000594C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000594C                            ; Check for bouncy floor collision
0000594C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000594C                            ObjPlayer_ChkBounce:
0000594C 4A38 E909                  		tst.b	rFlooactIDive.w		; Is the floor active?
00005950 6700 0000                  		beq.w	.End				; If so, branch
00005954                            
00005954 0828 0001 0028             		btst	#1,_objStatus(a0)			; Is Sonic in the air?
0000595A 6700                       		beq.s	.ChkDown			; If not, branch
0000595C                            
0000595C 4A68 001E                  		tst.w	_objYVel(a0)			; Is Sonic falling?
00005960 6700 0000                  		beq.w	.ChkBounceUp			; If not, branch
00005964 6B00 0000                  		bmi.w	.ChkBounceUp			; ''
00005968                            
00005968                            .ChkDown:
00005968 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y of left sensor
0000596C 1028 002D                  		move.b	_objColH(a0),d0			; ''
00005970 4880                       		ext.w	d0				; ''
00005972 D440                       		add.w	d0,d2				; ''
00005974 5442                       		addq.w	#2,d2				; ''
00005976 3628 0014                  		move.w	_objXPos(a0),d3			; Get X of left sensor
0000597A 1028 002C                  		move.b	_objColW(a0),d0			; ''
0000597E 4880                       		ext.w	d0				; ''
00005980 9640                       		sub.w	d0,d3				; ''
00005982 4EB8 3BEE                  		jsr	Level_FindBlock			; Get the block located there
00005986 3011                       		move.w	(a1),d0				; ''
00005988 0240 03FF                  		andi.w	#$3FF,d0			; ''
0000598C 0C40 0080                  		cmpi.w	#$80,d0				; Is the block the bouncy floor?
00005990 6700                       		beq.s	.Bounce				; If so, branch
00005992                            
00005992 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y of right sensor
00005996 1028 002D                  		move.b	_objColH(a0),d0			; ''
0000599A 4880                       		ext.w	d0				; ''
0000599C D440                       		add.w	d0,d2				; ''
0000599E 5442                       		addq.w	#2,d2				; ''
000059A0 3628 0014                  		move.w	_objXPos(a0),d3			; Get X of right sensor
000059A4 1028 002C                  		move.b	_objColW(a0),d0			; ''
000059A8 4880                       		ext.w	d0				; ''
000059AA D640                       		add.w	d0,d3				; ''
000059AC 4EB8 3BEE                  		jsr	Level_FindBlock			; Get the block located there
000059B0 3011                       		move.w	(a1),d0				; ''
000059B2 0240 03FF                  		andi.w	#$3FF,d0			; ''
000059B6 0C40 0080                  		cmpi.w	#$80,d0				; Is the block the bouncy floor?
000059BA 6600                       		bne.s	.End				; If not, branch
000059BC                            
000059BC                            .Bounce:
000059BC 317C EA00 001E             		move.w	#-$1600,_objYVel(a0)		; Bounce Sonic up
000059C2 08E8 0001 0028             		bset	#1,_objStatus(a0)			; Set in air flag
000059C8 4228 0040                  		clr.b	_objJumping(a0)			; Clear jump flag
000059CC 4228 0046                  		clr.b	_objDashTimer(a0)			; Reset dash timer
000059D0 4228 0045                  		clr.b	_objDashFlag(a0)			; Reset dash flag
000059D4                            
000059D4                            		playSnd	#sFloorBounce, 2		; Play the floor bounce sound
000059D4 11FC 009B C4BD           M 	move.b	#sfloorbounce,(mqueue+((2)-1)).w
000059DA                            
000059DA 0828 0002 0028             		btst	#2,_objStatus(a0)			; Is Sonic already rolling?
000059E0 6600                       		bne.s	.End				; If so, branch
000059E2 08E8 0002 0028             		bset	#2,_objStatus(a0)			; Set roll flag
000059E8 117C 0008 002D             		move.b	#$8,_objColH(a0)			; Reduce Sonic's hitbox
000059EE 117C 0007 002C             		move.b	#7,_objColW(a0)			; ''
000059F4                            	;	addq.w	#5,_objYPos(a0)			; Align Sonic to the ground
000059F4 117C 0002 0020             		move.b	#2,_objAnim(a0)			; Set rolling animation
000059FA                            
000059FA                            .End:
000059FA 4E75                       		rts
000059FC                            
000059FC                            .ChkBounceUp:
000059FC 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y of left sensor
00005A00 1028 002D                  		move.b	_objColH(a0),d0			; ''
00005A04 4880                       		ext.w	d0				; ''
00005A06 9440                       		sub.w	d0,d2				; ''
00005A08 5542                       		subq.w	#2,d2				; ''
00005A0A 3628 0014                  		move.w	_objXPos(a0),d3			; Get X of left sensor
00005A0E 1028 002C                  		move.b	_objColW(a0),d0			; ''
00005A12 4880                       		ext.w	d0				; ''
00005A14 9640                       		sub.w	d0,d3				; ''
00005A16 4EB8 3BEE                  		jsr	Level_FindBlock			; Get the block located there
00005A1A 3011                       		move.w	(a1),d0				; ''
00005A1C 0240 03FF                  		andi.w	#$3FF,d0			; ''
00005A20 0C40 0080                  		cmpi.w	#$80,d0				; Is the block the bouncy floor?
00005A24 6700                       		beq.s	.BounceUp			; If so, branch
00005A26                            
00005A26 3428 0018                  		move.w	_objYPos(a0),d2			; Get Y of right sensor
00005A2A 1028 002D                  		move.b	_objColH(a0),d0			; ''
00005A2E 4880                       		ext.w	d0				; ''
00005A30 9440                       		sub.w	d0,d2				; ''
00005A32 5542                       		subq.w	#2,d2				; ''
00005A34 3628 0014                  		move.w	_objXPos(a0),d3			; Get X of right sensor
00005A38 1028 002C                  		move.b	_objColW(a0),d0			; ''
00005A3C 4880                       		ext.w	d0				; ''
00005A3E D640                       		add.w	d0,d3				; ''
00005A40 4EB8 3BEE                  		jsr	Level_FindBlock			; Get the block located there
00005A44 3011                       		move.w	(a1),d0				; ''
00005A46 0240 03FF                  		andi.w	#$3FF,d0			; ''
00005A4A 0C40 0080                  		cmpi.w	#$80,d0				; Is the block the bouncy floor?
00005A4E 66AA                       		bne.s	.End				; If not, branch
00005A50                            
00005A50                            .BounceUp:
00005A50 588F                       		addq.l	#4,sp				; Don't return to caller
00005A52                            
00005A52 317C 1600 001E             		move.w	#$1600,_objYVel(a0)		; Bounce Sonic up
00005A58 08E8 0001 0028             		bset	#1,_objStatus(a0)			; Set in air flag
00005A5E 4228 0040                  		clr.b	_objJumping(a0)			; Clear jump flag
00005A62 4228 0046                  		clr.b	_objDashTimer(a0)			; Reset dash timer
00005A66 4228 0045                  		clr.b	_objDashFlag(a0)			; Reset dash flag
00005A6A                            
00005A6A                            		playSnd	#sFloorBounce, 2		; Play the floor bounce sound
00005A6A 11FC 009B C4BD           M 	move.b	#sfloorbounce,(mqueue+((2)-1)).w
00005A70                            
00005A70 0828 0002 0028             		btst	#2,_objStatus(a0)			; Is Sonic already rolling?
00005A76 6600                       		bne.s	.End2				; If so, branch
00005A78 08E8 0002 0028             		bset	#2,_objStatus(a0)			; Set roll flag
00005A7E 117C 0008 002D             		move.b	#$8,_objColH(a0)			; Reduce Sonic's hitbox
00005A84 117C 0007 002C             		move.b	#7,_objColW(a0)			; ''
00005A8A                            	;	addq.w	#5,_objYPos(a0)			; Align Sonic to the ground
00005A8A 117C 0002 0020             		move.b	#2,_objAnim(a0)			; Set rolling animation
00005A90                            
00005A90                            .End2:
00005A90 4E75                       		rts
00005A92                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005A92                            ; Check for bars to hang on to
00005A92                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005A92                            ObjPlayer_ChkHang:
00005A92 0828 0003 000C             		btst	#3,_objFlags(a0)			; Are we already hanging?
00005A98 6600                       		bne.s	.End				; If so, branch
00005A9A                            
00005A9A 3628 0014                  		move.w	_objXPos(a0),d3			; X position
00005A9E 3428 0018                  		move.w	_objYPos(a0),d2			; Y position
00005AA2 0442 0018                  		subi.w	#$18,d2				; ''
00005AA6 4EB8 3BEE                  		jsr	Level_FindBlock			; Get the block located there
00005AAA 3011                       		move.w	(a1),d0				; ''
00005AAC 0240 03FF                  		andi.w	#$3FF,d0			; ''
00005AB0 0C40 0081                  		cmpi.w	#$81,d0				; Is the block the bar?
00005AB4 6600                       		bne.s	.End				; If not, branch
00005AB6                            
00005AB6 08A8 0002 0028             		bclr	#2,_objStatus(a0)			; Clear roll flag
00005ABC 42A8 001C                  		clr.l	_objXVel(a0)			; Stop movement
00005AC0 4268 003A                  		clr.w	_objGVel(a0)			; ''
00005AC4 08E8 0003 000C             		bset	#3,_objFlags(a0)			; Set hanging flag
00005ACA 117C 000A 0020             		move.b	#$A,_objAnim(a0)			; Set hanging animation
00005AD0 117C 0007 004C             		move.b	#7,_objHangAniTime(a0)		; Animation timer
00005AD6                            	;	move.w	_objYPos(a0),d0			; Align with bar
00005AD6 0440 0018                  		subi.w	#$18,d0				; ''
00005ADA 0240 FFF0                  		andi.w	#$FFF0,d0			; ''
00005ADE 0640 0018                  		addi.w	#$18,d0				; ''
00005AE2 3140 0018                  		move.w	d0,_objYPos(a0)			; ''
00005AE6 4228 0041                  		clr.b	_objAngle(a0)			; Reset angle
00005AEA 08A8 0001 000D             		bclr	#1,_objRender(a0)			; ''
00005AF0                            
00005AF0                            .End:
00005AF0 4E75                       		rts
00005AF2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005AF2                            ; Hang onto the bars
00005AF2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005AF2                            ObjPlayer_Hang:
00005AF2 3628 0014                  		move.w	_objXPos(a0),d3			; X position
00005AF6 3428 0018                  		move.w	_objYPos(a0),d2			; Y position
00005AFA 0442 0018                  		subi.w	#$18,d2				; ''
00005AFE 4EB8 3BEE                  		jsr	Level_FindBlock			; Get the block located there
00005B02 3011                       		move.w	(a1),d0				; ''
00005B04 0240 03FF                  		andi.w	#$3FF,d0			; ''
00005B08 0C40 0081                  		cmpi.w	#$81,d0				; Is the block the bar?
00005B0C 6600                       		bne.s	.FallOff			; If not, branch
00005B0E 1038 E8DF                  		move.b	plrCtrlPress.w,d0		; Get control press bits
00005B12 0200 0070                  		andi.b	#$70,d0				; Are we jumping off?
00005B16 6700                       		beq.s	.MoveX				; If not, branch
00005B18                            
00005B18                            .FallOff:
00005B18 08A8 0003 000C             		bclr	#3,_objFlags(a0)			; Stop hanging
00005B1E 0668 0010 0018             		addi.w	#$10,_objYPos(a0)			; Fall off
00005B24 1168 0030 002D             		move.b	_objInitColH(a0),_objColH(a0)		; Reset collision height
00005B2A 1168 0031 002C             		move.b	_objInitColW(a0),_objColW(a0)		; Reset collision width
00005B30 4E75                       		rts
00005B32                            
00005B32                            .MoveX:
00005B32 7002                       		moveq	#2,d0				; X speed
00005B34 0838 0002 E8DE             		btst	#2,plrCtrlHold.w		; Are we going left?
00005B3A 6700                       		beq.s	.ChkRight			; If not, branch
00005B3C 4440                       		neg.w	d0				; Go the other way
00005B3E 08E8 0000 0028             		bset	#0,_objStatus(a0)			; Face to the left
00005B44 08E8 0000 000D             		bset	#0,_objRender(a0)			; ''
00005B4A 6000                       		bra.s	.DoMove				; Continue
00005B4C                            
00005B4C                            .ChkRight:
00005B4C 0838 0003 E8DE             		btst	#3,plrCtrlHold.w		; Are we going left?
00005B52 6700                       		beq.s	.ResetScr			; If not, branch
00005B54 08A8 0000 0028             		bclr	#0,_objStatus(a0)			; Face to the right
00005B5A 08A8 0000 000D             		bclr	#0,_objRender(a0)			; ''
00005B60                            
00005B60                            .DoMove:
00005B60 D168 0014                  		add.w	d0,_objXPos(a0)			; Move
00005B64 5328 004C                  		subq.b	#1,_objHangAniTime(a0)		; Decrement animation timer
00005B68 6A00                       		bpl.s	.ResetScr			; If it hasn't run out, branch
00005B6A 117C 0007 004C             		move.b	#7,_objHangAniTime(a0)		; Reset timer
00005B70 5228 0022                  		addq.b	#1,_objAnimFrame(a0)		; Increment animation frame
00005B74 0C28 0004 0022             		cmpi.b	#4,_objAnimFrame(a0)		; Have we reached the last one?
00005B7A 6500                       		bcs.s	.ResetScr			; If not, branch
00005B7C 4228 0022                  		clr.b	_objAnimFrame(a0)			; Reset animation frame
00005B80                            
00005B80                            .ResetScr:
00005B80 4228 0044                  		clr.b	_objScrlDelay(a0)			; Reset scroll delay counter
00005B84 0C78 0060 E8D8             		cmpi.w	#(224/2)-16,panCamYPos.w	; Is the camera centered vertically?
00005B8A 6700                       		beq.s	.End				; If so, branch
00005B8C 6400                       		bhs.s	.ScrollUp			; If it's below the center, branch
00005B8E 5878 E8D8                  		addq.w	#4,panCamYPos.w		; Scroll the camera up
00005B92                            
00005B92                            .ScrollUp:
00005B92 5578 E8D8                  		subq.w	#2,panCamYPos.w		; Scroll the camera down
00005B96                            
00005B96                            .End:
00005B96 4E75                       		rts
00005B98                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005B98                            ; Check for electricity
00005B98                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005B98                            ObjPlayer_ChkElectric:
00005B98 3628 0014                  		move.w	_objXPos(a0),d3			; X position
00005B9C 3428 0018                  		move.w	_objYPos(a0),d2			; Y position
00005BA0 4EB8 3BEE                  		jsr	Level_FindBlock			; Get the block located there
00005BA4 3011                       		move.w	(a1),d0				; ''
00005BA6 0240 03FF                  		andi.w	#$3FF,d0			; ''
00005BAA                            
00005BAA 43FA 0000                  		lea	.Blocks(pc),a1			; BLocks to check
00005BAE 7C02                       		moveq	#2,d6				; ''
00005BB0                            
00005BB0                            .ChkBlocks:
00005BB0 B059                       		cmp.w	(a1)+,d0			; have we touched this block?
00005BB2 6700                       		beq.s	ObjPlayer_GetHurt		; If so, branch
00005BB4 51CE FFFA                  		dbf	d6,.ChkBlocks			; Loop
00005BB8 4E75                       		rts
00005BBA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005BBA 0082 0083 0084             .Blocks:	dc.w	$82, $83, $84
00005BC0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005BC0                            ; Get Sonic hurt
00005BC0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005BC0                            ObjPlayer_GetHurt:
00005BC0                            		displaySprite	2,a0,a1,1		; Add sprite if not already being displayed
00005BC0 4A68 0008                M 	tst.w	_objdrawnext(a0)
00005BC4 6600                     M 	bne.s	.no_223
00005BC6 317C C16A 0008           M 	move.w	#objdisplay+(2*dsize),_objdrawnext(a0)
00005BCC 3278 C174                M 	move.w	objdisplay+dprev+(2*dsize).w,a1
00005BD0 3149 000A                M 	move.w	a1,_objdrawprev(a0)
00005BD4 3348 0008                M 	move.w	a0,_objdrawnext(a1)
00005BD8 31C8 C174                M 	move.w	a0,objdisplay+dprev+(2*dsize).w
00005BDC                          M .no_223
00005BDC 4A28 0042                  		tst.b	_objInvulTime(a0)			; Are we invulnerable?
00005BE0 6600 0000                  		bne.w	.End				; If so, branch
00005BE4 4A78 E85E                  		tst.w	ringCount.w			; Does Sonic have any rings?
00005BE8 6700 0000                  		beq.w	ObjPlayer_GetKilled		; If not, branch
00005BEC 4EB8 1A1C                  		jsr	FindFreeObj.w
00005BF0 6700                       		beq.s	.Hurt
00005BF2 22BC 0000 0000             		move.l	#ObjRingLoss,_objAddress(a1)
00005BF8 3368 0014 0014             		move.w	_objXPos(a0),_objXPos(a1)
00005BFE 3368 0018 0018             		move.w	_objYPos(a0),_objYPos(a1)
00005C04                            
00005C04                            .Hurt:
00005C04 117C 0008 0025             		move.b	#8,_objRoutine(a0)			; Set to hurt routine
00005C0A 4EB8 31DE                  		jsr	PlayerResetOnFloorPart2	; Reset Sonic like he would touching the ground
00005C0E 4228 0044                  		clr.b	_objScrlDelay(a0)			; Reset scroll delay counter
00005C12 08A8 0000 000C             		bclr	#0,_objFlags(a0)			; Allow modes
00005C18 08A8 0003 000C             		bclr	#3,_objFlags(a0)			; Stop hanging
00005C1E 08E8 0001 0028             		bset	#1,_objStatus(a0)			; Set the "in air" flag
00005C24 117C 001A 0020             		move.b	#$1A,_objAnim(a0)			; Set to hurt animation
00005C2A 117C 0078 0042             		move.b	#$78,_objInvulTime(a0)		; Set invulnerable timer
00005C30                            
00005C30 317C FC00 001E             		move.w	#-$400,_objYVel(a0)		; Make Sonic bounce away
00005C36 317C FE00 001C             		move.w	#-$200,_objXVel(a0)		; ''
00005C3C 0828 0006 0028             		btst	#6,_objStatus(a0)			; Is Sonic underwater?
00005C42 6700                       		beq.s	.ChkReverse			; If not, branch
00005C44 317C FE00 001E             		move.w	#-$200,_objYVel(a0)		; Make Sonic bounce away slower
00005C4A 317C FF00 001C             		move.w	#-$100,_objXVel(a0)
00005C50                            
00005C50                            .ChkReverse:
00005C50 3028 0014                  		move.w	_objXPos(a0),d0			; Get X position
00005C54 B06A 0014                  		cmp.w	_objXPos(a2),d0			; Is Sonic left of the object that hurt him?
00005C58 6500                       		bcs.s	.ChkSnd				; If so, branch
00005C5A 4468 001C                  		neg.w	_objXVel(a0)			; Make Sonic bounce the other way if on the right side
00005C5E                            
00005C5E                            .ChkSnd:
00005C5E 4268 003A                  		clr.w	_objGVel(a0)			; Reset ground velocity
00005C62                            
00005C62                            	;	cmpi.l	#ObjSpike,_objAddress(a2)		; Did Sonic hit a spike?
00005C62                            	;	beq.s	.End				; If not, branch
00005C62                            		playSnd	#sHurt, 2			; Play hurt sound
00005C62 11FC 0084 C4BD           M 	move.b	#shurt,(mqueue+((2)-1)).w
00005C68                            
00005C68                            .End:
00005C68 70FF                       		moveq	#-1,d0				; Set return status
00005C6A 4E75                       		rts
00005C6C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005C6C                            ; Hurt routine
00005C6C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005C6C                            ObjPlayer_Hurt:
00005C6C 4A38 C76A                  		tst.b	moveCheat.w
00005C70 6700                       		beq.s	.NoPlacementEnter
00005C72 0838 0004 C743             		btst	#4,ctrlPressP1.w			; Has the B button been pressed?
00005C78 6700                       		beq.s	.NoPlacementEnter		; If not, branch
00005C7A 11FC 0001 E8DD             		move.b	#1,debugMode.w		; Enable debug placement mode
00005C80 20BC 0000 0000             		move.l	#DebugPlacement,_objAddress(a0)	; Set to debug placement mode
00005C86 4E75                       		rts
00005C88                            
00005C88                            .NoPlacementEnter:
00005C88 4EB8 1D28                  		jsr	ObjectMove.w			; Allow movement
00005C8C 0668 0030 001E             		addi.w	#$30,_objYVel(a0)			; Apply gravity
00005C92 0828 0006 0028             		btst	#6,_objStatus(a0)			; Is Sonic underwater?
00005C98 6700                       		beq.s	.NotWater			; If not, branch
00005C9A 0468 0020 001E             		subi.w	#$20,_objYVel(a0)			; Reduce gravity underwater
00005CA0                            
00005CA0                            .NotWater:
00005CA0 117C 001A 0020             		move.b	#$1A,_objAnim(a0)			; Force the hurt animation
00005CA6 6100                       		bsr.s	.ChkStop			; Check if Sonic has hit the ground or the bottom boundary
00005CA8                            
00005CA8 0C78 0060 E8D8             		cmpi.w	#(224/2)-16,panCamYPos.w	; Is the camera centered vertically?
00005CAE 6700                       		beq.s	.Cont				; If so, branch
00005CB0 6400                       		bhs.s	.ScrollUp			; If it's below the center, branch
00005CB2 5878 E8D8                  		addq.w	#4,panCamYPos.w		; Scroll the camera up
00005CB6                            
00005CB6                            .ScrollUp:
00005CB6 5578 E8D8                  		subq.w	#2,panCamYPos.w		; Scroll the camera down
00005CBA                            
00005CBA                            .Cont:
00005CBA 6100 F80C                  		bsr.w	ObjPlayer_LvlBound		; Handle level boundaries
00005CBE 6100 0000                  		bsr.w	ObjPlayer_Animate		; Animate sprite
00005CC2 6000 0000                  		bra.w	ObjPlayer_LoadDPLCs		; Load DPLCs
00005CC6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005CC6                            .ChkStop:
00005CC6 3038 E8CC                  		move.w	maxCamYPos.w,d0		; Get bottom boundary
00005CCA 0640 00E0                  		addi.w	#224,d0				; ''
00005CCE B068 0018                  		cmp.w	_objYPos(a0),d0			; Has Sonic hit it?
00005CD2 6D00                       		blt.s	ObjPlayer_GetKilled		; If so, branch
00005CD4                            
00005CD4 4EB8 2FE2                  		jsr	PlayerChkCollision		; Check for level collision
00005CD8 0828 0001 0028             		btst	#1,_objStatus(a0)			; Is Sonic still in midair?
00005CDE 6600                       		bne.s	.End				; If so, branch
00005CE0                            
00005CE0 7000                       		moveq	#0,d0
00005CE2 3140 001E                  		move.w	d0,_objYVel(a0)			; Stop Sonic's movement
00005CE6 3140 001C                  		move.w	d0,_objXVel(a0)			; ''
00005CEA 3140 003A                  		move.w	d0,_objGVel(a0)			; ''
00005CEE 1140 000C                  		move.b	d0,_objFlags(a0)			; Allow Sonic to move
00005CF2 1140 0020                  		move.b	d0,_objAnim(a0)			; Reset animation
00005CF6 117C 0004 0025             		move.b	#4,_objRoutine(a0)			; Set back to main routine
00005CFC                            
00005CFC                            .End:
00005CFC 4E75                       		rts
00005CFE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005CFE                            ; Get Sonic killed
00005CFE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005CFE                            ObjPlayer_GetKilled:
00005CFE                            		displaySprite	2,a0,a1,1		; Add sprite if not already being displayed
00005CFE 4A68 0008                M 	tst.w	_objdrawnext(a0)
00005D02 6600                     M 	bne.s	.no_225
00005D04 317C C16A 0008           M 	move.w	#objdisplay+(2*dsize),_objdrawnext(a0)
00005D0A 3278 C174                M 	move.w	objdisplay+dprev+(2*dsize).w,a1
00005D0E 3149 000A                M 	move.w	a1,_objdrawprev(a0)
00005D12 3348 0008                M 	move.w	a0,_objdrawnext(a1)
00005D16 31C8 C174                M 	move.w	a0,objdisplay+dprev+(2*dsize).w
00005D1A                          M .no_225
00005D1A 117C 000C 0025             		move.b	#$C,_objRoutine(a0)			; Set to the death routine
00005D20 4EB8 31DE                  		jsr	PlayerResetOnFloorPart2	; Reset Sonic like he would touching the ground
00005D24 4228 0044                  		clr.b	_objScrlDelay(a0)			; Reset scroll delay counter
00005D28 08E8 0001 0028             		bset	#1,_objStatus(a0)			; Set the "in air" flag
00005D2E 117C 0018 0020             		move.b	#$18,_objAnim(a0)			; Set to death animation
00005D34                            
00005D34 317C F900 001E             		move.w	#-$700,_objYVel(a0)		; Make Sonic bounce up
00005D3A 4268 001C                  		clr.w	_objXVel(a0)			; Lock Sonic horizontally
00005D3E 4268 003A                  		clr.w	_objGVel(a0)			; ''
00005D42 31FC FFFF E8DA             		move.w	#$FFFF,camLocked.w		; Lock the camera
00005D48                            
00005D48                            	;	cmpi.l	#ObjSpike,_objAddress(a2)		; Did Sonic hit a spike?
00005D48                            	;	beq.s	.End				; If not, branch
00005D48                            		playSnd	#sDeath,2			; Play death sound
00005D48 11FC 0084 C4BD           M 	move.b	#sdeath,(mqueue+((2)-1)).w
00005D4E                            
00005D4E                            .End:
00005D4E 70FF                       		moveq	#-1,d0				; Set return status
00005D50 4E75                       		rts
00005D52                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005D52                            ; Death routine
00005D52                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005D52                            ObjPlayer_Dead:
00005D52 4A38 C76A                  		tst.b	moveCheat.w
00005D56 6700                       		beq.s	.NoPlacementEnter
00005D58 0838 0004 C743             		btst	#4,ctrlPressP1.w			; Has the B button been pressed?
00005D5E 6700                       		beq.s	.NoPlacementEnter		; If not, branch
00005D60 11FC 0001 E8DD             		move.b	#1,debugMode.w		; Enable debug placement mode
00005D66 20BC 0000 0000             		move.l	#DebugPlacement,_objAddress(a0)	; Set to debug placement mode
00005D6C 4E75                       		rts
00005D6E                            
00005D6E                            .NoPlacementEnter:
00005D6E 117C 0018 0020             		move.b	#$18,_objAnim(a0)			; Force the death animation
00005D74 0068 8000 000E             		ori.w	#$8000,_objVRAM(a0)		; Force high priority
00005D7A 6100                       		bsr.s	ObjPlayer_ChkBound		; Check for when Sonic goes off screen
00005D7C 4EB8 1D42                  		jsr	ObjectMoveAndFall.w		; Allow movement
00005D80 6100 0000                  		bsr.w	ObjPlayer_Animate		; Animate sprite
00005D84 6000 0000                  		bra.w	ObjPlayer_LoadDPLCs		; Load DPLCs
00005D88                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005D88                            ObjPlayer_ChkBound:
00005D88 3038 E8CC                  		move.w	maxCamYPos.w,d0		; Get bottom boundary
00005D8C 0640 0100                  		addi.w	#$100,d0			; ''
00005D90 B068 0018                  		cmp.w	_objYPos(a0),d0			; Has Sonic hit it?
00005D94 6C00                       		bge.s	.End				; If not, branch
00005D96                            
00005D96 117C 0010 0025             		move.b	#$10,_objRoutine(a0)			; Go to gone routine
00005D9C 117C 003C 0043             		move.b	#60,_objDeathTimer(a0)		; Set death timer to 1 second
00005DA2                            
00005DA2                            .End:
00005DA2 4E75                       		rts
00005DA4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005DA4                            ; Wait for level reload or game/time over
00005DA4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005DA4                            ObjPlayer_Gone:
00005DA4 4A28 0043                  		tst.b	_objDeathTimer(a0)
00005DA8 6700                       		beq.s	.End
00005DAA 5328 0043                  		subq.b	#1,_objDeathTimer(a0)		; Decrement the death counter
00005DAE 6600                       		bne.s	.End				; If it hasn't run out, branch
00005DB0 50F8 E906                  		st	lvlReload.w			; Reload the level
00005DB4                            
00005DB4                            .End:
00005DB4 4E75                       		rts
00005DB6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005DB6                            ; Display Sonic's sprite
00005DB6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005DB6                            ObjPlayer_Display:
00005DB6 1028 0042                  		move.b	_objInvulTime(a0),d0		; Get invulnerability timer
00005DBA 6700                       		beq.s	.Display			; If it's 0, branch
00005DBC 5328 0042                  		subq.b	#1,_objInvulTime(a0)		; Decrement invulnerability timer
00005DC0 E648                       		lsr.w	#3,d0				; Can Sonic's sprite be displayed?
00005DC2 6500                       		bcs.s	.Display			; If so, branch
00005DC4                            	removeSprite	a0,a1,1				; Remove sprite if displayed
00005DC4 4A68 0008                M 	tst.w	_objdrawnext(a0)
00005DC8 6700                     M 	beq.s	.yes_227
00005DCA 3268 000A                M 	move.w	_objdrawprev(a0),a1
00005DCE 3368 0008 0008           M 	move.w	_objdrawnext(a0),_objdrawnext(a1)
00005DD4 3268 0008                M 	move.w	_objdrawnext(a0),a1
00005DD8 3368 000A 000A           M 	move.w	_objdrawprev(a0),_objdrawprev(a1)
00005DDE                          M .no_227
00005DDE 42A8 0008                M 	clr.l	_objdrawnext(a0)
00005DE2                          M .yes_227
00005DE2 4E75                       		rts
00005DE4                            
00005DE4                            .Display:
00005DE4                            	displaySprite	2,a0,a1,1			; Add sprite if not already being displayed
00005DE4 4A68 0008                M 	tst.w	_objdrawnext(a0)
00005DE8 6600                     M 	bne.s	.no_228
00005DEA 317C C16A 0008           M 	move.w	#objdisplay+(2*dsize),_objdrawnext(a0)
00005DF0 3278 C174                M 	move.w	objdisplay+dprev+(2*dsize).w,a1
00005DF4 3149 000A                M 	move.w	a1,_objdrawprev(a0)
00005DF8 3348 0008                M 	move.w	a0,_objdrawnext(a1)
00005DFC 31C8 C174                M 	move.w	a0,objdisplay+dprev+(2*dsize).w
00005E00                          M .no_228
00005E00 4E75                       		rts
00005E02                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005E02                            ; Load Sonic's DPLCs
00005E02                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005E02                            ObjPlayer_LoadDPLCs:
00005E02 45F9 0000 0000             		lea	DPLC_ObjPlayer,a2		; DPLCs
00005E08 383C F000                  		move.w	#$F000,d4			; VRAM location
00005E0C 2C3C 0000 0000             		move.l	#ArtUnc_Sonic,d6		; Art
00005E12 4EF8 1CE8                  		jmp	LoadObjDPLCs.w			; Load DPLCs
00005E16                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005E16                            ; Animate Sonic's sprite
00005E16                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005E16                            ObjPlayer_Animate:
00005E16 43F9 0000 0000             		lea	Ani_ObjPlayer,a1			; Animation script
00005E1C 7000                       		moveq	#0,d0
00005E1E 1028 0020                  		move.b	_objAnim(a0),d0			; Get animation ID
00005E22 B028 0021                  		cmp.b	_objPrevAnim(a0),d0			; Has it changed?
00005E26 6700                       		beq.s	.Run				; If not, branch
00005E28 1140 0021                  		move.b	d0,_objPrevAnim(a0)			; Save the new ID
00005E2C 4228 0022                  		clr.b	_objAnimFrame(a0)			; Reset animation
00005E30 4228 0023                  		clr.b	_objAnimTimer(a0)			; Reset animation timer
00005E34 08A8 0005 0028             		bclr	#5,_objStatus(a0)			; Clear "pushing" flag
00005E3A                            
00005E3A                            .Run:
00005E3A D040                       		add.w	d0,d0				; Turn ID into offset
00005E3C D2F1 0000                  		adda.w	(a1,d0.w),a1			; Get pointer to current animation script
00005E40 1011                       		move.b	(a1),d0				; Get first byte
00005E42 6B00                       		bmi.s	.WalkRunAnim			; If this is a special animation, branch
00005E44 1228 0028                  		move.b	_objStatus(a0),d1			; Get status
00005E48 0201 0001                  		andi.b	#1,d1				; Only get horizontal flip bit
00005E4C 0228 00FC 000D             		andi.b	#$FC,_objRender(a0)		; Mask out flip bits in render flags
00005E52 8328 000D                  		or.b	d1,_objRender(a0)			; Set flip bits
00005E56 5328 0023                  		subq.b	#1,_objAnimTimer(a0)		; Decrement animation timer
00005E5A 6A00                       		bpl.s	.Wait				; If it hasn't run out, branch
00005E5C 1140 0023                  		move.b	d0,_objAnimTimer(a0)		; Set new animation timer
00005E60                            
00005E60                            .GetFrame:
00005E60 7200                       		moveq	#0,d1
00005E62 1228 0022                  		move.b	_objAnimFrame(a0),d1		; Get current value in the script
00005E66 1031 1001                  		move.b	1(a1,d1.w),d0			; ''
00005E6A 0C00 00FD                  		cmpi.b	#$FD,d0				; Is it a command value?
00005E6E 6400                       		bhs.s	.CmdReset			; If so, branch
00005E70                            
00005E70                            .Next:
00005E70 1140 0010                  		move.b	d0,_objFrame(a0)			; Set mapping frame ID
00005E74 5228 0022                  		addq.b	#1,_objAnimFrame(a0)		; Advance into the animation script
00005E78                            
00005E78                            .Wait:
00005E78 4E75                       		rts
00005E7A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005E7A                            .CmdReset:
00005E7A 5200                       		addq.b	#1,d0				; Is this flag $FF (reset)?
00005E7C 6600                       		bne.s	.CmdJump			; If not, branch
00005E7E 4228 0022                  		clr.b	_objAnimFrame(a0)			; Reset animation
00005E82 1029 0001                  		move.b	1(a1),d0			; Get first frame ID
00005E86 60E8                       		bra.s	.Next				; Continue
00005E88                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005E88                            .CmdJump:
00005E88 5200                       		addq.b	#1,d0				; Is this flag $FE (jump)?
00005E8A 6600                       		bne.s	.CmdSetAnim			; If not, branch
00005E8C 1031 1002                  		move.b	2(a1,d1.w),d0			; Get jump offset
00005E90 9128 0022                  		sub.b	d0,_objAnimFrame(a0)		; Go back
00005E94 9200                       		sub.b	d0,d1				; ''
00005E96 1031 1001                  		move.b	1(a1,d1.w),d0			; Get new frame ID
00005E9A 60D4                       		bra.s	.Next				; Continue
00005E9C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005E9C                            .CmdSetAnim:
00005E9C 5200                       		addq.b	#1,d0				; Is this flag $FD (set animation ID)?
00005E9E 6600                       		bne.s	.CmdEnd				; If not, branch
00005EA0 1171 1002 0020             		move.b	2(a1,d1.w),_objAnim(a0)		; Set new animation ID
00005EA6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005EA6                            .CmdEnd:
00005EA6 4E75                       		rts
00005EA8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005EA8                            .WalkRunAnim:
00005EA8 5328 0023                  		subq.b	#1,_objAnimTimer(a0)		; Decrement animation timer
00005EAC 6ACA                       		bpl.s	.Wait				; If it hasn't run out, branch
00005EAE 5200                       		addq.b	#1,d0				; Is the animation walking/running?
00005EB0 6600 0000                  		bne.w	.RollAnim			; If not, branch
00005EB4                            
00005EB4 7000                       		moveq	#0,d0
00005EB6 1028 0047                  		move.b	_objFlipAngle(a0),d0		; Is Sonic tumbling in the air?
00005EBA 6600 0000                  		bne.w	.TumbleAnim			; If so, branch
00005EBE                            
00005EBE 7200                       		moveq	#0,d1				; Intial flip bits
00005EC0 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
00005EC4 6B00                       		bmi.s	.ChkStatus			; If it's negative, branch
00005EC6 6700                       		beq.s	.ChkStatus			; If it's zero, branch
00005EC8 5300                       		subq.b	#1,d0				; Decrement angle if it's positive
00005ECA                            
00005ECA                            .ChkStatus:
00005ECA 1428 0028                  		move.b	_objStatus(a0),d2			; Get status
00005ECE 0202 0001                  		andi.b	#1,d2				; Is Sonic mirrored horizontally?
00005ED2 6600                       		bne.s	.ChkFlip			; If so, branch
00005ED4 4600                       		not.b	d0				; Reverse angle
00005ED6                            
00005ED6                            .ChkFlip:
00005ED6 0600 0010                  		addi.b	#$10,d0				; Shift angle
00005EDA 6A00                       		bpl.s	.SetFlags			; If it's positive, branch
00005EDC 7203                       		moveq	#3,d1				; Flags to flip Sonic's sprite
00005EDE                            
00005EDE                            .SetFlags:
00005EDE 0228 00FC 000D             		andi.b	#$FC,_objRender(a0)		; Mask out flip bits
00005EE4 B302                       		eor.b	d1,d2				; Flip
00005EE6 8528 000D                  		or.b	d2,_objRender(a0)			; Set in render flags
00005EEA                            
00005EEA 0828 0005 0028             		btst	#5,_objStatus(a0)			; Is Sonic pushing?
00005EF0 6600 0000                  		bne.w	.DoPushAnim			; If so, branch
00005EF4                            
00005EF4 E808                       		lsr.b	#4,d0				; Divide angle by $10
00005EF6 0200 0006                  		andi.b	#6,d0				; Get angle section
00005EFA                            
00005EFA 3428 003A                  		move.w	_objGVel(a0),d2			; Get Sonic's speed
00005EFE 6A00                       		bpl.s	.GetAnim			; If it's already positive, branch
00005F00 4442                       		neg.w	d2				; Force it to be positive
00005F02                            
00005F02                            .GetAnim:
00005F02 43F9 0000 0000             		lea	SonicAni_Sprint,a1		; Sprinting animation
00005F08 4A00                       		tst.b	d0
00005F0A 6600                       		bne.s	.ChkRun
00005F0C 0C42 0C00                  		cmpi.w	#$C00,d2			; Is Sonic sprinting?
00005F10 6400                       		bcc.s	.SkipWalk			; If so, branch
00005F12                            
00005F12                            .ChkRun:
00005F12 43F9 0000 0000             		lea	SonicAni_Run,a1			; Running animation
00005F18 0C42 0600                  		cmpi.w	#$600,d2			; Is Sonic running?
00005F1C 6400                       		bcc.s	.SkipWalk			; If so, branch
00005F1E 43F9 0000 0000             		lea	SonicAni_Walk,a1		; Walking animation
00005F24 1200                       		move.b	d0,d1				; Multiply angle section ID by 3
00005F26 E209                       		lsr.b	#1,d1				; ''
00005F28 D001                       		add.b	d1,d0				; ''
00005F2A                            
00005F2A                            .SkipWalk:
00005F2A D000                       		add.b	d0,d0				; Double the offset
00005F2C 1600                       		move.b	d0,d3				; Copy the oofset
00005F2E 4442                       		neg.w	d2				; Get animation speed
00005F30 0642 0800                  		addi.w	#$800,d2			; ''
00005F34 6A00                       		bpl.s	.SetTimer			; ''
00005F36 7400                       		moveq	#0,d2				; ''
00005F38                            
00005F38                            .SetTimer:
00005F38 E04A                       		lsr.w	#8,d2				; ''
00005F3A 1142 0023                  		move.b	d2,_objAnimTimer(a0)		; Set timer
00005F3E 6100 FF20                  		bsr.w	.GetFrame			; Get the next frame
00005F42 D728 0010                  		add.b	d3,_objFrame(a0)			; Add angle offset
00005F46 4E75                       		rts
00005F48                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005F48                            .TumbleAnim:
00005F48 1028 0047                  		move.b	_objFlipAngle(a0),d0		; Get flip angle
00005F4C 7200                       		moveq	#0,d1
00005F4E 1428 0028                  		move.b	_objStatus(a0),d2			; Get status
00005F52 0202 0001                  		andi.b	#1,d2				; Are we are facing left?
00005F56 6600                       		bne.s	.TumbleLeft			; If so, branch
00005F58                            
00005F58 0228 00FC 000D             		andi.b	#$FC,_objRender(a0)		; Clear flip bits
00005F5E 0600 000B                  		addi.b	#$B,d0				; Get map frame
00005F62 80FC 0016                  		divu.w	#$16,d0				; ''
00005F66 0600 0068                  		addi.b	#$68,d0				; ''
00005F6A 1140 0010                  		move.b	d0,_objFrame(a0)			; Set map frame
00005F6E 4228 0023                  		clr.b	_objAnimTimer(a0)			; Reset animation timer
00005F72 4E75                       		rts
00005F74                            
00005F74                            .TumbleLeft:
00005F74 0228 00FC 000D             		andi.b	#$FC,_objRender(a0)		; Clear flip bits
00005F7A 4A28 0048                  		tst.b	_objFlipTurned(a0)			; Is flipping inverted?
00005F7E 6700                       		beq.s	.NotInverted			; If not, branch
00005F80 0028 0001 000D             		ori.b	#1,_objRender(a0)			; Face left
00005F86 0600 000B                  		addi.b	#$B,d0				; Get map frame
00005F8A 6000                       		bra.s	.SetLeftFrame			; Continue
00005F8C                            
00005F8C                            .NotInverted:
00005F8C 0028 0003 000D             		ori.b	#3,_objRender(a0)			; Face left and be upside down
00005F92 4400                       		neg.b	d0				; Get map frame
00005F94 0600 008F                  		addi.b	#$8F,d0				; ''
00005F98                            
00005F98                            .SetLeftFrame:
00005F98 80FC 0016                  		divu.w	#$16,d0				; Continue getting map frame
00005F9C 0600 0068                  		addi.b	#$68,d0				; ''
00005FA0 1140 0010                  		move.b	d0,_objFrame(a0)			; Set map frame
00005FA4 4228 0023                  		clr.b	_objAnimTimer(a0)			; Reset animation timer
00005FA8 4E75                       		rts
00005FAA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005FAA                            .RollAnim:
00005FAA 5200                       		addq.b	#1,d0				; Is the animation rolling?
00005FAC 6600                       		bne.s	.PushAnim			; If not, branch
00005FAE                            
00005FAE 3428 003A                  		move.w	_objGVel(a0),d2			; Get Sonic's speed
00005FB2 6A00                       		bpl.s	.GetAnim2			; If it's already negative, branch
00005FB4 4442                       		neg.w	d2				; Force it to be negative
00005FB6                            
00005FB6                            .GetAnim2:
00005FB6 43F9 0000 0000             		lea	SonicAni_Roll2,a1		; Use fast animation
00005FBC 0C42 0600                  		cmpi.w	#$600,d2			; Is Sonic rolling fast enough?
00005FC0 6400                       		bcc.s	.PrepareTimer			; If so, branch
00005FC2 43F9 0000 0000             		lea	SonicAni_Roll,a1		; Use slower animation
00005FC8                            
00005FC8                            .PrepareTimer:
00005FC8 4442                       		neg.w	d2				; Get animation speed
00005FCA 0642 0400                  		addi.w	#$400,d2			; ''
00005FCE 6A00                       		bpl.s	.SetTimer2			; ''
00005FD0 7400                       		moveq	#0,d2				; ''
00005FD2                            
00005FD2                            .SetTimer2:
00005FD2 E04A                       		lsr.w	#8,d2				; ''
00005FD4 1142 0023                  		move.b	d2,_objAnimTimer(a0)		; Set timer
00005FD8                            
00005FD8 1228 0028                  		move.b	_objStatus(a0),d1			; Get status
00005FDC 0201 0001                  		andi.b	#1,d1				; Get horizontal flip flag only
00005FE0 0228 00FC 000D             		andi.b	#$FC,_objRender(a0)		; Clear flip bits in render flags
00005FE6 8328 000D                  		or.b	d1,_objRender(a0)			; Set new flip bits
00005FEA                            
00005FEA 6000 FE74                  		bra.w	.GetFrame			; Get the next frame
00005FEE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005FEE                            .PushAnim:
00005FEE 5200                       		addq.b	#1,d0				; Is the animation rolling?
00005FF0 6600                       		bne.s	.HangAnim			; If not, branch
00005FF2                            
00005FF2                            .DoPushAnim:
00005FF2 3428 003A                  		move.w	_objGVel(a0),d2			; Get Sonic's speed
00005FF6 6B00                       		bmi.s	.GetAnim3			; If it's already negative, branch
00005FF8 4442                       		neg.w	d2				; Force it to be negative
00005FFA                            
00005FFA                            .GetAnim3:
00005FFA 0642 0800                  		addi.w	#$800,d2			; Get animation speed
00005FFE 6A00                       		bpl.s	.SetTimer3			; ''
00006000 7400                       		moveq	#0,d2				; ''
00006002                            
00006002                            .SetTimer3:
00006002 EC4A                       		lsr.w	#6,d2				; ''
00006004 1142 0023                  		move.b	d2,_objAnimTimer(a0)		; Set timer
00006008 43F9 0000 0000             		lea	SonicAni_Push,a1		; Pushing animation
0000600E 6000 FE50                  		bra.w	.GetFrame			; Get the next frame
00006012                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006012                            .HangAnim:
00006012 7200                       		moveq	#0,d1
00006014 1228 0022                  		move.b	_objAnimFrame(a0),d1		; Get animation frame
00006018 1171 1001 0010             		move.b	1(a1,d1.w),_objFrame(a0)		; Set map frame
0000601E 4228 0023                  		clr.b	_objAnimTimer(a0)			; Clear animation timer
00006022 4E75                       		rts
00006024                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006024                            ; Handle debug placement mode
00006024                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006024                            DebugPlacement:
00006024 7000                       		moveq	#0,d0
00006026 1038 E8DD                  		move.b	debugMode.w,d0		; Get debug placement mode routine
0000602A 0240 0002                  		andi.w	#2,d0				; Only allow 0, 2, 4, and 6
0000602E D040                       		add.w	d0,d0				; Double it
00006030 4EBB 0000                  		jsr	.Routines(pc,d0.w)		; Go to the correct routine
00006034                            	nextObject
00006034 3068 0004                M 	movea.w	_objnext(a0),a0
00006038 2250                     M 	move.l	_objaddress(a0),a1
0000603A 4ED1                     M 	jmp	(a1)
0000603C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000603C                            .Routines:
0000603C 6000 0000                  		bra.w	Debug_Init			; Initialization(00*2)
00006040 6000 0000                  		bra.w	Debug_Main			; Main		(02*2)
00006044                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006044                            Debug_Init:
00006044 5438 E8DD                  		addq.b	#2,debugMode.w		; Next routine
00006048 4228 0010                  		clr.b	_objFrame(a0)			; Reset mapping frame
0000604C 4228 0020                  		clr.b	_objAnim(a0)			; Reset animation
00006050 4268 003A                  		clr.w	_objGVel(a0)			; Reset ground velocity
00006054 4278 E8DA                  		clr.w	camLocked.w			; Unlock the camera
00006058 4228 004B                  		clr.b	_objBallMode(a0)			; Reset ball mode
0000605C 4228 0041                  		clr.b	_objAngle(a0)			; Reset angle
00006060 117C 0004 0025             		move.b	#4,_objRoutine(a0)			; Set routine to main
00006066                            
00006066 3028 003C                  		move.w	_objInteract(a0),d0		; Get object interacted with last
0000606A 6700                       		beq.s	.NoInteract			; If there is none, branch
0000606C 3240                       		movea.w	d0,a1
0000606E 08A9 0003 0028             		bclr	#3,_objStatus(a1)			; Clear flags
00006074 08A9 0005 0028             		bclr	#5,_objStatus(a1)			; ''
0000607A 4268 003C                  		clr.w	_objInteract(a0)			; No more interaction
0000607E                            
0000607E                            .NoInteract:
0000607E 4228 000C                  		clr.b	_objFlags(a0)			; Reset flags
00006082 4228 0028                  		clr.b	_objStatus(a0)			; Reset status
00006086 0228 00FC 000D             		andi.b	#$FC,_objRender(a0)		; Mask out flip bits in render flags
0000608C 117C 0001 0010             		move.b	#1,_objFrame(a0)			; Display the standing frame
00006092 6100 FD6E                  		bsr.w	ObjPlayer_LoadDPLCs		; Load DPLCs
00006096                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006096                            Debug_Main:
00006096 6100 EE20                  		bsr.w	ObjPlayer_ExtendedCam		; Handle extended camera
0000609A 6100                       		bsr.s	Debug_Control			; Control
0000609C                            	displaySprite	2,a0,a2,1
0000609C 4A68 0008                M 	tst.w	_objdrawnext(a0)
000060A0 6600                     M 	bne.s	.no_230
000060A2 317C C16A 0008           M 	move.w	#objdisplay+(2*dsize),_objdrawnext(a0)
000060A8 3478 C174                M 	move.w	objdisplay+dprev+(2*dsize).w,a2
000060AC 314A 000A                M 	move.w	a2,_objdrawprev(a0)
000060B0 3548 0008                M 	move.w	a0,_objdrawnext(a2)
000060B4 31C8 C174                M 	move.w	a0,objdisplay+dprev+(2*dsize).w
000060B8                          M .no_230
000060B8 4E75                       		rts
000060BA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000060BA                            Debug_Control:
000060BA 7006                       		moveq	#6,d0				; Speed
000060BC 0838 0000 C742             		btst	#0,ctrlHoldP1.w			; Is up being held?
000060C2 6700                       		beq.s	.NoUp				; If not, branch
000060C4 9168 0018                  		sub.w	d0,_objYPos(a0)			; Move up
000060C8                            
000060C8                            .NoUp:
000060C8 0838 0001 C742             		btst	#1,ctrlHoldP1.w			; Is down being held?
000060CE 6700                       		beq.s	.NoDown				; If not, branch
000060D0 D168 0018                  		add.w	d0,_objYPos(a0)			; Move down
000060D4                            
000060D4                            .NoDown:
000060D4 0838 0002 C742             		btst	#2,ctrlHoldP1.w			; Is left being held?
000060DA 6700                       		beq.s	.NoLeft				; If not, branch
000060DC 9168 0014                  		sub.w	d0,_objXPos(a0)			; Move left
000060E0                            
000060E0                            .NoLeft:
000060E0 0838 0003 C742             		btst	#3,ctrlHoldP1.w			; Is right being held?
000060E6 6700                       		beq.s	.NoRight			; If not, branch
000060E8 D168 0014                  		add.w	d0,_objXPos(a0)			; Move right
000060EC                            
000060EC                            .NoRight:
000060EC 0838 0004 C743             		btst	#4,ctrlPressP1.w			; Has the B button been pressed?
000060F2 6700                       		beq.s	.ChkWrap			; If not, branch
000060F4 7000                       		moveq	#0,d0
000060F6 11C0 E8DD                  		move.b	d0,debugMode.w		; Disable debug placement mode
000060FA 1140 0016                  		move.b	d0,_objXPos+2(a0)			; Reset X subpixel
000060FE 1140 001A                  		move.b	d0,_objYPos+2(a0)			; Reset Y subpixel
00006102 3140 001C                  		move.w	d0,_objXVel(a0)			; Reset X velocity
00006106 3140 001E                  		move.w	d0,_objYVel(a0)			; Reset Y velocity
0000610A 3140 003A                  		move.w	d0,_objGVel(a0)			; Reset ground velocity
0000610E 0228 0001 0028             		andi.b	#1,_objStatus(a0)			; Reset status
00006114 08E8 0001 0028             		bset	#1,_objStatus(a0)			; Set "in air" flag
0000611A 20BC 0000 4DD8             		move.l	#ObjPlayer,_objAddress(a0)		; Use normal Sonic object
00006120 1168 0030 002D             		move.b	_objInitColH(a0),_objColH(a0)		; Reset collision height
00006126 1168 0031 002C             		move.b	_objInitColW(a0),_objColW(a0)		; Reset collision width
0000612C                            
0000612C                            .ChkWrap:
0000612C 4E75                       		rts
0000612E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000612E                            ; Data
0000612E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000612E                            Map_ObjPlayer:
0000612E                            		include	"Objects/Player/Mappings.asm"
0000612E                            Map_79b3:
0000612E 0000                       Map_79b3_0: 	dc.w Map_79b3_8-Map_79b3
00006130 0000                       Map_79b3_2: 	dc.w Map_79b3_A-Map_79b3
00006132 0000                       Map_79b3_4: 	dc.w Map_79b3_12-Map_79b3
00006134 0000                       Map_79b3_6: 	dc.w Map_79b3_1A-Map_79b3
00006136 0000                       Map_79b3_8: 	dc.b $0, $0
00006138 0001                       Map_79b3_A: 	dc.b $0, $1
0000613A FA05 0000 FFF8             	dc.b $FA, $5, $0, $0, $FF, $F8
00006140 0001                       Map_79b3_12: 	dc.b $0, $1
00006142 FA05 0000 FFF8             	dc.b $FA, $5, $0, $0, $FF, $F8
00006148 0001                       Map_79b3_1A: 	dc.b $0, $1
0000614A FA05 0000 FFF8             	dc.b $FA, $5, $0, $0, $FF, $F8
00006150                            	even
00006150                            		even
00006150                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006150                            DPLC_ObjPlayer:
00006150                            		include	"Objects/Player/DPLCs.asm"
00006150                            DPLC_bf0f:
00006150 0000                       DPLC_bf0f_0: 	dc.w DPLC_bf0f_8-DPLC_bf0f
00006152 0000                       DPLC_bf0f_2: 	dc.w DPLC_bf0f_A-DPLC_bf0f
00006154 0000                       DPLC_bf0f_4: 	dc.w DPLC_bf0f_E-DPLC_bf0f
00006156 0000                       DPLC_bf0f_6: 	dc.w DPLC_bf0f_12-DPLC_bf0f
00006158 0000                       DPLC_bf0f_8: 	dc.b $0, $0
0000615A 0001                       DPLC_bf0f_A: 	dc.b $0, $1
0000615C 3000                       	dc.b $30, $0
0000615E 0001                       DPLC_bf0f_E: 	dc.b $0, $1
00006160 3008                       	dc.b $30, $8
00006162 0001                       DPLC_bf0f_12: 	dc.b $0, $1
00006164 3004                       	dc.b $30, $4
00006166                            	even
00006166                            		even
00006166                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006166                            Ani_ObjPlayer:
00006166                            		include	"Objects/Player/Animations.asm"
00006166                            ; ---------------------------------------------------------------------------
00006166                            ; Animation script - Sonic
00006166                            ; ---------------------------------------------------------------------------
00006166                            SonicAniData:
00006166 0000                       		dc.w SonicAni_Blank-SonicAniData
00006168 0000                       		dc.w SonicANi_Blank-SonicAniData
0000616A 0000                       		dc.w SonicANi_Flap-SonicAniData
0000616C 0000                       		dc.w SonicANi_Flap-SonicAniData
0000616E 0000                       		dc.w SonicANi_Blank-SonicAniData
00006170 0000                       		dc.w SonicANi_Blank-SonicAniData
00006172 0000                       		dc.w SonicANi_Blank-SonicAniData
00006174 0000                       		dc.w SonicANi_Blank-SonicAniData
00006176 0000                       		dc.w SonicANi_Blank-SonicAniData
00006178 0000                       		dc.w SonicANi_Blank-SonicAniData
0000617A 0000                       		dc.w SonicANi_Blank-SonicAniData
0000617C 0000                       		dc.w SonicANi_Blank-SonicAniData
0000617E 0000                       		dc.w SonicANi_Blank-SonicAniData
00006180 0000                       		dc.w SonicANi_Blank-SonicAniData
00006182 0000                       		dc.w SonicANi_Blank-SonicAniData
00006184 0000                       		dc.w SonicANi_Blank-SonicAniData
00006186 0000                       		dc.w SonicANi_Blank-SonicAniData
00006188 0000                       		dc.w SonicANi_Blank-SonicAniData
0000618A 0000                       		dc.w SonicANi_Blank-SonicAniData
0000618C 0000                       		dc.w SonicANi_Blank-SonicAniData
0000618E 0000                       		dc.w SonicANi_Blank-SonicAniData
00006190 0000                       		dc.w SonicANi_Blank-SonicAniData
00006192 0000                       		dc.w SonicANi_Blank-SonicAniData
00006194 0000                       		dc.w SonicANi_Blank-SonicAniData
00006196 0000                       		dc.w SonicANi_Blank-SonicAniData
00006198 0000                       		dc.w SonicANi_Blank-SonicAniData
0000619A 0000                       		dc.w SonicANi_Blank-SonicAniData
0000619C 0000                       		dc.w SonicANi_Blank-SonicAniData
0000619E 0000                       		dc.w SonicANi_Blank-SonicAniData
000061A0 0000                       		dc.w SonicANi_Blank-SonicAniData
000061A2 0000                       		dc.w SonicANi_FlapB-SonicAniData
000061A4 0101 FD00                  SonicAni_Blank:		dc.b 1, 1, $FD, 0
000061A8                            		even
000061A8 03FD 1E                    SonicANi_Flap:		dc.b	3,	$FD,	$1E
000061AB 0301 0203 0201 FD00        SonicANi_FlapB:		dc.b	3,	1,	2,	3,	2,	1, $FD,	0
000061B3                            sonicani_sprint:
000061B3                            sonicani_run:
000061B3                            sonicani_walk:
000061B3                            sonicani_roll2:
000061B3                            sonicani_roll:
000061B3                            sonicani_push:
000061B4 00                         		even
000061B4                            ; =========================================================================================================================================================
000061B4                            		include	"Objects/Ring/Code.asm"		; Ring loss object
000061B4                            ; =========================================================================================================================================================
000061B4                            ; Water surface object
000061B4                            ; =========================================================================================================================================================
000061B4                            		rsset	_objLvlSSTs
000061B4                            
000061B4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000061B4                            ObjRingLoss:
000061B4 2248                       		movea.l	a0,a1
000061B6 7A00                       		moveq	#0,d5
000061B8 3A3C 0001                  		move.w	#1,d5
000061BC 7020                       		moveq	#32,d0
000061BE BA40                       		cmp.w	d0,d5
000061C0 6500                       		bcs.s	.BelowMax
000061C2 3A00                       		move.w	d0,d5
000061C4                            
000061C4                            .BelowMax:
000061C4 5345                       		subq.w	#1,d5
000061C6 47F9 0000 0000             		lea	ObjLostRing_Speeds,a3
000061CC 6000                       		bra.s	.MakeRings
000061CE                            
000061CE                            .Loop:
000061CE 4EB8 1A1C                  		jsr	FindFreeObj.w
000061D2 6700                       		beq.s	.ResetCounter
000061D4                            
000061D4                            .MakeRings:
000061D4 22BC 0000 0000             		move.l	#ObjLostRing,_objAddress(a1)
000061DA 3368 0014 0014             		move.w	_objXPos(a0),_objXPos(a1)
000061E0 3368 0018 0018             		move.w	_objYPos(a0),_objYPos(a1)
000061E6 237C 0000 0000 0010        		move.l	#Map_ObjLostRing,_objMapping(a1)	; Mappings
000061EE 337C 26B4 000E             		move.w	#$26B4,_objVRAM(a1)		; Tile properties
000061F4 137C 0004 000D             		move.b	#4,_objRender(a1)			; Render flags
000061FA                            	displaySprite	3,a1,a2,0			; Priority
000061FA 337C C172 0008           M 	move.w	#objdisplay+(3*dsize),_objdrawnext(a1)
00006200 3478 C17C                M 	move.w	objdisplay+dprev+(3*dsize).w,a2
00006204 334A 000A                M 	move.w	a2,_objdrawprev(a1)
00006208 3549 0008                M 	move.w	a1,_objdrawnext(a2)
0000620C 31C9 C17C                M 	move.w	a1,objdisplay+dprev+(3*dsize).w
00006210                          M .no_231
00006210 137C 0008 0017             		move.b	#8,_objDrawW(a1)			; Sprite width
00006216 137C 0008 001B             		move.b	#8,_objDrawH(a1)			; Sprite height
0000621C 137C 0008 002C             		move.b	#8,_objColW(a1)			; Collision width
00006222 137C 0008 002D             		move.b	#8,_objColH(a1)			; Collision height
00006228 335B 001C                  		move.w	(a3)+,_objXVel(a1)
0000622C 335B 001E                  		move.w	(a3)+,_objYVel(a1)
00006230 51CD FF9C                  		dbf	d5,.Loop
00006234 11FC 00FF E864             		move.b	#-1,ringLossAnimT.w
0000623A                            
0000623A                            .ResetCounter:
0000623A 4278 E85E                  		clr.w	ringCount.w
0000623E 11FC 0001 E867             		move.b	#1,hudUpdateRings.w
00006244                            		playSnd	#sRingLoss, 2
00006244 11FC 008D C4BD           M 	move.b	#sringloss,(mqueue+((2)-1)).w
0000624A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000624A                            ObjLostRing:
0000624A 4EB8 1D28                  		jsr	ObjectMove.w
0000624E 0668 0018 001E             		addi.w	#$18,_objYVel(a0)
00006254 6B00                       		bmi.s	.ChkCol
00006256 1038 C75B                  		move.b	(frameCounter+3).w,d0
0000625A D048                       		add.w	a0,d0
0000625C 0200 0006                  		andi.b	#6,d0
00006260 6600                       		bne.s	.ChkCol
00006262 4EB8 33FE                  		jsr	ObjCheckFloorDist
00006266 4A41                       		tst.w	d1
00006268 6A00                       		bpl.s	.ChkCol
0000626A D368 0018                  		add.w	d1,_objYPos(a0)
0000626E 3028 001E                  		move.w	_objYVel(a0),d0
00006272 E440                       		asr.w	#2,d0
00006274 9168 001E                  		sub.w	d0,_objYVel(a0)
00006278 4468 001E                  		neg.w	_objYVel(a0)
0000627C                            
0000627C                            .ChkCol:
0000627C 43FA 0000                  		lea	.RangeData(pc),a1		; Range data
00006280 3478 E876                  		movea.w	playerPtrP1.w,a2		; Player object
00006284 4EB8 1D62                  		jsr	CheckObjInRange.w		; Is the player in range?
00006288 4A40                       		tst.w	d0				; ''
0000628A 6700                       		beq.s	.ChkDel				; If not, branch
0000628C 0C2A 0069 0042             		cmpi.b	#105,_objInvulTime(a2)
00006292 6400                       		bhs.s	.ChkDel
00006294 6000                       		bra.s	ObjLostRing_Collect
00006296                            
00006296                            .ChkDel:
00006296 4A38 E864                  		tst.b	ringLossAnimT.w
0000629A 6700 0000                  		beq.w	ObjLostRing_Delete
0000629E 3038 E8CC                  		move.w	maxCamYPos.w,d0		; Get max camera Y position
000062A2 0640 00E0                  		addi.w	#224,d0				; Get bottom boundary position
000062A6 B068 0018                  		cmp.w	_objYPos(a0),d0			; Have we touched the bottom boundary?
000062AA 6D00                       		blt.s	ObjLostRing_Delete		; If so, branch
000062AC                            	nextObject
000062AC 3068 0004                M 	movea.w	_objnext(a0),a0
000062B0 2250                     M 	move.l	_objaddress(a0),a1
000062B2 4ED1                     M 	jmp	(a1)
000062B4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000062B4                            .RangeData:
000062B4 FFF0 0020                  		dc.w	-$10, $20
000062B8 FFF0 0020                  		dc.w	-$10, $20
000062BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000062BC                            ObjLostRing_Collect:
000062BC                            	removeSprite	a0,a1,0
000062BC 3268 000A                M 	move.w	_objdrawprev(a0),a1
000062C0 3368 0008 0008           M 	move.w	_objdrawnext(a0),_objdrawnext(a1)
000062C6 3268 0008                M 	move.w	_objdrawnext(a0),a1
000062CA 3368 000A 000A           M 	move.w	_objdrawprev(a0),_objdrawprev(a1)
000062D0                          M .no_234
000062D0 42A8 0008                M 	clr.l	_objdrawnext(a0)
000062D4                          M .yes_234
000062D4                            	displaySprite	1,a0,a1,0
000062D4 317C C162 0008           M 	move.w	#objdisplay+(1*dsize),_objdrawnext(a0)
000062DA 3278 C16C                M 	move.w	objdisplay+dprev+(1*dsize).w,a1
000062DE 3149 000A                M 	move.w	a1,_objdrawprev(a0)
000062E2 3348 0008                M 	move.w	a0,_objdrawnext(a1)
000062E6 31C8 C16C                M 	move.w	a0,objdisplay+dprev+(1*dsize).w
000062EA                          M .no_235
000062EA 4EB8 430A                  		jsr	CollectRing
000062EE 20BC 0000 0000             		move.l	#ObjLostRing_Sparkle,(a0)
000062F4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000062F4                            ObjLostRing_Sparkle:
000062F4 43F9 0000 0000             		lea	Ani_ObjRing,a1
000062FA 4EB8 1C42                  		jsr	AnimateObject.w
000062FE 4A28 0025                  		tst.b	_objRoutine(a0)
00006302 6600                       		bne.s	ObjLostRing_Delete
00006304                            	nextObject
00006304 3068 0004                M 	movea.w	_objnext(a0),a0
00006308 2250                     M 	move.l	_objaddress(a0),a1
0000630A 4ED1                     M 	jmp	(a1)
0000630C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000630C                            ObjLostRing_Delete:
0000630C 4EB8 1A4C                  		jsr	DeleteObject.w
00006310                            	nextObject
00006310 3068 0004                M 	movea.w	_objnext(a0),a0
00006314 2250                     M 	move.l	_objaddress(a0),a1
00006316 4ED1                     M 	jmp	(a1)
00006318                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006318                            ; Ring Spawn Array
00006318                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006318                            ObjLostRing_Speeds:
00006318 FF3C FC14 00C4 FC14 FDC8+  		dc.w	$FF3C,$FC14,$00C4,$FC14,$FDC8,$FCB0,$0238,$FCB0
00006328 FCB0 FDC8 0350 FDC8 FC14+  		dc.w	$FCB0,$FDC8,$0350,$FDC8,$FC14,$FF3C,$03EC,$FF3C
00006338 FC14 00C4 03EC 00C4 FCB0+  		dc.w	$FC14,$00C4,$03EC,$00C4,$FCB0,$0238,$0350,$0238
00006348 FDC8 0350 0238 0350 FF3C+  		dc.w	$FDC8,$0350,$0238,$0350,$FF3C,$03EC,$00C4,$03EC
00006358 FF9E FE0A 0062 FE0A FEE4+  		dc.w	$FF9E,$FE0A,$0062,$FE0A,$FEE4,$FE58,$011C,$FE58
00006368 FE58 FEE4 01A8 FEE4 FE0A+  		dc.w	$FE58,$FEE4,$01A8,$FEE4,$FE0A,$FF9E,$01F6,$FF9E
00006378 FE0A 0062 01F6 0062 FE58+  		dc.w	$FE0A,$0062,$01F6,$0062,$FE58,$011C,$01A8,$011C
00006388 FEE4 01A8 011C 01A8 FF9E+  		dc.w	$FEE4,$01A8,$011C,$01A8,$FF9E,$01F6,$0062,$01F6
00006398                            		even
00006398                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006398                            ; Data
00006398                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006398                            Map_ObjLostRing:
00006398                            		include	"Objects/Ring/Mappings.asm"
00006398                            ; --------------------------------------------------------------------------------
00006398                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
00006398                            ; --------------------------------------------------------------------------------
00006398                            
00006398                            SME_k4ulR:	
00006398 0000 0000                  		dc.w SME_k4ulrA-SME_k4ulR, SME_k4ulrC-SME_k4ulR	
0000639C 0000 0000                  		dc.w SME_k4ulr14-SME_k4ulR, SME_k4ulr1C-SME_k4ulR	
000063A0 0000                       		dc.w SME_k4ulr24-SME_k4ulR	
000063A2 0001                       SME_k4ulrA:	dc.b 0, 1	
000063A4 F805 0000 FFF8             		dc.b $F8, 5, 0, 0, $FF, $F8
000063AA 0001                       SME_k4ulrC:	dc.b 0, 1	
000063AC F805 1804 FFF8             		dc.b $F8, 5, $18, 4, $FF, $F8	
000063B2 0001                       SME_k4ulr14:	dc.b 0, 1	
000063B4 F805 1804 FFF8             		dc.b $F8, 5, $18, 4, $FF, $F8	
000063BA 0001                       SME_k4ulr1C:	dc.b 0, 1	
000063BC F805 0804 FFF8             		dc.b $F8, 5, 8, 4, $FF, $F8	
000063C2 0001                       SME_k4ulr24:	dc.b 0, 1	
000063C4 F805 1004 FFF8             		dc.b $F8, 5, $10, 4, $FF, $F8	
000063CA                            		even
000063CA                            		even
000063CA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000063CA                            Ani_ObjRing:
000063CA 0000                       		dc.w	.Ani0-Ani_ObjRing
000063CC 0501 0203 04FC             .Ani0:		dc.b	5, 1, 2, 3, 4, $FC
000063D2                            		even
000063D2                            ; =========================================================================================================================================================
000063D2                            		include	"Objects/Explosion/Code.asm"	; Explosion object
000063D2                            ; =========================================================================================================================================================
000063D2                            ; Explosion object
000063D2                            ; =========================================================================================================================================================
000063D2 =00000003                  EXPLODE_ANI	EQU	3
000063D2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000063D2                            ObjBossExplode:
000063D2                            		playSnd	#sBomb, 2			; Play explosion sound
000063D2 11FC 0099 C4BD           M 	move.b	#sbomb,(mqueue+((2)-1)).w
000063D8 6000                       		bra.s	ObjExplosion_Init		; Continue
000063DA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000063DA                            ObjExplosion:
000063DA                            		playSnd	#sBreakItem, 2			; Play explosion sound
000063DA 11FC 009A C4BD           M 	move.b	#sbreakitem,(mqueue+((2)-1)).w
000063E0                            
000063E0                            ObjExplosion_Init:
000063E0 20BC 0000 0000             		move.l	#ObjExplosion_Main,_objAddress(a0)	; Next routine
000063E6 117C 0004 000D             		move.b	#4,_objRender(a0)			; Render flags
000063EC 317C 86C0 000E             		move.w	#$86C0,_objVRAM(a0)		; Tile properties
000063F2 217C 0000 0000 0010        		move.l	#Map_ObjExplosion,_objMapping(a0)	; Mappings
000063FA                            	displaySprite	1,a0,a1,0			; Priority
000063FA 317C C162 0008           M 	move.w	#objdisplay+(1*dsize),_objdrawnext(a0)
00006400 3278 C16C                M 	move.w	objdisplay+dprev+(1*dsize).w,a1
00006404 3149 000A                M 	move.w	a1,_objdrawprev(a0)
00006408 3348 0008                M 	move.w	a0,_objdrawnext(a1)
0000640C 31C8 C16C                M 	move.w	a0,objdisplay+dprev+(1*dsize).w
00006410                          M .no_240
00006410 117C 000C 0017             		move.b	#$C,_objDrawW(a0)			; Sprite width
00006416 117C 000C 001B             		move.b	#$C,_objDrawH(a0)			; Sprite height
0000641C 117C 0003 0023             		move.b	#EXPLODE_ANI,_objAnimTimer(a0)	; Animation timer
00006422 4228 0010                  		clr.b	_objFrame(a0)			; Mapping frame
00006426                            		
00006426                            ObjExplosion_Main:
00006426 5328 0023                  		subq.b	#1,_objAnimTimer(a0)		; Decrement animation timer
0000642A 6A00                       		bpl.s	.Display			; If it hasn't run out, branch
0000642C 117C 0003 0023             		move.b	#EXPLODE_ANI,_objAnimTimer(a0)	; Reset animation timer
00006432 5228 0010                  		addq.b	#1,_objFrame(a0)			; Next frame
00006436 0C28 0005 0010             		cmpi.b	#5,_objFrame(a0)			; Has it reached the last frame?
0000643C 6600                       		bne.s	.Display			; If not, branch
0000643E 4EB8 1A4C                  		jsr	DeleteObject.w
00006442                            		
00006442                            .Display:
00006442                            	nextObject
00006442 3068 0004                M 	movea.w	_objnext(a0),a0
00006446 2250                     M 	move.l	_objaddress(a0),a1
00006448 4ED1                     M 	jmp	(a1)
0000644A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000644A                            ; Data
0000644A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000644A                            Map_ObjExplosion:
0000644A                            		include	"Objects/Explosion/Mappings.asm"
0000644A                            ; --------------------------------------------------------------------------------
0000644A                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
0000644A                            ; --------------------------------------------------------------------------------
0000644A                            
0000644A                            SME_PS_OI:	
0000644A 0000 0000                  		dc.w SME_PS_OI_A-SME_PS_OI, SME_PS_OI_12-SME_PS_OI	
0000644E 0000 0000                  		dc.w SME_PS_OI_1A-SME_PS_OI, SME_PS_OI_22-SME_PS_OI	
00006452 0000                       		dc.w SME_PS_OI_3C-SME_PS_OI	
00006454 0001                       SME_PS_OI_A:	dc.b 0, 1	
00006456 F809 0000 FFF4             		dc.b $F8, 9, 0, 0, $FF, $F4	
0000645C 0001                       SME_PS_OI_12:	dc.b 0, 1	
0000645E F00F 0020 FFF0             		dc.b $F0, $F, 0, $20, $FF, $F0	
00006464 0001                       SME_PS_OI_1A:	dc.b 0, 1	
00006466 F00F 0030 FFF0             		dc.b $F0, $F, 0, $30, $FF, $F0	
0000646C 0004                       SME_PS_OI_22:	dc.b 0, 4	
0000646E EC0A 0006 FFEC             		dc.b $EC, $A, 0, 6, $FF, $EC	
00006474 EC05 000F 0004             		dc.b $EC, 5, 0, $F, 0, 4	
0000647A 0405 180F FFEC             		dc.b 4, 5, $18, $F, $FF, $EC	
00006480 FC0A 1806 FFFC             		dc.b $FC, $A, $18, 6, $FF, $FC	
00006486 0004                       SME_PS_OI_3C:	dc.b 0, 4	
00006488 EC0A 0013 FFEC             		dc.b $EC, $A, 0, $13, $FF, $EC	
0000648E EC05 001C 0004             		dc.b $EC, 5, 0, $1C, 0, 4	
00006494 0405 181C FFEC             		dc.b 4, 5, $18, $1C, $FF, $EC	
0000649A FC0A 1813 FFFC             		dc.b $FC, $A, $18, $13, $FF, $FC	
000064A0                            		even
000064A0                            		even
000064A0                            ; =========================================================================================================================================================
000064A0                            		include	"Objects/Water Surface/Code.asm"	; Water surface object
000064A0                            ; =========================================================================================================================================================
000064A0                            ; Water surface object
000064A0                            ; =========================================================================================================================================================
000064A0                            		rsset	_objLvlSSTs
000064A0 =00000030                  _objSurfPause	rs.b	1			; Animation stop flag
000064A0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000064A0                            ObjWaterSurface:
000064A0 20BC 0000 0000             		move.l	#ObjWaterSurface_Main,_objAddress(a0)	; Next routine
000064A6 217C 0000 0000 0010        		move.l	#Map_ObjWaterSurface,_objMapping(a0)	; Mappings
000064AE 317C 8690 000E             		move.w	#$8690,_objVRAM(a0)		; Tile properties
000064B4 117C 0004 000D             		move.b	#4,_objRender(a0)			; Render flags
000064BA                            	displaySprite	0,a0,a1,0			; Priority
000064BA 317C C15A 0008           M 	move.w	#objdisplay+(0*dsize),_objdrawnext(a0)
000064C0 3278 C164                M 	move.w	objdisplay+dprev+(0*dsize).w,a1
000064C4 3149 000A                M 	move.w	a1,_objdrawprev(a0)
000064C8 3348 0008                M 	move.w	a0,_objdrawnext(a1)
000064CC 31C8 C164                M 	move.w	a0,objdisplay+dprev+(0*dsize).w
000064D0                          M .no_242
000064D0 117C 0080 0017             		move.b	#$80,_objDrawW(a0)			; Sprite width
000064D6 117C 0020 001B             		move.b	#$20,_objDrawH(a0)			; Sprite height
000064DC                            
000064DC                            ObjWaterSurface_Main:
000064DC 3238 E900                  		move.w	waterYPos.w,d1		; Get water height
000064E0 5D41                       		subq.w	#6,d1				; Shift it
000064E2 3141 0018                  		move.w	d1,_objYPos(a0)			; Set Y position
000064E6                            
000064E6 4A28 0030                  		tst.b	_objSurfPause(a0)			; Is the animation paused?
000064EA 6600                       		bne.s	.ChkUnpause			; If so, branch
000064EC 0838 0007 C743             		btst	#7,ctrlPressP1.w			; Has the start button been pressed?
000064F2 6700                       		beq.s	.Animate			; If not, branch
000064F4 5628 0010                  		addq.b	#3,_objFrame(a0)			; Use different frames
000064F8 50E8 0030                  		st	_objSurfPause(a0)			; Pause the animation
000064FC 6000                       		bra.s	.Animate			; Continue
000064FE                            
000064FE                            .ChkUnpause:
000064FE 4A38 C75E                  		tst.b	pauseFlag.w			; Is the game paused?
00006502 6600                       		bne.s	.Animate			; If so, branch
00006504 4228 0030                  		clr.b	_objSurfPause(a0)			; Resume animation
00006508 5728 0010                  		subq.b	#3,_objFrame(a0)			; Use normal frames
0000650C                            
0000650C                            .Animate:
0000650C 43FA 0000                  		lea	.AniScript(pc),a1		; Get animation script
00006510 7200                       		moveq	#0,d1
00006512 1228 0022                  		move.b	_objAnimFrame(a0),d1		; Get animation script frame
00006516 1171 1000 0010             		move.b	(a1,d1.w),_objFrame(a0)		; Set mapping frame
0000651C 5228 0022                  		addq.b	#1,_objAnimFrame(a0)		; Next frame in animation script
00006520 0228 003F 0022             		andi.b	#$3F,_objAnimFrame(a0)		; Loop in necessary
00006526                            	nextObject
00006526 3068 0004                M 	movea.w	_objnext(a0),a0
0000652A 2250                     M 	move.l	_objaddress(a0),a1
0000652C 4ED1                     M 	jmp	(a1)
0000652E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000652E                            .AniScript:
0000652E 0001 0001 0001 0001 0001+  		dc.b	0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1
0000653E 0102 0102 0102 0102 0102+  		dc.b	1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2
0000654E 0201 0201 0201 0201 0201+  		dc.b	2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1
0000655E 0100 0100 0100 0100 0100+  		dc.b	1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1
0000656E 00                         		even
0000656E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000656E                            ; Data
0000656E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000656E                            Map_ObjWaterSurface:
0000656E                            		include	"Objects/Water Surface/Mappings.asm"
0000656E                            MapConv_obj1B:
0000656E 0000                       	dc.w	byte_11178-MapConv_obj1B
00006570 0000                       	dc.w	byte_11188-MapConv_obj1B
00006572 0000                       	dc.w	byte_11198-MapConv_obj1B
00006574 0000                       	dc.w	byte_111A8-MapConv_obj1B
00006576 0000                       	dc.w	byte_111C7-MapConv_obj1B
00006578 0000                       	dc.w	byte_111E6-MapConv_obj1B
0000657A                            
0000657A 0003                       byte_11178:	dc.w 3
0000657C FD0D 0000 FFA0             	dc.w $FD0D, 0, $FFA0
00006582 FD0D 0000 FFE0             	dc.w $FD0D, 0, $FFE0
00006588 FD0D 0000 0020             	dc.w $FD0D, 0, $20
0000658E                            
0000658E 0003                       byte_11188:	dc.w 3
00006590 FD0D 0008 FFA0             	dc.w $FD0D, 8, $FFA0
00006596 FD0D 0008 FFE0             	dc.w $FD0D, 8, $FFE0
0000659C FD0D 0008 0020             	dc.w $FD0D, 8, $20
000065A2                            
000065A2 0003                       byte_11198:	dc.w 3
000065A4 FD0D 0800 FFA0             	dc.w $FD0D, $800, $FFA0
000065AA FD0D 0800 FFE0             	dc.w $FD0D, $800, $FFE0
000065B0 FD0D 0800 0020             	dc.w $FD0D, $800, $20
000065B6                            
000065B6 0006                       byte_111A8:	dc.w 6
000065B8 FD0D 0000 FFA0             	dc.w $FD0D, 0, $FFA0
000065BE FD0D 0000 FFC0             	dc.w $FD0D, 0, $FFC0
000065C4 FD0D 0000 FFE0             	dc.w $FD0D, 0, $FFE0
000065CA FD0D 0000 0000             	dc.w $FD0D, 0, 0
000065D0 FD0D 0000 0020             	dc.w $FD0D, 0, $20
000065D6 FD0D 0000 0040             	dc.w $FD0D, 0, $40
000065DC                            
000065DC 0006                       byte_111C7:	dc.w 6
000065DE FD0D 0008 FFA0             	dc.w $FD0D, 8, $FFA0
000065E4 FD0D 0008 FFC0             	dc.w $FD0D, 8, $FFC0
000065EA FD0D 0008 FFE0             	dc.w $FD0D, 8, $FFE0
000065F0 FD0D 0008 0000             	dc.w $FD0D, 8, 0
000065F6 FD0D 0008 0020             	dc.w $FD0D, 8, $20
000065FC FD0D 0008 0040             	dc.w $FD0D, 8, $40
00006602                            
00006602 0006                       byte_111E6:	dc.w 6
00006604 FD0D 0800 FFA0             	dc.w $FD0D, $800, $FFA0
0000660A FD0D 0800 FFC0             	dc.w $FD0D, $800, $FFC0
00006610 FD0D 0800 FFE0             	dc.w $FD0D, $800, $FFE0
00006616 FD0D 0800 0000             	dc.w $FD0D, $800, 0
0000661C FD0D 0800 0020             	dc.w $FD0D, $800, $20
00006622 FD0D 0800 0040             	dc.w $FD0D, $800, $40
00006628                            
00006628                            	even
00006628                            		even
00006628                            ; =========================================================================================================================================================
00006628                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006628                            		include	"Objects/Monitor/Code.asm"	; Monitor object
00006628                            ; =========================================================================================================================================================
00006628                            ; Monitor object
00006628                            ; =========================================================================================================================================================
00006628                            		rsset	_objLvlSSTs
00006628 =00000030                  _objMonFall	rs.b	1				; Fall flag
00006628                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006628                            ObjEnemy:
00006628 7000                               moveq   #0, d0
0000662A 1028 0025                          move.b  _objRoutine(a0),d0
0000662E 303B 0000                          move.w  .Index(pc,d0.w),d0
00006632 4EFB 0000                          jmp     .Index(pc,d0.w)
00006636                            
00006636                            .Index:
00006636 0000                               dc.w    ObjEnemy_Init-.Index
00006638 0000                               dc.w    ObjEnemy_Down-.Index
0000663A 0000                               dc.w    ObjEnemy_Up-.Index
0000663C                            
0000663C                            ObjEnemy_Init:
0000663C 5428 0025                          addq.b  #2, _objRoutine(a0)
00006640 217C 0000 0000 0010                move.l  #Map_ObjMonitor,_objMapping(a0)
00006648 317C 0588 000E                     move.w	#$588,_objVRAM(a0)
0000664E 117C 0004 000D             		move.b	#4,_objRender(a0)
00006654                                    displaySprite	3,a0,a1,0			; Priority
00006654 317C C172 0008           M 	move.w	#objdisplay+(3*dsize),_objdrawnext(a0)
0000665A 3278 C17C                M 	move.w	objdisplay+dprev+(3*dsize).w,a1
0000665E 3149 000A                M 	move.w	a1,_objdrawprev(a0)
00006662 3348 0008                M 	move.w	a0,_objdrawnext(a1)
00006666 31C8 C17C                M 	move.w	a0,objdisplay+dprev+(3*dsize).w
0000666A                          M .no_244
0000666A                            
0000666A                            ObjEnemy_Down:
0000666A 0C68 00C8 0018                     cmpi.w  #200,   _objYPos(a0)
00006670 6500                               blo.s   .cont
00006672 5428 0025                          addq.b  #2, _ObjRoutine(a0)
00006676                                .cont:
00006676 5268 0018                          add.w   #1, _objYPos(a0)
0000667A                                    nextObject
0000667A 3068 0004                M 	movea.w	_objnext(a0),a0
0000667E 2250                     M 	move.l	_objaddress(a0),a1
00006680 4ED1                     M 	jmp	(a1)
00006682                            
00006682                            ObjEnemy_Up:
00006682 0C68 0018 0018                     cmpi.w  #24,   _objYPos(a0)
00006688 6200                               bhi.s   .cont
0000668A 5528 0025                          subq.b  #2, _ObjRoutine(a0)
0000668E                                .cont:
0000668E 5368 0018                          sub.w   #1, _objYPos(a0)
00006692                                    nextObject
00006692 3068 0004                M 	movea.w	_objnext(a0),a0
00006696 2250                     M 	move.l	_objaddress(a0),a1
00006698 4ED1                     M 	jmp	(a1)
0000669A                            
0000669A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000669A                            ; Data
0000669A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000669A                            Map_ObjMonitor:
0000669A                            		include	"Objects/Monitor/Mappings.asm"
0000669A                            ; --------------------------------------------------------------------------------
0000669A                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
0000669A                            ; --------------------------------------------------------------------------------
0000669A                            
0000669A                            SME_7TKK1:	
0000669A 0000 0000                  		dc.w SME_7TKK1_10-SME_7TKK1, SME_7TKK1_18-SME_7TKK1	
0000669E 0000 0000                  		dc.w SME_7TKK1_26-SME_7TKK1, SME_7TKK1_34-SME_7TKK1	
000066A2 0000 0000                  		dc.w SME_7TKK1_42-SME_7TKK1, SME_7TKK1_50-SME_7TKK1	
000066A6 0000 0000                  		dc.w SME_7TKK1_5E-SME_7TKK1, SME_7TKK1_6C-SME_7TKK1	
000066AA 0001                       SME_7TKK1_10:	dc.b 0, 1	
000066AC EF0F 0000 FFF0             		dc.b $EF, $F, 0, 0, $FF, $F0	
000066B2 0002                       SME_7TKK1_18:	dc.b 0, 2	
000066B4 F505 0018 FFF8             		dc.b $F5, 5, 0, $18, $FF, $F8	
000066BA EF0F 0000 FFF0             		dc.b $EF, $F, 0, 0, $FF, $F0	
000066C0 0002                       SME_7TKK1_26:	dc.b 0, 2	
000066C2 F505 001C FFF8             		dc.b $F5, 5, 0, $1C, $FF, $F8	
000066C8 EF0F 0000 FFF0             		dc.b $EF, $F, 0, 0, $FF, $F0	
000066CE 0002                       SME_7TKK1_34:	dc.b 0, 2	
000066D0 F505 2020 FFF8             		dc.b $F5, 5, $20, $20, $FF, $F8	
000066D6 EF0F 0000 FFF0             		dc.b $EF, $F, 0, 0, $FF, $F0	
000066DC 0002                       SME_7TKK1_42:	dc.b 0, 2	
000066DE F505 0024 FFF8             		dc.b $F5, 5, 0, $24, $FF, $F8	
000066E4 EF0F 0000 FFF0             		dc.b $EF, $F, 0, 0, $FF, $F0	
000066EA 0002                       SME_7TKK1_50:	dc.b 0, 2	
000066EC F505 0028 FFF8             		dc.b $F5, 5, 0, $28, $FF, $F8	
000066F2 EF0F 0000 FFF0             		dc.b $EF, $F, 0, 0, $FF, $F0	
000066F8 0002                       SME_7TKK1_5E:	dc.b 0, 2	
000066FA F505 002C FFF8             		dc.b $F5, 5, 0, $2C, $FF, $F8	
00006700 EF0F 0000 FFF0             		dc.b $EF, $F, 0, 0, $FF, $F0	
00006706 0001                       SME_7TKK1_6C:	dc.b 0, 1	
00006708 FF0D 0010 FFF0             		dc.b $FF, $D, 0, $10, $FF, $F0	
0000670E                            		even
0000670E                            Ani_ObjMonitor:
0000670E                            		include	"Objects/Monitor/Animations.asm"
0000670E                            ; ---------------------------------------------------------------------------
0000670E                            ; Animation script - monitors
0000670E                            ; ---------------------------------------------------------------------------
0000670E 0000                       		dc.w .Static-Ani_ObjMonitor
00006710 0000                       		dc.w .Eggman-Ani_ObjMonitor
00006712 0000                       		dc.w .Rings-Ani_ObjMonitor
00006714 0000                       		dc.w .Shoes-Ani_ObjMonitor
00006716 0000                       		dc.w .Shield-Ani_ObjMonitor
00006718 0000                       		dc.w .Stars-Ani_ObjMonitor
0000671A 0000                       		dc.w .Destroyed-Ani_ObjMonitor
0000671C 0100 01FF 00               .Static:	dc.b 1, 0, 1, $FF, 0
00006721 0100 0202 0102 02FF 00     .Eggman:	dc.b 1, 0, 2, 2, 1, 2, 2, $FF, 0
0000672A 0100 0303 0103 03FF 00     .Rings:		dc.b 1, 0, 3, 3, 1, 3, 3, $FF, 0
00006733 0100 0404 0104 04FF 00     .Shoes:		dc.b 1, 0, 4, 4, 1, 4, 4, $FF, 0
0000673C 0100 0505 0105 05FF 00     .Shield:	dc.b 1, 0, 5, 5, 1, 5, 5, $FF, 0
00006745 0100 0606 0106 06FF 00     .Stars:		dc.b 1, 0, 6, 6, 1, 6, 6, $FF, 0
0000674E 0100 0107 FE01 00          .Destroyed:	dc.b 1, 0, 1, 7, $FE, 1, 0
00006756 00                         		even
00006756                            ; =========================================================================================================================================================
00006756                            		include	"Objects/Spikes/Code.asm"		; Spike object
00006756                            ; ===========================================================================
00006756                            ; Spike object
00006756                            ; ===========================================================================
00006756                            		rsset	_objLvlSSTs
00006756 =00000030                  _objSpikeX	rs.w	1
00006756 =00000032                  _objSpikeY	rs.w	1
00006756 =00000034                  _objSpkMvOff	rs.w	1
00006756 =00000036                  _objSpkMvState	rs.w	1
00006756 =00000038                  _objSpkMvTime	rs.w	1
00006756                            ; ===========================================================================
00006756                            ObjSpike:
00006756 7000                       		moveq	#0,d0
00006758 1028 0025                  		move.b	_objRoutine(a0),d0
0000675C 4EBB 0000                  		jsr	ObjSpike_Index(pc,d0.w)
00006760                            	nextObject
00006760 3068 0004                M 	movea.w	_objnext(a0),a0
00006764 2250                     M 	move.l	_objaddress(a0),a1
00006766 4ED1                     M 	jmp	(a1)
00006768                            ; ===========================================================================
00006768                            ObjSpike_Index:
00006768 6000 0000                  		bra.w ObjSpike_Init
0000676C 6000 0000                  		bra.w ObjSpike_Upright
00006770 6000 0000                  		bra.w ObjSpike_Sideways
00006774 6000 0000                  		bra.w ObjSpike_UpsideDown
00006778                            ; ===========================================================================
00006778                            ;ObjSpike_InitData:
00006778                            ;		dc.b $10,$10	; 0	- Upright or ceiling spikes
00006778                            ;		dc.b $10,$10	; 2	- Sideways spikes
00006778                            ; ===========================================================================
00006778                            ObjSpike_Init:
00006778 5828 0025                  		addq.b	#4,_objRoutine(a0)
0000677C 217C 0000 0000 0010        		move.l	#Map_ObjSpike,_objMapping(a0)
00006784 317C 06A8 000E             		move.w	#$6A8,_objVRAM(a0)
0000678A 0028 0004 000D             		ori.b	#4,_objRender(a0)
00006790                            	displaySprite	4,a0,a1,0			; Priority
00006790 317C C17A 0008           M 	move.w	#objdisplay+(4*dsize),_objdrawnext(a0)
00006796 3278 C184                M 	move.w	objdisplay+dprev+(4*dsize).w,a1
0000679A 3149 000A                M 	move.w	a1,_objdrawprev(a0)
0000679E 3348 0008                M 	move.w	a0,_objdrawnext(a1)
000067A2 31C8 C184                M 	move.w	a0,objdisplay+dprev+(4*dsize).w
000067A6                          M .no_248
000067A6 1028 0024                  		move.b	_objSubtype(a0),d0
000067AA 0228 000F 0024             		andi.b	#$F,_objSubtype(a0)
000067B0 0240 00F0                  		andi.w	#$F0,d0
000067B4 7210                       		moveq	#$10,d1
000067B6 1141 0017                  		move.b	d1,_objDrawW(a0)
000067BA 1141 002C                  		move.b	d1,_objColW(a0)
000067BE 1141 001B                  		move.b	d1,_objDrawH(a0)
000067C2 1141 002D                  		move.b	d1,_objColH(a0)
000067C6 E848                       		lsr.w	#4,d0
000067C8 1140 0010                  		move.b	d0,_objFrame(a0)
000067CC 0C00 0001                  		cmpi.b	#1,d0
000067D0 6600                       		bne.s	.ChkUpsideDown
000067D2 5828 0025                  		addq.b	#4,_objRoutine(a0)
000067D6 317C 06AC 000E             		move.w	#$6AC,_objVRAM(a0)
000067DC                            
000067DC                            .ChkUpsideDown:
000067DC 0828 0001 0028             		btst	#1,_objStatus(a0)
000067E2 6700                       		beq.s	.SavePos
000067E4 117C 000C 0025             		move.b	#$C,_objRoutine(a0)
000067EA                            
000067EA                            .SavePos:
000067EA 3168 0014 0030             		move.w	_objXPos(a0),_objSpikeX(a0)
000067F0 3168 0018 0032             		move.w	_objYPos(a0),_objSpikeY(a0)
000067F6                            
000067F6 6100 0000                  		bsr.w	MoveSpikes		; make the object move
000067FA 0C28 0001 0010             		cmpi.b	#1,_objFrame(a0)		; is object type $1x ?
00006800 6700                       		beq.s	ObjSpike_SideWays	; if yes, branch
00006802                            ; ===========================================================================
00006802                            ; Upright spikes
00006802                            ; ===========================================================================
00006802                            ObjSpike_Upright:
00006802 6100 0000                  		bsr.w	MoveSpikes
00006806 7200                       		moveq	#0,d1
00006808 1228 0017                  		move.b	_objDrawW(a0),d1
0000680C 0641 000B                  		addi.w	#$B,d1
00006810 7400                       		moveq	#0,d2
00006812 1428 001B                  		move.b	_objDrawH(a0),d2
00006816 3602                       		move.w	d2,d3
00006818 5243                       		addq.w	#1,d3
0000681A 3828 0014                  		move.w	_objXPos(a0),d4
0000681E 4EB8 453E                  		jsr	SolidObject
00006822 0828 0003 0028             		btst	#cStandBit,_objStatus(a0)
00006828 6700                       		beq.s	ObjSpike_UprightEnd
0000682A 3278 E876                  		movea.w	playerPtrP1.w,a1
0000682E 6100 0000                  		bsr.w	Touch_ChkHurt2
00006832                            
00006832                            ObjSpike_UprightEnd:
00006832 3028 0030                  		move.w	_objSpikeX(a0),d0
00006836 4EF8 2000                  		jmp	CheckObjActive.w
0000683A                            ; ===========================================================================
0000683A                            ; Sideways spikes
0000683A                            ; ===========================================================================
0000683A                            ObjSpike_Sideways:
0000683A 3F28 0014                  		move.w	_objXPos(a0),-(sp)	
0000683E 6100 0000                  		bsr.w	MoveSpikes
00006842 7200                       		moveq	#0,d1
00006844 1228 0017                  		move.b	_objDrawW(a0),d1
00006848 0641 000B                  		addi.w	#$B,d1
0000684C 7400                       		moveq	#0,d2
0000684E 1428 001B                  		move.b	_objDrawH(a0),d2
00006852 3602                       		move.w	d2,d3
00006854 5243                       		addq.w	#1,d3
00006856 381F                       		move.w	(sp)+,d4
00006858 4EB8 453E                  		jsr	SolidObject
0000685C 0806 0000                  		btst	#cTouchSideBit,d6
00006860 6700                       		beq.s	ObjSpike_SidewaysEnd
00006862 3278 E876                  		movea.w	playerPtrP1.w,a1
00006866 6100 0000                  		bsr.w	Touch_ChkHurt2
0000686A                            
0000686A                            ObjSpike_SidewaysEnd:
0000686A 3028 0030                  		move.w	_objSpikeX(a0),d0
0000686E 4EF8 2000                  		jmp	CheckObjActive.w
00006872                            ; ===========================================================================
00006872                            ; Upside down spikes
00006872                            ; ===========================================================================
00006872                            ObjSpike_UpsideDown:
00006872 6100 0000                  		bsr.w	MoveSpikes
00006876 7200                       		moveq	#0,d1
00006878 1228 0017                  		move.b	_objDrawW(a0),d1
0000687C 0641 000B                  		addi.w	#$B,d1
00006880 7400                       		moveq	#0,d2
00006882 1428 001B                  		move.b	_objDrawH(a0),d2
00006886 3602                       		move.w	d2,d3
00006888 5243                       		addq.w	#1,d3
0000688A 3828 0014                  		move.w	_objXPos(a0),d4
0000688E 4EB8 453E                  		jsr	SolidObject
00006892 0806 0002                  		btst	#cTouchBtmBit,d6
00006896 6700                       		beq.s	ObjSpike_UpsideDownEnd
00006898 3278 E876                  		movea.w	playerPtrP1.w,a1
0000689C 6100 0000                  		bsr.w	Touch_ChkHurt2
000068A0                            
000068A0                            ObjSpike_UpsideDownEnd:
000068A0 3028 0030                  		move.w	_objSpikeX(a0),d0
000068A4 4EF8 2000                  		jmp	CheckObjActive.w
000068A8                            ; ===========================================================================
000068A8                            Touch_ChkHurt2:
000068A8 4A29 0042                  		tst.b	_objInvulTime(a1)			; is Sonic invincible?
000068AC 6600                       		bne.s	.End				; if yes, branch
000068AE 0C29 0008 0025             		cmpi.b	#8,_objRoutine(a1)
000068B4 6700                       		beq.s	.End
000068B6 2629 0018                  		move.l	_objYPos(a1),d3
000068BA 3029 001E                  		move.w	_objYVel(a1),d0
000068BE 48C0                       		ext.l	d0
000068C0 E180                       		asl.l	#8,d0
000068C2 9680                       		sub.l	d0,d3
000068C4 2343 0018                  		move.l	d3,_objYPos(a1)
000068C8 2448                       		movea.l	a0,a2
000068CA 2049                       		movea.l	a1,a0
000068CC 4EB8 5BC0                  		jsr	ObjPlayer_GetHurt
000068D0 204A                       		movea.l	a2,a0
000068D2                            
000068D2                            .End:
000068D2 4E75                       		rts
000068D4                            ; ===========================================================================
000068D4                            MoveSpikes:	
000068D4 7000                       		moveq	#0,d0
000068D6 1028 0024                  		move.b	_objSubtype(a0),d0
000068DA D040                       		add.w	d0,d0
000068DC 4EFB 0000                  		jmp	MoveSpikes_Behaviors(pc,d0.w)
000068E0                            ; ===========================================================================
000068E0                            MoveSpikes_Behaviors:
000068E0 6000                       		bra.s MoveSpikes_Still
000068E2 6000                       		bra.s MoveSpikes_Vertical
000068E4 6000                       		bra.s MoveSpikes_Horizontal
000068E6                            ; ===========================================================================
000068E6                            MoveSpikes_Still:
000068E6 4E75                       		rts			; don't move the object
000068E8                            ; ===========================================================================
000068E8                            MoveSpikes_Vertical:
000068E8 6100 0000                  		bsr.w	MoveSpikes_Delay
000068EC 7000                       		moveq	#0,d0
000068EE 1028 0034                  		move.b	_objSpkMvOff(a0),d0
000068F2 D068 0032                  		add.w	_objSpikeY(a0),d0
000068F6 3140 0018                  		move.w	d0,_objYPos(a0)	; move the object vertically
000068FA 4E75                       		rts
000068FC                            ; ===========================================================================
000068FC                            MoveSpikes_Horizontal:
000068FC 6100 0000                  		bsr.w	MoveSpikes_Delay
00006900 7000                       		moveq	#0,d0
00006902 1028 0034                  		move.b	_objSpkMvOff(a0),d0
00006906 D068 0030                  		add.w	_objSpikeX(a0),d0
0000690A 3140 0014                  		move.w	d0,_objXPos(a0)	; move the object horizontally
0000690E 4E75                       		rts
00006910                            ; ===========================================================================
00006910                            MoveSpikes_Delay:
00006910 4A68 0038                  		tst.w	_objSpkMvTime(a0)		; is time delay	= zero?
00006914 6700                       		beq.s	MoveSpikes_ChkDir		; if yes, branch
00006916 5368 0038                  		subq.w	#1,_objSpkMvTime(a0)	; subtract 1 from time delay
0000691A 6600                       		bne.s	locret_CFE6
0000691C 4A28 000D                  		tst.b	_objRender(a0)
00006920 6A00                       		bpl.s	locret_CFE6
00006922                            		playSnd	#sSpikeMove, 2		; Play spike move sound
00006922 11FC 008B C4BD           M 	move.b	#sspikemove,(mqueue+((2)-1)).w
00006928 6000                       		bra.s	locret_CFE6
0000692A                            ; ===========================================================================
0000692A                            MoveSpikes_ChkDir:
0000692A 4A68 0036                  		tst.w	_objSpkMvState(a0)
0000692E 6700                       		beq.s	MoveSpikes_Retract
00006930 0468 0800 0034             		subi.w	#$800,_objSpkMvOff(a0)
00006936 6400                       		bcc.s	locret_CFE6
00006938 317C 0000 0034             		move.w	#0,_objSpkMvOff(a0)
0000693E 317C 0000 0036             		move.w	#0,_objSpkMvState(a0)
00006944 317C 003C 0038             		move.w	#60,_objSpkMvTime(a0)	; set time delay to 1 second
0000694A 6000                       		bra.s	locret_CFE6
0000694C                            ; ===========================================================================
0000694C                            MoveSpikes_Retract:
0000694C 0668 0800 0034             		addi.w	#$800,_objSpkMvOff(a0)
00006952 0C68 2000 0034             		cmpi.w	#$2000,_objSpkMvOff(a0)
00006958 6500                       		bcs.s	locret_CFE6
0000695A 317C 2000 0034             		move.w	#$2000,_objSpkMvOff(a0)
00006960 317C 0001 0036             		move.w	#1,_objSpkMvState(a0)
00006966 317C 003C 0038             		move.w	#60,_objSpkMvTime(a0)	; set time delay to 1 second
0000696C                            
0000696C                            locret_CFE6:
0000696C 4E75                       		rts
0000696E                            ; ===========================================================================
0000696E                            ; Spike object mappings
0000696E                            ; ===========================================================================
0000696E                            Map_ObjSpike:
0000696E                            	include "Objects/Spikes/Mappings.asm"
0000696E                            ; --------------------------------------------------------------------------------
0000696E                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
0000696E                            ; --------------------------------------------------------------------------------
0000696E                            
0000696E                            SME_5AG23:	
0000696E 0000 0000                  		dc.w SME_5AG23_4-SME_5AG23, SME_5AG23_1E-SME_5AG23	
00006972 0004                       SME_5AG23_4:	dc.b 0, 4	
00006974 F003 0000 FFF0             		dc.b $F0, 3, 0, 0, $FF, $F0	
0000697A F003 0000 FFF8             		dc.b $F0, 3, 0, 0, $FF, $F8	
00006980 F003 0000 0000             		dc.b $F0, 3, 0, 0, 0, 0	
00006986 F003 0000 0008             		dc.b $F0, 3, 0, 0, 0, 8	
0000698C 0004                       SME_5AG23_1E:	dc.b 0, 4	
0000698E F00C 0000 FFF0             		dc.b $F0, $C, 0, 0, $FF, $F0	
00006994 F80C 0000 FFF0             		dc.b $F8, $C, 0, 0, $FF, $F0	
0000699A 000C 0000 FFF0             		dc.b 0, $C, 0, 0, $FF, $F0	
000069A0 080C 0000 FFF0             		dc.b 8, $C, 0, 0, $FF, $F0	
000069A6                            		even
000069A6                            ; ===========================================================================
000069A6                            		include	"Objects/Spring/Code.asm"		; Spring object
000069A6                            ; =========================================================================================================================================================
000069A6                            ; Spring object
000069A6                            ; =========================================================================================================================================================
000069A6                            		rsset	_objLvlSSTs
000069A6 =00000030                  _objSprSpd		rs.w	1				; Spring strength
000069A6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000069A6                            ObjSpring:
000069A6 217C 0000 0000 0010        		move.l	#Map_ObjSpring,_objMapping(a0)		; Mappings
000069AE 317C 05BA 000E             		move.w	#$5BA,_objVRAM(a0)			; Tile properties
000069B4 0028 0004 000D             		ori.b	#4,_objRender(a0)			; Render flags
000069BA 117C 0010 0017             		move.b	#$10,_objDrawW(a0)			; Sprite width
000069C0 117C 0008 001B             		move.b	#8,_objDrawH(a0)			; Sprite height
000069C6 117C 000E 002C             		move.b	#$1C/2,_objColW(a0)		; Collision width
000069CC                            	displaySprite	4,a0,a1,0			; Priority
000069CC 317C C17A 0008           M 	move.w	#objdisplay+(4*dsize),_objdrawnext(a0)
000069D2 3278 C184                M 	move.w	objdisplay+dprev+(4*dsize).w,a1
000069D6 3149 000A                M 	move.w	a1,_objdrawprev(a0)
000069DA 3348 0008                M 	move.w	a0,_objdrawnext(a1)
000069DE 31C8 C184                M 	move.w	a0,objdisplay+dprev+(4*dsize).w
000069E2                          M .no_250
000069E2                            		
000069E2 1028 0024                  		move.b	_objSubtype(a0),d0			; Get subtype
000069E6 E648                       		lsr.w	#3,d0				; Turn into offset
000069E8 0240 000E                  		andi.w	#$E,d0				; ''
000069EC 4EFB 0000                  		jmp	.Subtypes(pc,d0.w)		; Jump to it
000069F0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000069F0                            .Subtypes:
000069F0 6000                       		bra.s .Init_Up				; Up
000069F2 6000                       		bra.s .Init_Horizontal			; Horizontal
000069F4 6000                       		bra.s .Init_Down			; Down
000069F6 6000                       		bra.s .Init_DiagonallyUp		; Diagonally up
000069F8 6000                       		bra.s .Init_DiagonallyDown		; Diagonally down
000069FA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000069FA                            .Init_Horizontal:
000069FA 117C 0002 0020             		move.b	#2,_objAnim(a0)			; Animation
00006A00 117C 0002 0010             		move.b	#2,_objFrame(a0)			; Mapping frame
00006A06 317C 05CA 000E             		move.w	#$5CA,_objVRAM(a0)			; Tile properties
00006A0C 117C 0008 0017             		move.b	#8,_objDrawW(a0)			; Sprite width
00006A12 117C 0010 001B             		move.b	#$10,_objDrawH(a0)			; Sprite height
00006A18 117C 000E 002C             		move.b	#$1C/2,_objColW(a0)		; Collision width
00006A1E 20BC 0000 0000             		move.l	#ObjSpring_Horizontal,_objAddress(a0)	; Next routine
00006A24 6000                       		bra.s	.Init_Common			; Continue
00006A26                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006A26                            .Init_Down:
00006A26 08E8 0001 0028             		bset	#1,_objStatus(a0)			; Flip vertically
00006A2C 20BC 0000 0000             		move.l	#ObjSpring_Down,_objAddress(a0)	; Next routine
00006A32 6000                       		bra.s	.Init_Common			; Continue
00006A34                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006A34                            .Init_DiagonallyUp:
00006A34 117C 0004 0020             		move.b	#4,_objAnim(a0)			; Animation
00006A3A 117C 0004 0010             		move.b	#4,_objFrame(a0)			; Map frame
00006A40 317C 05D9 000E             		move.w	#$5D9,_objVRAM(a0)			; Tile properties
00006A46 20BC 0000 0000             		move.l	#ObjSpring_DiagonallyUp,_objAddress(a0); Next routine
00006A4C 6000                       		bra.s	.Init_Common			; Continue
00006A4E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006A4E                            .Init_DiagonallyDown:
00006A4E 117C 0004 0020             		move.b	#4,_objAnim(a0)			; Animation
00006A54 117C 0006 0010             		move.b	#6,_objFrame(a0)			; Map frame
00006A5A 317C 05D9 000E             		move.w	#$5D9,_objVRAM(a0)			; Tile properties
00006A60 08E8 0001 0028             		bset	#1,_objStatus(a0)			; Flip vertically
00006A66 20BC 0000 0000             		move.l	#ObjSpring_DiagonallyDown,_objAddress(a0); Next routine
00006A6C 6000                       		bra.s	.Init_Common			; Continue
00006A6E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006A6E                            .Init_Up:
00006A6E 20BC 0000 0000             		move.l	#ObjSpring_Up,_objAddress(a0)		; Next routine
00006A74                            
00006A74                            .Init_Common:
00006A74 1028 0024                  		move.b	_objSubtype(a0),d0			; Get subtype
00006A78 0240 0002                  		andi.w	#2,d0				; Turn into offset
00006A7C 317B 0000 0030             		move.w	.Strengths(pc,d0.w),_objSprSpd(a0)	; Get spring strength
00006A82 0800 0001                  		btst	#1,d0				; Is the spring supposed to be yellow?
00006A86 6700                       		beq.s	.NotYellow			; If not, branch
00006A88 08E8 0005 000E             		bset	#5,_objVRAM(a0)			; Make the spring yellow
00006A8E                            
00006A8E                            .NotYellow:
00006A8E                            	nextObject
00006A8E 3068 0004                M 	movea.w	_objnext(a0),a0
00006A92 2250                     M 	move.l	_objaddress(a0),a1
00006A94 4ED1                     M 	jmp	(a1)
00006A96                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006A96                            .Strengths:
00006A96 F000                       		dc.w	-$1000				; Strength of red spring
00006A98 F600                       		dc.w	-$A00				; Strength of yellow spring
00006A9A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006A9A                            ObjSpring_Up:
00006A9A 323C 001A                  		move.w	#27-1,d1			; Width
00006A9E 343C 0008                  		move.w	#16/2,d2			; Height
00006AA2 3602                       		move.w	d2,d3				; ''
00006AA4 3828 0014                  		move.w	_objXPos(a0),d4			; X position
00006AA8 4EB8 458E                  		jsr	SolidObject_Always		; Set object as solid
00006AAC 0828 0003 0028             		btst	#cStandBit,_objStatus(a0)		; Has the player touched the top of the of spring?
00006AB2 6700                       		beq.s	.Display			; If not, branch
00006AB4 6100                       		bsr.s	.Bounce				; Bounce the player up
00006AB6                            
00006AB6                            .Display:
00006AB6 43FA 0000                  		lea	Ani_ObjSpring(pc),a1		; Animate sprite
00006ABA 4EB8 1C42                  		jsr	AnimateObject.w			; ''
00006ABE 4EB8 2000                  		jsr	CheckObjActive.w		; Display sprite
00006AC2                            	nextObject
00006AC2 3068 0004                M 	movea.w	_objnext(a0),a0
00006AC6 2250                     M 	move.l	_objaddress(a0),a1
00006AC8 4ED1                     M 	jmp	(a1)
00006ACA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006ACA                            .Bounce:
00006ACA 317C 0100 0020             		move.w	#$100,_objAnim(a0)			; Reset animation
00006AD0 5069 0018                  		addq.w	#8,_objYPos(a1)			; Align player to spring
00006AD4 3368 0030 001E             		move.w	_objSprSpd(a0),_objYVel(a1)		; Set the player's Y velocity
00006ADA 08E9 0001 0028             		bset	#1,_objStatus(a1)			; Set the player's "in air" flag
00006AE0 08A9 0003 0028             		bclr	#cStandBit,_objStatus(a1)		; Make the player no longer be on the spring
00006AE6 4229 0040                  		clr.b	_objJumping(a1)			; Clear the player's jump flag
00006AEA 137C 0010 0020             		move.b	#$10,_objAnim(a1)			; Set the player's animation to the spring animation
00006AF0 137C 0004 0025             		move.b	#4,_objRoutine(a1)			; Reset the player's routine
00006AF6                            		
00006AF6 1028 0024                  		move.b	_objSubtype(a0),d0			; Get subtype
00006AFA 6A00                       		bpl.s	.ChkPath1			; Branch if the player can still move horizontally
00006AFC 4269 001C                  		clr.w	_objXVel(a1)			; Stop the player's X movement
00006B00                            
00006B00                            .ChkPath1:
00006B00 0200 000C                  		andi.b	#$C,d0				; Only get path swap bits
00006B04 0C00 0004                  		cmpi.b	#4,d0				; Does the player need to switch to path 1?
00006B08 6600                       		bne.s	.ChkPath2			; If not, branch
00006B0A 137C 000C 0032             		move.b	#$C,_objTopSolid(a1)		; Switch to path 1
00006B10 137C 000D 0033             		move.b	#$D,_objLRBSolid(a1)		; ''
00006B16                            
00006B16                            .ChkPath2:
00006B16 0C00 0008                  		cmpi.b	#8,d0				; Does the player need to switch to path 2?
00006B1A 6600                       		bne.s	.PlaySound			; If not, branch
00006B1C 137C 000E 0032             		move.b	#$E,_objTopSolid(a1)		; Switch to path 2
00006B22 137C 000F 0033             		move.b	#$F,_objLRBSolid(a1)		; ''
00006B28                            
00006B28                            .PlaySound:
00006B28                            		playSnd	#sSpring, 2			; Play spring sound
00006B28 11FC 008E C4BD           M 	move.b	#sspring,(mqueue+((2)-1)).w
00006B2E 4E75                       		rts
00006B30                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006B30                            ObjSpring_Horizontal:
00006B30 323C 0013                  		move.w	#20-1,d1			; Width
00006B34 343C 000E                  		move.w	#28/2,d2			; Height
00006B38 3602                       		move.w	d2,d3				; ''
00006B3A 3828 0014                  		move.w	_objXPos(a0),d4			; X position
00006B3E 4EB8 458E                  		jsr	SolidObject_Always		; Set object as solid
00006B42 0806 0000                  		btst	#cTouchSideBit,d6		; Has the player touched the side of the spring?
00006B46 6700                       		beq.s	.Display			; If not, branch
00006B48 1228 0028                  		move.b	_objStatus(a0),d1			; Get status
00006B4C 3028 0014                  		move.w	_objXPos(a0),d0			; Get which side of the spring the player is facing
00006B50 9069 0014                  		sub.w	_objXPos(a1),d0			; ''
00006B54 6500                       		bcs.s	.NoFlip				; If the player is on the left side of the spring, branch
00006B56 0A01 0001                  		eori.b	#1,d1				; Flip so that we check for the other side of the spring
00006B5A                            
00006B5A                            .NoFlip:
00006B5A 0201 0001                  		andi.b	#1,d1				; Is the player touching the bouncy side of the spring?
00006B5E 6600                       		bne.s	.Display			; If not, branch
00006B60 6100                       		bsr.s	.Bounce				; Bounce the player
00006B62                            
00006B62                            .Display:
00006B62 43FA 0000                  		lea	Ani_ObjSpring(pc),a1		; Animate sprite
00006B66 4EB8 1C42                  		jsr	AnimateObject.w			; ''
00006B6A 4EB8 2000                  		jsr	CheckObjActive.w		; Display sprite
00006B6E                            	nextObject
00006B6E 3068 0004                M 	movea.w	_objnext(a0),a0
00006B72 2250                     M 	move.l	_objaddress(a0),a1
00006B74 4ED1                     M 	jmp	(a1)
00006B76                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006B76                            .Bounce:	
00006B76 317C 0300 0020             		move.w	#$300,_objAnim(a0)			; Reset animation
00006B7C 5069 0014                  		addq.w	#8,_objXPos(a1)			; Align player to spring
00006B80 3368 0030 001C             		move.w	_objSprSpd(a0),_objXVel(a1)		; Set the player's X velocity
00006B86 08E9 0000 0028             		bset	#0,_objStatus(a1)			; Make the player face the left
00006B8C 0828 0000 0028             		btst	#0,_objStatus(a0)			; Is this spring facing the left?
00006B92 6600                       		bne.s	.SetMoveLock			; If so, branch
00006B94 08A9 0000 0028             		bclr	#0,_objStatus(a1)			; Make the player face the right
00006B9A 0469 0010 0014             		subi.w	#$10,_objXPos(a1)			; Align player to spring
00006BA0 4469 001C                  		neg.w	_objXVel(a1)			; Move the player to the right
00006BA4                            
00006BA4                            .SetMoveLock:
00006BA4 137C 000F 003F             		move.b	#$F,_objMoveLock(a1)		; Lock the player's movement for a bit
00006BAA 3369 001C 003A             		move.w	_objXVel(a1),_objGVel(a1)		; Set the player's ground velocity
00006BB0                            		
00006BB0 0829 0002 0028             		btst	#2,_objStatus(a1)			; Is the player jumping?
00006BB6 6600                       		bne.s	.ChkYStop			; If so, branch
00006BB8 4229 0020                  		clr.b	_objAnim(a1)			; Set the animation to the walking animation
00006BBC                            		
00006BBC                            .ChkYStop:
00006BBC 1028 0024                  		move.b	_objSubtype(a0),d0			; Get subtype
00006BC0 6A00                       		bpl.s	.ChkPath1			; Branch if the player can still move vertically
00006BC2 4269 001C                  		clr.w	_objXVel(a1)			; Stop the player's Y movement
00006BC6                            
00006BC6                            .ChkPath1:
00006BC6 0200 000C                  		andi.b	#$C,d0				; Only get path swap bits
00006BCA 0C00 0004                  		cmpi.b	#4,d0				; Does the player need to switch to path 1?
00006BCE 6600                       		bne.s	.ChkPath2			; If not, branch
00006BD0 137C 000C 0032             		move.b	#$C,_objTopSolid(a1)		; Switch to path 1
00006BD6 137C 000D 0033             		move.b	#$D,_objLRBSolid(a1)		; ''
00006BDC                            
00006BDC                            .ChkPath2:
00006BDC 0C00 0008                  		cmpi.b	#8,d0				; Does the player need to switch to path 2?
00006BE0 6600                       		bne.s	.PlaySound			; If not, branch
00006BE2 137C 000E 0032             		move.b	#$E,_objTopSolid(a1)		; Switch to path 2
00006BE8 137C 000F 0033             		move.b	#$F,_objLRBSolid(a1)		; ''
00006BEE                            
00006BEE                            .PlaySound:
00006BEE 08A8 0005 0028             		bclr	#cPushBit,_objStatus(a0)		; Clear "push" flags
00006BF4 08A9 0005 0028             		bclr	#cPushBit,_objStatus(a1)		; ''
00006BFA                            		playSnd	#sSpring, 2			; Play spring sound
00006BFA 11FC 008E C4BD           M 	move.b	#sspring,(mqueue+((2)-1)).w
00006C00 4E75                       		rts
00006C02                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006C02                            ObjSpring_Down:
00006C02 323C 0012                  		move.w	#19-1,d1			; Width
00006C06 343C 0008                  		move.w	#16/2,d2			; Height
00006C0A 3602                       		move.w	d2,d3				; ''
00006C0C 3828 0014                  		move.w	_objXPos(a0),d4			; X position
00006C10 4EB8 458E                  		jsr	SolidObject_Always		; Set object as solid
00006C14 0C44 FFFE                  		cmpi.w	#-2,d4				; Has the player touched the bottom of the spring?
00006C18 6600                       		bne.s	.Display			; If not, branch
00006C1A 6100                       		bsr.s	.Bounce				; Bounce the player
00006C1C                            
00006C1C                            .Display:
00006C1C 43FA 0000                  		lea	Ani_ObjSpring(pc),a1		; Animate sprite
00006C20 4EB8 1C42                  		jsr	AnimateObject.w			; ''
00006C24 4EB8 2000                  		jsr	CheckObjActive.w		; Display sprite
00006C28                            	nextObject
00006C28 3068 0004                M 	movea.w	_objnext(a0),a0
00006C2C 2250                     M 	move.l	_objaddress(a0),a1
00006C2E 4ED1                     M 	jmp	(a1)
00006C30                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006C30                            .Bounce:
00006C30 317C 0100 0020             		move.w	#$100,_objAnim(a0)			; Reset animation
00006C36 5169 0018                  		subq.w	#8,_objYPos(a1)			; Align player with the spring
00006C3A 3368 0030 001E             		move.w	_objSprSpd(a0),_objYVel(a1)		; Set the player's Y velocity
00006C40 4469 001E                  		neg.w	_objYVel(a1)			; Move the player down
00006C44                            		
00006C44 1028 0024                  		move.b	_objSubtype(a0),d0			; Get subtype
00006C48 6A00                       		bpl.s	.ChkPath1			; Branch if the player can still move horizontally
00006C4A 4269 001C                  		clr.w	_objXVel(a1)			; Stop the player's X movement
00006C4E                            
00006C4E                            .ChkPath1:
00006C4E 0200 000C                  		andi.b	#$C,d0				; Only get path swap bits
00006C52 0C00 0004                  		cmpi.b	#4,d0				; Does the player need to switch to path 1?
00006C56 6600                       		bne.s	.ChkPath2			; If not, branch
00006C58 137C 000C 0032             		move.b	#$C,_objTopSolid(a1)		; Switch to path 1
00006C5E 137C 000D 0033             		move.b	#$D,_objLRBSolid(a1)		; ''
00006C64                            
00006C64                            .ChkPath2:
00006C64 0C00 0008                  		cmpi.b	#8,d0				; Does the player need to switch to path 2?
00006C68 6600                       		bne.s	.PlaySound			; If not, branch
00006C6A 137C 000E 0032             		move.b	#$E,_objTopSolid(a1)		; Switch to path 2
00006C70 137C 000F 0033             		move.b	#$F,_objLRBSolid(a1)		; ''
00006C76                            
00006C76                            .PlaySound:
00006C76 08E9 0001 0028             		bset	#1,_objStatus(a1)			; Set the player's "in air" flag
00006C7C 08A9 0003 0028             		bclr	#cStandBit,_objStatus(a1)		; Make the player no longer be on the spring
00006C82 137C 0004 0025             		move.b	#4,_objRoutine(a1)			; Reset the player's routine
00006C88                            		playSnd	#sSpring, 2			; Play spring sound
00006C88 11FC 008E C4BD           M 	move.b	#sspring,(mqueue+((2)-1)).w
00006C8E 4E75                       		rts
00006C90                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006C90                            ObjSpring_DiagonallyUp:
00006C90 323C 0019                  		move.w	#26-1,d1			; Width
00006C94 343C 0010                  		move.w	#32/2,d2			; Height
00006C98 3828 0014                  		move.w	_objXPos(a0),d4			; X position
00006C9C 45FA 0000                  		lea	.SlopeData(pc),a2		; Slope Data
00006CA0 4EB8 45DE                  		jsr	SlopedSolid			; Set object as a solid slope
00006CA4                            		
00006CA4 0828 0003 0028             		btst	#cStandBit,_objStatus(a0)		; Has the player touched the spring?
00006CAA 6700                       		beq.s	.End				; If not, branch
00006CAC 6100                       		bsr.s	.Bounce				; Bounce the player
00006CAE                            
00006CAE                            .End:
00006CAE 43FA 0000                  		lea	Ani_ObjSpring(pc),a1		; Animate sprite
00006CB2 4EB8 1C42                  		jsr	AnimateObject.w			; ''
00006CB6 4EB8 2000                  		jsr	CheckObjActive.w		; Display sprite
00006CBA                            	nextObject
00006CBA 3068 0004                M 	movea.w	_objnext(a0),a0
00006CBE 2250                     M 	move.l	_objaddress(a0),a1
00006CC0 4ED1                     M 	jmp	(a1)
00006CC2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006CC2                            .Bounce:
00006CC2 0828 0000 0028             		btst	#0,_objStatus(a0)			; Is the spring facing left?
00006CC8 6600                       		bne.s	.FaceLeft			; If so, branch
00006CCA 3028 0014                  		move.w	_objXPos(a0),d0			; Get X position
00006CCE 5940                       		subq.w	#4,d0				; Subtract 4
00006CD0 B069 0014                  		cmp.w	_objXPos(a1),d0			; Is the player
00006CD4 6500                       		blo.s	.DoBounce
00006CD6 4E75                       		rts
00006CD8                            
00006CD8                            .FaceLeft:
00006CD8 3028 0014                  		move.w	_objXPos(a0),d0
00006CDC 5840                       		addq.w	#4,d0
00006CDE B069 0014                  		cmp.w	_objXPos(a1),d0
00006CE2 6400                       		bhs.s	.DoBounce
00006CE4 4E75                       		rts
00006CE6                            
00006CE6                            .DoBounce:
00006CE6 317C 0500 0020             		move.w	#$500,_objAnim(a0)
00006CEC 3368 0030 001E             		move.w	_objSprSpd(a0),_objYVel(a1)
00006CF2 3368 0030 001C             		move.w	_objSprSpd(a0),_objXVel(a1)
00006CF8 5C69 0018                  		addq.w	#6,_objYPos(a1)
00006CFC 5C69 0014                  		addq.w	#6,_objXPos(a1)
00006D00 08E9 0000 0028             		bset	#0,_objStatus(a1)
00006D06 0828 0000 0028             		btst	#0,_objStatus(a0)
00006D0C 6600                       		bne.s	.SetAni
00006D0E 08A9 0000 0028             		bclr	#0,_objStatus(a1)
00006D14 0469 000C 0014             		subi.w	#$C,_objXPos(a1)
00006D1A 4469 001C                  		neg.w	_objXVel(a1)
00006D1E                            
00006D1E                            .SetAni:
00006D1E 08E9 0001 0028             		bset	#1,_objStatus(a1)
00006D24 08A9 0003 0028             		bclr	#3,_objStatus(a1)
00006D2A 137C 0010 0020             		move.b	#$10,_objAnim(a1)
00006D30 137C 0004 0025             		move.b	#4,_objRoutine(a1)
00006D36                            
00006D36 1028 0024                  		move.b	_objSubtype(a0),d0
00006D3A 0200 000C                  		andi.b	#$C,d0				; Only get path swap bits
00006D3E 0C00 0004                  		cmpi.b	#4,d0				; Does the player need to switch to path 1?
00006D42 6600                       		bne.s	.ChkPath2			; If not, branch
00006D44 137C 000C 0032             		move.b	#$C,_objTopSolid(a1)		; Switch to path 1
00006D4A 137C 000D 0033             		move.b	#$D,_objLRBSolid(a1)		; ''
00006D50                            
00006D50                            .ChkPath2:
00006D50 0C00 0008                  		cmpi.b	#8,d0				; Does the player need to switch to path 2?
00006D54 6600                       		bne.s	.PlaySound			; If not, branch
00006D56 137C 000E 0032             		move.b	#$E,_objTopSolid(a1)		; Switch to path 2
00006D5C 137C 000F 0033             		move.b	#$F,_objLRBSolid(a1)		; ''
00006D62                            
00006D62                            .PlaySound:
00006D62                            		playSnd	#sSpring, 2			; Play spring sound
00006D62 11FC 008E C4BD           M 	move.b	#sspring,(mqueue+((2)-1)).w
00006D68 4E75                       		rts
00006D6A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006D6A                            .SlopeData:
00006D6A 1010 1010 1010 10          		dc.b	$10, $10, $10, $10, $10, $10, $10
00006D71 1010 1010 100E 0C          		dc.b	$10, $10, $10, $10, $10, $0E, $0C
00006D78 0A08 0604 0200 FE          		dc.b	$0A, $08, $06, $04, $02, $00, $FE
00006D7F FCFC FCFC FCFC FC          		dc.b	$FC, $FC, $FC, $FC, $FC, $FC, $FC
00006D86                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006D86                            ObjSpring_DiagonallyDown:
00006D86 323C 0019                  		move.w	#26-1,d1			; Width
00006D8A 343C 0010                  		move.w	#32/2,d2
00006D8E 3828 0014                  		move.w	_objXPos(a0),d4
00006D92 45FA 0000                  		lea	.SlopeData(pc),a2
00006D96 4EB8 45DE                  		jsr	SlopedSolid			; Set object as a solid slope
00006D9A 0C44 FFFE                  		cmpi.w	#-2,d4				; Has the player touched the spring?
00006D9E 6600                       		bne.s	.End				; If not, branch
00006DA0 6100                       		bsr.s	.Bounce				; Bounce the player
00006DA2                            
00006DA2                            .End:
00006DA2 43FA 0000                  		lea	Ani_ObjSpring(pc),a1		; Animate sprite
00006DA6 4EB8 1C42                  		jsr	AnimateObject.w			; ''
00006DAA 4EB8 2000                  		jsr	CheckObjActive.w		; Display sprite
00006DAE                            	nextObject
00006DAE 3068 0004                M 	movea.w	_objnext(a0),a0
00006DB2 2250                     M 	move.l	_objaddress(a0),a1
00006DB4 4ED1                     M 	jmp	(a1)
00006DB6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006DB6                            .Bounce:
00006DB6 317C 0500 0020             		move.w	#$500,_objAnim(a0)
00006DBC 3368 0030 001E             		move.w	_objSprSpd(a0),_objYVel(a1)
00006DC2 4469 001E                  		neg.w	_objYVel(a1)
00006DC6 3368 0030 001C             		move.w	_objSprSpd(a0),_objXVel(a1)
00006DCC 5C69 0018                  		addq.w	#6,_objYPos(a1)
00006DD0 5C69 0014                  		addq.w	#6,_objXPos(a1)
00006DD4 08E9 0000 0028             		bset	#0,_objStatus(a1)
00006DDA 0828 0000 0028             		btst	#0,_objStatus(a0)
00006DE0 6600                       		bne.s	.SetAni
00006DE2 08A9 0000 0028             		bclr	#0,_objStatus(a1)
00006DE8 0469 000C 0014             		subi.w	#$C,_objXPos(a1)
00006DEE 4469 001C                  		neg.w	_objXVel(a1)
00006DF2                            
00006DF2                            .SetAni:
00006DF2 08E9 0001 0028             		bset	#1,_objStatus(a1)
00006DF8 08A9 0003 0028             		bclr	#3,_objStatus(a1)
00006DFE 137C 0004 0025             		move.b	#4,_objRoutine(a1)
00006E04                            
00006E04 1028 0024                  		move.b	_objSubtype(a0),d0
00006E08 0200 000C                  		andi.b	#$C,d0				; Only get path swap bits
00006E0C 0C00 0004                  		cmpi.b	#4,d0				; Does the player need to switch to path 1?
00006E10 6600                       		bne.s	.ChkPath2			; If not, branch
00006E12 137C 000C 0032             		move.b	#$C,_objTopSolid(a1)		; Switch to path 1
00006E18 137C 000D 0033             		move.b	#$D,_objLRBSolid(a1)		; ''
00006E1E                            
00006E1E                            .ChkPath2:
00006E1E 0C00 0008                  		cmpi.b	#8,d0				; Does the player need to switch to path 2?
00006E22 6600                       		bne.s	.PlaySound			; If not, branch
00006E24 137C 000E 0032             		move.b	#$E,_objTopSolid(a1)		; Switch to path 2
00006E2A 137C 000F 0033             		move.b	#$F,_objLRBSolid(a1)		; ''
00006E30                            
00006E30                            .PlaySound:
00006E30                            		playSnd	#sSpring, 2			; Play spring sound
00006E30 11FC 008E C4BD           M 	move.b	#sspring,(mqueue+((2)-1)).w
00006E36 4E75                       		rts
00006E38                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006E38                            .SlopeData:
00006E38 F4F0 F0F0 F0F0 F0          		dc.b	$F4, $F0, $F0, $F0, $F0, $F0, $F0
00006E3F F0F0 F0F0 F0F2 F4          		dc.b	$F0, $F0, $F0, $F0, $F0, $F2, $F4
00006E46 F6F8 FAFC FE00 02          		dc.b	$F6, $F8, $FA, $FC, $FE, $00, $02
00006E4D 0404 0404 0404 04          		dc.b	$04, $04, $04, $04, $04, $04, $04
00006E54                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006E54                            ; Data
00006E54                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006E54                            Ani_ObjSpring:
00006E54                            		include	"Objects/Spring/Animations.asm"
00006E54                            ; ---------------------------------------------------------------------------
00006E54                            ; Animation script - springs
00006E54                            ; ---------------------------------------------------------------------------
00006E54 0000                       		dc.w byte_18FEE-Ani_ObjSpring
00006E56 0000                       		dc.w byte_18FF1-Ani_ObjSpring
00006E58 0000                       		dc.w byte_18FFD-Ani_ObjSpring
00006E5A 0000                       		dc.w byte_19000-Ani_ObjSpring
00006E5C 0000                       		dc.w byte_1900C-Ani_ObjSpring
00006E5E 0000                       		dc.w byte_1900F-Ani_ObjSpring
00006E60                            byte_18FEE:
00006E60 0F00 FF                    		dc.b  $F, 0, $FF
00006E64 00                         		even
00006E64                            byte_18FF1:
00006E64 0001 0101 0101 01FD 00     		dc.b 0, 1, 1, 1, 1, 1, 1, $FD, 0
00006E6E 00                         		even
00006E6E                            byte_18FFD:
00006E6E 0F02 FF                    		dc.b $F, 2, $FF
00006E72 00                         		even
00006E72                            byte_19000:
00006E72 0003 0303 0303 03FD 02     		dc.b 0, 3, 3, 3, 3, 3, 3, $FD, 2
00006E7C 00                         		even
00006E7C                            byte_1900C:
00006E7C 0F04 FF                    		dc.b $F, 4, $FF
00006E80 00                         		even
00006E80                            byte_1900F:
00006E80 0005 0505 0505 05FD 04     		dc.b 0, 5, 5, 5, 5, 5, 5, $FD, 4
00006E8A 00                         		even
00006E8A                            Map_ObjSpring:
00006E8A                            		include	"Objects/Spring/Mappings.asm"
00006E8A                            ; --------------------------------------------------------------------------------
00006E8A                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
00006E8A                            ; --------------------------------------------------------------------------------
00006E8A                            
00006E8A                            SME_q_6K9:	
00006E8A 0000 0000                  		dc.w SME_q_6K9_E-SME_q_6K9, SME_q_6K9_1C-SME_q_6K9	
00006E8E 0000 0000                  		dc.w SME_q_6K9_3C-SME_q_6K9, SME_q_6K9_44-SME_q_6K9	
00006E92 0000 0000                  		dc.w SME_q_6K9_70-SME_q_6K9, SME_q_6K9_7E-SME_q_6K9	
00006E96 0000                       		dc.w SME_q_6K9_9E-SME_q_6K9	
00006E98 0002                       SME_q_6K9_E:	dc.b 0, 2	
00006E9A F80C 0000 FFF0             		dc.b $F8, $C, 0, 0, $FF, $F0	
00006EA0 000C 0004 FFF0             		dc.b 0, $C, 0, 4, $FF, $F0	
00006EA6 0005                       SME_q_6K9_1C:	dc.b 0, 5	
00006EA8 E00C 0000 FFF0             		dc.b $E0, $C, 0, 0, $FF, $F0	
00006EAE E804 0008 FFF8             		dc.b $E8, 4, 0, 8, $FF, $F8	
00006EB4 F004 000A FFF8             		dc.b $F0, 4, 0, $A, $FF, $F8	
00006EBA F804 000A FFF8             		dc.b $F8, 4, 0, $A, $FF, $F8	
00006EC0 000C 000C FFF0             		dc.b 0, $C, 0, $C, $FF, $F0	
00006EC6 0001                       SME_q_6K9_3C:	dc.b 0, 1	
00006EC8 E807 0000 FFF7             		dc.b $E8, 7, 0, 0, $FF, $F7	
00006ECE 0007                       SME_q_6K9_44:	dc.b 0, 7	
00006ED0 E803 0004 0017             		dc.b $E8, 3, 0, 4, 0, $17	
00006ED6 F001 0008 000F             		dc.b $F0, 1, 0, 8, 0, $F	
00006EDC F001 000A 0007             		dc.b $F0, 1, 0, $A, 0, 7	
00006EE2 F001 000A FFFF             		dc.b $F0, 1, 0, $A, $FF, $FF	
00006EE8 F001 000C FFF7             		dc.b $F0, 1, 0, $C, $FF, $F7	
00006EEE E800 000E FFF7             		dc.b $E8, 0, 0, $E, $FF, $F7	
00006EF4 0000 100E FFF7             		dc.b 0, 0, $10, $E, $FF, $F7	
00006EFA 0002                       SME_q_6K9_70:	dc.b 0, 2	
00006EFC F20B 0000 FFF0             		dc.b $F2, $B, 0, 0, $FF, $F0	
00006F02 FA02 000C 0008             		dc.b $FA, 2, 0, $C, 0, 8	
00006F08 0005                       SME_q_6K9_7E:	dc.b 0, 5	
00006F0A E20B 000F 0000             		dc.b $E2, $B, 0, $F, 0, 0	
00006F10 EA02 001B 0018             		dc.b $EA, 2, 0, $1B, 0, $18	
00006F16 F201 201E FFF8             		dc.b $F2, 1, $20, $1E, $FF, $F8	
00006F1C FA00 0020 FFF0             		dc.b $FA, 0, 0, $20, $FF, $F0	
00006F22 0209 0021 FFF0             		dc.b 2, 9, 0, $21, $FF, $F0	
00006F28 0002                       SME_q_6K9_9E:	dc.b 0, 2	
00006F2A 020B 1000 FFF0             		dc.b 2, $B, $10, 0, $FF, $F0	
00006F30 0202 100C 0008             		dc.b 2, 2, $10, $C, 0, 8	
00006F36                            		even
00006F36                            ; =========================================================================================================================================================
00006F36                            		include	"Objects/Checkpoint/Code.asm"	; Checkpoint object
00006F36                            ; =========================================================================================================================================================
00006F36                            ; Checkpoint object
00006F36                            ; =========================================================================================================================================================
00006F36                            		rsset	_objLvlSSTs
00006F36 =00000030                  _objDongleX	rs.w	1				; Ball dongle X
00006F36 =00000032                  _objDongleY	rs.w	1				; Ball dongle Y
00006F36 =00000034                  _objDongleTime	rs.w	1				; Ball dongle timer
00006F36 =00000036                  _objDonglePar	rs.w	1				; Ball dongle parent
00006F36                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006F36                            ObjCheckpoint:
00006F36 7000                       		moveq	#0,d0
00006F38 1028 0025                  		move.b	_objRoutine(a0),d0			; Get routine ID
00006F3C 4EBB 0000                  		jsr	.Index(pc,d0.w)			; Jump to it
00006F40                            	nextObject
00006F40 3068 0004                M 	movea.w	_objnext(a0),a0
00006F44 2250                     M 	move.l	_objaddress(a0),a1
00006F46 4ED1                     M 	jmp	(a1)
00006F48                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006F48                            .Index:
00006F48 6000 0000                  		bra.w	ObjChkpoint_Init
00006F4C 6000 0000                  		bra.w	ObjChkpoint_Main
00006F50 6000 0000                  		bra.w	ObjChkpoint_Animate
00006F54                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006F54                            ObjChkpoint_Init:
00006F54 5828 0025                  		addq.b	#4,_objRoutine(a0)			; Next routine
00006F58                            		
00006F58 217C 0000 0000 0010        		move.l	#Map_ObjChkpoint,_objMapping(a0)	; Mappings
00006F60 317C 057E 000E             		move.w	#$57E,_objVRAM(a0)			; Tile properties
00006F66 117C 0004 000D             		move.b	#4,_objRender(a0)			; Render flags
00006F6C 117C 0008 0017             		move.b	#8,_objDrawW(a0)			; Sprite width
00006F72 117C 0020 001B             		move.b	#$20,_objDrawH(a0)			; Sprite height
00006F78                            	displaySprite	5,a0,a1,0			; Priority
00006F78 317C C182 0008           M 	move.w	#objdisplay+(5*dsize),_objdrawnext(a0)
00006F7E 3278 C18C                M 	move.w	objdisplay+dprev+(5*dsize).w,a1
00006F82 3149 000A                M 	move.w	a1,_objdrawprev(a0)
00006F86 3348 0008                M 	move.w	a0,_objdrawnext(a1)
00006F8A 31C8 C18C                M 	move.w	a0,objdisplay+dprev+(5*dsize).w
00006F8E                          M .no_263
00006F8E                            		
00006F8E 3028 0026                  		move.w	_objRespawn(a0),d0			; Get respawn table address
00006F92 3440                       		movea.w	d0,a2				; ''
00006F94 0812 0000                  		btst	#0,(a2)				; Is it already set?
00006F98 6600                       		bne.s	.AlreadySet			; If so, branch
00006F9A                            
00006F9A 1228 0024                  		move.b	_objSubtype(a0),d1			; Get checkpoint ID
00006F9E B238 C7B0                  		cmp.b	chkIDLast.w,d1		; Has a later checkpoint already been hit?
00006FA2 6E00                       		bgt.s	ObjChkpoint_Main		; If not, branch
00006FA4                            
00006FA4                            .AlreadySet:
00006FA4 08D2 0000                  		bset	#0,(a2)				; Mark as set
00006FA8 117C 0002 0020             		move.b	#2,_objAnim(a0)			; ''
00006FAE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006FAE                            ObjChkpoint_Main:
00006FAE 4A38 E8DD                  		tst.b	debugMode.w			; Are we in debug placement mode?
00006FB2 6600 0000                  		bne.w	ObjChkpoint_Animate		; If so, branch
00006FB6                            		
00006FB6 3278 E876                  		movea.w	playerPtrP1.w,a1		; Player object
00006FBA 1238 C7B0                  		move.b	chkIDLast.w,d1		; Get last checkpoint hit
00006FBE B228 0024                  		cmp.b	_objSubtype(a0),d1			; Has a later checkpoint already been hit?
00006FC2 6400 0000                  		bhs.w	.ChkSetAnim			; If so, branch
00006FC6                            
00006FC6 3029 0014                  		move.w	_objXPos(a1),d0			; Get player's X position
00006FCA 9068 0014                  		sub.w	_objXPos(a0),d0			; Get delta X from current position
00006FCE 5040                       		addq.w	#8,d0				; Add 8
00006FD0 0C40 0010                  		cmpi.w	#$10,d0				; Is the player within horizontal boundaries?
00006FD4 6400 0000                  		bcc.w	ObjChkpoint_Animate		; If not, branch
00006FD8 3029 0018                  		move.w	_objYPos(a1),d0			; Get player's Y position
00006FDC 9068 0018                  		sub.w	_objYPos(a0),d0			; Get delta Y from current position
00006FE0 0640 0040                  		addi.w	#$40,d0				; Add $40
00006FE4 0C40 0068                  		cmpi.w	#$68,d0				; Is the player within vertical boundaries?
00006FE8 6400 0000                  		bcc.w	ObjChkpoint_Animate		; If not, branch
00006FEC                            		
00006FEC                            		playSnd	#sCheckpoint, 2			; Play checkpoint sound
00006FEC 11FC 008A C4BD           M 	move.b	#scheckpoint,(mqueue+((2)-1)).w
00006FF2                            
00006FF2 4EB8 1A1C                  		jsr	FindFreeObj.w			; Find a free object slot
00006FF6 6700                       		beq.s	.SetPoint			; If there is none, branch
00006FF8 22BC 0000 0000             		move.l	#ObjChkPoint_Dongle,_objAddress(a1)	; Load the checkpoint ball dongle object
00006FFE 3368 0014 0030             		move.w	_objXPos(a0),_objDongleX(a1)		; Dongle X
00007004 3368 0018 0032             		move.w	_objYPos(a0),_objDongleY(a1)		; Dongle Y
0000700A 0469 0014 0032             		subi.w	#$14,_objDongleY(a1)		; ''
00007010 2368 0010 0010             		move.l	_objMapping(a0),_objMapping(a1)		; Mappings
00007016 3368 000E 000E             		move.w	_objVRAM(a0),_objVRAM(a1)		; Tile properties
0000701C 137C 0004 000D             		move.b	#4,_objRender(a1)			; Render flags
00007022 137C 0008 0017             		move.b	#8,_objDrawW(a1)			; Sprite width
00007028 137C 0008 001B             		move.b	#8,_objDrawH(a1)			; Sprite height
0000702E                            	displaySprite	4,a1,a2,0			; Priority
0000702E 337C C17A 0008           M 	move.w	#objdisplay+(4*dsize),_objdrawnext(a1)
00007034 3478 C184                M 	move.w	objdisplay+dprev+(4*dsize).w,a2
00007038 334A 000A                M 	move.w	a2,_objdrawprev(a1)
0000703C 3549 0008                M 	move.w	a1,_objdrawnext(a2)
00007040 31C9 C184                M 	move.w	a1,objdisplay+dprev+(4*dsize).w
00007044                          M .no_265
00007044 137C 0002 0010             		move.b	#2,_objFrame(a1)			; Map frame
0000704A 337C 0020 0034             		move.w	#$20,_objDongleTime(a1)		; Dongle timer
00007050 3348 0036                  		move.w	a0,_objDonglePar(a1)		; Dongle parent
00007054                            
00007054                            .SetPoint:
00007054 3028 0026                  		move.w	_objRespawn(a0),d0			; Get respawn table address
00007058 3440                       		movea.w	d0,a2				; ''
0000705A 08D2 0000                  		bset	#0,(a2)				; Mark as set
0000705E                            		
0000705E 117C 0001 0020             		move.b	#1,_objAnim(a0)			; Use dongling animation
00007064 11E8 0024 C7B0             		move.b	_objSubtype(a0),chkIDLast.w	; Set checkpoint ID
0000706A                            
0000706A 5828 0025                  		addq.b	#4,_objRoutine(a0)
0000706E 4879 0000 0000             		pea	ObjChkpoint_Animate		; Animate
00007074 4EF8 4B32                  		jmp	Level_SaveInfo			; Save data
00007078                            		
00007078                            .ChkSetAnim:
00007078 5828 0025                  		addq.b	#4,_objRoutine(a0)
0000707C 4A28 0020                  		tst.b	_objAnim(a0)			; Are we still unset?
00007080 6600                       		bne.s	ObjChkpoint_Animate		; If not, branch
00007082 117C 0002 0020             		move.b	#2,_objAnim(a0)			; Use the set animation
00007088                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------		
00007088                            ObjChkpoint_Animate:
00007088 43F9 0000 0000             		lea	Ani_ObjChkpoint,a1		; Animate
0000708E 4EB8 1C42                  		jsr	AnimateObject.w			; ''
00007092 4EF8 2000                  		jmp	CheckObjActive.w		; Display
00007096                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------		
00007096                            ; Ball dongle object
00007096                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------		
00007096                            ObjChkPoint_Dongle:
00007096 5368 0034                  		subq.w	#1,_objDongleTime(a0)		; Decrement timer
0000709A 6A00                       		bpl.s	.MoveDongle			; If it hasn't run out, branch
0000709C 3268 0036                  		movea.w	_objDonglePar(a0),a1		; Get parent
000070A0 137C 0002 0020             		move.b	#2,_objAnim(a1)			; Set set animation for parent
000070A6 4229 0010                  		clr.b	_objFrame(a1)			; Reset map frame for parent
000070AA 4EB8 1A4C                  		jsr	DeleteObject.w			; Delete ourselves
000070AE                            	nextObject
000070AE 3068 0004                M 	movea.w	_objnext(a0),a0
000070B2 2250                     M 	move.l	_objaddress(a0),a1
000070B4 4ED1                     M 	jmp	(a1)
000070B6                            
000070B6                            .MoveDongle:
000070B6 1028 0041                  		move.b	_objAngle(a0),d0			; Get angle
000070BA 0428 0010 0041             		subi.b	#$10,_objAngle(a0)			; Decrement angle
000070C0 0400 0040                  		subi.b	#$40,d0				; Subtract $40
000070C4 4EB8 1374                  		jsr	CalcSine.w			; Get sine and cosine
000070C8 C3FC 0C00                  		muls.w	#$C00,d1			; Multiply cosine with $C00
000070CC 4841                       		swap	d1				; Get high word
000070CE D268 0030                  		add.w	_objDongleX(a0),d1			; Add dongle X
000070D2 3141 0014                  		move.w	d1,_objXPos(a0)			; Set actual X
000070D6 C1FC 0C00                  		muls.w	#$C00,d0			; Multiply sine with $C00
000070DA 4840                       		swap	d0				; Get high word
000070DC D068 0032                  		add.w	_objDongleY(a0),d0			; Add dongle X
000070E0 3140 0018                  		move.w	d0,_objYPos(a0)			; Set actual X
000070E4 4EB8 2000                  		jsr	CheckObjActive.w		; Display
000070E8                            	nextObject
000070E8 3068 0004                M 	movea.w	_objnext(a0),a0
000070EC 2250                     M 	move.l	_objaddress(a0),a1
000070EE 4ED1                     M 	jmp	(a1)
000070F0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000070F0                            ; Data
000070F0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000070F0                            Ani_ObjChkpoint:
000070F0 0000                       		dc.w	.Ani0-Ani_ObjChkpoint
000070F2 0000                       		dc.w	.Ani1-Ani_ObjChkpoint
000070F4 0000                       		dc.w	.Ani2-Ani_ObjChkpoint
000070F6 0F00 FF                    .Ani0:		dc.b	$F, 0, $FF
000070FA 00                         		even
000070FA 0F01 FF                    .Ani1:		dc.b	$F, 1, $FF
000070FE 00                         		even
000070FE 0300 04FF                  .Ani2:		dc.b	3, 0, 4, $FF
00007102                            		even
00007102                            Map_ObjChkpoint:
00007102                            		include	"Objects/Checkpoint/Mappings.asm"
00007102                            ; --------------------------------------------------------------------------------
00007102                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
00007102                            ; --------------------------------------------------------------------------------
00007102                            
00007102                            SME_JjCUP:	
00007102 0000 0000                  		dc.w SME_JjCUP_A-SME_JjCUP, SME_JjCUP_24-SME_JjCUP	
00007106 0000 0000                  		dc.w SME_JjCUP_38-SME_JjCUP, SME_JjCUP_40-SME_JjCUP	
0000710A 0000                       		dc.w SME_JjCUP_48-SME_JjCUP	
0000710C 0004                       SME_JjCUP_A:	dc.b 0, 4	
0000710E E801 2004 FFFC             		dc.b $E8, 1, $20, 4, $FF, $FC	
00007114 F803 2006 FFF8             		dc.b $F8, 3, $20, 6, $FF, $F8	
0000711A F803 2806 0000             		dc.b $F8, 3, $28, 6, 0, 0	
00007120 D805 0000 FFF8             		dc.b $D8, 5, 0, 0, $FF, $F8	
00007126 0003                       SME_JjCUP_24:	dc.b 0, 3	
00007128 E801 2004 FFFC             		dc.b $E8, 1, $20, 4, $FF, $FC	
0000712E F803 2006 FFF8             		dc.b $F8, 3, $20, 6, $FF, $F8	
00007134 F803 2806 0000             		dc.b $F8, 3, $28, 6, 0, 0	
0000713A 0001                       SME_JjCUP_38:	dc.b 0, 1	
0000713C F805 0000 FFF8             		dc.b $F8, 5, 0, 0, $FF, $F8	
00007142 0001                       SME_JjCUP_40:	dc.b 0, 1	
00007144 F805 2000 FFF8             		dc.b $F8, 5, $20, 0, $FF, $F8	
0000714A 0004                       SME_JjCUP_48:	dc.b 0, 4	
0000714C E801 2004 FFFC             		dc.b $E8, 1, $20, 4, $FF, $FC	
00007152 F803 2006 FFF8             		dc.b $F8, 3, $20, 6, $FF, $F8	
00007158 F803 2806 0000             		dc.b $F8, 3, $28, 6, 0, 0	
0000715E D805 2000 FFF8             		dc.b $D8, 5, $20, 0, $FF, $F8	
00007164                            		even
00007164                            ; =========================================================================================================================================================
00007164                            		include	"Objects/Wall Spring/Code.asm"	; Wall spring object
00007164                            ; =========================================================================================================================================================
00007164                            ; Wall spring object
00007164                            ; =========================================================================================================================================================
00007164                            ObjWallSpring:
00007164 20BC 0000 0000             		move.l	#ObjWallSpring_Main,_objAddress(a0)	; Next routine
0000716A                            	;	move.l	#Map_ObjWallSpring,_objMapping(a0)	; Mappings
0000716A                            	;	clr.w	_objVRAM(a0)			; Tile properties
0000716A                            	;	ori.b	#4,_objRender(a0)			; Render flags
0000716A                            	;	move.w	#rSprInput+$200,oPrio(a0)	; Priority
0000716A                            	;	move.b	#8,_objDrawW(a0)			; Sprite width
0000716A                            	;	move.b	#$40,_objDrawH(a0)			; Sprite height
0000716A 117C 0008 002C             		move.b	#8,_objColW(a0)			; Collision width
00007170 117C 0040 002D             		move.b	#$40,_objColH(a0)			; Collision height
00007176                            
00007176 1028 0024                  		move.b	_objSubtype(a0),d0			; Get subtype
0000717A E808                       		lsr.b	#4,d0				; Get map frame
0000717C 0200 0007                  		andi.b	#7,d0				; ''
00007180 1140 0010                  		move.b	d0,_objFrame(a0)			; Set map frame
00007184 6700                       		beq.s	ObjWallSpring_Main		; If it was 0, branch
00007186                            	;	move.b	#$80,_objDrawH(a0)			; Larger sprite height
00007186 117C 0080 002D             		move.b	#$80,_objColH(a0)			; Larger collision height
0000718C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000718C                            ObjWallSpring_Main:
0000718C 7208                       		moveq	#8,d1				; Width
0000718E 7400                       		moveq	#0,d2
00007190 1428 002D                  		move.b	_objColH(a0),d2			; Height
00007194 3602                       		move.w	d2,d3				; ''
00007196 5243                       		addq.w	#1,d3				; ''
00007198 3828 0014                  		move.w	_objXPos(a0),d4			; X position
0000719C 4EB8 458E                  		jsr	SolidObject_Always		; Make us solid
000071A0                            
000071A0 0806 0000                  		btst	#cTouchSideBit,d6		; Has Sonic touched the side of the spring?
000071A4 6700                       		beq.s	.Display			; If not, branch
000071A6 08E9 0001 0028             		bset	#1,_objStatus(a1)			; Set in air
000071AC 1228 0028                  		move.b	_objStatus(a0),d1			; Get status
000071B0 3028 0014                  		move.w	_objXPos(a0),d0			; Get distance between us and Sonic
000071B4 9069 0014                  		sub.w	_objXPos(a1),d0			; ''
000071B8 6500                       		bcs.s	.ChkXStat			; If Sonic is towards the right of the spring, branch
000071BA 0A01 0001                  		eori.b	#1,d1				; Go the other way
000071BE                            
000071BE                            .ChkXStat:
000071BE 0201 0001                  		andi.b	#1,d1				; Has Sonic touched the front of spring?
000071C2 6600                       		bne.s	.Display			; If not, branch
000071C4 6100                       		bsr.s	.Bounce
000071C6                            
000071C6                            .Display:
000071C6 4EB8 2000                  		jsr	CheckObjActive.w		; Delete if inactive
000071CA                            	nextObject
000071CA 3068 0004                M 	movea.w	_objnext(a0),a0
000071CE 2250                     M 	move.l	_objaddress(a0),a1
000071D0 4ED1                     M 	jmp	(a1)
000071D2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000071D2                            .Bounce:
000071D2 0C29 000C 0025             		cmpi.b	#$C,_objRoutine(a1)			; Is Sonic dead?
000071D8 6500                       		blo.s	.DoBounce			; If not, branch
000071DA 4E75                       		rts
000071DC                            
000071DC                            .DoBounce:
000071DC 137C 0004 0025             		move.b	#4,_objRoutine(a1)			; Make Sonic not hurt if he is
000071E2 337C F800 001C             		move.w	#-$800,_objXVel(a1)		; Bounce left
000071E8 337C F800 001E             		move.w	#-$800,_objYVel(a1)		; Bounce up
000071EE 08E9 0000 0028             		bset	#0,_objStatus(a1)			; Face left
000071F4 0828 0000 0028             		btst	#0,_objStatus(a0)			; Are we facing left?
000071FA 6600                       		bne.s	.MoveLock			; If so, branch
000071FC 08A9 0000 0028             		bclr	#0,_objStatus(a1)			; Face right
00007202 4469 001C                  		neg.w	_objXVel(a1)			; Go right
00007206                            
00007206                            .MoveLock:
00007206 137C 000F 003F             		move.b	#$F,_objMoveLock(a1)		; Set move lock timer
0000720C 0829 0002 0028             		btst	#2,_objStatus(a1)			; Was Sonic jumping?
00007212 6600                       		bne.s	.ChkN_objYVel			; If so, branch
00007214 4229 0020                  		clr.b	_objAnim(a1)			; Reset animation
00007218                            
00007218                            .ChkN_objYVel:
00007218 1028 0024                  		move.b	_objSubtype(a0),d0			; Get subtype
0000721C 6A00                       		bpl.s	.ChkFlip			; If Sonic should still bounce up, branch
0000721E 4229 001E                  		clr.b	_objYVel(a1)			; Stop Y velocity
00007222                            
00007222                            .ChkFlip:
00007222 0800 0000                  		btst	#0,d0				; Should Sonic tumble?
00007226 6700                       		beq.s	.PlaySnd			; If not, branch
00007228 337C 0001 003A             		move.w	#1,_objFlipDir(a1)			; Set flip direction
0000722E 137C 0001 0047             		move.b	#1,_objFlipAngle(a1)		; Set flip angle
00007234 4229 0020                  		clr.b	_objAnim(a1)			; Reset animation
00007238 137C 0001 0049             		move.b	#1,_objFlipRemain(a1)		; Set flips remaining
0000723E 137C 0008 004A             		move.b	#8,_objFlipSpeed(a1)		; Set flip speed
00007244 0800 0001                  		btst	#1,d0				; Should Sonic do 3 flips?
00007248 6600                       		bne.s	.ChkDir				; If not, branch
0000724A 137C 0003 0049             		move.b	#3,_objFlipRemain(a1)		; Do 3 flips isntead
00007250                            
00007250                            .ChkDir:
00007250 0829 0000 0028             		btst	#0,_objStatus(a1)			; Was Sonic facing left?
00007256 6700                       		beq.s	.PlaySnd			; If not, branch
00007258 4429 0047                  		neg.b	_objFlipAngle(a1)			; Flip the other way
0000725C 4469 003A                  		neg.w	_objFlipDir(a1)			; ''
00007260                            
00007260                            .PlaySnd:
00007260 08A8 0005 0028             		bclr	#cPushBit,_objStatus(a0)		; Stop pushing
00007266 08A9 0005 0028             		bclr	#cPushBit,_objStatus(a1)		; ''
0000726C                            		playSnd	#sSpring, 2			; Play spring sound
0000726C 11FC 008E C4BD           M 	move.b	#sspring,(mqueue+((2)-1)).w
00007272 4E75                       		rts
00007274                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00007274                            ; Data
00007274                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00007274                            Map_ObjWallSpring:
00007274                            		include	"Objects/Wall Spring/Mappings.asm"
00007274                            ; --------------------------------------------------------------------------------
00007274                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
00007274                            ; --------------------------------------------------------------------------------
00007274                            
00007274                            SME_ReVf5:	
00007274 0000 0000                  		dc.w SME_ReVf5_4-SME_ReVf5, SME_ReVf5_12-SME_ReVf5	
00007278 0002                       SME_ReVf5_4:	dc.b 0, 2	
0000727A C005 0034 FFF8             		dc.b $C0, 5, 0, $34, $FF, $F8	
00007280 3005 0034 FFF8             		dc.b $30, 5, 0, $34, $FF, $F8	
00007286 0002                       SME_ReVf5_12:	dc.b 0, 2	
00007288 8005 0034 FFF8             		dc.b $80, 5, 0, $34, $FF, $F8	
0000728E 7005 0034 FFF8             		dc.b $70, 5, 0, $34, $FF, $F8	
00007294                            		even
00007294                            		even
00007294                            ; =========================================================================================================================================================
00007294                            		include	"Objects/Ball Mode/Code.asm"	; Ball mode switch object
00007294                            ; =========================================================================================================================================================
00007294                            ; Ball mode enable/disable object
00007294                            ; =========================================================================================================================================================
00007294                            		rsset	_objLvlSSTs
00007294 =00000030                  _objBModeTouch	rs.b	1				; Touched flag
00007294                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00007294                            ObjBallMode:
00007294                            	;	move.l	#ObjBallMode_Main,_objAddress(a0)	; Next routine
00007294                            	;	move.l	#Map_ObjMonitor,_objMapping(a0)	; Mappings
00007294                            	;	clr.w	_objVRAM(a0)			; Tile properties
00007294                            	;	ori.b	#4,_objRender(a0)			; Render flags
00007294                            	;	move.w	#rSprInput+$280,oPrio(a0)	; Priority
00007294                            	;	move.b	#$10,_objDrawW(a0)			; Sprite width
00007294                            	;	move.b	#$10,_objDrawH(a0)			; Sprite height
00007294                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00007294                            ObjBallMode_Main:
00007294 43FA 0000                  		lea	.RangeData(pc),a1		; Range data
00007298 3478 E876                  		movea.w	playerPtrP1.w,a2		; Player object
0000729C 4EB8 1D62                  		jsr	CheckObjInRange.w		; Is the player in range?
000072A0 4A40                       		tst.w	d0				; ''
000072A2 6700                       		beq.s	.NotTouched			; If not, branch
000072A4                            
000072A4 08AA 0002 000C             		bclr	#2,_objFlags(a2)
000072AA                            		
000072AA 4A28 0024                  		tst.b	_objSubtype(a0)			; Should we force Sonic out of ball mode?
000072AE 6B00                       		bmi.s	.NoBallMode			; If so, branch
000072B0 6600                       		bne.s	.BallMode			; Branch if we should force Sonic in to ball mode
000072B2                            
000072B2 4A28 0030                  		tst.b	_objBModeTouch(a0)		; Have we already been touched?
000072B6 6600                       		bne.s	.End				; If so, branch
000072B8 50E8 0030                  		st	_objBModeTouch(a0)		; Touched
000072BC                            
000072BC 462A 004B                  		not.b	_objBallMode(a2)		; Switch ball mode for Sonic
000072C0 6700                       		beq.s	.End				; If it's not set, branch
000072C2                            
000072C2                            .MakeSonicRoll:
000072C2 2248                       		movea.l	a0,a1				; Save a0
000072C4 204A                       		movea.l	a2,a0				; Make Sonic roll
000072C6 4EB8 5888                  		jsr	ObjPlayer_DoRoll		; ''
000072CA 2049                       		movea.l	a1,a0				; Restore a0
000072CC                            	nextObject
000072CC 3068 0004                M 	movea.w	_objnext(a0),a0
000072D0 2250                     M 	move.l	_objaddress(a0),a1
000072D2 4ED1                     M 	jmp	(a1)
000072D4                            
000072D4                            .NotTouched:
000072D4 4228 0030                  		clr.b	_objBModeTouch(a0)		; Not touched
000072D8                            	nextObject
000072D8 3068 0004                M 	movea.w	_objnext(a0),a0
000072DC 2250                     M 	move.l	_objaddress(a0),a1
000072DE 4ED1                     M 	jmp	(a1)
000072E0                            
000072E0                            .BallMode:
000072E0 50EA 004B                  		st	_objBallMode(a2)		; Get in to ball mode
000072E4 60DC                       		bra.s	.MakeSonicRoll			; ''
000072E6                            
000072E6                            .NoBallMode:
000072E6 422A 004B                  		clr.b	_objBallMode(a2)		; Get out of ball mode
000072EA                            
000072EA                            .End:
000072EA                            	nextObject
000072EA 3068 0004                M 	movea.w	_objnext(a0),a0
000072EE 2250                     M 	move.l	_objaddress(a0),a1
000072F0 4ED1                     M 	jmp	(a1)
000072F2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000072F2                            .RangeData:
000072F2 FFF0 0020                  		dc.w	-$10, $20
000072F6 FFF0 0020                  		dc.w	-$10, $20
000072FA                            ; =========================================================================================================================================================
000072FA                            		include	"Objects/Bumper/Code.asm"		; Bumper object
000072FA                            ; =========================================================================================================================================================
000072FA                            ; Water surface object
000072FA                            ; =========================================================================================================================================================
000072FA                            		rsset	_objLvlSSTs
000072FA                            
000072FA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000072FA                            ObjAttack:
000072FA 20BC 0000 0000             		move.l	#ObjBumperMain,_objAddress(a0)	; Next routine
00007300 217C 0000 0000 0010        		move.l	#Map_ObjBumper,_objMapping(a0)		; Mappings
00007308 317C 035B 000E             		move.w	#$35B,_objVRAM(a0)			; Tile properties
0000730E 117C 0004 000D             		move.b	#4,_objRender(a0)			; Render flags
00007314                            		displaySprite	1,a0,a1,0			; Priority
00007314 317C C162 0008           M 	move.w	#objdisplay+(1*dsize),_objdrawnext(a0)
0000731A 3278 C16C                M 	move.w	objdisplay+dprev+(1*dsize).w,a1
0000731E 3149 000A                M 	move.w	a1,_objdrawprev(a0)
00007322 3348 0008                M 	move.w	a0,_objdrawnext(a1)
00007326 31C8 C16C                M 	move.w	a0,objdisplay+dprev+(1*dsize).w
0000732A                          M .no_273
0000732A 7210                       		moveq	#$10,d1
0000732C                            	;	move.b	d1,_objDrawW(a0)
0000732C                            	;	move.b	d1,_objColW(a0)
0000732C                            	;	move.b	d1,_objDrawH(a0)
0000732C                            	;	move.b	d1,_objColH(a0)
0000732C                            		
0000732C                            
0000732C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000732C                            ObjBumperMain:
0000732C 0C68 0000 0024             		cmpi.w	#0,	_objSubtype(a0)
00007332 6700                       		beq.s	.AttackX
00007334                            		
00007334 0668 FFF6 0014             		add.w	#-10,_objXPos(a0)
0000733A 6000                       		bra.s	.cont
0000733C                            		
0000733C                            	.AttackX:
0000733C 0668 000A 0014             		add.w	#10,_objXPos(a0)
00007342                            	.cont:
00007342 5328 0017                  		subq.b	#1,	_objDrawW(a0)
00007346 4A28 0017                  		tst.b	_objDrawW(a0)
0000734A 6700 0000                  		beq.w	ObjAttack_Delete
0000734E                            		
0000734E                            	nextObject
0000734E 3068 0004                M 	movea.w	_objnext(a0),a0
00007352 2250                     M 	move.l	_objaddress(a0),a1
00007354 4ED1                     M 	jmp	(a1)
00007356                            
00007356                            ObjAttack_Delete:
00007356                            	;	playSnd	#sCheckpoint, 2			; Play checkpoint sound
00007356 4EB8 1A4C                  		jsr	DeleteObject.w
0000735A                            	nextObject
0000735A 3068 0004                M 	movea.w	_objnext(a0),a0
0000735E 2250                     M 	move.l	_objaddress(a0),a1
00007360 4ED1                     M 	jmp	(a1)
00007362                            
00007362                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00007362                            ; Data
00007362                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00007362                            Map_ObjBumper:
00007362                            		include	"Objects/Bumper/Mappings.asm"
00007362                            Map_eb08:
00007362 0000                       Map_eb08_0: 	dc.w Map_eb08_2-Map_eb08
00007364 0001                       Map_eb08_2: 	dc.b $0, $1
00007366 FC04 0000 FFF8             	dc.b $FC, $4, $0, $0, $FF, $F8
0000736C                            	even
0000736C                            		even
0000736C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000736C                            Ani_ObjBumper:
0000736C 0000                       		dc.w	.Ani0-Ani_ObjBumper
0000736E 0000                       		dc.w	.Ani1-Ani_ObjBumper
00007370 0500 FF00                  .Ani0:		dc.b	5, 0, $FF, 0
00007374 0501 0201 02FD 00          .Ani1:		dc.b	5, 1, 2, 1, 2, $FD, 0
0000737C 00                         		even
0000737C                            ; =========================================================================================================================================================
0000737C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000737C                            ; Unused/Temporary
0000737C                            ;		include	"Objects/Slicer/Code.asm"		; Slicer object
0000737C                            ;		include	"Objects/Shellcracker/Code.asm"	; Shellcracker object
0000737C                            ;		include	"Objects/Asteron/Code.asm"	; Asteron object
0000737C                            ;		include	"Objects/Boss - WFZ/Code.asm"	; WFZ boss object
0000737C                            ;		include	"Objects/Harpoon/Code.asm"	; Harpoon object
0000737C                            ;		include	"Objects/CNZ Barrel/Code.asm"	; CNZ barrel object
0000737C                            ;		include	"Objects/Diamond/Code.asm"	; Diamond object
0000737C                            ;		include	"Objects/Orbinaut/Code.asm"	; Orbinaut object
0000737C                            
0000737C                            ; =========================================================================================================================================================
0000737C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000737C                            ; Object Art
0000737C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000737C                            ArtUnc_Sonic:
0000737C                            		incbin	"Graphics/Sprites/Sonic/Art.unc"
000074FC                            		even
000074FC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000074FC                            ArtKosM_Bumper:
000074FC                            		incbin	"Graphics/Sprites/Bumper/Art.kosm"
0000751A                            		even
0000751A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000751A                            ArtKosM_Chkpoint:
0000751A                            		incbin	"Graphics/Sprites/Checkpoint/Art.kosm"
0000761A 00                         		even
0000761A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000761A                            ArtKosM_DrownCnt:
0000761A                            		incbin	"Graphics/Sprites/Drown Countdown/Art.kosm"
00007BEC 00                         		even
00007BEC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00007BEC                            ArtKosM_Explosion:
00007BEC                            		incbin	"Graphics/Sprites/Explosion/Art.kosm"
0000807E                            		even
0000807E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000807E                            ArtKosM_Monitor:
0000807E                            		incbin	"Graphics/Sprites/Monitor/Art.kosm"
000083A0 00                         		even
000083A0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000083A0                            ArtUnc_Ring:
000083A0                            		incbin	"Graphics/Sprites/Ring/Art - Ring.unc"
000087A0                            		even
000087A0                            
000087A0                            ArtKosM_RingSparkle:
000087A0                            		incbin	"Graphics/Sprites/Ring/Art - Sparkle.kosm"
000087EC 00                         		even
000087EC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000087EC                            ArtKosM_SpikesN:
000087EC                            		incbin	"Graphics/Sprites/Spikes/Art - Normal.kosm"
0000882C                            		even
0000882C                            
0000882C                            ArtKosM_SpikesS:
0000882C                            		incbin	"Graphics/Sprites/Spikes/Art - Sideways.kosm"
0000886E 00                         		even
0000886E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000886E                            ArtKosM_SpringH:
0000886E                            		incbin	"Graphics/Sprites/Spring/Art - Horizontal.kosm"
0000894A 00                         		even
0000894A                            
0000894A                            ArtKosM_SpringV:
0000894A                            		incbin	"Graphics/Sprites/Spring/Art - Vertical.kosm"
00008A30 00                         		even
00008A30                            
00008A30                            ArtKosM_SpringD:
00008A30                            		incbin	"Graphics/Sprites/Spring/Art - Diagonal.kosm"
00008C4A 00                         		even
00008C4A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00008C4A                            ArtKosM_WaterSplash:
00008C4A                            		incbin	"Graphics/Sprites/Water Splash/Art.kosm"
0000945E                            		even
0000945E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000945E                            ArtKosM_WaterSurface:
0000945E                            		incbin	"Graphics/Sprites/Water Surface/Art.kosm"
000095B8                            		even
000095B8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000095B8                            ArtKosM_HUD:
000095B8                            		incbin	"Graphics/Sprites/HUD/Art - HUD Base.kosm"
0000962E                            		even
0000962E                            
0000962E                            ArtUnc_HUDNumbers:
0000962E                            		incbin	"Graphics/Sprites/HUD/Art - HUD Numbers.unc"
000098AE 0000 0000 0000 0000 0000+  		dcb.l	16, 0
000098EE                            		even
000098EE                            
000098EE                            ; =========================================================================================================================================================
000098EE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000098EE                            ; Level data
000098EE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000098EE                            ; Wacky Workbench Zone
000098EE                            
000098EE                            WWZ_FGLayout:
000098EE                            		incbin	"Zones/Wacky Workbench/Foreground.lvl"
0000A110                            		even
0000A110                            WWZ_BGLayout:
0000A110                            		incbin	"Zones/Wacky Workbench/Background.lvl"
0000A136                            		even
0000A136                            
0000A136 FFFF 0000 0000             		dc.w	$FFFF, 0, 0				; Null object list entry
0000A13C                            WWZ_Objects:
0000A13C                            		incbin	"Zones/Wacky Workbench/Objects.bin"
0000A148                            		even
0000A148                            WWZ_Rings:
0000A148                            		incbin	"Zones/Wacky Workbench/Rings.bin"
0000A14C                            		even
0000A14C                            WWZ_Collision:
0000A14C 0000 0000 0000 0000 0000+  		dc.l	.ColData, .Angles, .Heights, .HeightsR
0000A15C                            .ColData:
0000A15C                            		incbin	"Zones/Wacky Workbench/Collision.bin"
0000A75C                            		even
0000A75C                            .Angles:
0000A75C                            		incbin	"Zones/Wacky Workbench/Angle Values.bin"
0000A85C                            		even
0000A85C                            .Heights:
0000A85C                            		incbin	"Zones/Wacky Workbench/Height Values.bin"
0000B85C                            		even
0000B85C                            .HeightsR:
0000B85C                            		incbin	"Zones/Wacky Workbench/Height Values (Rotated).bin"
0000C85C                            		even
0000C85C                            WWZ_Chunks:
0000C85C                            		incbin	"Zones/Wacky Workbench/Chunks.bin"
0000C8C6                            		even
0000C8C6                            WWZ_Blocks:
0000C8C6                            		incbin	"Zones/Wacky Workbench/Blocks.bin"
0000C8F0                            		even
0000C8F0                            WWZ_Pal:
0000C8F0 007F                       		dc.w	$100>>1-1
0000C8F2                            		incbin	"Graphics/Palettes/Wacky Workbench/Normal.pal"
0000C972                                    WWZ_Pal_End:
0000C972                            		incbin	"Graphics/Palettes/Wacky Workbench/Water.pal"
0000C9F2                            		even
0000C9F2                            WWZ_Tiles:
0000C9F2                            		incbin	"Graphics/Tilesets/Wacky Workbench/Tiles.kosm"
0000CA7C                            		even
0000CA7C                            ArtUnc_Electricity:
0000CA7C                            		incbin	"Graphics/Tilesets/Wacky Workbench/Electricity.unc"
0000CE7C                            		even
0000CE7C                            ArtUnc_ElectricOrbs:
0000CE7C                            		incbin	"Graphics/Tilesets/Wacky Workbench/Electric Orbs.unc"
0000D07C                            		even
0000D07C                            ArtUnc_Sirens:
0000D07C                            		incbin	"Graphics/Tilesets/Wacky Workbench/Sirens.unc"
0000D27C                            		even
0000D27C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000D27C                            
0000D27C                            ; =========================================================================================================================================================
0000D27C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000D27C                            ; Sound driver
0000D27C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000D27C                            		include	"Sound/amps/code/68k.asm"
0000D27C                            	opt oz+					; enable zero-offset optimization
0000D27C                            	opt l.					; local lables are dots
0000D27C                            	opt ae+					; enable automatic even's
0000D27C                            
0000D27C                            	include "Sound/amps/code/routines.asm"	; include macro'd routines
0000D27C                            ; ===========================================================================
0000D27C                            ; ---------------------------------------------------------------------------
0000D27C                            ; Note timout handler macro
0000D27C                            ; ---------------------------------------------------------------------------
0000D27C                            
0000D27C                            dNoteToutHandler	macro
0000D27C                            		tst.b	cNoteTimeCur(a5)	; check if timer is 0
0000D27C                            		beq.s	.endt			; if is, do not timeout
0000D27C                            		subq.b	#1,cNoteTimeCur(a5)	; decrease delay by 1
0000D27C                            		bne.s	.endt			; if still not 0, branch
0000D27C                                endm
0000D27C                            ; ===========================================================================
0000D27C                            ; ---------------------------------------------------------------------------
0000D27C                            ; Note timout handler macro for DAC
0000D27C                            ; ---------------------------------------------------------------------------
0000D27C                            
0000D27C                            dNoteToutDAC	macro
0000D27C                            	dNoteToutHandler			; include timeout handler
0000D27C                            		moveq	#0,d0			; play stop sample
0000D27C                            		bra.w	dNoteOnDAC2		; ''
0000D27C                            .endt
0000D27C                                endm
0000D27C                            ; ===========================================================================
0000D27C                            ; ---------------------------------------------------------------------------
0000D27C                            ; Note timout handler macro for FM
0000D27C                            ; ---------------------------------------------------------------------------
0000D27C                            
0000D27C                            dNoteToutFM	macro
0000D27C                            	dNoteToutHandler			; include timeout handler
0000D27C                            		bset	#cfbRest,(a5)		; set track to resting
0000D27C                            		bsr.w	dKeyOffFM		; key off FM
0000D27C                            		bra.\0	.next			; jump to next track
0000D27C                            .endt
0000D27C                                endm
0000D27C                            ; ===========================================================================
0000D27C                            ; ---------------------------------------------------------------------------
0000D27C                            ; Note timout handler macro for PSG
0000D27C                            ; ---------------------------------------------------------------------------
0000D27C                            
0000D27C                            dNoteToutPSG	macro
0000D27C                            	dNoteToutHandler			; include timeout handler
0000D27C                            		bset	#cfbRest,(a5)		; set track to resting
0000D27C                            		bsr.w	dMutePSGmus		; mute PSG channel
0000D27C                            		bra.s	.next			; jump to next track
0000D27C                            .endt
0000D27C                                endm
0000D27C                            ; ===========================================================================
0000D27C                            ; ---------------------------------------------------------------------------
0000D27C                            ; Macro for calculating the current frequency (without modulation) into d6.
0000D27C                            ; Used if user wants to add extra pitch effects such as pitch slides.
0000D27C                            ; ---------------------------------------------------------------------------
0000D27C                            
0000D27C                            dCalcFreq	macro
0000D27C                            		move.b	cDetune(a5),d6		; get detune value to d6
0000D27C                            		ext.w	d6			; extend to word
0000D27C                            		add.w	cFreq(a5),d6		; add channel base frequency to it
0000D27C                                endm
0000D27C                            ; ===========================================================================
0000D27C                            ; ---------------------------------------------------------------------------
0000D27C                            ; Macro for generating frequency modulation code
0000D27C                            ; ---------------------------------------------------------------------------
0000D27C                            
0000D27C                            dModulate	macro jump,loop,type
0000D27C                            		btst	#cfbMod,(a5)		; check if modulation is active
0000D27C                            		beq.s	.noret			; if not, update volume and return
0000D27C                            		tst.b	cModDelay(a5)		; check if there is delay left
0000D27C                            		beq.s	.started		; if not, modulate!
0000D27C                            		subq.b	#1,cModDelay(a5)	; decrease delay
0000D27C                            .noret
0000D27C                            	if narg>0
0000D27C                            		if narg=3
0000D27C                            			if type<2
0000D27C                            				bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0000D27C                            				beq.s	.noupdatevol		; if not, skip
0000D27C                            				jsr	dUpdateVolFM(pc)	; update FM volume
0000D27C                            			.noupdatevol:
0000D27C                            			endif
0000D27C                            			if type>=4
0000D27C                            				bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0000D27C                            				beq.s	.noupdatevol		; if not, skip
0000D27C                            				jsr	dUpdateVolDAC(pc)	; update DAC volume
0000D27C                            			.noupdatevol:
0000D27C                            			endif
0000D27C                            			if \type<>5
0000D27C                            				dbf	d7,\loop		; loop for all channels
0000D27C                            			endif
0000D27C                            		endif
0000D27C                            		bra.w	\jump			; jump to next routine
0000D27C                            	else
0000D27C                            		bra.s	.endm			; jump to the next .endm routine
0000D27C                            	endif
0000D27C                            .started
0000D27C                            		subq.b	#1,cModSpeed(a5)	; decrease modulation speed counter
0000D27C                            		bne.s	.noret			; if there's still delay left, update vol and return
0000D27C                            		movea.l	cMod(a5),a1		; get modulation data offset to a1
0000D27C                            		move.b	1(a1),cModSpeed(a5)	; reset modulation speed counter
0000D27C                            		tst.b	cModCount(a5)		; check if this was the last step
0000D27C                            		bne.s	.norev			; if was not, do not reverse
0000D27C                            		move.b	3(a1),cModCount(a5)	; reset steps counter
0000D27C                            		neg.b	cModStep(a5)		; negate step amount
0000D27C                            .norev
0000D27C                            		subq.b	#1,cModCount(a5)	; decrease step counter
0000D27C                            		move.b	cModStep(a5),d5		; get step offset into d5
0000D27C                            		ext.w	d5			; extend to word
0000D27C                            		add.w	cModFreq(a5),d5		; add modulation frequency to it
0000D27C                            		move.w	d5,cModFreq(a5)		; save as the modulation frequency
0000D27C                            		add.w	d5,d6			; add to channel base frequency
0000D27C                                endm
0000D27C                            ; ===========================================================================
0000D27C                            ; ---------------------------------------------------------------------------
0000D27C                            ; Macro for processing the tracker
0000D27C                            ; ---------------------------------------------------------------------------
0000D27C                            
0000D27C                            dDoTracker	macro
0000D27C                            		movea.l	cData(a5),a4		; grab tracker address
0000D27C                            	if safe=1
0000D27C                            		AMPS_Debug_TrackUpd		; check if this address is valid
0000D27C                            	endif
0000D27C                            .data
0000D27C                            		moveq	#0,d5
0000D27C                            		move.b	(a4)+,d5		; get a byte from tracker
0000D27C                            		cmpi.b	#$E0,d5			; is this a command?
0000D27C                            		blo.s	.notcomm		; if not, continue
0000D27C                            		jsr	dCommands(pc)		; run the condition flag
0000D27C                            		bra.s	.data			; for most commands, use this branch to loop
0000D27C                            		bra.s	.next			; however, for example sStop will make us return here.
0000D27C                            .notcomm
0000D27C                                endm
0000D27C                            ; ===========================================================================
0000D27C                            ; ---------------------------------------------------------------------------
0000D27C                            ; Macro for playing a note, and setting up for it (software updates only)
0000D27C                            ; ---------------------------------------------------------------------------
0000D27C                            
0000D27C                            dProcNote	macro sfx, psg
0000D27C                            		move.l	a4,cData(a5)		; save tracker address
0000D27C                            		move.b	cLastDur(a5),cDuration(a5); copy stored duration
0000D27C                            		btst	#cfbHold,(a5)		; check if we are holding
0000D27C                            		bne.s	.endpn			; if we are, branch
0000D27C                            	if sfx=0
0000D27C                            		move.b	cNoteTimeMain(a5),cNoteTimeCur(a5); copy note timeout value
0000D27C                            	endif
0000D27C                            	if psg<>0
0000D27C                            		clr.b	cEnvPos(a5)		; clear envelope position if PSG channel
0000D27C                            	endif
0000D27C                            		btst	#cfbMod,(a5)		; check if modulation is enabled
0000D27C                            		beq.s	.endpn			; if not, branch
0000D27C                            		movea.l	cMod(a5),a1		; get modulation data address
0000D27C                            		move.b	(a1)+,cModDelay(a5)	; copy delay
0000D27C                            		move.b	(a1)+,cModSpeed(a5)	; copy speed
0000D27C                            		move.b	(a1)+,cModStep(a5)	; copy step offset
0000D27C                            		move.b	(a1),d0			; get number of steps
0000D27C                            		lsr.b	#1,d0			; halve it
0000D27C                            		move.b	d0,cModCount(a5)	; save as the current number of steps
0000D27C                            		clr.w	cModFreq(a5)		; clear frequency offset
0000D27C                            .endpn
0000D27C                                endm
0000D27C                            ; ===========================================================================
0000D27C                            ; ---------------------------------------------------------------------------
0000D27C                            ; Macro for processing a note in DAC channel
0000D27C                            ; ---------------------------------------------------------------------------
0000D27C                            
0000D27C                            dTrackNoteDAC	macro
0000D27C                            		btst	#cfbMode,(a5)		; check if we are on pitch mode
0000D27C                            		bne.s	.pitch			; if so, load pitch
0000D27C                            		move.b	d5,cSample(a5)		; else, save as a sample
0000D27C                            		bra.s	.cont
0000D27C                            .pitch
0000D27C                            		subi.b	#$80,d5			; sub $80 from the note (notes start at $80)
0000D27C                            		bne.s	.noprest		; branch if note wasnt $80 (rest)
0000D27C                            		moveq	#0,d0			; play stop sample
0000D27C                            		bsr.w	dNoteOnDAC2		; ''
0000D27C                            		moveq	#-$80,d6		; tell the code we are resting
0000D27C                            		bra.s	.cont
0000D27C                            .noprest
0000D27C                            		add.b	cPitch(a5),d5		; add pitch offset to note
0000D27C                            		add.w	d5,d5			; double offset (each entry is a word)
0000D27C                            		lea	dFreqDAC(pc),a1		; load DAC frequency table to a1
0000D27C                            		move.w	(a1,d5.w),cFreq(a5)	; load and save the requested frequency
0000D27C                            .cont
0000D27C                                endm
0000D27C                            ; ===========================================================================
0000D27C                            ; ---------------------------------------------------------------------------
0000D27C                            ; Macro for doing keying-on FM channel
0000D27C                            ; ---------------------------------------------------------------------------
0000D27C                            
0000D27C                            dKeyOnFM	macro
0000D27C                            		btst	#cfbHold,(a5)		; check if note is held
0000D27C                            		bne.s	.k			; if so, do not note on
0000D27C                            		btst	#cfbRest,(a5)		; check if channel is resting
0000D27C                            		bne.s	.k			; if so, do not note on
0000D27C                            	if narg=0
0000D27C                            		btst	#cfbInt,(a5)		; check if overridden by sfx
0000D27C                            		bne.s	.k			; if so, do not note on
0000D27C                            	endif
0000D27C                            		moveq	#$28,d0			; YM command: Key on
0000D27C                            		move.b	cType(a5),d1		; get channel type bits
0000D27C                            		ori.b	#$F0,d1			; turn all FM operators on
0000D27C                            		bsr.w	WriteYM_Pt1		; send note-on event
0000D27C                            .k
0000D27C                                endm
0000D27C                            ; ===========================================================================
0000D27C                            ; ---------------------------------------------------------------------------
0000D27C                            ; Macro for processing a note in PSG channel
0000D27C                            ; ---------------------------------------------------------------------------
0000D27C                            
0000D27C                            dGetFreqPSG	macro
0000D27C                            		subi.b	#$81,d5			; sub $81 from the note (notes start at $80)
0000D27C                            		bhs.s	.norest			; branch if note wasnt $80 (rest)
0000D27C                            		bset	#cfbRest,(a5)		; set channel to resting
0000D27C                            		move.w	#-1,cFreq(a5)		; set invalid PSG frequency
0000D27C                            		jsr	dMutePSGmus(pc)		; mute this PSG channel
0000D27C                            		bra.s	.freqgot
0000D27C                            .norest
0000D27C                            		add.b	cPitch(a5),d5		; add pitch offset to note
0000D27C                            		andi.w	#$7F,d5			; keep within $80 notes
0000D27C                            		add.w	d5,d5			; double offset (each entry is a word)
0000D27C                            		move.w	(a6,d5.w),cFreq(a5)	; load and save the requested frequency
0000D27C                            	if safe=1
0000D27C                            		AMPS_Debug_NotePSG		; check if the note was valid
0000D27C                            	endif
0000D27C                            .freqgot
0000D27C                                endm
0000D27C                            ; ===========================================================================
0000D27C                            	include "Sound/amps/code/debug.asm"	; debug data blob
0000D27C                            ; ===========================================================================
0000D27C                            ; ---------------------------------------------------------------------------
0000D27C                            ; write channel string to console
0000D27C                            ; ---------------------------------------------------------------------------
0000D27C                            
0000D27C                            AMPS_Debug_GetChannel	macro
0000D27C                            	cmp.w	#mPSG1,a5
0000D27C                            	bne.s	AMPS_Debug_Writepsg2
0000D27C                            	Console.Write "PSG1"
0000D27C                            	bra.w	AMPS_Debug_Writeend
0000D27C                            AMPS_Debug_Writepsg2
0000D27C                            	cmp.w	#mPSG2,a5
0000D27C                            	bne.s	AMPS_Debug_Writepsg3
0000D27C                            	Console.Write "PSG2"
0000D27C                            	bra.w	AMPS_Debug_Writeend
0000D27C                            AMPS_Debug_Writepsg3
0000D27C                            	cmp.w	#mPSG3,a5
0000D27C                            	bne.s	AMPS_Debug_Writepsgs1
0000D27C                            	Console.Write "PSG3"
0000D27C                            	bra.w	AMPS_Debug_Writeend
0000D27C                            AMPS_Debug_Writepsgs1
0000D27C                            	cmp.w	#mSFXPSG1,a5
0000D27C                            	bne.s	AMPS_Debug_Writepsgs2
0000D27C                            	Console.Write "SFX PSG1"
0000D27C                            	bra.w	AMPS_Debug_Writeend
0000D27C                            AMPS_Debug_Writepsgs2
0000D27C                            	cmp.w	#mSFXPSG2,a5
0000D27C                            	bne.s	AMPS_Debug_Writepsgs3
0000D27C                            	Console.Write "SFX PSG2"
0000D27C                            	bra.w	AMPS_Debug_Writeend
0000D27C                            AMPS_Debug_Writepsgs3
0000D27C                            	cmp.w	#mSFXPSG3,a5
0000D27C                            	bne.s	AMPS_Debug_Writedacs1
0000D27C                            	Console.Write "SFX PSG3"
0000D27C                            	bra.w	AMPS_Debug_Writeend
0000D27C                            AMPS_Debug_Writedacs1
0000D27C                            	cmp.w	#mSFXDAC1,a5
0000D27C                            	bne.s	AMPS_Debug_Writedac1
0000D27C                            	Console.Write "SFX DAC1"
0000D27C                            	bra.w	AMPS_Debug_Writeend
0000D27C                            AMPS_Debug_Writedac1
0000D27C                            	cmp.w	#mDAC1,a5
0000D27C                            	bne.s	AMPS_Debug_Writedac2
0000D27C                            	Console.Write "DAC1"
0000D27C                            	bra.w	AMPS_Debug_Writeend
0000D27C                            AMPS_Debug_Writedac2
0000D27C                            	cmp.w	#mDAC2,a5
0000D27C                            	bne.s	AMPS_Debug_Writefm1
0000D27C                            	Console.Write "DAC2"
0000D27C                            	bra.w	AMPS_Debug_Writeend
0000D27C                            AMPS_Debug_Writefm1
0000D27C                            	cmp.w	#mFM1,a5
0000D27C                            	bne.s	AMPS_Debug_Writefm2
0000D27C                            	Console.Write "FM1"
0000D27C                            	bra.w	AMPS_Debug_Writeend
0000D27C                            AMPS_Debug_Writefm2
0000D27C                            	cmp.w	#mFM2,a5
0000D27C                            	bne.s	AMPS_Debug_Writefm3
0000D27C                            	Console.Write "FM2"
0000D27C                            	bra.w	AMPS_Debug_Writeend
0000D27C                            AMPS_Debug_Writefm3
0000D27C                            	cmp.w	#mFM3,a5
0000D27C                            	bne.s	AMPS_Debug_Writefm4
0000D27C                            	Console.Write "FM3"
0000D27C                            	bra.w	AMPS_Debug_Writeend
0000D27C                            AMPS_Debug_Writefm4
0000D27C                            	cmp.w	#mFM4,a5
0000D27C                            	bne.s	AMPS_Debug_Writefm5
0000D27C                            	Console.Write "FM4"
0000D27C                            	bra.w	AMPS_Debug_Writeend
0000D27C                            AMPS_Debug_Writefm5
0000D27C                            	cmp.w	#mFM5,a5
0000D27C                            	bne.s	AMPS_Debug_Writefms3
0000D27C                            	Console.Write "FM5"
0000D27C                            	bra.w	AMPS_Debug_Writeend
0000D27C                            AMPS_Debug_Writefms3
0000D27C                            	cmp.w	#mSFXFM3,a5
0000D27C                            	bne.s	AMPS_Debug_Writefms4
0000D27C                            	Console.Write "SFX FM3"
0000D27C                            	rts
0000D27C                            AMPS_Debug_Writefms4
0000D27C                            	cmp.w	#mSFXFM4,a5
0000D27C                            	bne.s	AMPS_Debug_Writefms5
0000D27C                            	Console.Write "SFX FM4"
0000D27C                            	bra.s	AMPS_Debug_Writeend
0000D27C                            AMPS_Debug_Writefms5
0000D27C                            	cmp.w	#mSFXFM5,a5
0000D27C                            	beq.s	AMPS_Debug_Writefms5_
0000D27C                            AMPS_Debug_Writeaddr
0000D27C                            	Console.Write "%<fpal2>%<.l a5>"
0000D27C                            	rts
0000D27C                            AMPS_Debug_Writefms5_
0000D27C                            	Console.Write "SFX FM5"
0000D27C                            AMPS_Debug_Writeend
0000D27C                            	endm
0000D27C                            ; ===========================================================================
0000D27C                            ; ---------------------------------------------------------------------------
0000D27C                            ; Channel console code
0000D27C                            ; ---------------------------------------------------------------------------
0000D27C                            
0000D27C                            AMPS_Debug_Console_Channel:
0000D27C                            	Console.WriteLine "  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D27C 40E7                     M 	move.w	sr,-(sp)
0000D27E                          M 	__fstring_generateargumentscode	"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D27E =00000003                M 	__pos:	set instr("  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000D27E =00000000                M 	__stack:set	0
0000D27E =00000000                M 	__sp:	set 0
0000D27E                          M 	while	(__pos)
0000D27E =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000D27E =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000D27E =0000000A                M 	__midpos:	= __endpos
0000D27E                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D27E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D27E =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000D27E =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000D27E =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000D27E =00000016                M 	__midpos:	= __endpos
0000D27E                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D27E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D27E =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000D27E =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000D27E =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000D27E =0000001E                M 	__midpos:	= __endpos
0000D27E                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D27E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D27E                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D27E                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D27E                          M 	pushp	"move.l d0,-(sp)"
0000D27E =00000001                M 	__stack:	= __stack+1
0000D27E =00000004                M 	__sp:	= __sp+4
0000D27E =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000D27E =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000D27E =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000D27E =00000028                M 	__midpos:	= __endpos
0000D27E                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D27E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D27E =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000D27E =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000D27E =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000D27E =00000034                M 	__midpos:	= __endpos
0000D27E                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D27E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D27E =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000D27E =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000D27E =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000D27E =0000003C                M 	__midpos:	= __endpos
0000D27E                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D27E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D27E                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D27E                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D27E                          M 	pushp	"move.l a0,-(sp)"
0000D27E =00000002                M 	__stack:	= __stack+1
0000D27E =00000008                M 	__sp:	= __sp+4
0000D27E =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000D27E                          M 	rept	__stack
0000D27E                          M 	popp	__command
0000D27E 2F08                     M 	move.l	a0,-(sp)
0000D280                          M 	popp	__command
0000D280 2F00                     M 	move.l	d0,-(sp)
0000D282 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D286 45EF 0010                M 	lea	4*4(sp),a2
0000D28A 43FA 0000                M 	lea	.str_276(pc),a1
0000D28E 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000D294 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D298 504F                     M 	addq.w	#__sp,sp
0000D29A 46DF                     M 	move.w	(sp)+,sr
0000D29C 6000 0000                M 	bra.w	.instr_end_276
0000D2A0                          M 	.str_276:
0000D2A0                          M 	__fstring_generatedecodedstring	"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D2A0 =00000001                M 	__lpos:	set 1
0000D2A0 =00000003                M 	__pos:	set instr("  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000D2A0                          M 	while	(__pos)
0000D2A0                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D2A0 2020                     M 	dc.b	"  "
0000D2A2 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000D2A2 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000D2A2 =0000000A                M 	__midpos:	= __endpos
0000D2A2                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D2A2                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D2A2 E8                       M 	dc.b	fpal0
0000D2A3 =0000000B                M 	__lpos:	set __endpos+1
0000D2A3 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000D2A3                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D2A3 6430 3A20                M 	dc.b	"d0: "
0000D2A7 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000D2A7 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000D2A7 =00000016                M 	__midpos:	= __endpos
0000D2A7                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D2A7                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D2A7 EC                       M 	dc.b	fpal2
0000D2A8 =00000017                M 	__lpos:	set __endpos+1
0000D2A8 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000D2A8                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D2A8                          M 	dc.b	""
0000D2A8 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000D2A8 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000D2A8 =0000001E                M 	__midpos:	= __endpos
0000D2A8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D2A8                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D2A8                          M 	__param:	substr ,,"hex"
0000D2A8 83                       M 	dc.b	hex|3
0000D2A9 =0000001F                M 	__lpos:	set __endpos+1
0000D2A9 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000D2A9                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D2A9 2020                     M 	dc.b	"  "
0000D2AB =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000D2AB =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000D2AB =00000028                M 	__midpos:	= __endpos
0000D2AB                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D2AB                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D2AB E8                       M 	dc.b	fpal0
0000D2AC =00000029                M 	__lpos:	set __endpos+1
0000D2AC =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000D2AC                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D2AC 6130 3A20                M 	dc.b	"a0: "
0000D2B0 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000D2B0 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000D2B0 =00000034                M 	__midpos:	= __endpos
0000D2B0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D2B0                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D2B0 EC                       M 	dc.b	fpal2
0000D2B1 =00000035                M 	__lpos:	set __endpos+1
0000D2B1 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000D2B1                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D2B1                          M 	dc.b	""
0000D2B1 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000D2B1 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000D2B1 =0000003C                M 	__midpos:	= __endpos
0000D2B1                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D2B1                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D2B1                          M 	__param:	substr ,,"hex"
0000D2B1 83                       M 	dc.b	hex|3
0000D2B2 =0000003D                M 	__lpos:	set __endpos+1
0000D2B2 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000D2B2                          M 	__substr:	substr __lpos,,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000D2B2                          M 	dc.b	""
0000D2B2 00                       M 	dc.b	0
0000D2B4 00                       M 	even
0000D2B4                          M 	.instr_end_276:
0000D2B4                            	Console.WriteLine "  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D2B4 40E7                     M 	move.w	sr,-(sp)
0000D2B6                          M 	__fstring_generateargumentscode	"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D2B6 =00000003                M 	__pos:	set instr("  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000D2B6 =00000000                M 	__stack:set	0
0000D2B6 =00000000                M 	__sp:	set 0
0000D2B6                          M 	while	(__pos)
0000D2B6 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000D2B6 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000D2B6 =0000000A                M 	__midpos:	= __endpos
0000D2B6                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D2B6                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D2B6 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000D2B6 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000D2B6 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000D2B6 =00000016                M 	__midpos:	= __endpos
0000D2B6                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D2B6                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D2B6 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000D2B6 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000D2B6 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000D2B6 =0000001E                M 	__midpos:	= __endpos
0000D2B6                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D2B6                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D2B6                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D2B6                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D2B6                          M 	pushp	"move.l d1,-(sp)"
0000D2B6 =00000001                M 	__stack:	= __stack+1
0000D2B6 =00000004                M 	__sp:	= __sp+4
0000D2B6 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000D2B6 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000D2B6 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000D2B6 =00000028                M 	__midpos:	= __endpos
0000D2B6                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D2B6                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D2B6 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000D2B6 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000D2B6 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000D2B6 =00000034                M 	__midpos:	= __endpos
0000D2B6                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D2B6                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D2B6 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000D2B6 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000D2B6 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000D2B6 =0000003C                M 	__midpos:	= __endpos
0000D2B6                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D2B6                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D2B6                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D2B6                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D2B6                          M 	pushp	"move.l a1,-(sp)"
0000D2B6 =00000002                M 	__stack:	= __stack+1
0000D2B6 =00000008                M 	__sp:	= __sp+4
0000D2B6 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000D2B6                          M 	rept	__stack
0000D2B6                          M 	popp	__command
0000D2B6 2F09                     M 	move.l	a1,-(sp)
0000D2B8                          M 	popp	__command
0000D2B8 2F01                     M 	move.l	d1,-(sp)
0000D2BA 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D2BE 45EF 0010                M 	lea	4*4(sp),a2
0000D2C2 43FA 0000                M 	lea	.str_279(pc),a1
0000D2C6 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000D2CC 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D2D0 504F                     M 	addq.w	#__sp,sp
0000D2D2 46DF                     M 	move.w	(sp)+,sr
0000D2D4 6000 0000                M 	bra.w	.instr_end_279
0000D2D8                          M 	.str_279:
0000D2D8                          M 	__fstring_generatedecodedstring	"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D2D8 =00000001                M 	__lpos:	set 1
0000D2D8 =00000003                M 	__pos:	set instr("  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000D2D8                          M 	while	(__pos)
0000D2D8                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D2D8 2020                     M 	dc.b	"  "
0000D2DA =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000D2DA =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000D2DA =0000000A                M 	__midpos:	= __endpos
0000D2DA                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D2DA                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D2DA E8                       M 	dc.b	fpal0
0000D2DB =0000000B                M 	__lpos:	set __endpos+1
0000D2DB =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000D2DB                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D2DB 6431 3A20                M 	dc.b	"d1: "
0000D2DF =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000D2DF =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000D2DF =00000016                M 	__midpos:	= __endpos
0000D2DF                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D2DF                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D2DF EC                       M 	dc.b	fpal2
0000D2E0 =00000017                M 	__lpos:	set __endpos+1
0000D2E0 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000D2E0                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D2E0                          M 	dc.b	""
0000D2E0 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000D2E0 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000D2E0 =0000001E                M 	__midpos:	= __endpos
0000D2E0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D2E0                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D2E0                          M 	__param:	substr ,,"hex"
0000D2E0 83                       M 	dc.b	hex|3
0000D2E1 =0000001F                M 	__lpos:	set __endpos+1
0000D2E1 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000D2E1                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D2E1 2020                     M 	dc.b	"  "
0000D2E3 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000D2E3 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000D2E3 =00000028                M 	__midpos:	= __endpos
0000D2E3                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D2E3                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D2E3 E8                       M 	dc.b	fpal0
0000D2E4 =00000029                M 	__lpos:	set __endpos+1
0000D2E4 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000D2E4                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D2E4 6131 3A20                M 	dc.b	"a1: "
0000D2E8 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000D2E8 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000D2E8 =00000034                M 	__midpos:	= __endpos
0000D2E8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D2E8                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D2E8 EC                       M 	dc.b	fpal2
0000D2E9 =00000035                M 	__lpos:	set __endpos+1
0000D2E9 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000D2E9                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D2E9                          M 	dc.b	""
0000D2E9 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000D2E9 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000D2E9 =0000003C                M 	__midpos:	= __endpos
0000D2E9                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D2E9                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D2E9                          M 	__param:	substr ,,"hex"
0000D2E9 83                       M 	dc.b	hex|3
0000D2EA =0000003D                M 	__lpos:	set __endpos+1
0000D2EA =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000D2EA                          M 	__substr:	substr __lpos,,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000D2EA                          M 	dc.b	""
0000D2EA 00                       M 	dc.b	0
0000D2EC 00                       M 	even
0000D2EC                          M 	.instr_end_279:
0000D2EC                            	Console.WriteLine "  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D2EC 40E7                     M 	move.w	sr,-(sp)
0000D2EE                          M 	__fstring_generateargumentscode	"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D2EE =00000003                M 	__pos:	set instr("  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000D2EE =00000000                M 	__stack:set	0
0000D2EE =00000000                M 	__sp:	set 0
0000D2EE                          M 	while	(__pos)
0000D2EE =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000D2EE =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000D2EE =0000000A                M 	__midpos:	= __endpos
0000D2EE                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D2EE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D2EE =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000D2EE =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000D2EE =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000D2EE =00000016                M 	__midpos:	= __endpos
0000D2EE                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D2EE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D2EE =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000D2EE =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000D2EE =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000D2EE =0000001E                M 	__midpos:	= __endpos
0000D2EE                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D2EE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D2EE                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D2EE                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D2EE                          M 	pushp	"move.l d2,-(sp)"
0000D2EE =00000001                M 	__stack:	= __stack+1
0000D2EE =00000004                M 	__sp:	= __sp+4
0000D2EE =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000D2EE =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000D2EE =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000D2EE =00000028                M 	__midpos:	= __endpos
0000D2EE                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D2EE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D2EE =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000D2EE =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000D2EE =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000D2EE =00000034                M 	__midpos:	= __endpos
0000D2EE                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D2EE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D2EE =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000D2EE =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000D2EE =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000D2EE =0000003C                M 	__midpos:	= __endpos
0000D2EE                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D2EE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D2EE                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D2EE                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D2EE                          M 	pushp	"move.l a2,-(sp)"
0000D2EE =00000002                M 	__stack:	= __stack+1
0000D2EE =00000008                M 	__sp:	= __sp+4
0000D2EE =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000D2EE                          M 	rept	__stack
0000D2EE                          M 	popp	__command
0000D2EE 2F0A                     M 	move.l	a2,-(sp)
0000D2F0                          M 	popp	__command
0000D2F0 2F02                     M 	move.l	d2,-(sp)
0000D2F2 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D2F6 45EF 0010                M 	lea	4*4(sp),a2
0000D2FA 43FA 0000                M 	lea	.str_282(pc),a1
0000D2FE 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000D304 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D308 504F                     M 	addq.w	#__sp,sp
0000D30A 46DF                     M 	move.w	(sp)+,sr
0000D30C 6000 0000                M 	bra.w	.instr_end_282
0000D310                          M 	.str_282:
0000D310                          M 	__fstring_generatedecodedstring	"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D310 =00000001                M 	__lpos:	set 1
0000D310 =00000003                M 	__pos:	set instr("  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000D310                          M 	while	(__pos)
0000D310                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D310 2020                     M 	dc.b	"  "
0000D312 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000D312 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000D312 =0000000A                M 	__midpos:	= __endpos
0000D312                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D312                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D312 E8                       M 	dc.b	fpal0
0000D313 =0000000B                M 	__lpos:	set __endpos+1
0000D313 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000D313                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D313 6432 3A20                M 	dc.b	"d2: "
0000D317 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000D317 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000D317 =00000016                M 	__midpos:	= __endpos
0000D317                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D317                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D317 EC                       M 	dc.b	fpal2
0000D318 =00000017                M 	__lpos:	set __endpos+1
0000D318 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000D318                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D318                          M 	dc.b	""
0000D318 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000D318 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000D318 =0000001E                M 	__midpos:	= __endpos
0000D318                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D318                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D318                          M 	__param:	substr ,,"hex"
0000D318 83                       M 	dc.b	hex|3
0000D319 =0000001F                M 	__lpos:	set __endpos+1
0000D319 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000D319                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D319 2020                     M 	dc.b	"  "
0000D31B =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000D31B =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000D31B =00000028                M 	__midpos:	= __endpos
0000D31B                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D31B                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D31B E8                       M 	dc.b	fpal0
0000D31C =00000029                M 	__lpos:	set __endpos+1
0000D31C =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000D31C                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D31C 6132 3A20                M 	dc.b	"a2: "
0000D320 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000D320 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000D320 =00000034                M 	__midpos:	= __endpos
0000D320                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D320                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D320 EC                       M 	dc.b	fpal2
0000D321 =00000035                M 	__lpos:	set __endpos+1
0000D321 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000D321                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D321                          M 	dc.b	""
0000D321 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000D321 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000D321 =0000003C                M 	__midpos:	= __endpos
0000D321                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D321                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D321                          M 	__param:	substr ,,"hex"
0000D321 83                       M 	dc.b	hex|3
0000D322 =0000003D                M 	__lpos:	set __endpos+1
0000D322 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000D322                          M 	__substr:	substr __lpos,,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000D322                          M 	dc.b	""
0000D322 00                       M 	dc.b	0
0000D324 00                       M 	even
0000D324                          M 	.instr_end_282:
0000D324                            	Console.WriteLine "  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D324 40E7                     M 	move.w	sr,-(sp)
0000D326                          M 	__fstring_generateargumentscode	"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D326 =00000003                M 	__pos:	set instr("  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000D326 =00000000                M 	__stack:set	0
0000D326 =00000000                M 	__sp:	set 0
0000D326                          M 	while	(__pos)
0000D326 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000D326 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000D326 =0000000A                M 	__midpos:	= __endpos
0000D326                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D326                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D326 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000D326 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000D326 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000D326 =00000016                M 	__midpos:	= __endpos
0000D326                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D326                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D326 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000D326 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000D326 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000D326 =0000001E                M 	__midpos:	= __endpos
0000D326                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D326                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D326                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D326                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D326                          M 	pushp	"move.l d3,-(sp)"
0000D326 =00000001                M 	__stack:	= __stack+1
0000D326 =00000004                M 	__sp:	= __sp+4
0000D326 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000D326 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000D326 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000D326 =00000028                M 	__midpos:	= __endpos
0000D326                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D326                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D326 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000D326 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000D326 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000D326 =00000034                M 	__midpos:	= __endpos
0000D326                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D326                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D326 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000D326 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000D326 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000D326 =0000003C                M 	__midpos:	= __endpos
0000D326                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D326                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D326                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D326                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D326                          M 	pushp	"move.l a3,-(sp)"
0000D326 =00000002                M 	__stack:	= __stack+1
0000D326 =00000008                M 	__sp:	= __sp+4
0000D326 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000D326                          M 	rept	__stack
0000D326                          M 	popp	__command
0000D326 2F0B                     M 	move.l	a3,-(sp)
0000D328                          M 	popp	__command
0000D328 2F03                     M 	move.l	d3,-(sp)
0000D32A 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D32E 45EF 0010                M 	lea	4*4(sp),a2
0000D332 43FA 0000                M 	lea	.str_285(pc),a1
0000D336 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000D33C 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D340 504F                     M 	addq.w	#__sp,sp
0000D342 46DF                     M 	move.w	(sp)+,sr
0000D344 6000 0000                M 	bra.w	.instr_end_285
0000D348                          M 	.str_285:
0000D348                          M 	__fstring_generatedecodedstring	"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D348 =00000001                M 	__lpos:	set 1
0000D348 =00000003                M 	__pos:	set instr("  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000D348                          M 	while	(__pos)
0000D348                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D348 2020                     M 	dc.b	"  "
0000D34A =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000D34A =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000D34A =0000000A                M 	__midpos:	= __endpos
0000D34A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D34A                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D34A E8                       M 	dc.b	fpal0
0000D34B =0000000B                M 	__lpos:	set __endpos+1
0000D34B =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000D34B                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D34B 6433 3A20                M 	dc.b	"d3: "
0000D34F =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000D34F =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000D34F =00000016                M 	__midpos:	= __endpos
0000D34F                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D34F                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D34F EC                       M 	dc.b	fpal2
0000D350 =00000017                M 	__lpos:	set __endpos+1
0000D350 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000D350                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D350                          M 	dc.b	""
0000D350 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000D350 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000D350 =0000001E                M 	__midpos:	= __endpos
0000D350                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D350                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D350                          M 	__param:	substr ,,"hex"
0000D350 83                       M 	dc.b	hex|3
0000D351 =0000001F                M 	__lpos:	set __endpos+1
0000D351 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000D351                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D351 2020                     M 	dc.b	"  "
0000D353 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000D353 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000D353 =00000028                M 	__midpos:	= __endpos
0000D353                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D353                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D353 E8                       M 	dc.b	fpal0
0000D354 =00000029                M 	__lpos:	set __endpos+1
0000D354 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000D354                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D354 6133 3A20                M 	dc.b	"a3: "
0000D358 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000D358 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000D358 =00000034                M 	__midpos:	= __endpos
0000D358                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D358                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D358 EC                       M 	dc.b	fpal2
0000D359 =00000035                M 	__lpos:	set __endpos+1
0000D359 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000D359                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D359                          M 	dc.b	""
0000D359 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000D359 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000D359 =0000003C                M 	__midpos:	= __endpos
0000D359                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D359                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D359                          M 	__param:	substr ,,"hex"
0000D359 83                       M 	dc.b	hex|3
0000D35A =0000003D                M 	__lpos:	set __endpos+1
0000D35A =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000D35A                          M 	__substr:	substr __lpos,,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000D35A                          M 	dc.b	""
0000D35A 00                       M 	dc.b	0
0000D35C 00                       M 	even
0000D35C                          M 	.instr_end_285:
0000D35C                            	Console.WriteLine "  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D35C 40E7                     M 	move.w	sr,-(sp)
0000D35E                          M 	__fstring_generateargumentscode	"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D35E =00000003                M 	__pos:	set instr("  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D35E =00000000                M 	__stack:set	0
0000D35E =00000000                M 	__sp:	set 0
0000D35E                          M 	while	(__pos)
0000D35E =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000D35E =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000D35E =0000000A                M 	__midpos:	= __endpos
0000D35E                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D35E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D35E =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D35E =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000D35E =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000D35E =00000016                M 	__midpos:	= __endpos
0000D35E                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D35E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D35E =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D35E =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000D35E =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000D35E =0000001E                M 	__midpos:	= __endpos
0000D35E                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D35E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D35E                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D35E                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D35E                          M 	pushp	"move.l d4,-(sp)"
0000D35E =00000001                M 	__stack:	= __stack+1
0000D35E =00000004                M 	__sp:	= __sp+4
0000D35E =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D35E =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000D35E =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000D35E =00000028                M 	__midpos:	= __endpos
0000D35E                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D35E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D35E =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D35E =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000D35E =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000D35E =00000034                M 	__midpos:	= __endpos
0000D35E                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D35E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D35E =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D35E =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000D35E =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000D35E =0000003C                M 	__midpos:	= __endpos
0000D35E                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D35E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D35E                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D35E                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D35E                          M 	pushp	"move.l a4,-(sp)"
0000D35E =00000002                M 	__stack:	= __stack+1
0000D35E =00000008                M 	__sp:	= __sp+4
0000D35E =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D35E                          M 	rept	__stack
0000D35E                          M 	popp	__command
0000D35E 2F0C                     M 	move.l	a4,-(sp)
0000D360                          M 	popp	__command
0000D360 2F04                     M 	move.l	d4,-(sp)
0000D362 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D366 45EF 0010                M 	lea	4*4(sp),a2
0000D36A 43FA 0000                M 	lea	.str_288(pc),a1
0000D36E 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000D374 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D378 504F                     M 	addq.w	#__sp,sp
0000D37A 46DF                     M 	move.w	(sp)+,sr
0000D37C 6000 0000                M 	bra.w	.instr_end_288
0000D380                          M 	.str_288:
0000D380                          M 	__fstring_generatedecodedstring	"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D380 =00000001                M 	__lpos:	set 1
0000D380 =00000003                M 	__pos:	set instr("  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D380                          M 	while	(__pos)
0000D380                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D380 2020                     M 	dc.b	"  "
0000D382 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000D382 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000D382 =0000000A                M 	__midpos:	= __endpos
0000D382                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D382                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D382 E8                       M 	dc.b	fpal0
0000D383 =0000000B                M 	__lpos:	set __endpos+1
0000D383 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D383                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D383 6434 3A20                M 	dc.b	"d4: "
0000D387 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000D387 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000D387 =00000016                M 	__midpos:	= __endpos
0000D387                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D387                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D387 EC                       M 	dc.b	fpal2
0000D388 =00000017                M 	__lpos:	set __endpos+1
0000D388 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D388                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D388                          M 	dc.b	""
0000D388 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000D388 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000D388 =0000001E                M 	__midpos:	= __endpos
0000D388                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D388                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D388                          M 	__param:	substr ,,"hex"
0000D388 83                       M 	dc.b	hex|3
0000D389 =0000001F                M 	__lpos:	set __endpos+1
0000D389 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D389                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D389 2020                     M 	dc.b	"  "
0000D38B =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000D38B =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000D38B =00000028                M 	__midpos:	= __endpos
0000D38B                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D38B                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D38B E8                       M 	dc.b	fpal0
0000D38C =00000029                M 	__lpos:	set __endpos+1
0000D38C =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D38C                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D38C 6134 3A20                M 	dc.b	"a4: "
0000D390 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000D390 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000D390 =00000034                M 	__midpos:	= __endpos
0000D390                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D390                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D390 EC                       M 	dc.b	fpal2
0000D391 =00000035                M 	__lpos:	set __endpos+1
0000D391 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D391                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D391                          M 	dc.b	""
0000D391 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000D391 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000D391 =0000003C                M 	__midpos:	= __endpos
0000D391                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D391                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D391                          M 	__param:	substr ,,"hex"
0000D391 83                       M 	dc.b	hex|3
0000D392 =0000003D                M 	__lpos:	set __endpos+1
0000D392 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000D392                          M 	__substr:	substr __lpos,,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000D392                          M 	dc.b	""
0000D392 00                       M 	dc.b	0
0000D394 00                       M 	even
0000D394                          M 	.instr_end_288:
0000D394                            	Console.WriteLine "  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D394 40E7                     M 	move.w	sr,-(sp)
0000D396                          M 	__fstring_generateargumentscode	"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D396 =00000003                M 	__pos:	set instr("  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D396 =00000000                M 	__stack:set	0
0000D396 =00000000                M 	__sp:	set 0
0000D396                          M 	while	(__pos)
0000D396 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000D396 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000D396 =0000000A                M 	__midpos:	= __endpos
0000D396                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D396                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D396 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D396 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000D396 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000D396 =00000016                M 	__midpos:	= __endpos
0000D396                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D396                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D396 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D396 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000D396 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000D396 =0000001E                M 	__midpos:	= __endpos
0000D396                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D396                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D396                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D396                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D396                          M 	pushp	"move.l d5,-(sp)"
0000D396 =00000001                M 	__stack:	= __stack+1
0000D396 =00000004                M 	__sp:	= __sp+4
0000D396 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D396 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000D396 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000D396 =00000028                M 	__midpos:	= __endpos
0000D396                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D396                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D396 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D396 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000D396 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000D396 =00000034                M 	__midpos:	= __endpos
0000D396                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D396                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D396 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D396 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000D396 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000D396 =0000003C                M 	__midpos:	= __endpos
0000D396                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D396                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D396                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D396                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D396                          M 	pushp	"move.l a5,-(sp)"
0000D396 =00000002                M 	__stack:	= __stack+1
0000D396 =00000008                M 	__sp:	= __sp+4
0000D396 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D396                          M 	rept	__stack
0000D396                          M 	popp	__command
0000D396 2F0D                     M 	move.l	a5,-(sp)
0000D398                          M 	popp	__command
0000D398 2F05                     M 	move.l	d5,-(sp)
0000D39A 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D39E 45EF 0010                M 	lea	4*4(sp),a2
0000D3A2 43FA 0000                M 	lea	.str_291(pc),a1
0000D3A6 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000D3AC 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D3B0 504F                     M 	addq.w	#__sp,sp
0000D3B2 46DF                     M 	move.w	(sp)+,sr
0000D3B4 6000 0000                M 	bra.w	.instr_end_291
0000D3B8                          M 	.str_291:
0000D3B8                          M 	__fstring_generatedecodedstring	"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D3B8 =00000001                M 	__lpos:	set 1
0000D3B8 =00000003                M 	__pos:	set instr("  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D3B8                          M 	while	(__pos)
0000D3B8                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D3B8 2020                     M 	dc.b	"  "
0000D3BA =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000D3BA =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000D3BA =0000000A                M 	__midpos:	= __endpos
0000D3BA                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D3BA                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D3BA E8                       M 	dc.b	fpal0
0000D3BB =0000000B                M 	__lpos:	set __endpos+1
0000D3BB =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D3BB                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D3BB 6435 3A20                M 	dc.b	"d5: "
0000D3BF =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000D3BF =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000D3BF =00000016                M 	__midpos:	= __endpos
0000D3BF                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D3BF                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D3BF EC                       M 	dc.b	fpal2
0000D3C0 =00000017                M 	__lpos:	set __endpos+1
0000D3C0 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D3C0                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D3C0                          M 	dc.b	""
0000D3C0 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000D3C0 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000D3C0 =0000001E                M 	__midpos:	= __endpos
0000D3C0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D3C0                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D3C0                          M 	__param:	substr ,,"hex"
0000D3C0 83                       M 	dc.b	hex|3
0000D3C1 =0000001F                M 	__lpos:	set __endpos+1
0000D3C1 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D3C1                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D3C1 2020                     M 	dc.b	"  "
0000D3C3 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000D3C3 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000D3C3 =00000028                M 	__midpos:	= __endpos
0000D3C3                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D3C3                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D3C3 E8                       M 	dc.b	fpal0
0000D3C4 =00000029                M 	__lpos:	set __endpos+1
0000D3C4 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D3C4                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D3C4 6135 3A20                M 	dc.b	"a5: "
0000D3C8 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000D3C8 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000D3C8 =00000034                M 	__midpos:	= __endpos
0000D3C8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D3C8                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D3C8 EC                       M 	dc.b	fpal2
0000D3C9 =00000035                M 	__lpos:	set __endpos+1
0000D3C9 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D3C9                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D3C9                          M 	dc.b	""
0000D3C9 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000D3C9 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000D3C9 =0000003C                M 	__midpos:	= __endpos
0000D3C9                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D3C9                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D3C9                          M 	__param:	substr ,,"hex"
0000D3C9 83                       M 	dc.b	hex|3
0000D3CA =0000003D                M 	__lpos:	set __endpos+1
0000D3CA =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000D3CA                          M 	__substr:	substr __lpos,,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000D3CA                          M 	dc.b	""
0000D3CA 00                       M 	dc.b	0
0000D3CC 00                       M 	even
0000D3CC                          M 	.instr_end_291:
0000D3CC                            	Console.WriteLine "  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D3CC 40E7                     M 	move.w	sr,-(sp)
0000D3CE                          M 	__fstring_generateargumentscode	"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D3CE =00000003                M 	__pos:	set instr("  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D3CE =00000000                M 	__stack:set	0
0000D3CE =00000000                M 	__sp:	set 0
0000D3CE                          M 	while	(__pos)
0000D3CE =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000D3CE =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000D3CE =0000000A                M 	__midpos:	= __endpos
0000D3CE                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D3CE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D3CE =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D3CE =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000D3CE =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000D3CE =00000016                M 	__midpos:	= __endpos
0000D3CE                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D3CE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D3CE =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D3CE =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000D3CE =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000D3CE =0000001E                M 	__midpos:	= __endpos
0000D3CE                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D3CE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D3CE                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D3CE                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D3CE                          M 	pushp	"move.l d6,-(sp)"
0000D3CE =00000001                M 	__stack:	= __stack+1
0000D3CE =00000004                M 	__sp:	= __sp+4
0000D3CE =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D3CE =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000D3CE =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000D3CE =00000028                M 	__midpos:	= __endpos
0000D3CE                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D3CE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D3CE =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D3CE =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000D3CE =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000D3CE =00000034                M 	__midpos:	= __endpos
0000D3CE                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D3CE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D3CE =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D3CE =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000D3CE =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000D3CE =0000003C                M 	__midpos:	= __endpos
0000D3CE                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D3CE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D3CE                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D3CE                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D3CE                          M 	pushp	"move.l a6,-(sp)"
0000D3CE =00000002                M 	__stack:	= __stack+1
0000D3CE =00000008                M 	__sp:	= __sp+4
0000D3CE =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D3CE                          M 	rept	__stack
0000D3CE                          M 	popp	__command
0000D3CE 2F0E                     M 	move.l	a6,-(sp)
0000D3D0                          M 	popp	__command
0000D3D0 2F06                     M 	move.l	d6,-(sp)
0000D3D2 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D3D6 45EF 0010                M 	lea	4*4(sp),a2
0000D3DA 43FA 0000                M 	lea	.str_294(pc),a1
0000D3DE 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000D3E4 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D3E8 504F                     M 	addq.w	#__sp,sp
0000D3EA 46DF                     M 	move.w	(sp)+,sr
0000D3EC 6000 0000                M 	bra.w	.instr_end_294
0000D3F0                          M 	.str_294:
0000D3F0                          M 	__fstring_generatedecodedstring	"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D3F0 =00000001                M 	__lpos:	set 1
0000D3F0 =00000003                M 	__pos:	set instr("  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D3F0                          M 	while	(__pos)
0000D3F0                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D3F0 2020                     M 	dc.b	"  "
0000D3F2 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000D3F2 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000D3F2 =0000000A                M 	__midpos:	= __endpos
0000D3F2                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D3F2                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D3F2 E8                       M 	dc.b	fpal0
0000D3F3 =0000000B                M 	__lpos:	set __endpos+1
0000D3F3 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D3F3                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D3F3 6436 3A20                M 	dc.b	"d6: "
0000D3F7 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000D3F7 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000D3F7 =00000016                M 	__midpos:	= __endpos
0000D3F7                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D3F7                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D3F7 EC                       M 	dc.b	fpal2
0000D3F8 =00000017                M 	__lpos:	set __endpos+1
0000D3F8 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D3F8                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D3F8                          M 	dc.b	""
0000D3F8 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000D3F8 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000D3F8 =0000001E                M 	__midpos:	= __endpos
0000D3F8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D3F8                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D3F8                          M 	__param:	substr ,,"hex"
0000D3F8 83                       M 	dc.b	hex|3
0000D3F9 =0000001F                M 	__lpos:	set __endpos+1
0000D3F9 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D3F9                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D3F9 2020                     M 	dc.b	"  "
0000D3FB =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000D3FB =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000D3FB =00000028                M 	__midpos:	= __endpos
0000D3FB                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D3FB                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D3FB E8                       M 	dc.b	fpal0
0000D3FC =00000029                M 	__lpos:	set __endpos+1
0000D3FC =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D3FC                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D3FC 6136 3A20                M 	dc.b	"a6: "
0000D400 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000D400 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000D400 =00000034                M 	__midpos:	= __endpos
0000D400                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D400                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D400 EC                       M 	dc.b	fpal2
0000D401 =00000035                M 	__lpos:	set __endpos+1
0000D401 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D401                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D401                          M 	dc.b	""
0000D401 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000D401 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000D401 =0000003C                M 	__midpos:	= __endpos
0000D401                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D401                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D401                          M 	__param:	substr ,,"hex"
0000D401 83                       M 	dc.b	hex|3
0000D402 =0000003D                M 	__lpos:	set __endpos+1
0000D402 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000D402                          M 	__substr:	substr __lpos,,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000D402                          M 	dc.b	""
0000D402 00                       M 	dc.b	0
0000D404 00                       M 	even
0000D404                          M 	.instr_end_294:
0000D404                            	Console.WriteLine "  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D404 40E7                     M 	move.w	sr,-(sp)
0000D406                          M 	__fstring_generateargumentscode	"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D406 =00000003                M 	__pos:	set instr("  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D406 =00000000                M 	__stack:set	0
0000D406 =00000000                M 	__sp:	set 0
0000D406                          M 	while	(__pos)
0000D406 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000D406 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000D406 =0000000A                M 	__midpos:	= __endpos
0000D406                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D406                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D406 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D406 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000D406 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000D406 =00000016                M 	__midpos:	= __endpos
0000D406                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D406                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D406 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D406 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000D406 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000D406 =0000001E                M 	__midpos:	= __endpos
0000D406                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D406                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D406                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D406                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D406                          M 	pushp	"move.l d7,-(sp)"
0000D406 =00000001                M 	__stack:	= __stack+1
0000D406 =00000004                M 	__sp:	= __sp+4
0000D406 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D406 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000D406 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000D406 =00000028                M 	__midpos:	= __endpos
0000D406                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D406                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D406 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D406 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000D406 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000D406 =00000034                M 	__midpos:	= __endpos
0000D406                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D406                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D406 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D406 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000D406 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000D406 =0000003C                M 	__midpos:	= __endpos
0000D406                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D406                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D406                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D406                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D406                          M 	pushp	"move.l a7,-(sp)"
0000D406 =00000002                M 	__stack:	= __stack+1
0000D406 =00000008                M 	__sp:	= __sp+4
0000D406 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D406                          M 	rept	__stack
0000D406                          M 	popp	__command
0000D406 2F0F                     M 	move.l	a7,-(sp)
0000D408                          M 	popp	__command
0000D408 2F07                     M 	move.l	d7,-(sp)
0000D40A 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D40E 45EF 0010                M 	lea	4*4(sp),a2
0000D412 43FA 0000                M 	lea	.str_297(pc),a1
0000D416 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000D41C 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D420 504F                     M 	addq.w	#__sp,sp
0000D422 46DF                     M 	move.w	(sp)+,sr
0000D424 6000 0000                M 	bra.w	.instr_end_297
0000D428                          M 	.str_297:
0000D428                          M 	__fstring_generatedecodedstring	"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D428 =00000001                M 	__lpos:	set 1
0000D428 =00000003                M 	__pos:	set instr("  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D428                          M 	while	(__pos)
0000D428                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D428 2020                     M 	dc.b	"  "
0000D42A =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000D42A =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000D42A =0000000A                M 	__midpos:	= __endpos
0000D42A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D42A                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D42A E8                       M 	dc.b	fpal0
0000D42B =0000000B                M 	__lpos:	set __endpos+1
0000D42B =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D42B                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D42B 6437 3A20                M 	dc.b	"d7: "
0000D42F =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000D42F =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000D42F =00000016                M 	__midpos:	= __endpos
0000D42F                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D42F                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D42F EC                       M 	dc.b	fpal2
0000D430 =00000017                M 	__lpos:	set __endpos+1
0000D430 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D430                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D430                          M 	dc.b	""
0000D430 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000D430 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000D430 =0000001E                M 	__midpos:	= __endpos
0000D430                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D430                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D430                          M 	__param:	substr ,,"hex"
0000D430 83                       M 	dc.b	hex|3
0000D431 =0000001F                M 	__lpos:	set __endpos+1
0000D431 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D431                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D431 2020                     M 	dc.b	"  "
0000D433 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000D433 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000D433 =00000028                M 	__midpos:	= __endpos
0000D433                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D433                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D433 E8                       M 	dc.b	fpal0
0000D434 =00000029                M 	__lpos:	set __endpos+1
0000D434 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D434                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D434 7370 3A20                M 	dc.b	"sp: "
0000D438 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000D438 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000D438 =00000034                M 	__midpos:	= __endpos
0000D438                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D438                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D438 EC                       M 	dc.b	fpal2
0000D439 =00000035                M 	__lpos:	set __endpos+1
0000D439 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D439                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D439                          M 	dc.b	""
0000D439 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000D439 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000D439 =0000003C                M 	__midpos:	= __endpos
0000D439                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D439                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D439                          M 	__param:	substr ,,"hex"
0000D439 83                       M 	dc.b	hex|3
0000D43A =0000003D                M 	__lpos:	set __endpos+1
0000D43A =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000D43A                          M 	__substr:	substr __lpos,,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000D43A                          M 	dc.b	""
0000D43A 00                       M 	dc.b	0
0000D43C 00                       M 	even
0000D43C                          M 	.instr_end_297:
0000D43C                            	Console.BreakLine
0000D43C 40E7                     M 	move.w	sr,-(sp)
0000D43E 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_startnewline
0000D444 46DF                     M 	move.w	(sp)+,sr
0000D446                            
0000D446                            	Console.Write "%<fpal1>Channel: %<fpal0>"
0000D446 40E7                     M 	move.w	sr,-(sp)
0000D448                          M 	__fstring_generateargumentscode	"%<fpal1>Channel: %<fpal0>"
0000D448 =00000001                M 	__pos:	set instr("%<fpal1>Channel: %<fpal0>",'%<')
0000D448 =00000000                M 	__stack:set	0
0000D448 =00000000                M 	__sp:	set 0
0000D448                          M 	while	(__pos)
0000D448 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Channel: %<fpal0>",'>')
0000D448 =00000011                M 	__midpos:	set instr(__pos+5,"%<fpal1>Channel: %<fpal0>",' ')
0000D448 =00000008                M 	__midpos:	= __endpos
0000D448                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Channel: %<fpal0>"
0000D448                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Channel: %<fpal0>"
0000D448 =00000012                M 	__pos:	set instr(__pos+1,"%<fpal1>Channel: %<fpal0>",'%<')
0000D448 =00000019                M 	__endpos:	set instr(__pos+1,"%<fpal1>Channel: %<fpal0>",'>')
0000D448 =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal1>Channel: %<fpal0>",' ')
0000D448 =00000019                M 	__midpos:	= __endpos
0000D448                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Channel: %<fpal0>"
0000D448                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Channel: %<fpal0>"
0000D448 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Channel: %<fpal0>",'%<')
0000D448                          M 	rept	__stack
0000D448 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D44C 43FA 0000                M 	lea	.str_301(pc),a1
0000D450 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D456 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D45A 46DF                     M 	move.w	(sp)+,sr
0000D45C 6000 0000                M 	bra.w	.instr_end_301
0000D460                          M 	.str_301:
0000D460                          M 	__fstring_generatedecodedstring	"%<fpal1>Channel: %<fpal0>"
0000D460 =00000001                M 	__lpos:	set 1
0000D460 =00000001                M 	__pos:	set instr("%<fpal1>Channel: %<fpal0>",'%<')
0000D460                          M 	while	(__pos)
0000D460                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Channel: %<fpal0>"
0000D460                          M 	dc.b	""
0000D460 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Channel: %<fpal0>",'>')
0000D460 =00000011                M 	__midpos:	set instr(__pos+5,"%<fpal1>Channel: %<fpal0>",' ')
0000D460 =00000008                M 	__midpos:	= __endpos
0000D460                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Channel: %<fpal0>"
0000D460                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Channel: %<fpal0>"
0000D460 EA                       M 	dc.b	fpal1
0000D461 =00000009                M 	__lpos:	set __endpos+1
0000D461 =00000012                M 	__pos:	set instr(__pos+1,"%<fpal1>Channel: %<fpal0>",'%<')
0000D461                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Channel: %<fpal0>"
0000D461 4368 616E 6E65 6C3A 20   M 	dc.b	"Channel: "
0000D46A =00000019                M 	__endpos:	set instr(__pos+1,"%<fpal1>Channel: %<fpal0>",'>')
0000D46A =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal1>Channel: %<fpal0>",' ')
0000D46A =00000019                M 	__midpos:	= __endpos
0000D46A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Channel: %<fpal0>"
0000D46A                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Channel: %<fpal0>"
0000D46A E8                       M 	dc.b	fpal0
0000D46B =0000001A                M 	__lpos:	set __endpos+1
0000D46B =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Channel: %<fpal0>",'%<')
0000D46B                          M 	__substr:	substr __lpos,,"%<fpal1>Channel: %<fpal0>"
0000D46B                          M 	dc.b	""
0000D46B 00                       M 	dc.b	0
0000D46C                          M 	even
0000D46C                          M 	.instr_end_301:
0000D46C                            	AMPS_Debug_GetChannel
0000D46C BAFC C5F8                M 	cmp.w	#mpsg1,a5
0000D470 6600                     M 	bne.s	amps_debug_writepsg2
0000D472                          M 	console.write	"PSG1"
0000D472 40E7                     M 	move.w	sr,-(sp)
0000D474                          M 	__fstring_generateargumentscode	"PSG1"
0000D474 =00000000                M 	__pos:	set instr("PSG1",'%<')
0000D474 =00000000                M 	__stack:set	0
0000D474 =00000000                M 	__sp:	set 0
0000D474                          M 	while	(__pos)
0000D474                          M 	rept	__stack
0000D474 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D478 43FA 0000                M 	lea	.str_305(pc),a1
0000D47C 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D482 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D486 46DF                     M 	move.w	(sp)+,sr
0000D488 6000 0000                M 	bra.w	.instr_end_305
0000D48C                          M 	.str_305:
0000D48C                          M 	__fstring_generatedecodedstring	"PSG1"
0000D48C =00000001                M 	__lpos:	set 1
0000D48C =00000000                M 	__pos:	set instr("PSG1",'%<')
0000D48C                          M 	while	(__pos)
0000D48C                          M 	__substr:	substr __lpos,,"PSG1"
0000D48C 5053 4731                M 	dc.b	"PSG1"
0000D490 00                       M 	dc.b	0
0000D492 00                       M 	even
0000D492                          M 	.instr_end_305:
0000D492 6000 0000                M 	bra.w	amps_debug_writeend
0000D496                          M amps_debug_writepsg2
0000D496 BAFC C624                M 	cmp.w	#mpsg2,a5
0000D49A 6600                     M 	bne.s	amps_debug_writepsg3
0000D49C                          M 	console.write	"PSG2"
0000D49C 40E7                     M 	move.w	sr,-(sp)
0000D49E                          M 	__fstring_generateargumentscode	"PSG2"
0000D49E =00000000                M 	__pos:	set instr("PSG2",'%<')
0000D49E =00000000                M 	__stack:set	0
0000D49E =00000000                M 	__sp:	set 0
0000D49E                          M 	while	(__pos)
0000D49E                          M 	rept	__stack
0000D49E 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D4A2 43FA 0000                M 	lea	.str_308(pc),a1
0000D4A6 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D4AC 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D4B0 46DF                     M 	move.w	(sp)+,sr
0000D4B2 6000 0000                M 	bra.w	.instr_end_308
0000D4B6                          M 	.str_308:
0000D4B6                          M 	__fstring_generatedecodedstring	"PSG2"
0000D4B6 =00000001                M 	__lpos:	set 1
0000D4B6 =00000000                M 	__pos:	set instr("PSG2",'%<')
0000D4B6                          M 	while	(__pos)
0000D4B6                          M 	__substr:	substr __lpos,,"PSG2"
0000D4B6 5053 4732                M 	dc.b	"PSG2"
0000D4BA 00                       M 	dc.b	0
0000D4BC 00                       M 	even
0000D4BC                          M 	.instr_end_308:
0000D4BC 6000 0000                M 	bra.w	amps_debug_writeend
0000D4C0                          M amps_debug_writepsg3
0000D4C0 BAFC C650                M 	cmp.w	#mpsg3,a5
0000D4C4 6600                     M 	bne.s	amps_debug_writepsgs1
0000D4C6                          M 	console.write	"PSG3"
0000D4C6 40E7                     M 	move.w	sr,-(sp)
0000D4C8                          M 	__fstring_generateargumentscode	"PSG3"
0000D4C8 =00000000                M 	__pos:	set instr("PSG3",'%<')
0000D4C8 =00000000                M 	__stack:set	0
0000D4C8 =00000000                M 	__sp:	set 0
0000D4C8                          M 	while	(__pos)
0000D4C8                          M 	rept	__stack
0000D4C8 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D4CC 43FA 0000                M 	lea	.str_311(pc),a1
0000D4D0 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D4D6 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D4DA 46DF                     M 	move.w	(sp)+,sr
0000D4DC 6000 0000                M 	bra.w	.instr_end_311
0000D4E0                          M 	.str_311:
0000D4E0                          M 	__fstring_generatedecodedstring	"PSG3"
0000D4E0 =00000001                M 	__lpos:	set 1
0000D4E0 =00000000                M 	__pos:	set instr("PSG3",'%<')
0000D4E0                          M 	while	(__pos)
0000D4E0                          M 	__substr:	substr __lpos,,"PSG3"
0000D4E0 5053 4733                M 	dc.b	"PSG3"
0000D4E4 00                       M 	dc.b	0
0000D4E6 00                       M 	even
0000D4E6                          M 	.instr_end_311:
0000D4E6 6000 0000                M 	bra.w	amps_debug_writeend
0000D4EA                          M amps_debug_writepsgs1
0000D4EA BAFC C6EC                M 	cmp.w	#msfxpsg1,a5
0000D4EE 6600                     M 	bne.s	amps_debug_writepsgs2
0000D4F0                          M 	console.write	"SFX PSG1"
0000D4F0 40E7                     M 	move.w	sr,-(sp)
0000D4F2                          M 	__fstring_generateargumentscode	"SFX PSG1"
0000D4F2 =00000000                M 	__pos:	set instr("SFX PSG1",'%<')
0000D4F2 =00000000                M 	__stack:set	0
0000D4F2 =00000000                M 	__sp:	set 0
0000D4F2                          M 	while	(__pos)
0000D4F2                          M 	rept	__stack
0000D4F2 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D4F6 43FA 0000                M 	lea	.str_314(pc),a1
0000D4FA 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D500 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D504 46DF                     M 	move.w	(sp)+,sr
0000D506 6000 0000                M 	bra.w	.instr_end_314
0000D50A                          M 	.str_314:
0000D50A                          M 	__fstring_generatedecodedstring	"SFX PSG1"
0000D50A =00000001                M 	__lpos:	set 1
0000D50A =00000000                M 	__pos:	set instr("SFX PSG1",'%<')
0000D50A                          M 	while	(__pos)
0000D50A                          M 	__substr:	substr __lpos,,"SFX PSG1"
0000D50A 5346 5820 5053 4731      M 	dc.b	"SFX PSG1"
0000D512 00                       M 	dc.b	0
0000D514 00                       M 	even
0000D514                          M 	.instr_end_314:
0000D514 6000 0000                M 	bra.w	amps_debug_writeend
0000D518                          M amps_debug_writepsgs2
0000D518 BAFC C708                M 	cmp.w	#msfxpsg2,a5
0000D51C 6600                     M 	bne.s	amps_debug_writepsgs3
0000D51E                          M 	console.write	"SFX PSG2"
0000D51E 40E7                     M 	move.w	sr,-(sp)
0000D520                          M 	__fstring_generateargumentscode	"SFX PSG2"
0000D520 =00000000                M 	__pos:	set instr("SFX PSG2",'%<')
0000D520 =00000000                M 	__stack:set	0
0000D520 =00000000                M 	__sp:	set 0
0000D520                          M 	while	(__pos)
0000D520                          M 	rept	__stack
0000D520 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D524 43FA 0000                M 	lea	.str_317(pc),a1
0000D528 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D52E 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D532 46DF                     M 	move.w	(sp)+,sr
0000D534 6000 0000                M 	bra.w	.instr_end_317
0000D538                          M 	.str_317:
0000D538                          M 	__fstring_generatedecodedstring	"SFX PSG2"
0000D538 =00000001                M 	__lpos:	set 1
0000D538 =00000000                M 	__pos:	set instr("SFX PSG2",'%<')
0000D538                          M 	while	(__pos)
0000D538                          M 	__substr:	substr __lpos,,"SFX PSG2"
0000D538 5346 5820 5053 4732      M 	dc.b	"SFX PSG2"
0000D540 00                       M 	dc.b	0
0000D542 00                       M 	even
0000D542                          M 	.instr_end_317:
0000D542 6000 0000                M 	bra.w	amps_debug_writeend
0000D546                          M amps_debug_writepsgs3
0000D546 BAFC C724                M 	cmp.w	#msfxpsg3,a5
0000D54A 6600                     M 	bne.s	amps_debug_writedacs1
0000D54C                          M 	console.write	"SFX PSG3"
0000D54C 40E7                     M 	move.w	sr,-(sp)
0000D54E                          M 	__fstring_generateargumentscode	"SFX PSG3"
0000D54E =00000000                M 	__pos:	set instr("SFX PSG3",'%<')
0000D54E =00000000                M 	__stack:set	0
0000D54E =00000000                M 	__sp:	set 0
0000D54E                          M 	while	(__pos)
0000D54E                          M 	rept	__stack
0000D54E 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D552 43FA 0000                M 	lea	.str_320(pc),a1
0000D556 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D55C 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D560 46DF                     M 	move.w	(sp)+,sr
0000D562 6000 0000                M 	bra.w	.instr_end_320
0000D566                          M 	.str_320:
0000D566                          M 	__fstring_generatedecodedstring	"SFX PSG3"
0000D566 =00000001                M 	__lpos:	set 1
0000D566 =00000000                M 	__pos:	set instr("SFX PSG3",'%<')
0000D566                          M 	while	(__pos)
0000D566                          M 	__substr:	substr __lpos,,"SFX PSG3"
0000D566 5346 5820 5053 4733      M 	dc.b	"SFX PSG3"
0000D56E 00                       M 	dc.b	0
0000D570 00                       M 	even
0000D570                          M 	.instr_end_320:
0000D570 6000 0000                M 	bra.w	amps_debug_writeend
0000D574                          M amps_debug_writedacs1
0000D574 BAFC C67C                M 	cmp.w	#msfxdac1,a5
0000D578 6600                     M 	bne.s	amps_debug_writedac1
0000D57A                          M 	console.write	"SFX DAC1"
0000D57A 40E7                     M 	move.w	sr,-(sp)
0000D57C                          M 	__fstring_generateargumentscode	"SFX DAC1"
0000D57C =00000000                M 	__pos:	set instr("SFX DAC1",'%<')
0000D57C =00000000                M 	__stack:set	0
0000D57C =00000000                M 	__sp:	set 0
0000D57C                          M 	while	(__pos)
0000D57C                          M 	rept	__stack
0000D57C 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D580 43FA 0000                M 	lea	.str_323(pc),a1
0000D584 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D58A 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D58E 46DF                     M 	move.w	(sp)+,sr
0000D590 6000 0000                M 	bra.w	.instr_end_323
0000D594                          M 	.str_323:
0000D594                          M 	__fstring_generatedecodedstring	"SFX DAC1"
0000D594 =00000001                M 	__lpos:	set 1
0000D594 =00000000                M 	__pos:	set instr("SFX DAC1",'%<')
0000D594                          M 	while	(__pos)
0000D594                          M 	__substr:	substr __lpos,,"SFX DAC1"
0000D594 5346 5820 4441 4331      M 	dc.b	"SFX DAC1"
0000D59C 00                       M 	dc.b	0
0000D59E 00                       M 	even
0000D59E                          M 	.instr_end_323:
0000D59E 6000 0000                M 	bra.w	amps_debug_writeend
0000D5A2                          M amps_debug_writedac1
0000D5A2 BAFC C4C4                M 	cmp.w	#mdac1,a5
0000D5A6 6600                     M 	bne.s	amps_debug_writedac2
0000D5A8                          M 	console.write	"DAC1"
0000D5A8 40E7                     M 	move.w	sr,-(sp)
0000D5AA                          M 	__fstring_generateargumentscode	"DAC1"
0000D5AA =00000000                M 	__pos:	set instr("DAC1",'%<')
0000D5AA =00000000                M 	__stack:set	0
0000D5AA =00000000                M 	__sp:	set 0
0000D5AA                          M 	while	(__pos)
0000D5AA                          M 	rept	__stack
0000D5AA 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D5AE 43FA 0000                M 	lea	.str_326(pc),a1
0000D5B2 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D5B8 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D5BC 46DF                     M 	move.w	(sp)+,sr
0000D5BE 6000 0000                M 	bra.w	.instr_end_326
0000D5C2                          M 	.str_326:
0000D5C2                          M 	__fstring_generatedecodedstring	"DAC1"
0000D5C2 =00000001                M 	__lpos:	set 1
0000D5C2 =00000000                M 	__pos:	set instr("DAC1",'%<')
0000D5C2                          M 	while	(__pos)
0000D5C2                          M 	__substr:	substr __lpos,,"DAC1"
0000D5C2 4441 4331                M 	dc.b	"DAC1"
0000D5C6 00                       M 	dc.b	0
0000D5C8 00                       M 	even
0000D5C8                          M 	.instr_end_326:
0000D5C8 6000 0000                M 	bra.w	amps_debug_writeend
0000D5CC                          M amps_debug_writedac2
0000D5CC BAFC C4F0                M 	cmp.w	#mdac2,a5
0000D5D0 6600                     M 	bne.s	amps_debug_writefm1
0000D5D2                          M 	console.write	"DAC2"
0000D5D2 40E7                     M 	move.w	sr,-(sp)
0000D5D4                          M 	__fstring_generateargumentscode	"DAC2"
0000D5D4 =00000000                M 	__pos:	set instr("DAC2",'%<')
0000D5D4 =00000000                M 	__stack:set	0
0000D5D4 =00000000                M 	__sp:	set 0
0000D5D4                          M 	while	(__pos)
0000D5D4                          M 	rept	__stack
0000D5D4 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D5D8 43FA 0000                M 	lea	.str_329(pc),a1
0000D5DC 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D5E2 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D5E6 46DF                     M 	move.w	(sp)+,sr
0000D5E8 6000 0000                M 	bra.w	.instr_end_329
0000D5EC                          M 	.str_329:
0000D5EC                          M 	__fstring_generatedecodedstring	"DAC2"
0000D5EC =00000001                M 	__lpos:	set 1
0000D5EC =00000000                M 	__pos:	set instr("DAC2",'%<')
0000D5EC                          M 	while	(__pos)
0000D5EC                          M 	__substr:	substr __lpos,,"DAC2"
0000D5EC 4441 4332                M 	dc.b	"DAC2"
0000D5F0 00                       M 	dc.b	0
0000D5F2 00                       M 	even
0000D5F2                          M 	.instr_end_329:
0000D5F2 6000 0000                M 	bra.w	amps_debug_writeend
0000D5F6                          M amps_debug_writefm1
0000D5F6 BAFC C51C                M 	cmp.w	#mfm1,a5
0000D5FA 6600                     M 	bne.s	amps_debug_writefm2
0000D5FC                          M 	console.write	"FM1"
0000D5FC 40E7                     M 	move.w	sr,-(sp)
0000D5FE                          M 	__fstring_generateargumentscode	"FM1"
0000D5FE =00000000                M 	__pos:	set instr("FM1",'%<')
0000D5FE =00000000                M 	__stack:set	0
0000D5FE =00000000                M 	__sp:	set 0
0000D5FE                          M 	while	(__pos)
0000D5FE                          M 	rept	__stack
0000D5FE 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D602 43FA 0000                M 	lea	.str_332(pc),a1
0000D606 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D60C 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D610 46DF                     M 	move.w	(sp)+,sr
0000D612 6000 0000                M 	bra.w	.instr_end_332
0000D616                          M 	.str_332:
0000D616                          M 	__fstring_generatedecodedstring	"FM1"
0000D616 =00000001                M 	__lpos:	set 1
0000D616 =00000000                M 	__pos:	set instr("FM1",'%<')
0000D616                          M 	while	(__pos)
0000D616                          M 	__substr:	substr __lpos,,"FM1"
0000D616 464D 31                  M 	dc.b	"FM1"
0000D619 00                       M 	dc.b	0
0000D61A                          M 	even
0000D61A                          M 	.instr_end_332:
0000D61A 6000 0000                M 	bra.w	amps_debug_writeend
0000D61E                          M amps_debug_writefm2
0000D61E BAFC C548                M 	cmp.w	#mfm2,a5
0000D622 6600                     M 	bne.s	amps_debug_writefm3
0000D624                          M 	console.write	"FM2"
0000D624 40E7                     M 	move.w	sr,-(sp)
0000D626                          M 	__fstring_generateargumentscode	"FM2"
0000D626 =00000000                M 	__pos:	set instr("FM2",'%<')
0000D626 =00000000                M 	__stack:set	0
0000D626 =00000000                M 	__sp:	set 0
0000D626                          M 	while	(__pos)
0000D626                          M 	rept	__stack
0000D626 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D62A 43FA 0000                M 	lea	.str_335(pc),a1
0000D62E 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D634 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D638 46DF                     M 	move.w	(sp)+,sr
0000D63A 6000 0000                M 	bra.w	.instr_end_335
0000D63E                          M 	.str_335:
0000D63E                          M 	__fstring_generatedecodedstring	"FM2"
0000D63E =00000001                M 	__lpos:	set 1
0000D63E =00000000                M 	__pos:	set instr("FM2",'%<')
0000D63E                          M 	while	(__pos)
0000D63E                          M 	__substr:	substr __lpos,,"FM2"
0000D63E 464D 32                  M 	dc.b	"FM2"
0000D641 00                       M 	dc.b	0
0000D642                          M 	even
0000D642                          M 	.instr_end_335:
0000D642 6000 0000                M 	bra.w	amps_debug_writeend
0000D646                          M amps_debug_writefm3
0000D646 BAFC C574                M 	cmp.w	#mfm3,a5
0000D64A 6600                     M 	bne.s	amps_debug_writefm4
0000D64C                          M 	console.write	"FM3"
0000D64C 40E7                     M 	move.w	sr,-(sp)
0000D64E                          M 	__fstring_generateargumentscode	"FM3"
0000D64E =00000000                M 	__pos:	set instr("FM3",'%<')
0000D64E =00000000                M 	__stack:set	0
0000D64E =00000000                M 	__sp:	set 0
0000D64E                          M 	while	(__pos)
0000D64E                          M 	rept	__stack
0000D64E 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D652 43FA 0000                M 	lea	.str_338(pc),a1
0000D656 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D65C 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D660 46DF                     M 	move.w	(sp)+,sr
0000D662 6000 0000                M 	bra.w	.instr_end_338
0000D666                          M 	.str_338:
0000D666                          M 	__fstring_generatedecodedstring	"FM3"
0000D666 =00000001                M 	__lpos:	set 1
0000D666 =00000000                M 	__pos:	set instr("FM3",'%<')
0000D666                          M 	while	(__pos)
0000D666                          M 	__substr:	substr __lpos,,"FM3"
0000D666 464D 33                  M 	dc.b	"FM3"
0000D669 00                       M 	dc.b	0
0000D66A                          M 	even
0000D66A                          M 	.instr_end_338:
0000D66A 6000 0000                M 	bra.w	amps_debug_writeend
0000D66E                          M amps_debug_writefm4
0000D66E BAFC C5A0                M 	cmp.w	#mfm4,a5
0000D672 6600                     M 	bne.s	amps_debug_writefm5
0000D674                          M 	console.write	"FM4"
0000D674 40E7                     M 	move.w	sr,-(sp)
0000D676                          M 	__fstring_generateargumentscode	"FM4"
0000D676 =00000000                M 	__pos:	set instr("FM4",'%<')
0000D676 =00000000                M 	__stack:set	0
0000D676 =00000000                M 	__sp:	set 0
0000D676                          M 	while	(__pos)
0000D676                          M 	rept	__stack
0000D676 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D67A 43FA 0000                M 	lea	.str_341(pc),a1
0000D67E 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D684 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D688 46DF                     M 	move.w	(sp)+,sr
0000D68A 6000 0000                M 	bra.w	.instr_end_341
0000D68E                          M 	.str_341:
0000D68E                          M 	__fstring_generatedecodedstring	"FM4"
0000D68E =00000001                M 	__lpos:	set 1
0000D68E =00000000                M 	__pos:	set instr("FM4",'%<')
0000D68E                          M 	while	(__pos)
0000D68E                          M 	__substr:	substr __lpos,,"FM4"
0000D68E 464D 34                  M 	dc.b	"FM4"
0000D691 00                       M 	dc.b	0
0000D692                          M 	even
0000D692                          M 	.instr_end_341:
0000D692 6000 0000                M 	bra.w	amps_debug_writeend
0000D696                          M amps_debug_writefm5
0000D696 BAFC C5CC                M 	cmp.w	#mfm5,a5
0000D69A 6600                     M 	bne.s	amps_debug_writefms3
0000D69C                          M 	console.write	"FM5"
0000D69C 40E7                     M 	move.w	sr,-(sp)
0000D69E                          M 	__fstring_generateargumentscode	"FM5"
0000D69E =00000000                M 	__pos:	set instr("FM5",'%<')
0000D69E =00000000                M 	__stack:set	0
0000D69E =00000000                M 	__sp:	set 0
0000D69E                          M 	while	(__pos)
0000D69E                          M 	rept	__stack
0000D69E 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D6A2 43FA 0000                M 	lea	.str_344(pc),a1
0000D6A6 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D6AC 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D6B0 46DF                     M 	move.w	(sp)+,sr
0000D6B2 6000 0000                M 	bra.w	.instr_end_344
0000D6B6                          M 	.str_344:
0000D6B6                          M 	__fstring_generatedecodedstring	"FM5"
0000D6B6 =00000001                M 	__lpos:	set 1
0000D6B6 =00000000                M 	__pos:	set instr("FM5",'%<')
0000D6B6                          M 	while	(__pos)
0000D6B6                          M 	__substr:	substr __lpos,,"FM5"
0000D6B6 464D 35                  M 	dc.b	"FM5"
0000D6B9 00                       M 	dc.b	0
0000D6BA                          M 	even
0000D6BA                          M 	.instr_end_344:
0000D6BA 6000 0000                M 	bra.w	amps_debug_writeend
0000D6BE                          M amps_debug_writefms3
0000D6BE BAFC C698                M 	cmp.w	#msfxfm3,a5
0000D6C2 6600                     M 	bne.s	amps_debug_writefms4
0000D6C4                          M 	console.write	"SFX FM3"
0000D6C4 40E7                     M 	move.w	sr,-(sp)
0000D6C6                          M 	__fstring_generateargumentscode	"SFX FM3"
0000D6C6 =00000000                M 	__pos:	set instr("SFX FM3",'%<')
0000D6C6 =00000000                M 	__stack:set	0
0000D6C6 =00000000                M 	__sp:	set 0
0000D6C6                          M 	while	(__pos)
0000D6C6                          M 	rept	__stack
0000D6C6 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D6CA 43FA 0000                M 	lea	.str_347(pc),a1
0000D6CE 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D6D4 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D6D8 46DF                     M 	move.w	(sp)+,sr
0000D6DA 6000 0000                M 	bra.w	.instr_end_347
0000D6DE                          M 	.str_347:
0000D6DE                          M 	__fstring_generatedecodedstring	"SFX FM3"
0000D6DE =00000001                M 	__lpos:	set 1
0000D6DE =00000000                M 	__pos:	set instr("SFX FM3",'%<')
0000D6DE                          M 	while	(__pos)
0000D6DE                          M 	__substr:	substr __lpos,,"SFX FM3"
0000D6DE 5346 5820 464D 33        M 	dc.b	"SFX FM3"
0000D6E5 00                       M 	dc.b	0
0000D6E6                          M 	even
0000D6E6                          M 	.instr_end_347:
0000D6E6 4E75                     M 	rts
0000D6E8                          M amps_debug_writefms4
0000D6E8 BAFC C6B4                M 	cmp.w	#msfxfm4,a5
0000D6EC 6600                     M 	bne.s	amps_debug_writefms5
0000D6EE                          M 	console.write	"SFX FM4"
0000D6EE 40E7                     M 	move.w	sr,-(sp)
0000D6F0                          M 	__fstring_generateargumentscode	"SFX FM4"
0000D6F0 =00000000                M 	__pos:	set instr("SFX FM4",'%<')
0000D6F0 =00000000                M 	__stack:set	0
0000D6F0 =00000000                M 	__sp:	set 0
0000D6F0                          M 	while	(__pos)
0000D6F0                          M 	rept	__stack
0000D6F0 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D6F4 43FA 0000                M 	lea	.str_350(pc),a1
0000D6F8 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D6FE 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D702 46DF                     M 	move.w	(sp)+,sr
0000D704 6000 0000                M 	bra.w	.instr_end_350
0000D708                          M 	.str_350:
0000D708                          M 	__fstring_generatedecodedstring	"SFX FM4"
0000D708 =00000001                M 	__lpos:	set 1
0000D708 =00000000                M 	__pos:	set instr("SFX FM4",'%<')
0000D708                          M 	while	(__pos)
0000D708                          M 	__substr:	substr __lpos,,"SFX FM4"
0000D708 5346 5820 464D 34        M 	dc.b	"SFX FM4"
0000D70F 00                       M 	dc.b	0
0000D710                          M 	even
0000D710                          M 	.instr_end_350:
0000D710 6000                     M 	bra.s	amps_debug_writeend
0000D712                          M amps_debug_writefms5
0000D712 BAFC C6D0                M 	cmp.w	#msfxfm5,a5
0000D716 6700                     M 	beq.s	amps_debug_writefms5_
0000D718                          M amps_debug_writeaddr
0000D718                          M 	console.write	"%<fpal2>%<.l a5>"
0000D718 40E7                     M 	move.w	sr,-(sp)
0000D71A                          M 	__fstring_generateargumentscode	"%<fpal2>%<.l a5>"
0000D71A =00000001                M 	__pos:	set instr("%<fpal2>%<.l a5>",'%<')
0000D71A =00000000                M 	__stack:set	0
0000D71A =00000000                M 	__sp:	set 0
0000D71A                          M 	while	(__pos)
0000D71A =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal2>%<.l a5>",'>')
0000D71A =0000000D                M 	__midpos:	set instr(__pos+5,"%<fpal2>%<.l a5>",' ')
0000D71A =00000008                M 	__midpos:	= __endpos
0000D71A                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal2>%<.l a5>"
0000D71A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal2>%<.l a5>"
0000D71A =00000009                M 	__pos:	set instr(__pos+1,"%<fpal2>%<.l a5>",'%<')
0000D71A =00000010                M 	__endpos:	set instr(__pos+1,"%<fpal2>%<.l a5>",'>')
0000D71A =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal2>%<.l a5>",' ')
0000D71A =00000010                M 	__midpos:	= __endpos
0000D71A                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal2>%<.l a5>"
0000D71A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal2>%<.l a5>"
0000D71A                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal2>%<.l a5>"
0000D71A                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal2>%<.l a5>"
0000D71A                          M 	pushp	"move.l a5,-(sp)"
0000D71A =00000001                M 	__stack:	= __stack+1
0000D71A =00000004                M 	__sp:	= __sp+4
0000D71A =00000000                M 	__pos:	set instr(__pos+1,"%<fpal2>%<.l a5>",'%<')
0000D71A                          M 	rept	__stack
0000D71A                          M 	popp	__command
0000D71A 2F0D                     M 	move.l	a5,-(sp)
0000D71C 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D720 45EF 0010                M 	lea	4*4(sp),a2
0000D724 43FA 0000                M 	lea	.str_353(pc),a1
0000D728 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D72E 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D732 584F                     M 	addq.w	#__sp,sp
0000D734 46DF                     M 	move.w	(sp)+,sr
0000D736 6000 0000                M 	bra.w	.instr_end_353
0000D73A                          M 	.str_353:
0000D73A                          M 	__fstring_generatedecodedstring	"%<fpal2>%<.l a5>"
0000D73A =00000001                M 	__lpos:	set 1
0000D73A =00000001                M 	__pos:	set instr("%<fpal2>%<.l a5>",'%<')
0000D73A                          M 	while	(__pos)
0000D73A                          M 	__substr:	substr __lpos,__pos-1,"%<fpal2>%<.l a5>"
0000D73A                          M 	dc.b	""
0000D73A =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal2>%<.l a5>",'>')
0000D73A =0000000D                M 	__midpos:	set instr(__pos+5,"%<fpal2>%<.l a5>",' ')
0000D73A =00000008                M 	__midpos:	= __endpos
0000D73A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal2>%<.l a5>"
0000D73A                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal2>%<.l a5>"
0000D73A EC                       M 	dc.b	fpal2
0000D73B =00000009                M 	__lpos:	set __endpos+1
0000D73B =00000009                M 	__pos:	set instr(__pos+1,"%<fpal2>%<.l a5>",'%<')
0000D73B                          M 	__substr:	substr __lpos,__pos-1,"%<fpal2>%<.l a5>"
0000D73B                          M 	dc.b	""
0000D73B =00000010                M 	__endpos:	set instr(__pos+1,"%<fpal2>%<.l a5>",'>')
0000D73B =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal2>%<.l a5>",' ')
0000D73B =00000010                M 	__midpos:	= __endpos
0000D73B                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal2>%<.l a5>"
0000D73B                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal2>%<.l a5>"
0000D73B                          M 	__param:	substr ,,"hex"
0000D73B 83                       M 	dc.b	hex|3
0000D73C =00000011                M 	__lpos:	set __endpos+1
0000D73C =00000000                M 	__pos:	set instr(__pos+1,"%<fpal2>%<.l a5>",'%<')
0000D73C                          M 	__substr:	substr __lpos,,"%<fpal2>%<.l a5>"
0000D73C                          M 	dc.b	""
0000D73C 00                       M 	dc.b	0
0000D73E 00                       M 	even
0000D73E                          M 	.instr_end_353:
0000D73E 4E75                     M 	rts
0000D740                          M amps_debug_writefms5_
0000D740                          M 	console.write	"SFX FM5"
0000D740 40E7                     M 	move.w	sr,-(sp)
0000D742                          M 	__fstring_generateargumentscode	"SFX FM5"
0000D742 =00000000                M 	__pos:	set instr("SFX FM5",'%<')
0000D742 =00000000                M 	__stack:set	0
0000D742 =00000000                M 	__sp:	set 0
0000D742                          M 	while	(__pos)
0000D742                          M 	rept	__stack
0000D742 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D746 43FA 0000                M 	lea	.str_356(pc),a1
0000D74A 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D750 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D754 46DF                     M 	move.w	(sp)+,sr
0000D756 6000 0000                M 	bra.w	.instr_end_356
0000D75A                          M 	.str_356:
0000D75A                          M 	__fstring_generatedecodedstring	"SFX FM5"
0000D75A =00000001                M 	__lpos:	set 1
0000D75A =00000000                M 	__pos:	set instr("SFX FM5",'%<')
0000D75A                          M 	while	(__pos)
0000D75A                          M 	__substr:	substr __lpos,,"SFX FM5"
0000D75A 5346 5820 464D 35        M 	dc.b	"SFX FM5"
0000D761 00                       M 	dc.b	0
0000D762                          M 	even
0000D762                          M 	.instr_end_356:
0000D762                          M amps_debug_writeend
0000D762                            	Console.BreakLine
0000D762 40E7                     M 	move.w	sr,-(sp)
0000D764 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_startnewline
0000D76A 46DF                     M 	move.w	(sp)+,sr
0000D76C                            
0000D76C                            	Console.WriteLine "%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D76C 40E7                     M 	move.w	sr,-(sp)
0000D76E                          M 	__fstring_generateargumentscode	"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D76E =00000001                M 	__pos:	set instr("%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D76E =00000000                M 	__stack:set	0
0000D76E =00000000                M 	__sp:	set 0
0000D76E                          M 	while	(__pos)
0000D76E =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D76E =0000000E                M 	__midpos:	set instr(__pos+5,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D76E =00000008                M 	__midpos:	= __endpos
0000D76E                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D76E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D76E =0000000F                M 	__pos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D76E =00000016                M 	__endpos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D76E =0000001B                M 	__midpos:	set instr(__pos+5,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D76E =00000016                M 	__midpos:	= __endpos
0000D76E                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D76E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D76E =00000017                M 	__pos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D76E =00000029                M 	__endpos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D76E =0000001E                M 	__midpos:	set instr(__pos+5,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D76E                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D76E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D76E                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D76E                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D76E                          M 	pushp	"move.l a4,-(sp)"
0000D76E =00000001                M 	__stack:	= __stack+1
0000D76E =00000004                M 	__sp:	= __sp+4
0000D76E =0000002A                M 	__pos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D76E =0000003A                M 	__endpos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D76E =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D76E =0000003A                M 	__midpos:	= __endpos
0000D76E                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D76E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D76E =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D76E                          M 	rept	__stack
0000D76E                          M 	popp	__command
0000D76E 2F0C                     M 	move.l	a4,-(sp)
0000D770 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D774 45EF 0010                M 	lea	4*4(sp),a2
0000D778 43FA 0000                M 	lea	.str_360(pc),a1
0000D77C 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000D782 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D786 584F                     M 	addq.w	#__sp,sp
0000D788 46DF                     M 	move.w	(sp)+,sr
0000D78A 6000 0000                M 	bra.w	.instr_end_360
0000D78E                          M 	.str_360:
0000D78E                          M 	__fstring_generatedecodedstring	"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D78E =00000001                M 	__lpos:	set 1
0000D78E =00000001                M 	__pos:	set instr("%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D78E                          M 	while	(__pos)
0000D78E                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D78E                          M 	dc.b	""
0000D78E =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D78E =0000000E                M 	__midpos:	set instr(__pos+5,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D78E =00000008                M 	__midpos:	= __endpos
0000D78E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D78E                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D78E EA                       M 	dc.b	fpal1
0000D78F =00000009                M 	__lpos:	set __endpos+1
0000D78F =0000000F                M 	__pos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D78F                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D78F 4164 6472 3A20           M 	dc.b	"Addr: "
0000D795 =00000016                M 	__endpos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D795 =0000001B                M 	__midpos:	set instr(__pos+5,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D795 =00000016                M 	__midpos:	= __endpos
0000D795                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D795                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D795 E8                       M 	dc.b	fpal0
0000D796 =00000017                M 	__lpos:	set __endpos+1
0000D796 =00000017                M 	__pos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D796                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D796                          M 	dc.b	""
0000D796 =00000029                M 	__endpos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D796 =0000001E                M 	__midpos:	set instr(__pos+5,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D796                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D796                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D796 BB                       M 	dc.b	sym|fsplit|3
0000D797 =0000002A                M 	__lpos:	set __endpos+1
0000D797 =0000002A                M 	__pos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D797                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D797                          M 	dc.b	""
0000D797 =0000003A                M 	__endpos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D797 =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D797 =0000003A                M 	__midpos:	= __endpos
0000D797                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D797                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D797 ECC0                     M 	dc.b	fpal2,fsymdisp
0000D799 =0000003B                M 	__lpos:	set __endpos+1
0000D799 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D799                          M 	__substr:	substr __lpos,,"%<fpal1>Addr: %<fpal0>%<.l a4 sym|fsplit>%<fpal2,fsymdisp>"
0000D799                          M 	dc.b	""
0000D799 00                       M 	dc.b	0
0000D79A                          M 	even
0000D79A                          M 	.instr_end_360:
0000D79A                            ; fmt: flag, type, pan, det, pitch, vol, tick, sample/voice, dur, lastdur, freq
0000D79A                            	Console.Write	  "%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D79A 40E7                     M 	move.w	sr,-(sp)
0000D79C                          M 	__fstring_generateargumentscode	"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D79C =00000001                M 	__pos:	set instr("%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'%<')
0000D79C =00000000                M 	__stack:set	0
0000D79C =00000000                M 	__sp:	set 0
0000D79C                          M 	while	(__pos)
0000D79C =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'>')
0000D79C =0000000C                M 	__midpos:	set instr(__pos+5,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",' ')
0000D79C =00000008                M 	__midpos:	= __endpos
0000D79C                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D79C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D79C =0000000D                M 	__pos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'%<')
0000D79C =00000014                M 	__endpos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'>')
0000D79C =00000019                M 	__midpos:	set instr(__pos+5,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",' ')
0000D79C =00000014                M 	__midpos:	= __endpos
0000D79C                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D79C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D79C =00000015                M 	__pos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'%<')
0000D79C =0000001E                M 	__endpos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'>')
0000D79C =0000001F                M 	__midpos:	set instr(__pos+5,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",' ')
0000D79C =0000001E                M 	__midpos:	= __endpos
0000D79C                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D79C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D79C                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D79C                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D79C                          M 	pushp	"move.b (a5),1(sp)"
0000D79C                          M 	pushp	"subq.w	#2, sp"
0000D79C =00000002                M 	__stack:	= __stack+2
0000D79C =00000002                M 	__sp:	= __sp+2
0000D79C =00000020                M 	__pos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'%<')
0000D79C =0000002E                M 	__endpos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'>')
0000D79C =0000002F                M 	__midpos:	set instr(__pos+5,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",' ')
0000D79C =0000002E                M 	__midpos:	= __endpos
0000D79C                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D79C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D79C                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D79C                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D79C                          M 	pushp	"move.b cType(a5),1(sp)"
0000D79C                          M 	pushp	"subq.w	#2, sp"
0000D79C =00000004                M 	__stack:	= __stack+2
0000D79C =00000004                M 	__sp:	= __sp+2
0000D79C =00000030                M 	__pos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'%<')
0000D79C =00000041                M 	__endpos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'>')
0000D79C =00000042                M 	__midpos:	set instr(__pos+5,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",' ')
0000D79C =00000041                M 	__midpos:	= __endpos
0000D79C                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D79C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D79C                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D79C                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D79C                          M 	pushp	"move.b cPanning(a5),1(sp)"
0000D79C                          M 	pushp	"subq.w	#2, sp"
0000D79C =00000006                M 	__stack:	= __stack+2
0000D79C =00000006                M 	__sp:	= __sp+2
0000D79C =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'%<')
0000D79C                          M 	rept	__stack
0000D79C                          M 	popp	__command
0000D79C 554F                     M 	subq.w	#2,sp
0000D79E                          M 	popp	__command
0000D79E 1F6D 0006 0001           M 	move.b	cpanning(a5),1(sp)
0000D7A4                          M 	popp	__command
0000D7A4 554F                     M 	subq.w	#2,sp
0000D7A6                          M 	popp	__command
0000D7A6 1F6D 0001 0001           M 	move.b	ctype(a5),1(sp)
0000D7AC                          M 	popp	__command
0000D7AC 554F                     M 	subq.w	#2,sp
0000D7AE                          M 	popp	__command
0000D7AE 1F55 0001                M 	move.b	(a5),1(sp)
0000D7B2 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D7B6 45EF 0010                M 	lea	4*4(sp),a2
0000D7BA 43FA 0000                M 	lea	.str_363(pc),a1
0000D7BE 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D7C4 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D7C8 5C4F                     M 	addq.w	#__sp,sp
0000D7CA 46DF                     M 	move.w	(sp)+,sr
0000D7CC 6000 0000                M 	bra.w	.instr_end_363
0000D7D0                          M 	.str_363:
0000D7D0                          M 	__fstring_generatedecodedstring	"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D7D0 =00000001                M 	__lpos:	set 1
0000D7D0 =00000001                M 	__pos:	set instr("%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'%<')
0000D7D0                          M 	while	(__pos)
0000D7D0                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D7D0                          M 	dc.b	""
0000D7D0 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'>')
0000D7D0 =0000000C                M 	__midpos:	set instr(__pos+5,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",' ')
0000D7D0 =00000008                M 	__midpos:	= __endpos
0000D7D0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D7D0                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D7D0 EA                       M 	dc.b	fpal1
0000D7D1 =00000009                M 	__lpos:	set __endpos+1
0000D7D1 =0000000D                M 	__pos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'%<')
0000D7D1                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D7D1 4348 3A20                M 	dc.b	"CH: "
0000D7D5 =00000014                M 	__endpos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'>')
0000D7D5 =00000019                M 	__midpos:	set instr(__pos+5,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",' ')
0000D7D5 =00000014                M 	__midpos:	= __endpos
0000D7D5                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D7D5                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D7D5 EC                       M 	dc.b	fpal2
0000D7D6 =00000015                M 	__lpos:	set __endpos+1
0000D7D6 =00000015                M 	__pos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'%<')
0000D7D6                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D7D6                          M 	dc.b	""
0000D7D6 =0000001E                M 	__endpos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'>')
0000D7D6 =0000001F                M 	__midpos:	set instr(__pos+5,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",' ')
0000D7D6 =0000001E                M 	__midpos:	= __endpos
0000D7D6                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D7D6                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D7D6                          M 	__param:	substr ,,"hex"
0000D7D6 80                       M 	dc.b	hex
0000D7D7 =0000001F                M 	__lpos:	set __endpos+1
0000D7D7 =00000020                M 	__pos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'%<')
0000D7D7                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D7D7 20                       M 	dc.b	" "
0000D7D8 =0000002E                M 	__endpos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'>')
0000D7D8 =0000002F                M 	__midpos:	set instr(__pos+5,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",' ')
0000D7D8 =0000002E                M 	__midpos:	= __endpos
0000D7D8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D7D8                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D7D8                          M 	__param:	substr ,,"hex"
0000D7D8 80                       M 	dc.b	hex
0000D7D9 =0000002F                M 	__lpos:	set __endpos+1
0000D7D9 =00000030                M 	__pos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'%<')
0000D7D9                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D7D9 20                       M 	dc.b	" "
0000D7DA =00000041                M 	__endpos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'>')
0000D7DA =00000042                M 	__midpos:	set instr(__pos+5,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",' ')
0000D7DA =00000041                M 	__midpos:	= __endpos
0000D7DA                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D7DA                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D7DA                          M 	__param:	substr ,,"hex"
0000D7DA 80                       M 	dc.b	hex
0000D7DB =00000042                M 	__lpos:	set __endpos+1
0000D7DB =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> ",'%<')
0000D7DB                          M 	__substr:	substr __lpos,,"%<fpal1>CH: %<fpal2>%<.b (a5)> %<.b cType(a5)> %<.b cPanning(a5)> "
0000D7DB 20                       M 	dc.b	" "
0000D7DC 00                       M 	dc.b	0
0000D7DE 00                       M 	even
0000D7DE                          M 	.instr_end_363:
0000D7DE                            	Console.Write	  "%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D7DE 40E7                     M 	move.w	sr,-(sp)
0000D7E0                          M 	__fstring_generateargumentscode	"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D7E0 =00000001                M 	__pos:	set instr("%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'%<')
0000D7E0 =00000000                M 	__stack:set	0
0000D7E0 =00000000                M 	__sp:	set 0
0000D7E0                          M 	while	(__pos)
0000D7E0 =00000011                M 	__endpos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'>')
0000D7E0 =00000012                M 	__midpos:	set instr(__pos+5,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",' ')
0000D7E0 =00000011                M 	__midpos:	= __endpos
0000D7E0                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D7E0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D7E0                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D7E0                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D7E0                          M 	pushp	"move.b cDetune(a5),1(sp)"
0000D7E0                          M 	pushp	"subq.w	#2, sp"
0000D7E0 =00000002                M 	__stack:	= __stack+2
0000D7E0 =00000002                M 	__sp:	= __sp+2
0000D7E0 =00000013                M 	__pos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'%<')
0000D7E0 =00000022                M 	__endpos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'>')
0000D7E0 =00000023                M 	__midpos:	set instr(__pos+5,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",' ')
0000D7E0 =00000022                M 	__midpos:	= __endpos
0000D7E0                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D7E0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D7E0                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D7E0                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D7E0                          M 	pushp	"move.b cPitch(a5),1(sp)"
0000D7E0                          M 	pushp	"subq.w	#2, sp"
0000D7E0 =00000004                M 	__stack:	= __stack+2
0000D7E0 =00000004                M 	__sp:	= __sp+2
0000D7E0 =00000024                M 	__pos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'%<')
0000D7E0 =00000034                M 	__endpos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'>')
0000D7E0 =00000035                M 	__midpos:	set instr(__pos+5,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",' ')
0000D7E0 =00000034                M 	__midpos:	= __endpos
0000D7E0                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D7E0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D7E0                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D7E0                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D7E0                          M 	pushp	"move.b cVolume(a5),1(sp)"
0000D7E0                          M 	pushp	"subq.w	#2, sp"
0000D7E0 =00000006                M 	__stack:	= __stack+2
0000D7E0 =00000006                M 	__sp:	= __sp+2
0000D7E0 =00000036                M 	__pos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'%<')
0000D7E0 =00000044                M 	__endpos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'>')
0000D7E0 =00000045                M 	__midpos:	set instr(__pos+5,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",' ')
0000D7E0 =00000044                M 	__midpos:	= __endpos
0000D7E0                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D7E0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D7E0                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D7E0                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D7E0                          M 	pushp	"move.b cTick(a5),1(sp)"
0000D7E0                          M 	pushp	"subq.w	#2, sp"
0000D7E0 =00000008                M 	__stack:	= __stack+2
0000D7E0 =00000008                M 	__sp:	= __sp+2
0000D7E0 =00000000                M 	__pos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'%<')
0000D7E0                          M 	rept	__stack
0000D7E0                          M 	popp	__command
0000D7E0 554F                     M 	subq.w	#2,sp
0000D7E2                          M 	popp	__command
0000D7E2 1F6D 000A 0001           M 	move.b	ctick(a5),1(sp)
0000D7E8                          M 	popp	__command
0000D7E8 554F                     M 	subq.w	#2,sp
0000D7EA                          M 	popp	__command
0000D7EA 1F6D 0009 0001           M 	move.b	cvolume(a5),1(sp)
0000D7F0                          M 	popp	__command
0000D7F0 554F                     M 	subq.w	#2,sp
0000D7F2                          M 	popp	__command
0000D7F2 1F6D 0008 0001           M 	move.b	cpitch(a5),1(sp)
0000D7F8                          M 	popp	__command
0000D7F8 554F                     M 	subq.w	#2,sp
0000D7FA                          M 	popp	__command
0000D7FA 1F6D 0007 0001           M 	move.b	cdetune(a5),1(sp)
0000D800 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D804 45EF 0010                M 	lea	4*4(sp),a2
0000D808 43FA 0000                M 	lea	.str_366(pc),a1
0000D80C 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D812 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D816 504F                     M 	addq.w	#__sp,sp
0000D818 46DF                     M 	move.w	(sp)+,sr
0000D81A 6000 0000                M 	bra.w	.instr_end_366
0000D81E                          M 	.str_366:
0000D81E                          M 	__fstring_generatedecodedstring	"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D81E =00000001                M 	__lpos:	set 1
0000D81E =00000001                M 	__pos:	set instr("%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'%<')
0000D81E                          M 	while	(__pos)
0000D81E                          M 	__substr:	substr __lpos,__pos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D81E                          M 	dc.b	""
0000D81E =00000011                M 	__endpos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'>')
0000D81E =00000012                M 	__midpos:	set instr(__pos+5,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",' ')
0000D81E =00000011                M 	__midpos:	= __endpos
0000D81E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D81E                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D81E                          M 	__param:	substr ,,"hex"
0000D81E 80                       M 	dc.b	hex
0000D81F =00000012                M 	__lpos:	set __endpos+1
0000D81F =00000013                M 	__pos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'%<')
0000D81F                          M 	__substr:	substr __lpos,__pos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D81F 20                       M 	dc.b	" "
0000D820 =00000022                M 	__endpos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'>')
0000D820 =00000023                M 	__midpos:	set instr(__pos+5,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",' ')
0000D820 =00000022                M 	__midpos:	= __endpos
0000D820                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D820                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D820                          M 	__param:	substr ,,"hex"
0000D820 80                       M 	dc.b	hex
0000D821 =00000023                M 	__lpos:	set __endpos+1
0000D821 =00000024                M 	__pos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'%<')
0000D821                          M 	__substr:	substr __lpos,__pos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D821 20                       M 	dc.b	" "
0000D822 =00000034                M 	__endpos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'>')
0000D822 =00000035                M 	__midpos:	set instr(__pos+5,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",' ')
0000D822 =00000034                M 	__midpos:	= __endpos
0000D822                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D822                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D822                          M 	__param:	substr ,,"hex"
0000D822 80                       M 	dc.b	hex
0000D823 =00000035                M 	__lpos:	set __endpos+1
0000D823 =00000036                M 	__pos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'%<')
0000D823                          M 	__substr:	substr __lpos,__pos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D823 20                       M 	dc.b	" "
0000D824 =00000044                M 	__endpos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'>')
0000D824 =00000045                M 	__midpos:	set instr(__pos+5,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",' ')
0000D824 =00000044                M 	__midpos:	= __endpos
0000D824                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D824                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D824                          M 	__param:	substr ,,"hex"
0000D824 80                       M 	dc.b	hex
0000D825 =00000045                M 	__lpos:	set __endpos+1
0000D825 =00000000                M 	__pos:	set instr(__pos+1,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> ",'%<')
0000D825                          M 	__substr:	substr __lpos,,"%<.b cDetune(a5)> %<.b cPitch(a5)> %<.b cVolume(a5)> %<.b cTick(a5)> "
0000D825 20                       M 	dc.b	" "
0000D826 00                       M 	dc.b	0
0000D828 00                       M 	even
0000D828                          M 	.instr_end_366:
0000D828                            	Console.WriteLine "%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D828 40E7                     M 	move.w	sr,-(sp)
0000D82A                          M 	__fstring_generateargumentscode	"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D82A =00000001                M 	__pos:	set instr("%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'%<')
0000D82A =00000000                M 	__stack:set	0
0000D82A =00000000                M 	__sp:	set 0
0000D82A                          M 	while	(__pos)
0000D82A =00000011                M 	__endpos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'>')
0000D82A =00000012                M 	__midpos:	set instr(__pos+5,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",' ')
0000D82A =00000011                M 	__midpos:	= __endpos
0000D82A                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D82A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D82A                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D82A                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D82A                          M 	pushp	"move.b cSample(a5),1(sp)"
0000D82A                          M 	pushp	"subq.w	#2, sp"
0000D82A =00000002                M 	__stack:	= __stack+2
0000D82A =00000002                M 	__sp:	= __sp+2
0000D82A =00000013                M 	__pos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'%<')
0000D82A =00000025                M 	__endpos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'>')
0000D82A =00000026                M 	__midpos:	set instr(__pos+5,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",' ')
0000D82A =00000025                M 	__midpos:	= __endpos
0000D82A                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D82A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D82A                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D82A                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D82A                          M 	pushp	"move.b cDuration(a5),1(sp)"
0000D82A                          M 	pushp	"subq.w	#2, sp"
0000D82A =00000004                M 	__stack:	= __stack+2
0000D82A =00000004                M 	__sp:	= __sp+2
0000D82A =00000027                M 	__pos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'%<')
0000D82A =00000038                M 	__endpos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'>')
0000D82A =00000039                M 	__midpos:	set instr(__pos+5,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",' ')
0000D82A =00000038                M 	__midpos:	= __endpos
0000D82A                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D82A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D82A                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D82A                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D82A                          M 	pushp	"move.b cLastDur(a5),1(sp)"
0000D82A                          M 	pushp	"subq.w	#2, sp"
0000D82A =00000006                M 	__stack:	= __stack+2
0000D82A =00000006                M 	__sp:	= __sp+2
0000D82A =0000003A                M 	__pos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'%<')
0000D82A =00000048                M 	__endpos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'>')
0000D82A =00000000                M 	__midpos:	set instr(__pos+5,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",' ')
0000D82A =00000048                M 	__midpos:	= __endpos
0000D82A                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D82A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D82A                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D82A                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D82A                          M 	pushp	"move.w cFreq(a5),-(sp)"
0000D82A =00000007                M 	__stack:	= __stack+1
0000D82A =00000008                M 	__sp:	= __sp+2
0000D82A =00000000                M 	__pos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'%<')
0000D82A                          M 	rept	__stack
0000D82A                          M 	popp	__command
0000D82A 3F2D 000E                M 	move.w	cfreq(a5),-(sp)
0000D82E                          M 	popp	__command
0000D82E 554F                     M 	subq.w	#2,sp
0000D830                          M 	popp	__command
0000D830 1F6D 000D 0001           M 	move.b	clastdur(a5),1(sp)
0000D836                          M 	popp	__command
0000D836 554F                     M 	subq.w	#2,sp
0000D838                          M 	popp	__command
0000D838 1F6D 000C 0001           M 	move.b	cduration(a5),1(sp)
0000D83E                          M 	popp	__command
0000D83E 554F                     M 	subq.w	#2,sp
0000D840                          M 	popp	__command
0000D840 1F6D 000B 0001           M 	move.b	csample(a5),1(sp)
0000D846 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D84A 45EF 0010                M 	lea	4*4(sp),a2
0000D84E 43FA 0000                M 	lea	.str_369(pc),a1
0000D852 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000D858 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D85C 504F                     M 	addq.w	#__sp,sp
0000D85E 46DF                     M 	move.w	(sp)+,sr
0000D860 6000 0000                M 	bra.w	.instr_end_369
0000D864                          M 	.str_369:
0000D864                          M 	__fstring_generatedecodedstring	"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D864 =00000001                M 	__lpos:	set 1
0000D864 =00000001                M 	__pos:	set instr("%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'%<')
0000D864                          M 	while	(__pos)
0000D864                          M 	__substr:	substr __lpos,__pos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D864                          M 	dc.b	""
0000D864 =00000011                M 	__endpos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'>')
0000D864 =00000012                M 	__midpos:	set instr(__pos+5,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",' ')
0000D864 =00000011                M 	__midpos:	= __endpos
0000D864                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D864                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D864                          M 	__param:	substr ,,"hex"
0000D864 80                       M 	dc.b	hex
0000D865 =00000012                M 	__lpos:	set __endpos+1
0000D865 =00000013                M 	__pos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'%<')
0000D865                          M 	__substr:	substr __lpos,__pos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D865 20                       M 	dc.b	" "
0000D866 =00000025                M 	__endpos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'>')
0000D866 =00000026                M 	__midpos:	set instr(__pos+5,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",' ')
0000D866 =00000025                M 	__midpos:	= __endpos
0000D866                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D866                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D866                          M 	__param:	substr ,,"hex"
0000D866 80                       M 	dc.b	hex
0000D867 =00000026                M 	__lpos:	set __endpos+1
0000D867 =00000027                M 	__pos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'%<')
0000D867                          M 	__substr:	substr __lpos,__pos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D867 20                       M 	dc.b	" "
0000D868 =00000038                M 	__endpos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'>')
0000D868 =00000039                M 	__midpos:	set instr(__pos+5,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",' ')
0000D868 =00000038                M 	__midpos:	= __endpos
0000D868                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D868                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D868                          M 	__param:	substr ,,"hex"
0000D868 80                       M 	dc.b	hex
0000D869 =00000039                M 	__lpos:	set __endpos+1
0000D869 =0000003A                M 	__pos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'%<')
0000D869                          M 	__substr:	substr __lpos,__pos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D869 20                       M 	dc.b	" "
0000D86A =00000048                M 	__endpos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'>')
0000D86A =00000000                M 	__midpos:	set instr(__pos+5,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",' ')
0000D86A =00000048                M 	__midpos:	= __endpos
0000D86A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D86A                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D86A                          M 	__param:	substr ,,"hex"
0000D86A 81                       M 	dc.b	hex|1
0000D86B =00000049                M 	__lpos:	set __endpos+1
0000D86B =00000000                M 	__pos:	set instr(__pos+1,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>",'%<')
0000D86B                          M 	__substr:	substr __lpos,,"%<.b cSample(a5)> %<.b cDuration(a5)> %<.b cLastDur(a5)> %<.w cFreq(a5)>"
0000D86B                          M 	dc.b	""
0000D86B 00                       M 	dc.b	0
0000D86C                          M 	even
0000D86C                          M 	.instr_end_369:
0000D86C                            	Console.BreakLine
0000D86C 40E7                     M 	move.w	sr,-(sp)
0000D86E 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_startnewline
0000D874 46DF                     M 	move.w	(sp)+,sr
0000D876                            
0000D876                            	Console.WriteLine "%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D876 40E7                     M 	move.w	sr,-(sp)
0000D878                          M 	__fstring_generateargumentscode	"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D878 =00000001                M 	__pos:	set instr("%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D878 =00000000                M 	__stack:set	0
0000D878 =00000000                M 	__sp:	set 0
0000D878                          M 	while	(__pos)
0000D878 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D878 =0000000D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D878 =00000008                M 	__midpos:	= __endpos
0000D878                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D878                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D878 =0000000E                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D878 =00000015                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D878 =0000001A                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D878 =00000015                M 	__midpos:	= __endpos
0000D878                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D878                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D878 =00000016                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D878 =0000002E                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D878 =00000023                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D878                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D878                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D878                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D878                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D878                          M 	pushp	"move.l cMod(a5),-(sp)"
0000D878 =00000001                M 	__stack:	= __stack+1
0000D878 =00000004                M 	__sp:	= __sp+4
0000D878 =0000002F                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D878 =0000003F                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D878 =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D878 =0000003F                M 	__midpos:	= __endpos
0000D878                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D878                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D878 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D878                          M 	rept	__stack
0000D878                          M 	popp	__command
0000D878 2F2D 0010                M 	move.l	cmod(a5),-(sp)
0000D87C 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D880 45EF 0010                M 	lea	4*4(sp),a2
0000D884 43FA 0000                M 	lea	.str_373(pc),a1
0000D888 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000D88E 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D892 584F                     M 	addq.w	#__sp,sp
0000D894 46DF                     M 	move.w	(sp)+,sr
0000D896 6000 0000                M 	bra.w	.instr_end_373
0000D89A                          M 	.str_373:
0000D89A                          M 	__fstring_generatedecodedstring	"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D89A =00000001                M 	__lpos:	set 1
0000D89A =00000001                M 	__pos:	set instr("%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D89A                          M 	while	(__pos)
0000D89A                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D89A                          M 	dc.b	""
0000D89A =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D89A =0000000D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D89A =00000008                M 	__midpos:	= __endpos
0000D89A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D89A                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D89A EA                       M 	dc.b	fpal1
0000D89B =00000009                M 	__lpos:	set __endpos+1
0000D89B =0000000E                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D89B                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D89B 4D6F 643A 20             M 	dc.b	"Mod: "
0000D8A0 =00000015                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D8A0 =0000001A                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D8A0 =00000015                M 	__midpos:	= __endpos
0000D8A0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D8A0                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D8A0 E8                       M 	dc.b	fpal0
0000D8A1 =00000016                M 	__lpos:	set __endpos+1
0000D8A1 =00000016                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D8A1                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D8A1                          M 	dc.b	""
0000D8A1 =0000002E                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D8A1 =00000023                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D8A1                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D8A1                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D8A1 BB                       M 	dc.b	sym|fsplit|3
0000D8A2 =0000002F                M 	__lpos:	set __endpos+1
0000D8A2 =0000002F                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D8A2                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D8A2                          M 	dc.b	""
0000D8A2 =0000003F                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D8A2 =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D8A2 =0000003F                M 	__midpos:	= __endpos
0000D8A2                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D8A2                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D8A2 ECC0                     M 	dc.b	fpal2,fsymdisp
0000D8A4 =00000040                M 	__lpos:	set __endpos+1
0000D8A4 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D8A4                          M 	__substr:	substr __lpos,,"%<fpal1>Mod: %<fpal0>%<.l cMod(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000D8A4                          M 	dc.b	""
0000D8A4 00                       M 	dc.b	0
0000D8A6 00                       M 	even
0000D8A6                          M 	.instr_end_373:
0000D8A6                            	Console.Write	  "%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D8A6 40E7                     M 	move.w	sr,-(sp)
0000D8A8                          M 	__fstring_generateargumentscode	"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D8A8 =00000001                M 	__pos:	set instr("%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'%<')
0000D8A8 =00000000                M 	__stack:set	0
0000D8A8 =00000000                M 	__sp:	set 0
0000D8A8                          M 	while	(__pos)
0000D8A8 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'>')
0000D8A8 =0000000C                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",' ')
0000D8A8 =00000008                M 	__midpos:	= __endpos
0000D8A8                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D8A8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D8A8 =00000013                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'%<')
0000D8A8 =0000001A                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'>')
0000D8A8 =0000001F                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",' ')
0000D8A8 =0000001A                M 	__midpos:	= __endpos
0000D8A8                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D8A8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D8A8 =0000001B                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'%<')
0000D8A8 =0000002D                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'>')
0000D8A8 =0000002E                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",' ')
0000D8A8 =0000002D                M 	__midpos:	= __endpos
0000D8A8                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D8A8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D8A8                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D8A8                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D8A8                          M 	pushp	"move.b cModDelay(a5),1(sp)"
0000D8A8                          M 	pushp	"subq.w	#2, sp"
0000D8A8 =00000002                M 	__stack:	= __stack+2
0000D8A8 =00000002                M 	__sp:	= __sp+2
0000D8A8 =0000002F                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'%<')
0000D8A8 =00000036                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'>')
0000D8A8 =0000003B                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",' ')
0000D8A8 =00000036                M 	__midpos:	= __endpos
0000D8A8                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D8A8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D8A8 =00000037                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'%<')
0000D8A8 =00000048                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'>')
0000D8A8 =00000049                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",' ')
0000D8A8 =00000048                M 	__midpos:	= __endpos
0000D8A8                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D8A8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D8A8                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D8A8                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D8A8                          M 	pushp	"move.w cModFreq(a5),-(sp)"
0000D8A8 =00000003                M 	__stack:	= __stack+1
0000D8A8 =00000004                M 	__sp:	= __sp+2
0000D8A8 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'%<')
0000D8A8                          M 	rept	__stack
0000D8A8                          M 	popp	__command
0000D8A8 3F2D 0014                M 	move.w	cmodfreq(a5),-(sp)
0000D8AC                          M 	popp	__command
0000D8AC 554F                     M 	subq.w	#2,sp
0000D8AE                          M 	popp	__command
0000D8AE 1F6D 0010 0001           M 	move.b	cmoddelay(a5),1(sp)
0000D8B4 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D8B8 45EF 0010                M 	lea	4*4(sp),a2
0000D8BC 43FA 0000                M 	lea	.str_376(pc),a1
0000D8C0 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D8C6 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D8CA 584F                     M 	addq.w	#__sp,sp
0000D8CC 46DF                     M 	move.w	(sp)+,sr
0000D8CE 6000 0000                M 	bra.w	.instr_end_376
0000D8D2                          M 	.str_376:
0000D8D2                          M 	__fstring_generatedecodedstring	"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D8D2 =00000001                M 	__lpos:	set 1
0000D8D2 =00000001                M 	__pos:	set instr("%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'%<')
0000D8D2                          M 	while	(__pos)
0000D8D2                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D8D2                          M 	dc.b	""
0000D8D2 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'>')
0000D8D2 =0000000C                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",' ')
0000D8D2 =00000008                M 	__midpos:	= __endpos
0000D8D2                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D8D2                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D8D2 EA                       M 	dc.b	fpal1
0000D8D3 =00000009                M 	__lpos:	set __endpos+1
0000D8D3 =00000013                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'%<')
0000D8D3                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D8D3 4D6F 6420 4461 7461 3A20 M 	dc.b	"Mod Data: "
0000D8DD =0000001A                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'>')
0000D8DD =0000001F                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",' ')
0000D8DD =0000001A                M 	__midpos:	= __endpos
0000D8DD                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D8DD                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D8DD EC                       M 	dc.b	fpal2
0000D8DE =0000001B                M 	__lpos:	set __endpos+1
0000D8DE =0000001B                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'%<')
0000D8DE                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D8DE                          M 	dc.b	""
0000D8DE =0000002D                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'>')
0000D8DE =0000002E                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",' ')
0000D8DE =0000002D                M 	__midpos:	= __endpos
0000D8DE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D8DE                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D8DE                          M 	__param:	substr ,,"hex"
0000D8DE 80                       M 	dc.b	hex
0000D8DF =0000002E                M 	__lpos:	set __endpos+1
0000D8DF =0000002F                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'%<')
0000D8DF                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D8DF 20                       M 	dc.b	" "
0000D8E0 =00000036                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'>')
0000D8E0 =0000003B                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",' ')
0000D8E0 =00000036                M 	__midpos:	= __endpos
0000D8E0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D8E0                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D8E0 EC                       M 	dc.b	fpal2
0000D8E1 =00000037                M 	__lpos:	set __endpos+1
0000D8E1 =00000037                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'%<')
0000D8E1                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D8E1                          M 	dc.b	""
0000D8E1 =00000048                M 	__endpos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'>')
0000D8E1 =00000049                M 	__midpos:	set instr(__pos+5,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",' ')
0000D8E1 =00000048                M 	__midpos:	= __endpos
0000D8E1                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D8E1                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D8E1                          M 	__param:	substr ,,"hex"
0000D8E1 81                       M 	dc.b	hex|1
0000D8E2 =00000049                M 	__lpos:	set __endpos+1
0000D8E2 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> ",'%<')
0000D8E2                          M 	__substr:	substr __lpos,,"%<fpal1>Mod Data: %<fpal2>%<.b cModDelay(a5)> %<fpal2>%<.w cModFreq(a5)> "
0000D8E2 20                       M 	dc.b	" "
0000D8E3 00                       M 	dc.b	0
0000D8E4                          M 	even
0000D8E4                          M 	.instr_end_376:
0000D8E4                            	Console.WriteLine "%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D8E4 40E7                     M 	move.w	sr,-(sp)
0000D8E6                          M 	__fstring_generateargumentscode	"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D8E6 =00000001                M 	__pos:	set instr("%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",'%<')
0000D8E6 =00000000                M 	__stack:set	0
0000D8E6 =00000000                M 	__sp:	set 0
0000D8E6                          M 	while	(__pos)
0000D8E6 =00000013                M 	__endpos:	set instr(__pos+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",'>')
0000D8E6 =00000014                M 	__midpos:	set instr(__pos+5,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",' ')
0000D8E6 =00000013                M 	__midpos:	= __endpos
0000D8E6                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D8E6                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D8E6                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D8E6                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D8E6                          M 	pushp	"move.b cModSpeed(a5),1(sp)"
0000D8E6                          M 	pushp	"subq.w	#2, sp"
0000D8E6 =00000002                M 	__stack:	= __stack+2
0000D8E6 =00000002                M 	__sp:	= __sp+2
0000D8E6 =00000015                M 	__pos:	set instr(__pos+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",'%<')
0000D8E6 =00000026                M 	__endpos:	set instr(__pos+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",'>')
0000D8E6 =00000027                M 	__midpos:	set instr(__pos+5,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",' ')
0000D8E6 =00000026                M 	__midpos:	= __endpos
0000D8E6                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D8E6                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D8E6                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D8E6                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D8E6                          M 	pushp	"move.b cModStep(a5),1(sp)"
0000D8E6                          M 	pushp	"subq.w	#2, sp"
0000D8E6 =00000004                M 	__stack:	= __stack+2
0000D8E6 =00000004                M 	__sp:	= __sp+2
0000D8E6 =00000028                M 	__pos:	set instr(__pos+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",'%<')
0000D8E6 =0000003A                M 	__endpos:	set instr(__pos+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",'>')
0000D8E6 =00000000                M 	__midpos:	set instr(__pos+5,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",' ')
0000D8E6 =0000003A                M 	__midpos:	= __endpos
0000D8E6                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D8E6                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D8E6                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D8E6                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D8E6                          M 	pushp	"move.b cModCount(a5),1(sp)"
0000D8E6                          M 	pushp	"subq.w	#2, sp"
0000D8E6 =00000006                M 	__stack:	= __stack+2
0000D8E6 =00000006                M 	__sp:	= __sp+2
0000D8E6 =00000000                M 	__pos:	set instr(__pos+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",'%<')
0000D8E6                          M 	rept	__stack
0000D8E6                          M 	popp	__command
0000D8E6 554F                     M 	subq.w	#2,sp
0000D8E8                          M 	popp	__command
0000D8E8 1F6D 0018 0001           M 	move.b	cmodcount(a5),1(sp)
0000D8EE                          M 	popp	__command
0000D8EE 554F                     M 	subq.w	#2,sp
0000D8F0                          M 	popp	__command
0000D8F0 1F6D 0017 0001           M 	move.b	cmodstep(a5),1(sp)
0000D8F6                          M 	popp	__command
0000D8F6 554F                     M 	subq.w	#2,sp
0000D8F8                          M 	popp	__command
0000D8F8 1F6D 0016 0001           M 	move.b	cmodspeed(a5),1(sp)
0000D8FE 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D902 45EF 0010                M 	lea	4*4(sp),a2
0000D906 43FA 0000                M 	lea	.str_379(pc),a1
0000D90A 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000D910 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D914 5C4F                     M 	addq.w	#__sp,sp
0000D916 46DF                     M 	move.w	(sp)+,sr
0000D918 6000 0000                M 	bra.w	.instr_end_379
0000D91C                          M 	.str_379:
0000D91C                          M 	__fstring_generatedecodedstring	"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D91C =00000001                M 	__lpos:	set 1
0000D91C =00000001                M 	__pos:	set instr("%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",'%<')
0000D91C                          M 	while	(__pos)
0000D91C                          M 	__substr:	substr __lpos,__pos-1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D91C                          M 	dc.b	""
0000D91C =00000013                M 	__endpos:	set instr(__pos+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",'>')
0000D91C =00000014                M 	__midpos:	set instr(__pos+5,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",' ')
0000D91C =00000013                M 	__midpos:	= __endpos
0000D91C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D91C                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D91C                          M 	__param:	substr ,,"hex"
0000D91C 80                       M 	dc.b	hex
0000D91D =00000014                M 	__lpos:	set __endpos+1
0000D91D =00000015                M 	__pos:	set instr(__pos+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",'%<')
0000D91D                          M 	__substr:	substr __lpos,__pos-1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D91D 20                       M 	dc.b	" "
0000D91E =00000026                M 	__endpos:	set instr(__pos+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",'>')
0000D91E =00000027                M 	__midpos:	set instr(__pos+5,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",' ')
0000D91E =00000026                M 	__midpos:	= __endpos
0000D91E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D91E                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D91E                          M 	__param:	substr ,,"hex"
0000D91E 80                       M 	dc.b	hex
0000D91F =00000027                M 	__lpos:	set __endpos+1
0000D91F =00000028                M 	__pos:	set instr(__pos+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",'%<')
0000D91F                          M 	__substr:	substr __lpos,__pos-1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D91F 20                       M 	dc.b	" "
0000D920 =0000003A                M 	__endpos:	set instr(__pos+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",'>')
0000D920 =00000000                M 	__midpos:	set instr(__pos+5,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",' ')
0000D920 =0000003A                M 	__midpos:	= __endpos
0000D920                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D920                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D920                          M 	__param:	substr ,,"hex"
0000D920 80                       M 	dc.b	hex
0000D921 =0000003B                M 	__lpos:	set __endpos+1
0000D921 =00000000                M 	__pos:	set instr(__pos+1,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>",'%<')
0000D921                          M 	__substr:	substr __lpos,,"%<.b cModSpeed(a5)> %<.b cModStep(a5)> %<.b cModCount(a5)>"
0000D921                          M 	dc.b	""
0000D921 00                       M 	dc.b	0
0000D922                          M 	even
0000D922                          M 	.instr_end_379:
0000D922                            	Console.BreakLine
0000D922 40E7                     M 	move.w	sr,-(sp)
0000D924 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_startnewline
0000D92A 46DF                     M 	move.w	(sp)+,sr
0000D92C                            
0000D92C                            	Console.Write "%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D92C 40E7                     M 	move.w	sr,-(sp)
0000D92E                          M 	__fstring_generateargumentscode	"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D92E =00000001                M 	__pos:	set instr("%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'%<')
0000D92E =00000000                M 	__stack:set	0
0000D92E =00000000                M 	__sp:	set 0
0000D92E                          M 	while	(__pos)
0000D92E =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'>')
0000D92E =0000000E                M 	__midpos:	set instr(__pos+5,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",' ')
0000D92E =00000008                M 	__midpos:	= __endpos
0000D92E                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D92E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D92E =0000000F                M 	__pos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'%<')
0000D92E =00000016                M 	__endpos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'>')
0000D92E =0000001B                M 	__midpos:	set instr(__pos+5,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",' ')
0000D92E =00000016                M 	__midpos:	= __endpos
0000D92E                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D92E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D92E =00000017                M 	__pos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'%<')
0000D92E =00000025                M 	__endpos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'>')
0000D92E =00000026                M 	__midpos:	set instr(__pos+5,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",' ')
0000D92E =00000025                M 	__midpos:	= __endpos
0000D92E                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D92E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D92E                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D92E                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D92E                          M 	pushp	"move.b cLoop(a5),1(sp)"
0000D92E                          M 	pushp	"subq.w	#2, sp"
0000D92E =00000002                M 	__stack:	= __stack+2
0000D92E =00000002                M 	__sp:	= __sp+2
0000D92E =00000027                M 	__pos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'%<')
0000D92E =00000037                M 	__endpos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'>')
0000D92E =00000038                M 	__midpos:	set instr(__pos+5,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",' ')
0000D92E =00000037                M 	__midpos:	= __endpos
0000D92E                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D92E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D92E                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D92E                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D92E                          M 	pushp	"move.b cLoop+1(a5),1(sp)"
0000D92E                          M 	pushp	"subq.w	#2, sp"
0000D92E =00000004                M 	__stack:	= __stack+2
0000D92E =00000004                M 	__sp:	= __sp+2
0000D92E =00000039                M 	__pos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'%<')
0000D92E =00000049                M 	__endpos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'>')
0000D92E =0000004A                M 	__midpos:	set instr(__pos+5,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",' ')
0000D92E =00000049                M 	__midpos:	= __endpos
0000D92E                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D92E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D92E                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D92E                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D92E                          M 	pushp	"move.b cLoop+2(a5),1(sp)"
0000D92E                          M 	pushp	"subq.w	#2, sp"
0000D92E =00000006                M 	__stack:	= __stack+2
0000D92E =00000006                M 	__sp:	= __sp+2
0000D92E =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'%<')
0000D92E                          M 	rept	__stack
0000D92E                          M 	popp	__command
0000D92E 554F                     M 	subq.w	#2,sp
0000D930                          M 	popp	__command
0000D930 1F6D 001B 0001           M 	move.b	cloop+2(a5),1(sp)
0000D936                          M 	popp	__command
0000D936 554F                     M 	subq.w	#2,sp
0000D938                          M 	popp	__command
0000D938 1F6D 001A 0001           M 	move.b	cloop+1(a5),1(sp)
0000D93E                          M 	popp	__command
0000D93E 554F                     M 	subq.w	#2,sp
0000D940                          M 	popp	__command
0000D940 1F6D 0019 0001           M 	move.b	cloop(a5),1(sp)
0000D946 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D94A 45EF 0010                M 	lea	4*4(sp),a2
0000D94E 43FA 0000                M 	lea	.str_383(pc),a1
0000D952 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000D958 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D95C 5C4F                     M 	addq.w	#__sp,sp
0000D95E 46DF                     M 	move.w	(sp)+,sr
0000D960 6000 0000                M 	bra.w	.instr_end_383
0000D964                          M 	.str_383:
0000D964                          M 	__fstring_generatedecodedstring	"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D964 =00000001                M 	__lpos:	set 1
0000D964 =00000001                M 	__pos:	set instr("%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'%<')
0000D964                          M 	while	(__pos)
0000D964                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D964                          M 	dc.b	""
0000D964 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'>')
0000D964 =0000000E                M 	__midpos:	set instr(__pos+5,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",' ')
0000D964 =00000008                M 	__midpos:	= __endpos
0000D964                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D964                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D964 EA                       M 	dc.b	fpal1
0000D965 =00000009                M 	__lpos:	set __endpos+1
0000D965 =0000000F                M 	__pos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'%<')
0000D965                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D965 4C6F 6F70 3A20           M 	dc.b	"Loop: "
0000D96B =00000016                M 	__endpos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'>')
0000D96B =0000001B                M 	__midpos:	set instr(__pos+5,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",' ')
0000D96B =00000016                M 	__midpos:	= __endpos
0000D96B                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D96B                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D96B EC                       M 	dc.b	fpal2
0000D96C =00000017                M 	__lpos:	set __endpos+1
0000D96C =00000017                M 	__pos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'%<')
0000D96C                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D96C                          M 	dc.b	""
0000D96C =00000025                M 	__endpos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'>')
0000D96C =00000026                M 	__midpos:	set instr(__pos+5,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",' ')
0000D96C =00000025                M 	__midpos:	= __endpos
0000D96C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D96C                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D96C                          M 	__param:	substr ,,"hex"
0000D96C 80                       M 	dc.b	hex
0000D96D =00000026                M 	__lpos:	set __endpos+1
0000D96D =00000027                M 	__pos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'%<')
0000D96D                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D96D 20                       M 	dc.b	" "
0000D96E =00000037                M 	__endpos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'>')
0000D96E =00000038                M 	__midpos:	set instr(__pos+5,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",' ')
0000D96E =00000037                M 	__midpos:	= __endpos
0000D96E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D96E                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D96E                          M 	__param:	substr ,,"hex"
0000D96E 80                       M 	dc.b	hex
0000D96F =00000038                M 	__lpos:	set __endpos+1
0000D96F =00000039                M 	__pos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'%<')
0000D96F                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D96F 20                       M 	dc.b	" "
0000D970 =00000049                M 	__endpos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'>')
0000D970 =0000004A                M 	__midpos:	set instr(__pos+5,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",' ')
0000D970 =00000049                M 	__midpos:	= __endpos
0000D970                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D970                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D970                          M 	__param:	substr ,,"hex"
0000D970 80                       M 	dc.b	hex
0000D971 =0000004A                M 	__lpos:	set __endpos+1
0000D971 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> ",'%<')
0000D971                          M 	__substr:	substr __lpos,,"%<fpal1>Loop: %<fpal2>%<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)> "
0000D971 20                       M 	dc.b	" "
0000D972 00                       M 	dc.b	0
0000D974 00                       M 	even
0000D974                          M 	.instr_end_383:
0000D974 BAFC C67C                  	cmp.w	#mSFXDAC1,a5
0000D978 6400 0000                  	bhs.w	AMPS_Debug_Console_Channel_Writerts
0000D97C                            	Console.WriteLine "%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000D97C 40E7                     M 	move.w	sr,-(sp)
0000D97E                          M 	__fstring_generateargumentscode	"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000D97E =00000001                M 	__pos:	set instr("%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>",'%<')
0000D97E =00000000                M 	__stack:set	0
0000D97E =00000000                M 	__sp:	set 0
0000D97E                          M 	while	(__pos)
0000D97E =00000016                M 	__endpos:	set instr(__pos+1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>",'>')
0000D97E =00000017                M 	__midpos:	set instr(__pos+5,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>",' ')
0000D97E =00000016                M 	__midpos:	= __endpos
0000D97E                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000D97E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000D97E                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000D97E                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000D97E                          M 	pushp	"move.b cNoteTimeCur(a5),1(sp)"
0000D97E                          M 	pushp	"subq.w	#2, sp"
0000D97E =00000002                M 	__stack:	= __stack+2
0000D97E =00000002                M 	__sp:	= __sp+2
0000D97E =00000018                M 	__pos:	set instr(__pos+1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>",'%<')
0000D97E =0000002E                M 	__endpos:	set instr(__pos+1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>",'>')
0000D97E =00000000                M 	__midpos:	set instr(__pos+5,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>",' ')
0000D97E =0000002E                M 	__midpos:	= __endpos
0000D97E                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000D97E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000D97E                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000D97E                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000D97E                          M 	pushp	"move.b cNoteTimeMain(a5),1(sp)"
0000D97E                          M 	pushp	"subq.w	#2, sp"
0000D97E =00000004                M 	__stack:	= __stack+2
0000D97E =00000004                M 	__sp:	= __sp+2
0000D97E =00000000                M 	__pos:	set instr(__pos+1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>",'%<')
0000D97E                          M 	rept	__stack
0000D97E                          M 	popp	__command
0000D97E 554F                     M 	subq.w	#2,sp
0000D980                          M 	popp	__command
0000D980 1F6D 001D 0001           M 	move.b	cnotetimemain(a5),1(sp)
0000D986                          M 	popp	__command
0000D986 554F                     M 	subq.w	#2,sp
0000D988                          M 	popp	__command
0000D988 1F6D 001C 0001           M 	move.b	cnotetimecur(a5),1(sp)
0000D98E 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D992 45EF 0010                M 	lea	4*4(sp),a2
0000D996 43FA 0000                M 	lea	.str_386(pc),a1
0000D99A 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000D9A0 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D9A4 584F                     M 	addq.w	#__sp,sp
0000D9A6 46DF                     M 	move.w	(sp)+,sr
0000D9A8 6000 0000                M 	bra.w	.instr_end_386
0000D9AC                          M 	.str_386:
0000D9AC                          M 	__fstring_generatedecodedstring	"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000D9AC =00000001                M 	__lpos:	set 1
0000D9AC =00000001                M 	__pos:	set instr("%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>",'%<')
0000D9AC                          M 	while	(__pos)
0000D9AC                          M 	__substr:	substr __lpos,__pos-1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000D9AC                          M 	dc.b	""
0000D9AC =00000016                M 	__endpos:	set instr(__pos+1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>",'>')
0000D9AC =00000017                M 	__midpos:	set instr(__pos+5,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>",' ')
0000D9AC =00000016                M 	__midpos:	= __endpos
0000D9AC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000D9AC                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000D9AC                          M 	__param:	substr ,,"hex"
0000D9AC 80                       M 	dc.b	hex
0000D9AD =00000017                M 	__lpos:	set __endpos+1
0000D9AD =00000018                M 	__pos:	set instr(__pos+1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>",'%<')
0000D9AD                          M 	__substr:	substr __lpos,__pos-1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000D9AD 20                       M 	dc.b	" "
0000D9AE =0000002E                M 	__endpos:	set instr(__pos+1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>",'>')
0000D9AE =00000000                M 	__midpos:	set instr(__pos+5,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>",' ')
0000D9AE =0000002E                M 	__midpos:	= __endpos
0000D9AE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000D9AE                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000D9AE                          M 	__param:	substr ,,"hex"
0000D9AE 80                       M 	dc.b	hex
0000D9AF =0000002F                M 	__lpos:	set __endpos+1
0000D9AF =00000000                M 	__pos:	set instr(__pos+1,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>",'%<')
0000D9AF                          M 	__substr:	substr __lpos,,"%<.b cNoteTimeCur(a5)> %<.b cNoteTimeMain(a5)>"
0000D9AF                          M 	dc.b	""
0000D9AF 00                       M 	dc.b	0
0000D9B0                          M 	even
0000D9B0                          M 	.instr_end_386:
0000D9B0                            	Console.WriteLine "%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000D9B0 40E7                     M 	move.w	sr,-(sp)
0000D9B2                          M 	__fstring_generateargumentscode	"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000D9B2 =00000001                M 	__pos:	set instr("%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",'%<')
0000D9B2 =00000000                M 	__stack:set	0
0000D9B2 =00000000                M 	__sp:	set 0
0000D9B2                          M 	while	(__pos)
0000D9B2 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",'>')
0000D9B2 =0000000F                M 	__midpos:	set instr(__pos+5,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",' ')
0000D9B2 =00000008                M 	__midpos:	= __endpos
0000D9B2                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000D9B2                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000D9B2 =00000010                M 	__pos:	set instr(__pos+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",'%<')
0000D9B2 =00000017                M 	__endpos:	set instr(__pos+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",'>')
0000D9B2 =0000001C                M 	__midpos:	set instr(__pos+5,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",' ')
0000D9B2 =00000017                M 	__midpos:	= __endpos
0000D9B2                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000D9B2                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000D9B2 =00000018                M 	__pos:	set instr(__pos+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",'%<')
0000D9B2 =00000027                M 	__endpos:	set instr(__pos+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",'>')
0000D9B2 =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",' ')
0000D9B2 =00000027                M 	__midpos:	= __endpos
0000D9B2                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000D9B2                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000D9B2                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000D9B2                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000D9B2                          M 	pushp	"move.b cStack(a5),1(sp)"
0000D9B2                          M 	pushp	"subq.w	#2, sp"
0000D9B2 =00000002                M 	__stack:	= __stack+2
0000D9B2 =00000002                M 	__sp:	= __sp+2
0000D9B2 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",'%<')
0000D9B2                          M 	rept	__stack
0000D9B2                          M 	popp	__command
0000D9B2 554F                     M 	subq.w	#2,sp
0000D9B4                          M 	popp	__command
0000D9B4 1F6D 001E 0001           M 	move.b	cstack(a5),1(sp)
0000D9BA 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D9BE 45EF 0010                M 	lea	4*4(sp),a2
0000D9C2 43FA 0000                M 	lea	.str_389(pc),a1
0000D9C6 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000D9CC 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000D9D0 544F                     M 	addq.w	#__sp,sp
0000D9D2 46DF                     M 	move.w	(sp)+,sr
0000D9D4 6000 0000                M 	bra.w	.instr_end_389
0000D9D8                          M 	.str_389:
0000D9D8                          M 	__fstring_generatedecodedstring	"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000D9D8 =00000001                M 	__lpos:	set 1
0000D9D8 =00000001                M 	__pos:	set instr("%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",'%<')
0000D9D8                          M 	while	(__pos)
0000D9D8                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000D9D8                          M 	dc.b	""
0000D9D8 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",'>')
0000D9D8 =0000000F                M 	__midpos:	set instr(__pos+5,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",' ')
0000D9D8 =00000008                M 	__midpos:	= __endpos
0000D9D8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000D9D8                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000D9D8 EA                       M 	dc.b	fpal1
0000D9D9 =00000009                M 	__lpos:	set __endpos+1
0000D9D9 =00000010                M 	__pos:	set instr(__pos+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",'%<')
0000D9D9                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000D9D9 5374 6163 6B3A 20        M 	dc.b	"Stack: "
0000D9E0 =00000017                M 	__endpos:	set instr(__pos+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",'>')
0000D9E0 =0000001C                M 	__midpos:	set instr(__pos+5,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",' ')
0000D9E0 =00000017                M 	__midpos:	= __endpos
0000D9E0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000D9E0                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000D9E0 EC                       M 	dc.b	fpal2
0000D9E1 =00000018                M 	__lpos:	set __endpos+1
0000D9E1 =00000018                M 	__pos:	set instr(__pos+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",'%<')
0000D9E1                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000D9E1                          M 	dc.b	""
0000D9E1 =00000027                M 	__endpos:	set instr(__pos+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",'>')
0000D9E1 =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",' ')
0000D9E1 =00000027                M 	__midpos:	= __endpos
0000D9E1                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000D9E1                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000D9E1                          M 	__param:	substr ,,"hex"
0000D9E1 80                       M 	dc.b	hex
0000D9E2 =00000028                M 	__lpos:	set __endpos+1
0000D9E2 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>",'%<')
0000D9E2                          M 	__substr:	substr __lpos,,"%<fpal1>Stack: %<fpal2>%<.b cStack(a5)>"
0000D9E2                          M 	dc.b	""
0000D9E2 00                       M 	dc.b	0
0000D9E4 00                       M 	even
0000D9E4                          M 	.instr_end_389:
0000D9E4                            
0000D9E4 320D                       	move.w	a5,d1
0000D9E6 0641 002C                  	add.w	#cSize,d1
0000D9EA                            
0000D9EA 7000                       	moveq	#0,d0
0000D9EC 102D 001E                  	move.b	cStack(a5),d0
0000D9F0 DAC0                       	add.w	d0,a5
0000D9F2                            
0000D9F2                            AMPS_Debug_Console_Channel_Writeloop
0000D9F2 B24D                       	cmp.w	a5,d1
0000D9F4 6300                       	bls.s	AMPS_Debug_Console_Channel_Writerts
0000D9F6                            	Console.WriteLine "%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000D9F6 40E7                     M 	move.w	sr,-(sp)
0000D9F8                          M 	__fstring_generateargumentscode	"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000D9F8 =00000001                M 	__pos:	set instr("%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D9F8 =00000000                M 	__stack:set	0
0000D9F8 =00000000                M 	__sp:	set 0
0000D9F8                          M 	while	(__pos)
0000D9F8 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D9F8 =0000000D                M 	__midpos:	set instr(__pos+5,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D9F8 =00000008                M 	__midpos:	= __endpos
0000D9F8                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000D9F8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000D9F8 =00000009                M 	__pos:	set instr(__pos+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D9F8 =0000001E                M 	__endpos:	set instr(__pos+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D9F8 =00000013                M 	__midpos:	set instr(__pos+5,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D9F8                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000D9F8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000D9F8                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000D9F8                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000D9F8                          M 	pushp	"move.l (a5)+,-(sp)"
0000D9F8 =00000001                M 	__stack:	= __stack+1
0000D9F8 =00000004                M 	__sp:	= __sp+4
0000D9F8 =0000001F                M 	__pos:	set instr(__pos+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D9F8 =0000002F                M 	__endpos:	set instr(__pos+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000D9F8 =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000D9F8 =0000002F                M 	__midpos:	= __endpos
0000D9F8                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000D9F8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000D9F8 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000D9F8                          M 	rept	__stack
0000D9F8                          M 	popp	__command
0000D9F8 2F1D                     M 	move.l	(a5)+,-(sp)
0000D9FA 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000D9FE 45EF 0010                M 	lea	4*4(sp),a2
0000DA02 43FA 0000                M 	lea	.str_392(pc),a1
0000DA06 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000DA0C 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DA10 584F                     M 	addq.w	#__sp,sp
0000DA12 46DF                     M 	move.w	(sp)+,sr
0000DA14 6000 0000                M 	bra.w	.instr_end_392
0000DA18                          M 	.str_392:
0000DA18                          M 	__fstring_generatedecodedstring	"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DA18 =00000001                M 	__lpos:	set 1
0000DA18 =00000001                M 	__pos:	set instr("%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DA18                          M 	while	(__pos)
0000DA18                          M 	__substr:	substr __lpos,__pos-1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DA18                          M 	dc.b	""
0000DA18 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DA18 =0000000D                M 	__midpos:	set instr(__pos+5,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DA18 =00000008                M 	__midpos:	= __endpos
0000DA18                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DA18                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DA18 E8                       M 	dc.b	fpal0
0000DA19 =00000009                M 	__lpos:	set __endpos+1
0000DA19 =00000009                M 	__pos:	set instr(__pos+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DA19                          M 	__substr:	substr __lpos,__pos-1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DA19                          M 	dc.b	""
0000DA19 =0000001E                M 	__endpos:	set instr(__pos+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DA19 =00000013                M 	__midpos:	set instr(__pos+5,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DA19                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DA19                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DA19 BB                       M 	dc.b	sym|fsplit|3
0000DA1A =0000001F                M 	__lpos:	set __endpos+1
0000DA1A =0000001F                M 	__pos:	set instr(__pos+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DA1A                          M 	__substr:	substr __lpos,__pos-1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DA1A                          M 	dc.b	""
0000DA1A =0000002F                M 	__endpos:	set instr(__pos+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DA1A =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DA1A =0000002F                M 	__midpos:	= __endpos
0000DA1A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DA1A                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DA1A ECC0                     M 	dc.b	fpal2,fsymdisp
0000DA1C =00000030                M 	__lpos:	set __endpos+1
0000DA1C =00000000                M 	__pos:	set instr(__pos+1,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DA1C                          M 	__substr:	substr __lpos,,"%<fpal0>%<.l (a5)+ sym|fsplit>%<fpal2,fsymdisp>"
0000DA1C                          M 	dc.b	""
0000DA1C 00                       M 	dc.b	0
0000DA1E 00                       M 	even
0000DA1E                          M 	.instr_end_392:
0000DA1E 60D2                       	bra.s	AMPS_Debug_Console_Channel_Writeloop
0000DA20                            
0000DA20                            AMPS_Debug_Console_Channel_Writerts
0000DA20 4E75                       	rts
0000DA22                            ; ===========================================================================
0000DA22                            ; ---------------------------------------------------------------------------
0000DA22                            ; Generic console code
0000DA22                            ; ---------------------------------------------------------------------------
0000DA22                            
0000DA22                            AMPS_Debug_Console_Main:
0000DA22                            	Console.WriteLine "  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA22 40E7                     M 	move.w	sr,-(sp)
0000DA24                          M 	__fstring_generateargumentscode	"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA24 =00000003                M 	__pos:	set instr("  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000DA24 =00000000                M 	__stack:set	0
0000DA24 =00000000                M 	__sp:	set 0
0000DA24                          M 	while	(__pos)
0000DA24 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000DA24 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000DA24 =0000000A                M 	__midpos:	= __endpos
0000DA24                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA24                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA24 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000DA24 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000DA24 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000DA24 =00000016                M 	__midpos:	= __endpos
0000DA24                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA24                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA24 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000DA24 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000DA24 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000DA24 =0000001E                M 	__midpos:	= __endpos
0000DA24                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA24                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA24                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA24                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA24                          M 	pushp	"move.l d0,-(sp)"
0000DA24 =00000001                M 	__stack:	= __stack+1
0000DA24 =00000004                M 	__sp:	= __sp+4
0000DA24 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000DA24 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000DA24 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000DA24 =00000028                M 	__midpos:	= __endpos
0000DA24                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA24                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA24 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000DA24 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000DA24 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000DA24 =00000034                M 	__midpos:	= __endpos
0000DA24                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA24                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA24 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000DA24 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000DA24 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000DA24 =0000003C                M 	__midpos:	= __endpos
0000DA24                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA24                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA24                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA24                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA24                          M 	pushp	"move.l a0,-(sp)"
0000DA24 =00000002                M 	__stack:	= __stack+1
0000DA24 =00000008                M 	__sp:	= __sp+4
0000DA24 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000DA24                          M 	rept	__stack
0000DA24                          M 	popp	__command
0000DA24 2F08                     M 	move.l	a0,-(sp)
0000DA26                          M 	popp	__command
0000DA26 2F00                     M 	move.l	d0,-(sp)
0000DA28 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DA2C 45EF 0010                M 	lea	4*4(sp),a2
0000DA30 43FA 0000                M 	lea	.str_395(pc),a1
0000DA34 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000DA3A 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DA3E 504F                     M 	addq.w	#__sp,sp
0000DA40 46DF                     M 	move.w	(sp)+,sr
0000DA42 6000 0000                M 	bra.w	.instr_end_395
0000DA46                          M 	.str_395:
0000DA46                          M 	__fstring_generatedecodedstring	"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA46 =00000001                M 	__lpos:	set 1
0000DA46 =00000003                M 	__pos:	set instr("  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000DA46                          M 	while	(__pos)
0000DA46                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA46 2020                     M 	dc.b	"  "
0000DA48 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000DA48 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000DA48 =0000000A                M 	__midpos:	= __endpos
0000DA48                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA48                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA48 E8                       M 	dc.b	fpal0
0000DA49 =0000000B                M 	__lpos:	set __endpos+1
0000DA49 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000DA49                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA49 6430 3A20                M 	dc.b	"d0: "
0000DA4D =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000DA4D =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000DA4D =00000016                M 	__midpos:	= __endpos
0000DA4D                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA4D                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA4D EC                       M 	dc.b	fpal2
0000DA4E =00000017                M 	__lpos:	set __endpos+1
0000DA4E =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000DA4E                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA4E                          M 	dc.b	""
0000DA4E =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000DA4E =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000DA4E =0000001E                M 	__midpos:	= __endpos
0000DA4E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA4E                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA4E                          M 	__param:	substr ,,"hex"
0000DA4E 83                       M 	dc.b	hex|3
0000DA4F =0000001F                M 	__lpos:	set __endpos+1
0000DA4F =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000DA4F                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA4F 2020                     M 	dc.b	"  "
0000DA51 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000DA51 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000DA51 =00000028                M 	__midpos:	= __endpos
0000DA51                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA51                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA51 E8                       M 	dc.b	fpal0
0000DA52 =00000029                M 	__lpos:	set __endpos+1
0000DA52 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000DA52                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA52 6130 3A20                M 	dc.b	"a0: "
0000DA56 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000DA56 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000DA56 =00000034                M 	__midpos:	= __endpos
0000DA56                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA56                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA56 EC                       M 	dc.b	fpal2
0000DA57 =00000035                M 	__lpos:	set __endpos+1
0000DA57 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000DA57                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA57                          M 	dc.b	""
0000DA57 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'>')
0000DA57 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",' ')
0000DA57 =0000003C                M 	__midpos:	= __endpos
0000DA57                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA57                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA57                          M 	__param:	substr ,,"hex"
0000DA57 83                       M 	dc.b	hex|3
0000DA58 =0000003D                M 	__lpos:	set __endpos+1
0000DA58 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>",'%<')
0000DA58                          M 	__substr:	substr __lpos,,"  %<fpal0>d0: %<fpal2>%<.l d0>  %<fpal0>a0: %<fpal2>%<.l a0>"
0000DA58                          M 	dc.b	""
0000DA58 00                       M 	dc.b	0
0000DA5A 00                       M 	even
0000DA5A                          M 	.instr_end_395:
0000DA5A                            	Console.WriteLine "  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DA5A 40E7                     M 	move.w	sr,-(sp)
0000DA5C                          M 	__fstring_generateargumentscode	"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DA5C =00000003                M 	__pos:	set instr("  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000DA5C =00000000                M 	__stack:set	0
0000DA5C =00000000                M 	__sp:	set 0
0000DA5C                          M 	while	(__pos)
0000DA5C =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000DA5C =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000DA5C =0000000A                M 	__midpos:	= __endpos
0000DA5C                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DA5C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DA5C =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000DA5C =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000DA5C =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000DA5C =00000016                M 	__midpos:	= __endpos
0000DA5C                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DA5C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DA5C =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000DA5C =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000DA5C =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000DA5C =0000001E                M 	__midpos:	= __endpos
0000DA5C                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DA5C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DA5C                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DA5C                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DA5C                          M 	pushp	"move.l d1,-(sp)"
0000DA5C =00000001                M 	__stack:	= __stack+1
0000DA5C =00000004                M 	__sp:	= __sp+4
0000DA5C =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000DA5C =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000DA5C =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000DA5C =00000028                M 	__midpos:	= __endpos
0000DA5C                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DA5C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DA5C =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000DA5C =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000DA5C =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000DA5C =00000034                M 	__midpos:	= __endpos
0000DA5C                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DA5C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DA5C =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000DA5C =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000DA5C =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000DA5C =0000003C                M 	__midpos:	= __endpos
0000DA5C                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DA5C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DA5C                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DA5C                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DA5C                          M 	pushp	"move.l a1,-(sp)"
0000DA5C =00000002                M 	__stack:	= __stack+1
0000DA5C =00000008                M 	__sp:	= __sp+4
0000DA5C =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000DA5C                          M 	rept	__stack
0000DA5C                          M 	popp	__command
0000DA5C 2F09                     M 	move.l	a1,-(sp)
0000DA5E                          M 	popp	__command
0000DA5E 2F01                     M 	move.l	d1,-(sp)
0000DA60 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DA64 45EF 0010                M 	lea	4*4(sp),a2
0000DA68 43FA 0000                M 	lea	.str_398(pc),a1
0000DA6C 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000DA72 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DA76 504F                     M 	addq.w	#__sp,sp
0000DA78 46DF                     M 	move.w	(sp)+,sr
0000DA7A 6000 0000                M 	bra.w	.instr_end_398
0000DA7E                          M 	.str_398:
0000DA7E                          M 	__fstring_generatedecodedstring	"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DA7E =00000001                M 	__lpos:	set 1
0000DA7E =00000003                M 	__pos:	set instr("  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000DA7E                          M 	while	(__pos)
0000DA7E                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DA7E 2020                     M 	dc.b	"  "
0000DA80 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000DA80 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000DA80 =0000000A                M 	__midpos:	= __endpos
0000DA80                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DA80                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DA80 E8                       M 	dc.b	fpal0
0000DA81 =0000000B                M 	__lpos:	set __endpos+1
0000DA81 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000DA81                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DA81 6431 3A20                M 	dc.b	"d1: "
0000DA85 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000DA85 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000DA85 =00000016                M 	__midpos:	= __endpos
0000DA85                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DA85                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DA85 EC                       M 	dc.b	fpal2
0000DA86 =00000017                M 	__lpos:	set __endpos+1
0000DA86 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000DA86                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DA86                          M 	dc.b	""
0000DA86 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000DA86 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000DA86 =0000001E                M 	__midpos:	= __endpos
0000DA86                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DA86                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DA86                          M 	__param:	substr ,,"hex"
0000DA86 83                       M 	dc.b	hex|3
0000DA87 =0000001F                M 	__lpos:	set __endpos+1
0000DA87 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000DA87                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DA87 2020                     M 	dc.b	"  "
0000DA89 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000DA89 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000DA89 =00000028                M 	__midpos:	= __endpos
0000DA89                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DA89                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DA89 E8                       M 	dc.b	fpal0
0000DA8A =00000029                M 	__lpos:	set __endpos+1
0000DA8A =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000DA8A                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DA8A 6131 3A20                M 	dc.b	"a1: "
0000DA8E =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000DA8E =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000DA8E =00000034                M 	__midpos:	= __endpos
0000DA8E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DA8E                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DA8E EC                       M 	dc.b	fpal2
0000DA8F =00000035                M 	__lpos:	set __endpos+1
0000DA8F =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000DA8F                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DA8F                          M 	dc.b	""
0000DA8F =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'>')
0000DA8F =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",' ')
0000DA8F =0000003C                M 	__midpos:	= __endpos
0000DA8F                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DA8F                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DA8F                          M 	__param:	substr ,,"hex"
0000DA8F 83                       M 	dc.b	hex|3
0000DA90 =0000003D                M 	__lpos:	set __endpos+1
0000DA90 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>",'%<')
0000DA90                          M 	__substr:	substr __lpos,,"  %<fpal0>d1: %<fpal2>%<.l d1>  %<fpal0>a1: %<fpal2>%<.l a1>"
0000DA90                          M 	dc.b	""
0000DA90 00                       M 	dc.b	0
0000DA92 00                       M 	even
0000DA92                          M 	.instr_end_398:
0000DA92                            	Console.WriteLine "  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DA92 40E7                     M 	move.w	sr,-(sp)
0000DA94                          M 	__fstring_generateargumentscode	"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DA94 =00000003                M 	__pos:	set instr("  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000DA94 =00000000                M 	__stack:set	0
0000DA94 =00000000                M 	__sp:	set 0
0000DA94                          M 	while	(__pos)
0000DA94 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000DA94 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000DA94 =0000000A                M 	__midpos:	= __endpos
0000DA94                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DA94                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DA94 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000DA94 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000DA94 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000DA94 =00000016                M 	__midpos:	= __endpos
0000DA94                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DA94                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DA94 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000DA94 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000DA94 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000DA94 =0000001E                M 	__midpos:	= __endpos
0000DA94                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DA94                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DA94                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DA94                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DA94                          M 	pushp	"move.l d2,-(sp)"
0000DA94 =00000001                M 	__stack:	= __stack+1
0000DA94 =00000004                M 	__sp:	= __sp+4
0000DA94 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000DA94 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000DA94 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000DA94 =00000028                M 	__midpos:	= __endpos
0000DA94                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DA94                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DA94 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000DA94 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000DA94 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000DA94 =00000034                M 	__midpos:	= __endpos
0000DA94                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DA94                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DA94 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000DA94 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000DA94 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000DA94 =0000003C                M 	__midpos:	= __endpos
0000DA94                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DA94                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DA94                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DA94                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DA94                          M 	pushp	"move.l a2,-(sp)"
0000DA94 =00000002                M 	__stack:	= __stack+1
0000DA94 =00000008                M 	__sp:	= __sp+4
0000DA94 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000DA94                          M 	rept	__stack
0000DA94                          M 	popp	__command
0000DA94 2F0A                     M 	move.l	a2,-(sp)
0000DA96                          M 	popp	__command
0000DA96 2F02                     M 	move.l	d2,-(sp)
0000DA98 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DA9C 45EF 0010                M 	lea	4*4(sp),a2
0000DAA0 43FA 0000                M 	lea	.str_401(pc),a1
0000DAA4 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000DAAA 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DAAE 504F                     M 	addq.w	#__sp,sp
0000DAB0 46DF                     M 	move.w	(sp)+,sr
0000DAB2 6000 0000                M 	bra.w	.instr_end_401
0000DAB6                          M 	.str_401:
0000DAB6                          M 	__fstring_generatedecodedstring	"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DAB6 =00000001                M 	__lpos:	set 1
0000DAB6 =00000003                M 	__pos:	set instr("  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000DAB6                          M 	while	(__pos)
0000DAB6                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DAB6 2020                     M 	dc.b	"  "
0000DAB8 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000DAB8 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000DAB8 =0000000A                M 	__midpos:	= __endpos
0000DAB8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DAB8                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DAB8 E8                       M 	dc.b	fpal0
0000DAB9 =0000000B                M 	__lpos:	set __endpos+1
0000DAB9 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000DAB9                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DAB9 6432 3A20                M 	dc.b	"d2: "
0000DABD =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000DABD =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000DABD =00000016                M 	__midpos:	= __endpos
0000DABD                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DABD                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DABD EC                       M 	dc.b	fpal2
0000DABE =00000017                M 	__lpos:	set __endpos+1
0000DABE =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000DABE                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DABE                          M 	dc.b	""
0000DABE =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000DABE =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000DABE =0000001E                M 	__midpos:	= __endpos
0000DABE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DABE                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DABE                          M 	__param:	substr ,,"hex"
0000DABE 83                       M 	dc.b	hex|3
0000DABF =0000001F                M 	__lpos:	set __endpos+1
0000DABF =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000DABF                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DABF 2020                     M 	dc.b	"  "
0000DAC1 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000DAC1 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000DAC1 =00000028                M 	__midpos:	= __endpos
0000DAC1                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DAC1                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DAC1 E8                       M 	dc.b	fpal0
0000DAC2 =00000029                M 	__lpos:	set __endpos+1
0000DAC2 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000DAC2                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DAC2 6132 3A20                M 	dc.b	"a2: "
0000DAC6 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000DAC6 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000DAC6 =00000034                M 	__midpos:	= __endpos
0000DAC6                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DAC6                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DAC6 EC                       M 	dc.b	fpal2
0000DAC7 =00000035                M 	__lpos:	set __endpos+1
0000DAC7 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000DAC7                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DAC7                          M 	dc.b	""
0000DAC7 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'>')
0000DAC7 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",' ')
0000DAC7 =0000003C                M 	__midpos:	= __endpos
0000DAC7                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DAC7                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DAC7                          M 	__param:	substr ,,"hex"
0000DAC7 83                       M 	dc.b	hex|3
0000DAC8 =0000003D                M 	__lpos:	set __endpos+1
0000DAC8 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>",'%<')
0000DAC8                          M 	__substr:	substr __lpos,,"  %<fpal0>d2: %<fpal2>%<.l d2>  %<fpal0>a2: %<fpal2>%<.l a2>"
0000DAC8                          M 	dc.b	""
0000DAC8 00                       M 	dc.b	0
0000DACA 00                       M 	even
0000DACA                          M 	.instr_end_401:
0000DACA                            	Console.WriteLine "  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DACA 40E7                     M 	move.w	sr,-(sp)
0000DACC                          M 	__fstring_generateargumentscode	"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DACC =00000003                M 	__pos:	set instr("  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000DACC =00000000                M 	__stack:set	0
0000DACC =00000000                M 	__sp:	set 0
0000DACC                          M 	while	(__pos)
0000DACC =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000DACC =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000DACC =0000000A                M 	__midpos:	= __endpos
0000DACC                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DACC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DACC =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000DACC =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000DACC =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000DACC =00000016                M 	__midpos:	= __endpos
0000DACC                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DACC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DACC =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000DACC =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000DACC =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000DACC =0000001E                M 	__midpos:	= __endpos
0000DACC                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DACC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DACC                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DACC                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DACC                          M 	pushp	"move.l d3,-(sp)"
0000DACC =00000001                M 	__stack:	= __stack+1
0000DACC =00000004                M 	__sp:	= __sp+4
0000DACC =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000DACC =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000DACC =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000DACC =00000028                M 	__midpos:	= __endpos
0000DACC                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DACC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DACC =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000DACC =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000DACC =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000DACC =00000034                M 	__midpos:	= __endpos
0000DACC                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DACC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DACC =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000DACC =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000DACC =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000DACC =0000003C                M 	__midpos:	= __endpos
0000DACC                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DACC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DACC                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DACC                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DACC                          M 	pushp	"move.l a3,-(sp)"
0000DACC =00000002                M 	__stack:	= __stack+1
0000DACC =00000008                M 	__sp:	= __sp+4
0000DACC =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000DACC                          M 	rept	__stack
0000DACC                          M 	popp	__command
0000DACC 2F0B                     M 	move.l	a3,-(sp)
0000DACE                          M 	popp	__command
0000DACE 2F03                     M 	move.l	d3,-(sp)
0000DAD0 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DAD4 45EF 0010                M 	lea	4*4(sp),a2
0000DAD8 43FA 0000                M 	lea	.str_404(pc),a1
0000DADC 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000DAE2 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DAE6 504F                     M 	addq.w	#__sp,sp
0000DAE8 46DF                     M 	move.w	(sp)+,sr
0000DAEA 6000 0000                M 	bra.w	.instr_end_404
0000DAEE                          M 	.str_404:
0000DAEE                          M 	__fstring_generatedecodedstring	"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DAEE =00000001                M 	__lpos:	set 1
0000DAEE =00000003                M 	__pos:	set instr("  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000DAEE                          M 	while	(__pos)
0000DAEE                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DAEE 2020                     M 	dc.b	"  "
0000DAF0 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000DAF0 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000DAF0 =0000000A                M 	__midpos:	= __endpos
0000DAF0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DAF0                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DAF0 E8                       M 	dc.b	fpal0
0000DAF1 =0000000B                M 	__lpos:	set __endpos+1
0000DAF1 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000DAF1                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DAF1 6433 3A20                M 	dc.b	"d3: "
0000DAF5 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000DAF5 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000DAF5 =00000016                M 	__midpos:	= __endpos
0000DAF5                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DAF5                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DAF5 EC                       M 	dc.b	fpal2
0000DAF6 =00000017                M 	__lpos:	set __endpos+1
0000DAF6 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000DAF6                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DAF6                          M 	dc.b	""
0000DAF6 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000DAF6 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000DAF6 =0000001E                M 	__midpos:	= __endpos
0000DAF6                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DAF6                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DAF6                          M 	__param:	substr ,,"hex"
0000DAF6 83                       M 	dc.b	hex|3
0000DAF7 =0000001F                M 	__lpos:	set __endpos+1
0000DAF7 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000DAF7                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DAF7 2020                     M 	dc.b	"  "
0000DAF9 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000DAF9 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000DAF9 =00000028                M 	__midpos:	= __endpos
0000DAF9                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DAF9                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DAF9 E8                       M 	dc.b	fpal0
0000DAFA =00000029                M 	__lpos:	set __endpos+1
0000DAFA =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000DAFA                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DAFA 6133 3A20                M 	dc.b	"a3: "
0000DAFE =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000DAFE =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000DAFE =00000034                M 	__midpos:	= __endpos
0000DAFE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DAFE                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DAFE EC                       M 	dc.b	fpal2
0000DAFF =00000035                M 	__lpos:	set __endpos+1
0000DAFF =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000DAFF                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DAFF                          M 	dc.b	""
0000DAFF =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'>')
0000DAFF =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",' ')
0000DAFF =0000003C                M 	__midpos:	= __endpos
0000DAFF                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DAFF                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DAFF                          M 	__param:	substr ,,"hex"
0000DAFF 83                       M 	dc.b	hex|3
0000DB00 =0000003D                M 	__lpos:	set __endpos+1
0000DB00 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>",'%<')
0000DB00                          M 	__substr:	substr __lpos,,"  %<fpal0>d3: %<fpal2>%<.l d3>  %<fpal0>a3: %<fpal2>%<.l a3>"
0000DB00                          M 	dc.b	""
0000DB00 00                       M 	dc.b	0
0000DB02 00                       M 	even
0000DB02                          M 	.instr_end_404:
0000DB02                            	Console.WriteLine "  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB02 40E7                     M 	move.w	sr,-(sp)
0000DB04                          M 	__fstring_generateargumentscode	"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB04 =00000003                M 	__pos:	set instr("  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000DB04 =00000000                M 	__stack:set	0
0000DB04 =00000000                M 	__sp:	set 0
0000DB04                          M 	while	(__pos)
0000DB04 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000DB04 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000DB04 =0000000A                M 	__midpos:	= __endpos
0000DB04                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB04                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB04 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000DB04 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000DB04 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000DB04 =00000016                M 	__midpos:	= __endpos
0000DB04                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB04                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB04 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000DB04 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000DB04 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000DB04 =0000001E                M 	__midpos:	= __endpos
0000DB04                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB04                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB04                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB04                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB04                          M 	pushp	"move.l d4,-(sp)"
0000DB04 =00000001                M 	__stack:	= __stack+1
0000DB04 =00000004                M 	__sp:	= __sp+4
0000DB04 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000DB04 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000DB04 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000DB04 =00000028                M 	__midpos:	= __endpos
0000DB04                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB04                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB04 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000DB04 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000DB04 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000DB04 =00000034                M 	__midpos:	= __endpos
0000DB04                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB04                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB04 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000DB04 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000DB04 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000DB04 =0000003C                M 	__midpos:	= __endpos
0000DB04                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB04                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB04                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB04                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB04                          M 	pushp	"move.l a4,-(sp)"
0000DB04 =00000002                M 	__stack:	= __stack+1
0000DB04 =00000008                M 	__sp:	= __sp+4
0000DB04 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000DB04                          M 	rept	__stack
0000DB04                          M 	popp	__command
0000DB04 2F0C                     M 	move.l	a4,-(sp)
0000DB06                          M 	popp	__command
0000DB06 2F04                     M 	move.l	d4,-(sp)
0000DB08 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DB0C 45EF 0010                M 	lea	4*4(sp),a2
0000DB10 43FA 0000                M 	lea	.str_407(pc),a1
0000DB14 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000DB1A 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DB1E 504F                     M 	addq.w	#__sp,sp
0000DB20 46DF                     M 	move.w	(sp)+,sr
0000DB22 6000 0000                M 	bra.w	.instr_end_407
0000DB26                          M 	.str_407:
0000DB26                          M 	__fstring_generatedecodedstring	"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB26 =00000001                M 	__lpos:	set 1
0000DB26 =00000003                M 	__pos:	set instr("  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000DB26                          M 	while	(__pos)
0000DB26                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB26 2020                     M 	dc.b	"  "
0000DB28 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000DB28 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000DB28 =0000000A                M 	__midpos:	= __endpos
0000DB28                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB28                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB28 E8                       M 	dc.b	fpal0
0000DB29 =0000000B                M 	__lpos:	set __endpos+1
0000DB29 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000DB29                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB29 6434 3A20                M 	dc.b	"d4: "
0000DB2D =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000DB2D =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000DB2D =00000016                M 	__midpos:	= __endpos
0000DB2D                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB2D                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB2D EC                       M 	dc.b	fpal2
0000DB2E =00000017                M 	__lpos:	set __endpos+1
0000DB2E =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000DB2E                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB2E                          M 	dc.b	""
0000DB2E =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000DB2E =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000DB2E =0000001E                M 	__midpos:	= __endpos
0000DB2E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB2E                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB2E                          M 	__param:	substr ,,"hex"
0000DB2E 83                       M 	dc.b	hex|3
0000DB2F =0000001F                M 	__lpos:	set __endpos+1
0000DB2F =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000DB2F                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB2F 2020                     M 	dc.b	"  "
0000DB31 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000DB31 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000DB31 =00000028                M 	__midpos:	= __endpos
0000DB31                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB31                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB31 E8                       M 	dc.b	fpal0
0000DB32 =00000029                M 	__lpos:	set __endpos+1
0000DB32 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000DB32                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB32 6134 3A20                M 	dc.b	"a4: "
0000DB36 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000DB36 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000DB36 =00000034                M 	__midpos:	= __endpos
0000DB36                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB36                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB36 EC                       M 	dc.b	fpal2
0000DB37 =00000035                M 	__lpos:	set __endpos+1
0000DB37 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000DB37                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB37                          M 	dc.b	""
0000DB37 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'>')
0000DB37 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",' ')
0000DB37 =0000003C                M 	__midpos:	= __endpos
0000DB37                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB37                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB37                          M 	__param:	substr ,,"hex"
0000DB37 83                       M 	dc.b	hex|3
0000DB38 =0000003D                M 	__lpos:	set __endpos+1
0000DB38 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>",'%<')
0000DB38                          M 	__substr:	substr __lpos,,"  %<fpal0>d4: %<fpal2>%<.l d4>  %<fpal0>a4: %<fpal2>%<.l a4>"
0000DB38                          M 	dc.b	""
0000DB38 00                       M 	dc.b	0
0000DB3A 00                       M 	even
0000DB3A                          M 	.instr_end_407:
0000DB3A                            	Console.WriteLine "  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DB3A 40E7                     M 	move.w	sr,-(sp)
0000DB3C                          M 	__fstring_generateargumentscode	"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DB3C =00000003                M 	__pos:	set instr("  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000DB3C =00000000                M 	__stack:set	0
0000DB3C =00000000                M 	__sp:	set 0
0000DB3C                          M 	while	(__pos)
0000DB3C =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000DB3C =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000DB3C =0000000A                M 	__midpos:	= __endpos
0000DB3C                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DB3C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DB3C =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000DB3C =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000DB3C =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000DB3C =00000016                M 	__midpos:	= __endpos
0000DB3C                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DB3C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DB3C =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000DB3C =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000DB3C =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000DB3C =0000001E                M 	__midpos:	= __endpos
0000DB3C                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DB3C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DB3C                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DB3C                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DB3C                          M 	pushp	"move.l d5,-(sp)"
0000DB3C =00000001                M 	__stack:	= __stack+1
0000DB3C =00000004                M 	__sp:	= __sp+4
0000DB3C =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000DB3C =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000DB3C =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000DB3C =00000028                M 	__midpos:	= __endpos
0000DB3C                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DB3C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DB3C =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000DB3C =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000DB3C =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000DB3C =00000034                M 	__midpos:	= __endpos
0000DB3C                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DB3C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DB3C =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000DB3C =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000DB3C =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000DB3C =0000003C                M 	__midpos:	= __endpos
0000DB3C                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DB3C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DB3C                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DB3C                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DB3C                          M 	pushp	"move.l a5,-(sp)"
0000DB3C =00000002                M 	__stack:	= __stack+1
0000DB3C =00000008                M 	__sp:	= __sp+4
0000DB3C =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000DB3C                          M 	rept	__stack
0000DB3C                          M 	popp	__command
0000DB3C 2F0D                     M 	move.l	a5,-(sp)
0000DB3E                          M 	popp	__command
0000DB3E 2F05                     M 	move.l	d5,-(sp)
0000DB40 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DB44 45EF 0010                M 	lea	4*4(sp),a2
0000DB48 43FA 0000                M 	lea	.str_410(pc),a1
0000DB4C 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000DB52 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DB56 504F                     M 	addq.w	#__sp,sp
0000DB58 46DF                     M 	move.w	(sp)+,sr
0000DB5A 6000 0000                M 	bra.w	.instr_end_410
0000DB5E                          M 	.str_410:
0000DB5E                          M 	__fstring_generatedecodedstring	"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DB5E =00000001                M 	__lpos:	set 1
0000DB5E =00000003                M 	__pos:	set instr("  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000DB5E                          M 	while	(__pos)
0000DB5E                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DB5E 2020                     M 	dc.b	"  "
0000DB60 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000DB60 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000DB60 =0000000A                M 	__midpos:	= __endpos
0000DB60                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DB60                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DB60 E8                       M 	dc.b	fpal0
0000DB61 =0000000B                M 	__lpos:	set __endpos+1
0000DB61 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000DB61                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DB61 6435 3A20                M 	dc.b	"d5: "
0000DB65 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000DB65 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000DB65 =00000016                M 	__midpos:	= __endpos
0000DB65                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DB65                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DB65 EC                       M 	dc.b	fpal2
0000DB66 =00000017                M 	__lpos:	set __endpos+1
0000DB66 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000DB66                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DB66                          M 	dc.b	""
0000DB66 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000DB66 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000DB66 =0000001E                M 	__midpos:	= __endpos
0000DB66                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DB66                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DB66                          M 	__param:	substr ,,"hex"
0000DB66 83                       M 	dc.b	hex|3
0000DB67 =0000001F                M 	__lpos:	set __endpos+1
0000DB67 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000DB67                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DB67 2020                     M 	dc.b	"  "
0000DB69 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000DB69 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000DB69 =00000028                M 	__midpos:	= __endpos
0000DB69                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DB69                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DB69 E8                       M 	dc.b	fpal0
0000DB6A =00000029                M 	__lpos:	set __endpos+1
0000DB6A =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000DB6A                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DB6A 6135 3A20                M 	dc.b	"a5: "
0000DB6E =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000DB6E =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000DB6E =00000034                M 	__midpos:	= __endpos
0000DB6E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DB6E                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DB6E EC                       M 	dc.b	fpal2
0000DB6F =00000035                M 	__lpos:	set __endpos+1
0000DB6F =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000DB6F                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DB6F                          M 	dc.b	""
0000DB6F =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'>')
0000DB6F =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",' ')
0000DB6F =0000003C                M 	__midpos:	= __endpos
0000DB6F                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DB6F                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DB6F                          M 	__param:	substr ,,"hex"
0000DB6F 83                       M 	dc.b	hex|3
0000DB70 =0000003D                M 	__lpos:	set __endpos+1
0000DB70 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>",'%<')
0000DB70                          M 	__substr:	substr __lpos,,"  %<fpal0>d5: %<fpal2>%<.l d5>  %<fpal0>a5: %<fpal2>%<.l a5>"
0000DB70                          M 	dc.b	""
0000DB70 00                       M 	dc.b	0
0000DB72 00                       M 	even
0000DB72                          M 	.instr_end_410:
0000DB72                            	Console.WriteLine "  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DB72 40E7                     M 	move.w	sr,-(sp)
0000DB74                          M 	__fstring_generateargumentscode	"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DB74 =00000003                M 	__pos:	set instr("  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000DB74 =00000000                M 	__stack:set	0
0000DB74 =00000000                M 	__sp:	set 0
0000DB74                          M 	while	(__pos)
0000DB74 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000DB74 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000DB74 =0000000A                M 	__midpos:	= __endpos
0000DB74                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DB74                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DB74 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000DB74 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000DB74 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000DB74 =00000016                M 	__midpos:	= __endpos
0000DB74                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DB74                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DB74 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000DB74 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000DB74 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000DB74 =0000001E                M 	__midpos:	= __endpos
0000DB74                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DB74                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DB74                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DB74                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DB74                          M 	pushp	"move.l d6,-(sp)"
0000DB74 =00000001                M 	__stack:	= __stack+1
0000DB74 =00000004                M 	__sp:	= __sp+4
0000DB74 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000DB74 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000DB74 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000DB74 =00000028                M 	__midpos:	= __endpos
0000DB74                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DB74                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DB74 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000DB74 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000DB74 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000DB74 =00000034                M 	__midpos:	= __endpos
0000DB74                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DB74                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DB74 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000DB74 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000DB74 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000DB74 =0000003C                M 	__midpos:	= __endpos
0000DB74                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DB74                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DB74                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DB74                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DB74                          M 	pushp	"move.l a6,-(sp)"
0000DB74 =00000002                M 	__stack:	= __stack+1
0000DB74 =00000008                M 	__sp:	= __sp+4
0000DB74 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000DB74                          M 	rept	__stack
0000DB74                          M 	popp	__command
0000DB74 2F0E                     M 	move.l	a6,-(sp)
0000DB76                          M 	popp	__command
0000DB76 2F06                     M 	move.l	d6,-(sp)
0000DB78 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DB7C 45EF 0010                M 	lea	4*4(sp),a2
0000DB80 43FA 0000                M 	lea	.str_413(pc),a1
0000DB84 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000DB8A 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DB8E 504F                     M 	addq.w	#__sp,sp
0000DB90 46DF                     M 	move.w	(sp)+,sr
0000DB92 6000 0000                M 	bra.w	.instr_end_413
0000DB96                          M 	.str_413:
0000DB96                          M 	__fstring_generatedecodedstring	"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DB96 =00000001                M 	__lpos:	set 1
0000DB96 =00000003                M 	__pos:	set instr("  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000DB96                          M 	while	(__pos)
0000DB96                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DB96 2020                     M 	dc.b	"  "
0000DB98 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000DB98 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000DB98 =0000000A                M 	__midpos:	= __endpos
0000DB98                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DB98                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DB98 E8                       M 	dc.b	fpal0
0000DB99 =0000000B                M 	__lpos:	set __endpos+1
0000DB99 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000DB99                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DB99 6436 3A20                M 	dc.b	"d6: "
0000DB9D =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000DB9D =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000DB9D =00000016                M 	__midpos:	= __endpos
0000DB9D                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DB9D                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DB9D EC                       M 	dc.b	fpal2
0000DB9E =00000017                M 	__lpos:	set __endpos+1
0000DB9E =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000DB9E                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DB9E                          M 	dc.b	""
0000DB9E =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000DB9E =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000DB9E =0000001E                M 	__midpos:	= __endpos
0000DB9E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DB9E                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DB9E                          M 	__param:	substr ,,"hex"
0000DB9E 83                       M 	dc.b	hex|3
0000DB9F =0000001F                M 	__lpos:	set __endpos+1
0000DB9F =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000DB9F                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DB9F 2020                     M 	dc.b	"  "
0000DBA1 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000DBA1 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000DBA1 =00000028                M 	__midpos:	= __endpos
0000DBA1                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DBA1                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DBA1 E8                       M 	dc.b	fpal0
0000DBA2 =00000029                M 	__lpos:	set __endpos+1
0000DBA2 =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000DBA2                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DBA2 6136 3A20                M 	dc.b	"a6: "
0000DBA6 =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000DBA6 =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000DBA6 =00000034                M 	__midpos:	= __endpos
0000DBA6                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DBA6                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DBA6 EC                       M 	dc.b	fpal2
0000DBA7 =00000035                M 	__lpos:	set __endpos+1
0000DBA7 =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000DBA7                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DBA7                          M 	dc.b	""
0000DBA7 =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'>')
0000DBA7 =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",' ')
0000DBA7 =0000003C                M 	__midpos:	= __endpos
0000DBA7                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DBA7                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DBA7                          M 	__param:	substr ,,"hex"
0000DBA7 83                       M 	dc.b	hex|3
0000DBA8 =0000003D                M 	__lpos:	set __endpos+1
0000DBA8 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>",'%<')
0000DBA8                          M 	__substr:	substr __lpos,,"  %<fpal0>d6: %<fpal2>%<.l d6>  %<fpal0>a6: %<fpal2>%<.l a6>"
0000DBA8                          M 	dc.b	""
0000DBA8 00                       M 	dc.b	0
0000DBAA 00                       M 	even
0000DBAA                          M 	.instr_end_413:
0000DBAA                            	Console.WriteLine "  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DBAA 40E7                     M 	move.w	sr,-(sp)
0000DBAC                          M 	__fstring_generateargumentscode	"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DBAC =00000003                M 	__pos:	set instr("  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000DBAC =00000000                M 	__stack:set	0
0000DBAC =00000000                M 	__sp:	set 0
0000DBAC                          M 	while	(__pos)
0000DBAC =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000DBAC =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000DBAC =0000000A                M 	__midpos:	= __endpos
0000DBAC                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DBAC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DBAC =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000DBAC =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000DBAC =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000DBAC =00000016                M 	__midpos:	= __endpos
0000DBAC                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DBAC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DBAC =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000DBAC =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000DBAC =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000DBAC =0000001E                M 	__midpos:	= __endpos
0000DBAC                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DBAC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DBAC                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DBAC                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DBAC                          M 	pushp	"move.l d7,-(sp)"
0000DBAC =00000001                M 	__stack:	= __stack+1
0000DBAC =00000004                M 	__sp:	= __sp+4
0000DBAC =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000DBAC =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000DBAC =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000DBAC =00000028                M 	__midpos:	= __endpos
0000DBAC                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DBAC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DBAC =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000DBAC =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000DBAC =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000DBAC =00000034                M 	__midpos:	= __endpos
0000DBAC                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DBAC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DBAC =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000DBAC =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000DBAC =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000DBAC =0000003C                M 	__midpos:	= __endpos
0000DBAC                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DBAC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DBAC                          M 	__operand:	substr __pos+1+1,__midpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DBAC                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DBAC                          M 	pushp	"move.l a7,-(sp)"
0000DBAC =00000002                M 	__stack:	= __stack+1
0000DBAC =00000008                M 	__sp:	= __sp+4
0000DBAC =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000DBAC                          M 	rept	__stack
0000DBAC                          M 	popp	__command
0000DBAC 2F0F                     M 	move.l	a7,-(sp)
0000DBAE                          M 	popp	__command
0000DBAE 2F07                     M 	move.l	d7,-(sp)
0000DBB0 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DBB4 45EF 0010                M 	lea	4*4(sp),a2
0000DBB8 43FA 0000                M 	lea	.str_416(pc),a1
0000DBBC 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000DBC2 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DBC6 504F                     M 	addq.w	#__sp,sp
0000DBC8 46DF                     M 	move.w	(sp)+,sr
0000DBCA 6000 0000                M 	bra.w	.instr_end_416
0000DBCE                          M 	.str_416:
0000DBCE                          M 	__fstring_generatedecodedstring	"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DBCE =00000001                M 	__lpos:	set 1
0000DBCE =00000003                M 	__pos:	set instr("  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000DBCE                          M 	while	(__pos)
0000DBCE                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DBCE 2020                     M 	dc.b	"  "
0000DBD0 =0000000A                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000DBD0 =0000000E                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000DBD0 =0000000A                M 	__midpos:	= __endpos
0000DBD0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DBD0                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DBD0 E8                       M 	dc.b	fpal0
0000DBD1 =0000000B                M 	__lpos:	set __endpos+1
0000DBD1 =0000000F                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000DBD1                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DBD1 6437 3A20                M 	dc.b	"d7: "
0000DBD5 =00000016                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000DBD5 =0000001B                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000DBD5 =00000016                M 	__midpos:	= __endpos
0000DBD5                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DBD5                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DBD5 EC                       M 	dc.b	fpal2
0000DBD6 =00000017                M 	__lpos:	set __endpos+1
0000DBD6 =00000017                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000DBD6                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DBD6                          M 	dc.b	""
0000DBD6 =0000001E                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000DBD6 =0000001F                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000DBD6 =0000001E                M 	__midpos:	= __endpos
0000DBD6                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DBD6                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DBD6                          M 	__param:	substr ,,"hex"
0000DBD6 83                       M 	dc.b	hex|3
0000DBD7 =0000001F                M 	__lpos:	set __endpos+1
0000DBD7 =00000021                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000DBD7                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DBD7 2020                     M 	dc.b	"  "
0000DBD9 =00000028                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000DBD9 =0000002C                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000DBD9 =00000028                M 	__midpos:	= __endpos
0000DBD9                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DBD9                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DBD9 E8                       M 	dc.b	fpal0
0000DBDA =00000029                M 	__lpos:	set __endpos+1
0000DBDA =0000002D                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000DBDA                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DBDA 7370 3A20                M 	dc.b	"sp: "
0000DBDE =00000034                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000DBDE =00000039                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000DBDE =00000034                M 	__midpos:	= __endpos
0000DBDE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DBDE                          M 	__substr:	substr __pos+1+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DBDE EC                       M 	dc.b	fpal2
0000DBDF =00000035                M 	__lpos:	set __endpos+1
0000DBDF =00000035                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000DBDF                          M 	__substr:	substr __lpos,__pos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DBDF                          M 	dc.b	""
0000DBDF =0000003C                M 	__endpos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'>')
0000DBDF =00000000                M 	__midpos:	set instr(__pos+5,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",' ')
0000DBDF =0000003C                M 	__midpos:	= __endpos
0000DBDF                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DBDF                          M 	__param:	substr __midpos+1,__endpos-1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DBDF                          M 	__param:	substr ,,"hex"
0000DBDF 83                       M 	dc.b	hex|3
0000DBE0 =0000003D                M 	__lpos:	set __endpos+1
0000DBE0 =00000000                M 	__pos:	set instr(__pos+1,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>",'%<')
0000DBE0                          M 	__substr:	substr __lpos,,"  %<fpal0>d7: %<fpal2>%<.l d7>  %<fpal0>sp: %<fpal2>%<.l a7>"
0000DBE0                          M 	dc.b	""
0000DBE0 00                       M 	dc.b	0
0000DBE2 00                       M 	even
0000DBE2                          M 	.instr_end_416:
0000DBE2                            	Console.BreakLine
0000DBE2 40E7                     M 	move.w	sr,-(sp)
0000DBE4 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_startnewline
0000DBEA 46DF                     M 	move.w	(sp)+,sr
0000DBEC                            
0000DBEC                            	Console.Write	  "%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DBEC 40E7                     M 	move.w	sr,-(sp)
0000DBEE                          M 	__fstring_generateargumentscode	"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DBEE =00000001                M 	__pos:	set instr("%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'%<')
0000DBEE =00000000                M 	__stack:set	0
0000DBEE =00000000                M 	__sp:	set 0
0000DBEE                          M 	while	(__pos)
0000DBEE =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'>')
0000DBEE =0000000E                M 	__midpos:	set instr(__pos+5,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",' ')
0000DBEE =00000008                M 	__midpos:	= __endpos
0000DBEE                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DBEE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DBEE =00000011                M 	__pos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'%<')
0000DBEE =00000018                M 	__endpos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'>')
0000DBEE =0000001D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",' ')
0000DBEE =00000018                M 	__midpos:	= __endpos
0000DBEE                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DBEE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DBEE =00000019                M 	__pos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'%<')
0000DBEE =00000026                M 	__endpos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'>')
0000DBEE =00000027                M 	__midpos:	set instr(__pos+5,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",' ')
0000DBEE =00000026                M 	__midpos:	= __endpos
0000DBEE                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DBEE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DBEE                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DBEE                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DBEE                          M 	pushp	"move.b mFlags.w,1(sp)"
0000DBEE                          M 	pushp	"subq.w	#2, sp"
0000DBEE =00000002                M 	__stack:	= __stack+2
0000DBEE =00000002                M 	__sp:	= __sp+2
0000DBEE =00000028                M 	__pos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'%<')
0000DBEE =00000036                M 	__endpos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'>')
0000DBEE =00000037                M 	__midpos:	set instr(__pos+5,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",' ')
0000DBEE =00000036                M 	__midpos:	= __endpos
0000DBEE                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DBEE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DBEE                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DBEE                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DBEE                          M 	pushp	"move.b mCtrPal.w,1(sp)"
0000DBEE                          M 	pushp	"subq.w	#2, sp"
0000DBEE =00000004                M 	__stack:	= __stack+2
0000DBEE =00000004                M 	__sp:	= __sp+2
0000DBEE =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'%<')
0000DBEE                          M 	rept	__stack
0000DBEE                          M 	popp	__command
0000DBEE 554F                     M 	subq.w	#2,sp
0000DBF0                          M 	popp	__command
0000DBF0 1F78 C4A7 0001           M 	move.b	mctrpal.w,1(sp)
0000DBF6                          M 	popp	__command
0000DBF6 554F                     M 	subq.w	#2,sp
0000DBF8                          M 	popp	__command
0000DBF8 1F78 C4A6 0001           M 	move.b	mflags.w,1(sp)
0000DBFE 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DC02 45EF 0010                M 	lea	4*4(sp),a2
0000DC06 43FA 0000                M 	lea	.str_420(pc),a1
0000DC0A 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000DC10 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DC14 584F                     M 	addq.w	#__sp,sp
0000DC16 46DF                     M 	move.w	(sp)+,sr
0000DC18 6000 0000                M 	bra.w	.instr_end_420
0000DC1C                          M 	.str_420:
0000DC1C                          M 	__fstring_generatedecodedstring	"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DC1C =00000001                M 	__lpos:	set 1
0000DC1C =00000001                M 	__pos:	set instr("%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'%<')
0000DC1C                          M 	while	(__pos)
0000DC1C                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DC1C                          M 	dc.b	""
0000DC1C =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'>')
0000DC1C =0000000E                M 	__midpos:	set instr(__pos+5,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",' ')
0000DC1C =00000008                M 	__midpos:	= __endpos
0000DC1C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DC1C                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DC1C EA                       M 	dc.b	fpal1
0000DC1D =00000009                M 	__lpos:	set __endpos+1
0000DC1D =00000011                M 	__pos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'%<')
0000DC1D                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DC1D 4D69 7363 3A20 2020      M 	dc.b	"Misc:   "
0000DC25 =00000018                M 	__endpos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'>')
0000DC25 =0000001D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",' ')
0000DC25 =00000018                M 	__midpos:	= __endpos
0000DC25                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DC25                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DC25 EC                       M 	dc.b	fpal2
0000DC26 =00000019                M 	__lpos:	set __endpos+1
0000DC26 =00000019                M 	__pos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'%<')
0000DC26                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DC26                          M 	dc.b	""
0000DC26 =00000026                M 	__endpos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'>')
0000DC26 =00000027                M 	__midpos:	set instr(__pos+5,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",' ')
0000DC26 =00000026                M 	__midpos:	= __endpos
0000DC26                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DC26                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DC26                          M 	__param:	substr ,,"hex"
0000DC26 80                       M 	dc.b	hex
0000DC27 =00000027                M 	__lpos:	set __endpos+1
0000DC27 =00000028                M 	__pos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'%<')
0000DC27                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DC27 20                       M 	dc.b	" "
0000DC28 =00000036                M 	__endpos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'>')
0000DC28 =00000037                M 	__midpos:	set instr(__pos+5,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",' ')
0000DC28 =00000036                M 	__midpos:	= __endpos
0000DC28                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DC28                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DC28                          M 	__param:	substr ,,"hex"
0000DC28 80                       M 	dc.b	hex
0000DC29 =00000037                M 	__lpos:	set __endpos+1
0000DC29 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> ",'%<')
0000DC29                          M 	__substr:	substr __lpos,,"%<fpal1>Misc:   %<fpal2>%<.b mFlags.w> %<.b mCtrPal.w> "
0000DC29 20                       M 	dc.b	" "
0000DC2A 00                       M 	dc.b	0
0000DC2C 00                       M 	even
0000DC2C                          M 	.instr_end_420:
0000DC2C                            	Console.WriteLine "%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DC2C 40E7                     M 	move.w	sr,-(sp)
0000DC2E                          M 	__fstring_generateargumentscode	"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DC2E =00000001                M 	__pos:	set instr("%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",'%<')
0000DC2E =00000000                M 	__stack:set	0
0000DC2E =00000000                M 	__sp:	set 0
0000DC2E                          M 	while	(__pos)
0000DC2E =00000011                M 	__endpos:	set instr(__pos+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",'>')
0000DC2E =00000012                M 	__midpos:	set instr(__pos+5,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",' ')
0000DC2E =00000011                M 	__midpos:	= __endpos
0000DC2E                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DC2E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DC2E                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DC2E                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DC2E                          M 	pushp	"move.b mSpindash.w,1(sp)"
0000DC2E                          M 	pushp	"subq.w	#2, sp"
0000DC2E =00000002                M 	__stack:	= __stack+2
0000DC2E =00000002                M 	__sp:	= __sp+2
0000DC2E =00000013                M 	__pos:	set instr(__pos+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",'%<')
0000DC2E =00000022                M 	__endpos:	set instr(__pos+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",'>')
0000DC2E =00000023                M 	__midpos:	set instr(__pos+5,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",' ')
0000DC2E =00000022                M 	__midpos:	= __endpos
0000DC2E                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DC2E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DC2E                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DC2E                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DC2E                          M 	pushp	"move.b mContCtr.w,1(sp)"
0000DC2E                          M 	pushp	"subq.w	#2, sp"
0000DC2E =00000004                M 	__stack:	= __stack+2
0000DC2E =00000004                M 	__sp:	= __sp+2
0000DC2E =00000024                M 	__pos:	set instr(__pos+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",'%<')
0000DC2E =00000034                M 	__endpos:	set instr(__pos+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",'>')
0000DC2E =00000000                M 	__midpos:	set instr(__pos+5,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",' ')
0000DC2E =00000034                M 	__midpos:	= __endpos
0000DC2E                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DC2E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DC2E                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DC2E                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DC2E                          M 	pushp	"move.b mContLast.w,1(sp)"
0000DC2E                          M 	pushp	"subq.w	#2, sp"
0000DC2E =00000006                M 	__stack:	= __stack+2
0000DC2E =00000006                M 	__sp:	= __sp+2
0000DC2E =00000000                M 	__pos:	set instr(__pos+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",'%<')
0000DC2E                          M 	rept	__stack
0000DC2E                          M 	popp	__command
0000DC2E 554F                     M 	subq.w	#2,sp
0000DC30                          M 	popp	__command
0000DC30 1F78 C4C3 0001           M 	move.b	mcontlast.w,1(sp)
0000DC36                          M 	popp	__command
0000DC36 554F                     M 	subq.w	#2,sp
0000DC38                          M 	popp	__command
0000DC38 1F78 C4C2 0001           M 	move.b	mcontctr.w,1(sp)
0000DC3E                          M 	popp	__command
0000DC3E 554F                     M 	subq.w	#2,sp
0000DC40                          M 	popp	__command
0000DC40 1F78 C4C1 0001           M 	move.b	mspindash.w,1(sp)
0000DC46 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DC4A 45EF 0010                M 	lea	4*4(sp),a2
0000DC4E 43FA 0000                M 	lea	.str_423(pc),a1
0000DC52 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000DC58 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DC5C 5C4F                     M 	addq.w	#__sp,sp
0000DC5E 46DF                     M 	move.w	(sp)+,sr
0000DC60 6000 0000                M 	bra.w	.instr_end_423
0000DC64                          M 	.str_423:
0000DC64                          M 	__fstring_generatedecodedstring	"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DC64 =00000001                M 	__lpos:	set 1
0000DC64 =00000001                M 	__pos:	set instr("%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",'%<')
0000DC64                          M 	while	(__pos)
0000DC64                          M 	__substr:	substr __lpos,__pos-1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DC64                          M 	dc.b	""
0000DC64 =00000011                M 	__endpos:	set instr(__pos+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",'>')
0000DC64 =00000012                M 	__midpos:	set instr(__pos+5,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",' ')
0000DC64 =00000011                M 	__midpos:	= __endpos
0000DC64                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DC64                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DC64                          M 	__param:	substr ,,"hex"
0000DC64 80                       M 	dc.b	hex
0000DC65 =00000012                M 	__lpos:	set __endpos+1
0000DC65 =00000013                M 	__pos:	set instr(__pos+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",'%<')
0000DC65                          M 	__substr:	substr __lpos,__pos-1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DC65 20                       M 	dc.b	" "
0000DC66 =00000022                M 	__endpos:	set instr(__pos+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",'>')
0000DC66 =00000023                M 	__midpos:	set instr(__pos+5,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",' ')
0000DC66 =00000022                M 	__midpos:	= __endpos
0000DC66                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DC66                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DC66                          M 	__param:	substr ,,"hex"
0000DC66 80                       M 	dc.b	hex
0000DC67 =00000023                M 	__lpos:	set __endpos+1
0000DC67 =00000024                M 	__pos:	set instr(__pos+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",'%<')
0000DC67                          M 	__substr:	substr __lpos,__pos-1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DC67 20                       M 	dc.b	" "
0000DC68 =00000034                M 	__endpos:	set instr(__pos+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",'>')
0000DC68 =00000000                M 	__midpos:	set instr(__pos+5,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",' ')
0000DC68 =00000034                M 	__midpos:	= __endpos
0000DC68                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DC68                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DC68                          M 	__param:	substr ,,"hex"
0000DC68 80                       M 	dc.b	hex
0000DC69 =00000035                M 	__lpos:	set __endpos+1
0000DC69 =00000000                M 	__pos:	set instr(__pos+1,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>",'%<')
0000DC69                          M 	__substr:	substr __lpos,,"%<.b mSpindash.w> %<.b mContCtr.w> %<.b mContLast.w>"
0000DC69                          M 	dc.b	""
0000DC69 00                       M 	dc.b	0
0000DC6A                          M 	even
0000DC6A                          M 	.instr_end_423:
0000DC6A                            	Console.Write	  "%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DC6A 40E7                     M 	move.w	sr,-(sp)
0000DC6C                          M 	__fstring_generateargumentscode	"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DC6C =00000001                M 	__pos:	set instr("%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'%<')
0000DC6C =00000000                M 	__stack:set	0
0000DC6C =00000000                M 	__sp:	set 0
0000DC6C                          M 	while	(__pos)
0000DC6C =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'>')
0000DC6C =0000000F                M 	__midpos:	set instr(__pos+5,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",' ')
0000DC6C =00000008                M 	__midpos:	= __endpos
0000DC6C                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DC6C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DC6C =00000011                M 	__pos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'%<')
0000DC6C =00000018                M 	__endpos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'>')
0000DC6C =0000001D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",' ')
0000DC6C =00000018                M 	__midpos:	= __endpos
0000DC6C                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DC6C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DC6C =00000019                M 	__pos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'%<')
0000DC6C =0000002A                M 	__endpos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'>')
0000DC6C =0000002B                M 	__midpos:	set instr(__pos+5,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",' ')
0000DC6C =0000002A                M 	__midpos:	= __endpos
0000DC6C                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DC6C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DC6C                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DC6C                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DC6C                          M 	pushp	"move.b mTempoMain.w,1(sp)"
0000DC6C                          M 	pushp	"subq.w	#2, sp"
0000DC6C =00000002                M 	__stack:	= __stack+2
0000DC6C =00000002                M 	__sp:	= __sp+2
0000DC6C =0000002C                M 	__pos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'%<')
0000DC6C =0000003E                M 	__endpos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'>')
0000DC6C =0000003F                M 	__midpos:	set instr(__pos+5,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",' ')
0000DC6C =0000003E                M 	__midpos:	= __endpos
0000DC6C                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DC6C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DC6C                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DC6C                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DC6C                          M 	pushp	"move.b mTempoSpeed.w,1(sp)"
0000DC6C                          M 	pushp	"subq.w	#2, sp"
0000DC6C =00000004                M 	__stack:	= __stack+2
0000DC6C =00000004                M 	__sp:	= __sp+2
0000DC6C =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'%<')
0000DC6C                          M 	rept	__stack
0000DC6C                          M 	popp	__command
0000DC6C 554F                     M 	subq.w	#2,sp
0000DC6E                          M 	popp	__command
0000DC6E 1F78 C4B9 0001           M 	move.b	mtempospeed.w,1(sp)
0000DC74                          M 	popp	__command
0000DC74 554F                     M 	subq.w	#2,sp
0000DC76                          M 	popp	__command
0000DC76 1F78 C4B8 0001           M 	move.b	mtempomain.w,1(sp)
0000DC7C 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DC80 45EF 0010                M 	lea	4*4(sp),a2
0000DC84 43FA 0000                M 	lea	.str_426(pc),a1
0000DC88 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000DC8E 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DC92 584F                     M 	addq.w	#__sp,sp
0000DC94 46DF                     M 	move.w	(sp)+,sr
0000DC96 6000 0000                M 	bra.w	.instr_end_426
0000DC9A                          M 	.str_426:
0000DC9A                          M 	__fstring_generatedecodedstring	"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DC9A =00000001                M 	__lpos:	set 1
0000DC9A =00000001                M 	__pos:	set instr("%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'%<')
0000DC9A                          M 	while	(__pos)
0000DC9A                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DC9A                          M 	dc.b	""
0000DC9A =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'>')
0000DC9A =0000000F                M 	__midpos:	set instr(__pos+5,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",' ')
0000DC9A =00000008                M 	__midpos:	= __endpos
0000DC9A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DC9A                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DC9A EA                       M 	dc.b	fpal1
0000DC9B =00000009                M 	__lpos:	set __endpos+1
0000DC9B =00000011                M 	__pos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'%<')
0000DC9B                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DC9B 5465 6D70 6F3A 2020      M 	dc.b	"Tempo:  "
0000DCA3 =00000018                M 	__endpos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'>')
0000DCA3 =0000001D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",' ')
0000DCA3 =00000018                M 	__midpos:	= __endpos
0000DCA3                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DCA3                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DCA3 EC                       M 	dc.b	fpal2
0000DCA4 =00000019                M 	__lpos:	set __endpos+1
0000DCA4 =00000019                M 	__pos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'%<')
0000DCA4                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DCA4                          M 	dc.b	""
0000DCA4 =0000002A                M 	__endpos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'>')
0000DCA4 =0000002B                M 	__midpos:	set instr(__pos+5,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",' ')
0000DCA4 =0000002A                M 	__midpos:	= __endpos
0000DCA4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DCA4                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DCA4                          M 	__param:	substr ,,"hex"
0000DCA4 80                       M 	dc.b	hex
0000DCA5 =0000002B                M 	__lpos:	set __endpos+1
0000DCA5 =0000002C                M 	__pos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'%<')
0000DCA5                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DCA5 20                       M 	dc.b	" "
0000DCA6 =0000003E                M 	__endpos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'>')
0000DCA6 =0000003F                M 	__midpos:	set instr(__pos+5,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",' ')
0000DCA6 =0000003E                M 	__midpos:	= __endpos
0000DCA6                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DCA6                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DCA6                          M 	__param:	substr ,,"hex"
0000DCA6 80                       M 	dc.b	hex
0000DCA7 =0000003F                M 	__lpos:	set __endpos+1
0000DCA7 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> ",'%<')
0000DCA7                          M 	__substr:	substr __lpos,,"%<fpal1>Tempo:  %<fpal2>%<.b mTempoMain.w> %<.b mTempoSpeed.w> "
0000DCA7 20                       M 	dc.b	" "
0000DCA8 00                       M 	dc.b	0
0000DCAA 00                       M 	even
0000DCAA                          M 	.instr_end_426:
0000DCAA                            	Console.WriteLine "%<.b mTempo.w> %<.b mTempoCur.w>"
0000DCAA 40E7                     M 	move.w	sr,-(sp)
0000DCAC                          M 	__fstring_generateargumentscode	"%<.b mTempo.w> %<.b mTempoCur.w>"
0000DCAC =00000001                M 	__pos:	set instr("%<.b mTempo.w> %<.b mTempoCur.w>",'%<')
0000DCAC =00000000                M 	__stack:set	0
0000DCAC =00000000                M 	__sp:	set 0
0000DCAC                          M 	while	(__pos)
0000DCAC =0000000E                M 	__endpos:	set instr(__pos+1,"%<.b mTempo.w> %<.b mTempoCur.w>",'>')
0000DCAC =0000000F                M 	__midpos:	set instr(__pos+5,"%<.b mTempo.w> %<.b mTempoCur.w>",' ')
0000DCAC =0000000E                M 	__midpos:	= __endpos
0000DCAC                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b mTempo.w> %<.b mTempoCur.w>"
0000DCAC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mTempo.w> %<.b mTempoCur.w>"
0000DCAC                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b mTempo.w> %<.b mTempoCur.w>"
0000DCAC                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mTempo.w> %<.b mTempoCur.w>"
0000DCAC                          M 	pushp	"move.b mTempo.w,1(sp)"
0000DCAC                          M 	pushp	"subq.w	#2, sp"
0000DCAC =00000002                M 	__stack:	= __stack+2
0000DCAC =00000002                M 	__sp:	= __sp+2
0000DCAC =00000010                M 	__pos:	set instr(__pos+1,"%<.b mTempo.w> %<.b mTempoCur.w>",'%<')
0000DCAC =00000020                M 	__endpos:	set instr(__pos+1,"%<.b mTempo.w> %<.b mTempoCur.w>",'>')
0000DCAC =00000000                M 	__midpos:	set instr(__pos+5,"%<.b mTempo.w> %<.b mTempoCur.w>",' ')
0000DCAC =00000020                M 	__midpos:	= __endpos
0000DCAC                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b mTempo.w> %<.b mTempoCur.w>"
0000DCAC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mTempo.w> %<.b mTempoCur.w>"
0000DCAC                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b mTempo.w> %<.b mTempoCur.w>"
0000DCAC                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mTempo.w> %<.b mTempoCur.w>"
0000DCAC                          M 	pushp	"move.b mTempoCur.w,1(sp)"
0000DCAC                          M 	pushp	"subq.w	#2, sp"
0000DCAC =00000004                M 	__stack:	= __stack+2
0000DCAC =00000004                M 	__sp:	= __sp+2
0000DCAC =00000000                M 	__pos:	set instr(__pos+1,"%<.b mTempo.w> %<.b mTempoCur.w>",'%<')
0000DCAC                          M 	rept	__stack
0000DCAC                          M 	popp	__command
0000DCAC 554F                     M 	subq.w	#2,sp
0000DCAE                          M 	popp	__command
0000DCAE 1F78 C4BB 0001           M 	move.b	mtempocur.w,1(sp)
0000DCB4                          M 	popp	__command
0000DCB4 554F                     M 	subq.w	#2,sp
0000DCB6                          M 	popp	__command
0000DCB6 1F78 C4BA 0001           M 	move.b	mtempo.w,1(sp)
0000DCBC 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DCC0 45EF 0010                M 	lea	4*4(sp),a2
0000DCC4 43FA 0000                M 	lea	.str_429(pc),a1
0000DCC8 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000DCCE 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DCD2 584F                     M 	addq.w	#__sp,sp
0000DCD4 46DF                     M 	move.w	(sp)+,sr
0000DCD6 6000 0000                M 	bra.w	.instr_end_429
0000DCDA                          M 	.str_429:
0000DCDA                          M 	__fstring_generatedecodedstring	"%<.b mTempo.w> %<.b mTempoCur.w>"
0000DCDA =00000001                M 	__lpos:	set 1
0000DCDA =00000001                M 	__pos:	set instr("%<.b mTempo.w> %<.b mTempoCur.w>",'%<')
0000DCDA                          M 	while	(__pos)
0000DCDA                          M 	__substr:	substr __lpos,__pos-1,"%<.b mTempo.w> %<.b mTempoCur.w>"
0000DCDA                          M 	dc.b	""
0000DCDA =0000000E                M 	__endpos:	set instr(__pos+1,"%<.b mTempo.w> %<.b mTempoCur.w>",'>')
0000DCDA =0000000F                M 	__midpos:	set instr(__pos+5,"%<.b mTempo.w> %<.b mTempoCur.w>",' ')
0000DCDA =0000000E                M 	__midpos:	= __endpos
0000DCDA                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mTempo.w> %<.b mTempoCur.w>"
0000DCDA                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mTempo.w> %<.b mTempoCur.w>"
0000DCDA                          M 	__param:	substr ,,"hex"
0000DCDA 80                       M 	dc.b	hex
0000DCDB =0000000F                M 	__lpos:	set __endpos+1
0000DCDB =00000010                M 	__pos:	set instr(__pos+1,"%<.b mTempo.w> %<.b mTempoCur.w>",'%<')
0000DCDB                          M 	__substr:	substr __lpos,__pos-1,"%<.b mTempo.w> %<.b mTempoCur.w>"
0000DCDB 20                       M 	dc.b	" "
0000DCDC =00000020                M 	__endpos:	set instr(__pos+1,"%<.b mTempo.w> %<.b mTempoCur.w>",'>')
0000DCDC =00000000                M 	__midpos:	set instr(__pos+5,"%<.b mTempo.w> %<.b mTempoCur.w>",' ')
0000DCDC =00000020                M 	__midpos:	= __endpos
0000DCDC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mTempo.w> %<.b mTempoCur.w>"
0000DCDC                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mTempo.w> %<.b mTempoCur.w>"
0000DCDC                          M 	__param:	substr ,,"hex"
0000DCDC 80                       M 	dc.b	hex
0000DCDD =00000021                M 	__lpos:	set __endpos+1
0000DCDD =00000000                M 	__pos:	set instr(__pos+1,"%<.b mTempo.w> %<.b mTempoCur.w>",'%<')
0000DCDD                          M 	__substr:	substr __lpos,,"%<.b mTempo.w> %<.b mTempoCur.w>"
0000DCDD                          M 	dc.b	""
0000DCDD 00                       M 	dc.b	0
0000DCDE                          M 	even
0000DCDE                          M 	.instr_end_429:
0000DCDE                            	Console.Write	  "%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DCDE 40E7                     M 	move.w	sr,-(sp)
0000DCE0                          M 	__fstring_generateargumentscode	"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DCE0 =00000001                M 	__pos:	set instr("%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'%<')
0000DCE0 =00000000                M 	__stack:set	0
0000DCE0 =00000000                M 	__sp:	set 0
0000DCE0                          M 	while	(__pos)
0000DCE0 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'>')
0000DCE0 =00000010                M 	__midpos:	set instr(__pos+5,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",' ')
0000DCE0 =00000008                M 	__midpos:	= __endpos
0000DCE0                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DCE0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DCE0 =00000011                M 	__pos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'%<')
0000DCE0 =00000018                M 	__endpos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'>')
0000DCE0 =0000001D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",' ')
0000DCE0 =00000018                M 	__midpos:	= __endpos
0000DCE0                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DCE0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DCE0 =00000019                M 	__pos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'%<')
0000DCE0 =0000002C                M 	__endpos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'>')
0000DCE0 =0000002D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",' ')
0000DCE0 =0000002C                M 	__midpos:	= __endpos
0000DCE0                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DCE0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DCE0                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DCE0                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DCE0                          M 	pushp	"move.b mMasterVolFM.w,1(sp)"
0000DCE0                          M 	pushp	"subq.w	#2, sp"
0000DCE0 =00000002                M 	__stack:	= __stack+2
0000DCE0 =00000002                M 	__sp:	= __sp+2
0000DCE0 =0000002E                M 	__pos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'%<')
0000DCE0 =00000042                M 	__endpos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'>')
0000DCE0 =00000043                M 	__midpos:	set instr(__pos+5,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",' ')
0000DCE0 =00000042                M 	__midpos:	= __endpos
0000DCE0                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DCE0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DCE0                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DCE0                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DCE0                          M 	pushp	"move.b mMasterVolDAC.w,1(sp)"
0000DCE0                          M 	pushp	"subq.w	#2, sp"
0000DCE0 =00000004                M 	__stack:	= __stack+2
0000DCE0 =00000004                M 	__sp:	= __sp+2
0000DCE0 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'%<')
0000DCE0                          M 	rept	__stack
0000DCE0                          M 	popp	__command
0000DCE0 554F                     M 	subq.w	#2,sp
0000DCE2                          M 	popp	__command
0000DCE2 1F78 C4C0 0001           M 	move.b	mmastervoldac.w,1(sp)
0000DCE8                          M 	popp	__command
0000DCE8 554F                     M 	subq.w	#2,sp
0000DCEA                          M 	popp	__command
0000DCEA 1F78 C4B4 0001           M 	move.b	mmastervolfm.w,1(sp)
0000DCF0 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DCF4 45EF 0010                M 	lea	4*4(sp),a2
0000DCF8 43FA 0000                M 	lea	.str_432(pc),a1
0000DCFC 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000DD02 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DD06 584F                     M 	addq.w	#__sp,sp
0000DD08 46DF                     M 	move.w	(sp)+,sr
0000DD0A 6000 0000                M 	bra.w	.instr_end_432
0000DD0E                          M 	.str_432:
0000DD0E                          M 	__fstring_generatedecodedstring	"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DD0E =00000001                M 	__lpos:	set 1
0000DD0E =00000001                M 	__pos:	set instr("%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'%<')
0000DD0E                          M 	while	(__pos)
0000DD0E                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DD0E                          M 	dc.b	""
0000DD0E =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'>')
0000DD0E =00000010                M 	__midpos:	set instr(__pos+5,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",' ')
0000DD0E =00000008                M 	__midpos:	= __endpos
0000DD0E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DD0E                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DD0E EA                       M 	dc.b	fpal1
0000DD0F =00000009                M 	__lpos:	set __endpos+1
0000DD0F =00000011                M 	__pos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'%<')
0000DD0F                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DD0F 566F 6C75 6D65 3A20      M 	dc.b	"Volume: "
0000DD17 =00000018                M 	__endpos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'>')
0000DD17 =0000001D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",' ')
0000DD17 =00000018                M 	__midpos:	= __endpos
0000DD17                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DD17                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DD17 EC                       M 	dc.b	fpal2
0000DD18 =00000019                M 	__lpos:	set __endpos+1
0000DD18 =00000019                M 	__pos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'%<')
0000DD18                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DD18                          M 	dc.b	""
0000DD18 =0000002C                M 	__endpos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'>')
0000DD18 =0000002D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",' ')
0000DD18 =0000002C                M 	__midpos:	= __endpos
0000DD18                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DD18                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DD18                          M 	__param:	substr ,,"hex"
0000DD18 80                       M 	dc.b	hex
0000DD19 =0000002D                M 	__lpos:	set __endpos+1
0000DD19 =0000002E                M 	__pos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'%<')
0000DD19                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DD19 20                       M 	dc.b	" "
0000DD1A =00000042                M 	__endpos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'>')
0000DD1A =00000043                M 	__midpos:	set instr(__pos+5,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",' ')
0000DD1A =00000042                M 	__midpos:	= __endpos
0000DD1A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DD1A                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DD1A                          M 	__param:	substr ,,"hex"
0000DD1A 80                       M 	dc.b	hex
0000DD1B =00000043                M 	__lpos:	set __endpos+1
0000DD1B =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> ",'%<')
0000DD1B                          M 	__substr:	substr __lpos,,"%<fpal1>Volume: %<fpal2>%<.b mMasterVolFM.w> %<.b mMasterVolDAC.w> "
0000DD1B 20                       M 	dc.b	" "
0000DD1C 00                       M 	dc.b	0
0000DD1E 00                       M 	even
0000DD1E                          M 	.instr_end_432:
0000DD1E                            	Console.WriteLine "%<.b mMasterVolPSG.w>"
0000DD1E 40E7                     M 	move.w	sr,-(sp)
0000DD20                          M 	__fstring_generateargumentscode	"%<.b mMasterVolPSG.w>"
0000DD20 =00000001                M 	__pos:	set instr("%<.b mMasterVolPSG.w>",'%<')
0000DD20 =00000000                M 	__stack:set	0
0000DD20 =00000000                M 	__sp:	set 0
0000DD20                          M 	while	(__pos)
0000DD20 =00000015                M 	__endpos:	set instr(__pos+1,"%<.b mMasterVolPSG.w>",'>')
0000DD20 =00000000                M 	__midpos:	set instr(__pos+5,"%<.b mMasterVolPSG.w>",' ')
0000DD20 =00000015                M 	__midpos:	= __endpos
0000DD20                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b mMasterVolPSG.w>"
0000DD20                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mMasterVolPSG.w>"
0000DD20                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b mMasterVolPSG.w>"
0000DD20                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mMasterVolPSG.w>"
0000DD20                          M 	pushp	"move.b mMasterVolPSG.w,1(sp)"
0000DD20                          M 	pushp	"subq.w	#2, sp"
0000DD20 =00000002                M 	__stack:	= __stack+2
0000DD20 =00000002                M 	__sp:	= __sp+2
0000DD20 =00000000                M 	__pos:	set instr(__pos+1,"%<.b mMasterVolPSG.w>",'%<')
0000DD20                          M 	rept	__stack
0000DD20                          M 	popp	__command
0000DD20 554F                     M 	subq.w	#2,sp
0000DD22                          M 	popp	__command
0000DD22 1F78 C4BF 0001           M 	move.b	mmastervolpsg.w,1(sp)
0000DD28 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DD2C 45EF 0010                M 	lea	4*4(sp),a2
0000DD30 43FA 0000                M 	lea	.str_435(pc),a1
0000DD34 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000DD3A 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DD3E 544F                     M 	addq.w	#__sp,sp
0000DD40 46DF                     M 	move.w	(sp)+,sr
0000DD42 6000 0000                M 	bra.w	.instr_end_435
0000DD46                          M 	.str_435:
0000DD46                          M 	__fstring_generatedecodedstring	"%<.b mMasterVolPSG.w>"
0000DD46 =00000001                M 	__lpos:	set 1
0000DD46 =00000001                M 	__pos:	set instr("%<.b mMasterVolPSG.w>",'%<')
0000DD46                          M 	while	(__pos)
0000DD46                          M 	__substr:	substr __lpos,__pos-1,"%<.b mMasterVolPSG.w>"
0000DD46                          M 	dc.b	""
0000DD46 =00000015                M 	__endpos:	set instr(__pos+1,"%<.b mMasterVolPSG.w>",'>')
0000DD46 =00000000                M 	__midpos:	set instr(__pos+5,"%<.b mMasterVolPSG.w>",' ')
0000DD46 =00000015                M 	__midpos:	= __endpos
0000DD46                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mMasterVolPSG.w>"
0000DD46                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mMasterVolPSG.w>"
0000DD46                          M 	__param:	substr ,,"hex"
0000DD46 80                       M 	dc.b	hex
0000DD47 =00000016                M 	__lpos:	set __endpos+1
0000DD47 =00000000                M 	__pos:	set instr(__pos+1,"%<.b mMasterVolPSG.w>",'%<')
0000DD47                          M 	__substr:	substr __lpos,,"%<.b mMasterVolPSG.w>"
0000DD47                          M 	dc.b	""
0000DD47 00                       M 	dc.b	0
0000DD48                          M 	even
0000DD48                          M 	.instr_end_435:
0000DD48                            	Console.WriteLine "%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DD48 40E7                     M 	move.w	sr,-(sp)
0000DD4A                          M 	__fstring_generateargumentscode	"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DD4A =00000001                M 	__pos:	set instr("%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DD4A =00000000                M 	__stack:set	0
0000DD4A =00000000                M 	__sp:	set 0
0000DD4A                          M 	while	(__pos)
0000DD4A =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DD4A =0000000E                M 	__midpos:	set instr(__pos+5,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DD4A =00000008                M 	__midpos:	= __endpos
0000DD4A                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DD4A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DD4A =00000011                M 	__pos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DD4A =00000018                M 	__endpos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DD4A =0000001D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DD4A =00000018                M 	__midpos:	= __endpos
0000DD4A                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DD4A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DD4A =00000019                M 	__pos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DD4A =00000034                M 	__endpos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DD4A =00000029                M 	__midpos:	set instr(__pos+5,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DD4A                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DD4A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DD4A                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DD4A                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DD4A                          M 	pushp	"move.l mFadeAddr.w,-(sp)"
0000DD4A =00000001                M 	__stack:	= __stack+1
0000DD4A =00000004                M 	__sp:	= __sp+4
0000DD4A =00000035                M 	__pos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DD4A =00000045                M 	__endpos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DD4A =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DD4A =00000045                M 	__midpos:	= __endpos
0000DD4A                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DD4A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DD4A =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DD4A                          M 	rept	__stack
0000DD4A                          M 	popp	__command
0000DD4A 2F38 C4B4                M 	move.l	mfadeaddr.w,-(sp)
0000DD4E 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DD52 45EF 0010                M 	lea	4*4(sp),a2
0000DD56 43FA 0000                M 	lea	.str_438(pc),a1
0000DD5A 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000DD60 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DD64 584F                     M 	addq.w	#__sp,sp
0000DD66 46DF                     M 	move.w	(sp)+,sr
0000DD68 6000 0000                M 	bra.w	.instr_end_438
0000DD6C                          M 	.str_438:
0000DD6C                          M 	__fstring_generatedecodedstring	"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DD6C =00000001                M 	__lpos:	set 1
0000DD6C =00000001                M 	__pos:	set instr("%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DD6C                          M 	while	(__pos)
0000DD6C                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DD6C                          M 	dc.b	""
0000DD6C =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DD6C =0000000E                M 	__midpos:	set instr(__pos+5,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DD6C =00000008                M 	__midpos:	= __endpos
0000DD6C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DD6C                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DD6C EA                       M 	dc.b	fpal1
0000DD6D =00000009                M 	__lpos:	set __endpos+1
0000DD6D =00000011                M 	__pos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DD6D                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DD6D 4661 6465 3A20 2020      M 	dc.b	"Fade:   "
0000DD75 =00000018                M 	__endpos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DD75 =0000001D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DD75 =00000018                M 	__midpos:	= __endpos
0000DD75                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DD75                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DD75 E8                       M 	dc.b	fpal0
0000DD76 =00000019                M 	__lpos:	set __endpos+1
0000DD76 =00000019                M 	__pos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DD76                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DD76                          M 	dc.b	""
0000DD76 =00000034                M 	__endpos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DD76 =00000029                M 	__midpos:	set instr(__pos+5,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DD76                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DD76                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DD76 BB                       M 	dc.b	sym|fsplit|3
0000DD77 =00000035                M 	__lpos:	set __endpos+1
0000DD77 =00000035                M 	__pos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DD77                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DD77                          M 	dc.b	""
0000DD77 =00000045                M 	__endpos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'>')
0000DD77 =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",' ')
0000DD77 =00000045                M 	__midpos:	= __endpos
0000DD77                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DD77                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DD77 ECC0                     M 	dc.b	fpal2,fsymdisp
0000DD79 =00000046                M 	__lpos:	set __endpos+1
0000DD79 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000DD79                          M 	__substr:	substr __lpos,,"%<fpal1>Fade:   %<fpal0>%<.l mFadeAddr.w sym|fsplit>%<fpal2,fsymdisp>"
0000DD79                          M 	dc.b	""
0000DD79 00                       M 	dc.b	0
0000DD7A                          M 	even
0000DD7A                          M 	.instr_end_438:
0000DD7A                            	Console.WriteLine "%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DD7A 40E7                     M 	move.w	sr,-(sp)
0000DD7C                          M 	__fstring_generateargumentscode	"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DD7C =00000001                M 	__pos:	set instr("%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'%<')
0000DD7C =00000000                M 	__stack:set	0
0000DD7C =00000000                M 	__sp:	set 0
0000DD7C                          M 	while	(__pos)
0000DD7C =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'>')
0000DD7C =0000000F                M 	__midpos:	set instr(__pos+5,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",' ')
0000DD7C =00000008                M 	__midpos:	= __endpos
0000DD7C                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DD7C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DD7C =00000011                M 	__pos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'%<')
0000DD7C =00000018                M 	__endpos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'>')
0000DD7C =0000001D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",' ')
0000DD7C =00000018                M 	__midpos:	= __endpos
0000DD7C                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DD7C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DD7C =00000019                M 	__pos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'%<')
0000DD7C =00000026                M 	__endpos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'>')
0000DD7C =00000027                M 	__midpos:	set instr(__pos+5,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",' ')
0000DD7C =00000026                M 	__midpos:	= __endpos
0000DD7C                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DD7C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DD7C                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DD7C                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DD7C                          M 	pushp	"move.b mQueue.w,1(sp)"
0000DD7C                          M 	pushp	"subq.w	#2, sp"
0000DD7C =00000002                M 	__stack:	= __stack+2
0000DD7C =00000002                M 	__sp:	= __sp+2
0000DD7C =00000028                M 	__pos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'%<')
0000DD7C =00000037                M 	__endpos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'>')
0000DD7C =00000038                M 	__midpos:	set instr(__pos+5,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",' ')
0000DD7C =00000037                M 	__midpos:	= __endpos
0000DD7C                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DD7C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DD7C                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DD7C                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DD7C                          M 	pushp	"move.b mQueue+1.w,1(sp)"
0000DD7C                          M 	pushp	"subq.w	#2, sp"
0000DD7C =00000004                M 	__stack:	= __stack+2
0000DD7C =00000004                M 	__sp:	= __sp+2
0000DD7C =00000039                M 	__pos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'%<')
0000DD7C =00000048                M 	__endpos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'>')
0000DD7C =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",' ')
0000DD7C =00000048                M 	__midpos:	= __endpos
0000DD7C                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DD7C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DD7C                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DD7C                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DD7C                          M 	pushp	"move.b mQueue+2.w,1(sp)"
0000DD7C                          M 	pushp	"subq.w	#2, sp"
0000DD7C =00000006                M 	__stack:	= __stack+2
0000DD7C =00000006                M 	__sp:	= __sp+2
0000DD7C =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'%<')
0000DD7C                          M 	rept	__stack
0000DD7C                          M 	popp	__command
0000DD7C 554F                     M 	subq.w	#2,sp
0000DD7E                          M 	popp	__command
0000DD7E 1F78 C4BE 0001           M 	move.b	mqueue+2.w,1(sp)
0000DD84                          M 	popp	__command
0000DD84 554F                     M 	subq.w	#2,sp
0000DD86                          M 	popp	__command
0000DD86 1F78 C4BD 0001           M 	move.b	mqueue+1.w,1(sp)
0000DD8C                          M 	popp	__command
0000DD8C 554F                     M 	subq.w	#2,sp
0000DD8E                          M 	popp	__command
0000DD8E 1F78 C4BC 0001           M 	move.b	mqueue.w,1(sp)
0000DD94 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DD98 45EF 0010                M 	lea	4*4(sp),a2
0000DD9C 43FA 0000                M 	lea	.str_441(pc),a1
0000DDA0 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000DDA6 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DDAA 5C4F                     M 	addq.w	#__sp,sp
0000DDAC 46DF                     M 	move.w	(sp)+,sr
0000DDAE 6000 0000                M 	bra.w	.instr_end_441
0000DDB2                          M 	.str_441:
0000DDB2                          M 	__fstring_generatedecodedstring	"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DDB2 =00000001                M 	__lpos:	set 1
0000DDB2 =00000001                M 	__pos:	set instr("%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'%<')
0000DDB2                          M 	while	(__pos)
0000DDB2                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DDB2                          M 	dc.b	""
0000DDB2 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'>')
0000DDB2 =0000000F                M 	__midpos:	set instr(__pos+5,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",' ')
0000DDB2 =00000008                M 	__midpos:	= __endpos
0000DDB2                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DDB2                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DDB2 EA                       M 	dc.b	fpal1
0000DDB3 =00000009                M 	__lpos:	set __endpos+1
0000DDB3 =00000011                M 	__pos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'%<')
0000DDB3                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DDB3 5175 6575 653A 2020      M 	dc.b	"Queue:  "
0000DDBB =00000018                M 	__endpos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'>')
0000DDBB =0000001D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",' ')
0000DDBB =00000018                M 	__midpos:	= __endpos
0000DDBB                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DDBB                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DDBB EC                       M 	dc.b	fpal2
0000DDBC =00000019                M 	__lpos:	set __endpos+1
0000DDBC =00000019                M 	__pos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'%<')
0000DDBC                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DDBC                          M 	dc.b	""
0000DDBC =00000026                M 	__endpos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'>')
0000DDBC =00000027                M 	__midpos:	set instr(__pos+5,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",' ')
0000DDBC =00000026                M 	__midpos:	= __endpos
0000DDBC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DDBC                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DDBC                          M 	__param:	substr ,,"hex"
0000DDBC 80                       M 	dc.b	hex
0000DDBD =00000027                M 	__lpos:	set __endpos+1
0000DDBD =00000028                M 	__pos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'%<')
0000DDBD                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DDBD 20                       M 	dc.b	" "
0000DDBE =00000037                M 	__endpos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'>')
0000DDBE =00000038                M 	__midpos:	set instr(__pos+5,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",' ')
0000DDBE =00000037                M 	__midpos:	= __endpos
0000DDBE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DDBE                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DDBE                          M 	__param:	substr ,,"hex"
0000DDBE 80                       M 	dc.b	hex
0000DDBF =00000038                M 	__lpos:	set __endpos+1
0000DDBF =00000039                M 	__pos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'%<')
0000DDBF                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DDBF 20                       M 	dc.b	" "
0000DDC0 =00000048                M 	__endpos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'>')
0000DDC0 =00000000                M 	__midpos:	set instr(__pos+5,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",' ')
0000DDC0 =00000048                M 	__midpos:	= __endpos
0000DDC0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DDC0                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DDC0                          M 	__param:	substr ,,"hex"
0000DDC0 80                       M 	dc.b	hex
0000DDC1 =00000049                M 	__lpos:	set __endpos+1
0000DDC1 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>",'%<')
0000DDC1                          M 	__substr:	substr __lpos,,"%<fpal1>Queue:  %<fpal2>%<.b mQueue.w> %<.b mQueue+1.w> %<.b mQueue+2.w>"
0000DDC1                          M 	dc.b	""
0000DDC1 00                       M 	dc.b	0
0000DDC2                          M 	even
0000DDC2                          M 	.instr_end_441:
0000DDC2                            	Console.Write	  "%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DDC2 40E7                     M 	move.w	sr,-(sp)
0000DDC4                          M 	__fstring_generateargumentscode	"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DDC4 =00000001                M 	__pos:	set instr("%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'%<')
0000DDC4 =00000000                M 	__stack:set	0
0000DDC4 =00000000                M 	__sp:	set 0
0000DDC4                          M 	while	(__pos)
0000DDC4 =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'>')
0000DDC4 =0000000E                M 	__midpos:	set instr(__pos+5,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",' ')
0000DDC4 =00000008                M 	__midpos:	= __endpos
0000DDC4                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DDC4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DDC4 =00000011                M 	__pos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'%<')
0000DDC4 =00000018                M 	__endpos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'>')
0000DDC4 =0000001D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",' ')
0000DDC4 =00000018                M 	__midpos:	= __endpos
0000DDC4                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DDC4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DDC4 =00000019                M 	__pos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'%<')
0000DDC4 =00000025                M 	__endpos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'>')
0000DDC4 =00000026                M 	__midpos:	set instr(__pos+5,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",' ')
0000DDC4 =00000025                M 	__midpos:	= __endpos
0000DDC4                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DDC4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DDC4                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DDC4                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DDC4                          M 	pushp	"move.b mComm.w,1(sp)"
0000DDC4                          M 	pushp	"subq.w	#2, sp"
0000DDC4 =00000002                M 	__stack:	= __stack+2
0000DDC4 =00000002                M 	__sp:	= __sp+2
0000DDC4 =00000027                M 	__pos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'%<')
0000DDC4 =00000035                M 	__endpos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'>')
0000DDC4 =00000036                M 	__midpos:	set instr(__pos+5,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",' ')
0000DDC4 =00000035                M 	__midpos:	= __endpos
0000DDC4                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DDC4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DDC4                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DDC4                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DDC4                          M 	pushp	"move.b mComm+1.w,1(sp)"
0000DDC4                          M 	pushp	"subq.w	#2, sp"
0000DDC4 =00000004                M 	__stack:	= __stack+2
0000DDC4 =00000004                M 	__sp:	= __sp+2
0000DDC4 =00000037                M 	__pos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'%<')
0000DDC4 =00000045                M 	__endpos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'>')
0000DDC4 =00000046                M 	__midpos:	set instr(__pos+5,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",' ')
0000DDC4 =00000045                M 	__midpos:	= __endpos
0000DDC4                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DDC4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DDC4                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DDC4                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DDC4                          M 	pushp	"move.b mComm+2.w,1(sp)"
0000DDC4                          M 	pushp	"subq.w	#2, sp"
0000DDC4 =00000006                M 	__stack:	= __stack+2
0000DDC4 =00000006                M 	__sp:	= __sp+2
0000DDC4 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'%<')
0000DDC4                          M 	rept	__stack
0000DDC4                          M 	popp	__command
0000DDC4 554F                     M 	subq.w	#2,sp
0000DDC6                          M 	popp	__command
0000DDC6 1F78 C4AE 0001           M 	move.b	mcomm+2.w,1(sp)
0000DDCC                          M 	popp	__command
0000DDCC 554F                     M 	subq.w	#2,sp
0000DDCE                          M 	popp	__command
0000DDCE 1F78 C4AD 0001           M 	move.b	mcomm+1.w,1(sp)
0000DDD4                          M 	popp	__command
0000DDD4 554F                     M 	subq.w	#2,sp
0000DDD6                          M 	popp	__command
0000DDD6 1F78 C4AC 0001           M 	move.b	mcomm.w,1(sp)
0000DDDC 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DDE0 45EF 0010                M 	lea	4*4(sp),a2
0000DDE4 43FA 0000                M 	lea	.str_444(pc),a1
0000DDE8 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000DDEE 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DDF2 5C4F                     M 	addq.w	#__sp,sp
0000DDF4 46DF                     M 	move.w	(sp)+,sr
0000DDF6 6000 0000                M 	bra.w	.instr_end_444
0000DDFA                          M 	.str_444:
0000DDFA                          M 	__fstring_generatedecodedstring	"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DDFA =00000001                M 	__lpos:	set 1
0000DDFA =00000001                M 	__pos:	set instr("%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'%<')
0000DDFA                          M 	while	(__pos)
0000DDFA                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DDFA                          M 	dc.b	""
0000DDFA =00000008                M 	__endpos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'>')
0000DDFA =0000000E                M 	__midpos:	set instr(__pos+5,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",' ')
0000DDFA =00000008                M 	__midpos:	= __endpos
0000DDFA                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DDFA                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DDFA EA                       M 	dc.b	fpal1
0000DDFB =00000009                M 	__lpos:	set __endpos+1
0000DDFB =00000011                M 	__pos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'%<')
0000DDFB                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DDFB 436F 6D6D 3A20 2020      M 	dc.b	"Comm:   "
0000DE03 =00000018                M 	__endpos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'>')
0000DE03 =0000001D                M 	__midpos:	set instr(__pos+5,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",' ')
0000DE03 =00000018                M 	__midpos:	= __endpos
0000DE03                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE03                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE03 EC                       M 	dc.b	fpal2
0000DE04 =00000019                M 	__lpos:	set __endpos+1
0000DE04 =00000019                M 	__pos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'%<')
0000DE04                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE04                          M 	dc.b	""
0000DE04 =00000025                M 	__endpos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'>')
0000DE04 =00000026                M 	__midpos:	set instr(__pos+5,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",' ')
0000DE04 =00000025                M 	__midpos:	= __endpos
0000DE04                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE04                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE04                          M 	__param:	substr ,,"hex"
0000DE04 80                       M 	dc.b	hex
0000DE05 =00000026                M 	__lpos:	set __endpos+1
0000DE05 =00000027                M 	__pos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'%<')
0000DE05                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE05 20                       M 	dc.b	" "
0000DE06 =00000035                M 	__endpos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'>')
0000DE06 =00000036                M 	__midpos:	set instr(__pos+5,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",' ')
0000DE06 =00000035                M 	__midpos:	= __endpos
0000DE06                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE06                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE06                          M 	__param:	substr ,,"hex"
0000DE06 80                       M 	dc.b	hex
0000DE07 =00000036                M 	__lpos:	set __endpos+1
0000DE07 =00000037                M 	__pos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'%<')
0000DE07                          M 	__substr:	substr __lpos,__pos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE07 20                       M 	dc.b	" "
0000DE08 =00000045                M 	__endpos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'>')
0000DE08 =00000046                M 	__midpos:	set instr(__pos+5,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",' ')
0000DE08 =00000045                M 	__midpos:	= __endpos
0000DE08                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE08                          M 	__param:	substr __midpos+1,__endpos-1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE08                          M 	__param:	substr ,,"hex"
0000DE08 80                       M 	dc.b	hex
0000DE09 =00000046                M 	__lpos:	set __endpos+1
0000DE09 =00000000                M 	__pos:	set instr(__pos+1,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> ",'%<')
0000DE09                          M 	__substr:	substr __lpos,,"%<fpal1>Comm:   %<fpal2>%<.b mComm.w> %<.b mComm+1.w> %<.b mComm+2.w> "
0000DE09 20                       M 	dc.b	" "
0000DE0A 00                       M 	dc.b	0
0000DE0C 00                       M 	even
0000DE0C                          M 	.instr_end_444:
0000DE0C                            	Console.Write	  "%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE0C 40E7                     M 	move.w	sr,-(sp)
0000DE0E                          M 	__fstring_generateargumentscode	"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE0E =00000001                M 	__pos:	set instr("%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'%<')
0000DE0E =00000000                M 	__stack:set	0
0000DE0E =00000000                M 	__sp:	set 0
0000DE0E                          M 	while	(__pos)
0000DE0E =0000000F                M 	__endpos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'>')
0000DE0E =00000010                M 	__midpos:	set instr(__pos+5,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",' ')
0000DE0E =0000000F                M 	__midpos:	= __endpos
0000DE0E                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE0E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE0E                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE0E                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE0E                          M 	pushp	"move.b mComm+3.w,1(sp)"
0000DE0E                          M 	pushp	"subq.w	#2, sp"
0000DE0E =00000002                M 	__stack:	= __stack+2
0000DE0E =00000002                M 	__sp:	= __sp+2
0000DE0E =00000011                M 	__pos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'%<')
0000DE0E =0000001F                M 	__endpos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'>')
0000DE0E =00000020                M 	__midpos:	set instr(__pos+5,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",' ')
0000DE0E =0000001F                M 	__midpos:	= __endpos
0000DE0E                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE0E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE0E                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE0E                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE0E                          M 	pushp	"move.b mComm+4.w,1(sp)"
0000DE0E                          M 	pushp	"subq.w	#2, sp"
0000DE0E =00000004                M 	__stack:	= __stack+2
0000DE0E =00000004                M 	__sp:	= __sp+2
0000DE0E =00000021                M 	__pos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'%<')
0000DE0E =0000002F                M 	__endpos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'>')
0000DE0E =00000030                M 	__midpos:	set instr(__pos+5,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",' ')
0000DE0E =0000002F                M 	__midpos:	= __endpos
0000DE0E                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE0E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE0E                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE0E                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE0E                          M 	pushp	"move.b mComm+5.w,1(sp)"
0000DE0E                          M 	pushp	"subq.w	#2, sp"
0000DE0E =00000006                M 	__stack:	= __stack+2
0000DE0E =00000006                M 	__sp:	= __sp+2
0000DE0E =00000031                M 	__pos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'%<')
0000DE0E =0000003F                M 	__endpos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'>')
0000DE0E =00000040                M 	__midpos:	set instr(__pos+5,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",' ')
0000DE0E =0000003F                M 	__midpos:	= __endpos
0000DE0E                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE0E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE0E                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE0E                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE0E                          M 	pushp	"move.b mComm+6.w,1(sp)"
0000DE0E                          M 	pushp	"subq.w	#2, sp"
0000DE0E =00000008                M 	__stack:	= __stack+2
0000DE0E =00000008                M 	__sp:	= __sp+2
0000DE0E =00000000                M 	__pos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'%<')
0000DE0E                          M 	rept	__stack
0000DE0E                          M 	popp	__command
0000DE0E 554F                     M 	subq.w	#2,sp
0000DE10                          M 	popp	__command
0000DE10 1F78 C4B2 0001           M 	move.b	mcomm+6.w,1(sp)
0000DE16                          M 	popp	__command
0000DE16 554F                     M 	subq.w	#2,sp
0000DE18                          M 	popp	__command
0000DE18 1F78 C4B1 0001           M 	move.b	mcomm+5.w,1(sp)
0000DE1E                          M 	popp	__command
0000DE1E 554F                     M 	subq.w	#2,sp
0000DE20                          M 	popp	__command
0000DE20 1F78 C4B0 0001           M 	move.b	mcomm+4.w,1(sp)
0000DE26                          M 	popp	__command
0000DE26 554F                     M 	subq.w	#2,sp
0000DE28                          M 	popp	__command
0000DE28 1F78 C4AF 0001           M 	move.b	mcomm+3.w,1(sp)
0000DE2E 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DE32 45EF 0010                M 	lea	4*4(sp),a2
0000DE36 43FA 0000                M 	lea	.str_447(pc),a1
0000DE3A 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000DE40 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DE44 504F                     M 	addq.w	#__sp,sp
0000DE46 46DF                     M 	move.w	(sp)+,sr
0000DE48 6000 0000                M 	bra.w	.instr_end_447
0000DE4C                          M 	.str_447:
0000DE4C                          M 	__fstring_generatedecodedstring	"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE4C =00000001                M 	__lpos:	set 1
0000DE4C =00000001                M 	__pos:	set instr("%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'%<')
0000DE4C                          M 	while	(__pos)
0000DE4C                          M 	__substr:	substr __lpos,__pos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE4C                          M 	dc.b	""
0000DE4C =0000000F                M 	__endpos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'>')
0000DE4C =00000010                M 	__midpos:	set instr(__pos+5,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",' ')
0000DE4C =0000000F                M 	__midpos:	= __endpos
0000DE4C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE4C                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE4C                          M 	__param:	substr ,,"hex"
0000DE4C 80                       M 	dc.b	hex
0000DE4D =00000010                M 	__lpos:	set __endpos+1
0000DE4D =00000011                M 	__pos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'%<')
0000DE4D                          M 	__substr:	substr __lpos,__pos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE4D 20                       M 	dc.b	" "
0000DE4E =0000001F                M 	__endpos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'>')
0000DE4E =00000020                M 	__midpos:	set instr(__pos+5,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",' ')
0000DE4E =0000001F                M 	__midpos:	= __endpos
0000DE4E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE4E                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE4E                          M 	__param:	substr ,,"hex"
0000DE4E 80                       M 	dc.b	hex
0000DE4F =00000020                M 	__lpos:	set __endpos+1
0000DE4F =00000021                M 	__pos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'%<')
0000DE4F                          M 	__substr:	substr __lpos,__pos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE4F 20                       M 	dc.b	" "
0000DE50 =0000002F                M 	__endpos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'>')
0000DE50 =00000030                M 	__midpos:	set instr(__pos+5,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",' ')
0000DE50 =0000002F                M 	__midpos:	= __endpos
0000DE50                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE50                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE50                          M 	__param:	substr ,,"hex"
0000DE50 80                       M 	dc.b	hex
0000DE51 =00000030                M 	__lpos:	set __endpos+1
0000DE51 =00000031                M 	__pos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'%<')
0000DE51                          M 	__substr:	substr __lpos,__pos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE51 20                       M 	dc.b	" "
0000DE52 =0000003F                M 	__endpos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'>')
0000DE52 =00000040                M 	__midpos:	set instr(__pos+5,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",' ')
0000DE52 =0000003F                M 	__midpos:	= __endpos
0000DE52                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE52                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE52                          M 	__param:	substr ,,"hex"
0000DE52 80                       M 	dc.b	hex
0000DE53 =00000040                M 	__lpos:	set __endpos+1
0000DE53 =00000000                M 	__pos:	set instr(__pos+1,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> ",'%<')
0000DE53                          M 	__substr:	substr __lpos,,"%<.b mComm+3.w> %<.b mComm+4.w> %<.b mComm+5.w> %<.b mComm+6.w> "
0000DE53 20                       M 	dc.b	" "
0000DE54 00                       M 	dc.b	0
0000DE56 00                       M 	even
0000DE56                          M 	.instr_end_447:
0000DE56                            	Console.WriteLine "%<.b mComm+7.w>"
0000DE56 40E7                     M 	move.w	sr,-(sp)
0000DE58                          M 	__fstring_generateargumentscode	"%<.b mComm+7.w>"
0000DE58 =00000001                M 	__pos:	set instr("%<.b mComm+7.w>",'%<')
0000DE58 =00000000                M 	__stack:set	0
0000DE58 =00000000                M 	__sp:	set 0
0000DE58                          M 	while	(__pos)
0000DE58 =0000000F                M 	__endpos:	set instr(__pos+1,"%<.b mComm+7.w>",'>')
0000DE58 =00000000                M 	__midpos:	set instr(__pos+5,"%<.b mComm+7.w>",' ')
0000DE58 =0000000F                M 	__midpos:	= __endpos
0000DE58                          M 	__substr:	substr __pos+1+1,__endpos-1,"%<.b mComm+7.w>"
0000DE58                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mComm+7.w>"
0000DE58                          M 	__operand:	substr __pos+1+1,__midpos-1,"%<.b mComm+7.w>"
0000DE58                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mComm+7.w>"
0000DE58                          M 	pushp	"move.b mComm+7.w,1(sp)"
0000DE58                          M 	pushp	"subq.w	#2, sp"
0000DE58 =00000002                M 	__stack:	= __stack+2
0000DE58 =00000002                M 	__sp:	= __sp+2
0000DE58 =00000000                M 	__pos:	set instr(__pos+1,"%<.b mComm+7.w>",'%<')
0000DE58                          M 	rept	__stack
0000DE58                          M 	popp	__command
0000DE58 554F                     M 	subq.w	#2,sp
0000DE5A                          M 	popp	__command
0000DE5A 1F78 C4B3 0001           M 	move.b	mcomm+7.w,1(sp)
0000DE60 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000DE64 45EF 0010                M 	lea	4*4(sp),a2
0000DE68 43FA 0000                M 	lea	.str_450(pc),a1
0000DE6C 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000DE72 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000DE76 544F                     M 	addq.w	#__sp,sp
0000DE78 46DF                     M 	move.w	(sp)+,sr
0000DE7A 6000 0000                M 	bra.w	.instr_end_450
0000DE7E                          M 	.str_450:
0000DE7E                          M 	__fstring_generatedecodedstring	"%<.b mComm+7.w>"
0000DE7E =00000001                M 	__lpos:	set 1
0000DE7E =00000001                M 	__pos:	set instr("%<.b mComm+7.w>",'%<')
0000DE7E                          M 	while	(__pos)
0000DE7E                          M 	__substr:	substr __lpos,__pos-1,"%<.b mComm+7.w>"
0000DE7E                          M 	dc.b	""
0000DE7E =0000000F                M 	__endpos:	set instr(__pos+1,"%<.b mComm+7.w>",'>')
0000DE7E =00000000                M 	__midpos:	set instr(__pos+5,"%<.b mComm+7.w>",' ')
0000DE7E =0000000F                M 	__midpos:	= __endpos
0000DE7E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"%<.b mComm+7.w>"
0000DE7E                          M 	__param:	substr __midpos+1,__endpos-1,"%<.b mComm+7.w>"
0000DE7E                          M 	__param:	substr ,,"hex"
0000DE7E 80                       M 	dc.b	hex
0000DE7F =00000010                M 	__lpos:	set __endpos+1
0000DE7F =00000000                M 	__pos:	set instr(__pos+1,"%<.b mComm+7.w>",'%<')
0000DE7F                          M 	__substr:	substr __lpos,,"%<.b mComm+7.w>"
0000DE7F                          M 	dc.b	""
0000DE7F 00                       M 	dc.b	0
0000DE80                          M 	even
0000DE80                          M 	.instr_end_450:
0000DE80                            
0000DE80                            .rts
0000DE80 4E75                       	rts
0000DE82                            ; ===========================================================================
0000DE82                            ; ---------------------------------------------------------------------------
0000DE82                            ; Invalid fade command handler
0000DE82                            ; ---------------------------------------------------------------------------
0000DE82                            
0000DE82                            AMPS_Debug_FadeCmd	macro
0000DE82                            	cmp.b	#fLast,d0	; check against max
0000DE82                            	bhs.s	.fail		; if in range, branch
0000DE82                            	cmp.b	#$80,d0		; check against min
0000DE82                            	blo.s	.fail		; if too little, bra
0000DE82                            	btst	#1,d0		; check if bit1 set
0000DE82                            	bne.s	.fail		; if is, branch
0000DE82                            	btst	#0,d0		; check if even
0000DE82                            	beq.s	.ok		; if is, branch
0000DE82                            .fail
0000DE82                            	if def(RaiseError)	; check if Vladik's debugger is active
0000DE82                            		jsr	AMPS_DebugR_FadeCmd
0000DE82                            	else
0000DE82                            		bra.w	*
0000DE82                            	endif
0000DE82                            .ok
0000DE82                                endm
0000DE82                            
0000DE82                            AMPS_DebugR_FadeCmd:
0000DE82                            		RaiseError2 "Invalid Fade command: %<.b d0>", AMPS_Debug_Console_Main
0000DE82 40E7                     M 	move.w	sr,-(sp)
0000DE84                          M 	__fstring_generateargumentscode	"Invalid Fade command: %<.b d0>"
0000DE84 =00000017                M 	__pos:	set instr("Invalid Fade command: %<.b d0>",'%<')
0000DE84 =00000000                M 	__stack:set	0
0000DE84 =00000000                M 	__sp:	set 0
0000DE84                          M 	while	(__pos)
0000DE84 =0000001E                M 	__endpos:	set instr(__pos+1,"Invalid Fade command: %<.b d0>",'>')
0000DE84 =00000000                M 	__midpos:	set instr(__pos+5,"Invalid Fade command: %<.b d0>",' ')
0000DE84 =0000001E                M 	__midpos:	= __endpos
0000DE84                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid Fade command: %<.b d0>"
0000DE84                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid Fade command: %<.b d0>"
0000DE84                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid Fade command: %<.b d0>"
0000DE84                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid Fade command: %<.b d0>"
0000DE84                          M 	pushp	"move.b d0,1(sp)"
0000DE84                          M 	pushp	"subq.w	#2, sp"
0000DE84 =00000002                M 	__stack:	= __stack+2
0000DE84 =00000002                M 	__sp:	= __sp+2
0000DE84 =00000000                M 	__pos:	set instr(__pos+1,"Invalid Fade command: %<.b d0>",'%<')
0000DE84                          M 	rept	__stack
0000DE84                          M 	popp	__command
0000DE84 554F                     M 	subq.w	#2,sp
0000DE86                          M 	popp	__command
0000DE86 1F40 0001                M 	move.b	d0,1(sp)
0000DE8A 4EB9 0000 0000           M 	jsr	errorhandler
0000DE90                          M 	__fstring_generatedecodedstring	"Invalid Fade command: %<.b d0>"
0000DE90 =00000001                M 	__lpos:	set 1
0000DE90 =00000017                M 	__pos:	set instr("Invalid Fade command: %<.b d0>",'%<')
0000DE90                          M 	while	(__pos)
0000DE90                          M 	__substr:	substr __lpos,__pos-1,"Invalid Fade command: %<.b d0>"
0000DE90 496E 7661 6C69 6420 4661+M 	dc.b	"Invalid Fade command: "
0000DEA6 =0000001E                M 	__endpos:	set instr(__pos+1,"Invalid Fade command: %<.b d0>",'>')
0000DEA6 =00000000                M 	__midpos:	set instr(__pos+5,"Invalid Fade command: %<.b d0>",' ')
0000DEA6 =0000001E                M 	__midpos:	= __endpos
0000DEA6                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid Fade command: %<.b d0>"
0000DEA6                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid Fade command: %<.b d0>"
0000DEA6                          M 	__param:	substr ,,"hex"
0000DEA6 80                       M 	dc.b	hex
0000DEA7 =0000001F                M 	__lpos:	set __endpos+1
0000DEA7 =00000000                M 	__pos:	set instr(__pos+1,"Invalid Fade command: %<.b d0>",'%<')
0000DEA7                          M 	__substr:	substr __lpos,,"Invalid Fade command: %<.b d0>"
0000DEA7                          M 	dc.b	""
0000DEA7 00                       M 	dc.b	0
0000DEA8 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000DEAA 00                       M 	even
0000DEAA 4EFA FB76                M 	jmp	amps_debug_console_main
0000DEAE                          M 	even
0000DEAE                            ; ===========================================================================
0000DEAE                            ; ---------------------------------------------------------------------------
0000DEAE                            ; Invalid volume envelope handler
0000DEAE                            ; ---------------------------------------------------------------------------
0000DEAE                            
0000DEAE                            AMPS_Debug_VolEnvID	macro
0000DEAE                            	cmp.b	#(VolEnvs_End-VolEnvs)/4,d4	; check against max
0000DEAE                            	bls.s	.ok			; if in range, branch
0000DEAE                            	if def(RaiseError)	; check if Vladik's debugger is active
0000DEAE                            		jsr	AMPS_DebugR_VolEnvID
0000DEAE                            	else
0000DEAE                            		bra.w	*
0000DEAE                            	endif
0000DEAE                            .ok
0000DEAE                                endm
0000DEAE                            
0000DEAE                            AMPS_DebugR_VolEnvID:
0000DEAE                            		RaiseError2 "Volume envelope ID out of range: %<.b d4>", AMPS_Debug_Console_Channel
0000DEAE 40E7                     M 	move.w	sr,-(sp)
0000DEB0                          M 	__fstring_generateargumentscode	"Volume envelope ID out of range: %<.b d4>"
0000DEB0 =00000022                M 	__pos:	set instr("Volume envelope ID out of range: %<.b d4>",'%<')
0000DEB0 =00000000                M 	__stack:set	0
0000DEB0 =00000000                M 	__sp:	set 0
0000DEB0                          M 	while	(__pos)
0000DEB0 =00000029                M 	__endpos:	set instr(__pos+1,"Volume envelope ID out of range: %<.b d4>",'>')
0000DEB0 =00000000                M 	__midpos:	set instr(__pos+5,"Volume envelope ID out of range: %<.b d4>",' ')
0000DEB0 =00000029                M 	__midpos:	= __endpos
0000DEB0                          M 	__substr:	substr __pos+1+1,__endpos-1,"Volume envelope ID out of range: %<.b d4>"
0000DEB0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Volume envelope ID out of range: %<.b d4>"
0000DEB0                          M 	__operand:	substr __pos+1+1,__midpos-1,"Volume envelope ID out of range: %<.b d4>"
0000DEB0                          M 	__param:	substr __midpos+1,__endpos-1,"Volume envelope ID out of range: %<.b d4>"
0000DEB0                          M 	pushp	"move.b d4,1(sp)"
0000DEB0                          M 	pushp	"subq.w	#2, sp"
0000DEB0 =00000002                M 	__stack:	= __stack+2
0000DEB0 =00000002                M 	__sp:	= __sp+2
0000DEB0 =00000000                M 	__pos:	set instr(__pos+1,"Volume envelope ID out of range: %<.b d4>",'%<')
0000DEB0                          M 	rept	__stack
0000DEB0                          M 	popp	__command
0000DEB0 554F                     M 	subq.w	#2,sp
0000DEB2                          M 	popp	__command
0000DEB2 1F44 0001                M 	move.b	d4,1(sp)
0000DEB6 4EB9 0000 0000           M 	jsr	errorhandler
0000DEBC                          M 	__fstring_generatedecodedstring	"Volume envelope ID out of range: %<.b d4>"
0000DEBC =00000001                M 	__lpos:	set 1
0000DEBC =00000022                M 	__pos:	set instr("Volume envelope ID out of range: %<.b d4>",'%<')
0000DEBC                          M 	while	(__pos)
0000DEBC                          M 	__substr:	substr __lpos,__pos-1,"Volume envelope ID out of range: %<.b d4>"
0000DEBC 566F 6C75 6D65 2065 6E76+M 	dc.b	"Volume envelope ID out of range: "
0000DEDD =00000029                M 	__endpos:	set instr(__pos+1,"Volume envelope ID out of range: %<.b d4>",'>')
0000DEDD =00000000                M 	__midpos:	set instr(__pos+5,"Volume envelope ID out of range: %<.b d4>",' ')
0000DEDD =00000029                M 	__midpos:	= __endpos
0000DEDD                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Volume envelope ID out of range: %<.b d4>"
0000DEDD                          M 	__param:	substr __midpos+1,__endpos-1,"Volume envelope ID out of range: %<.b d4>"
0000DEDD                          M 	__param:	substr ,,"hex"
0000DEDD 80                       M 	dc.b	hex
0000DEDE =0000002A                M 	__lpos:	set __endpos+1
0000DEDE =00000000                M 	__pos:	set instr(__pos+1,"Volume envelope ID out of range: %<.b d4>",'%<')
0000DEDE                          M 	__substr:	substr __lpos,,"Volume envelope ID out of range: %<.b d4>"
0000DEDE                          M 	dc.b	""
0000DEDE 00                       M 	dc.b	0
0000DEDF 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000DEE0                          M 	even
0000DEE0 4EFA F39A                M 	jmp	amps_debug_console_channel
0000DEE4                          M 	even
0000DEE4                            ; ===========================================================================
0000DEE4                            ; ---------------------------------------------------------------------------
0000DEE4                            ; Invalid volume envelope command handler
0000DEE4                            ; ---------------------------------------------------------------------------
0000DEE4                            
0000DEE4                            AMPS_Debug_VolEnvCmd	macro
0000DEE4                            	cmp.b	#eLast,d0	; check against max
0000DEE4                            	bhs.s	.fail		; if too much, bra
0000DEE4                            	cmp.b	#$80,d0		; check against min
0000DEE4                            	blo.s	.fail		; if too little, bra
0000DEE4                            	btst	#0,d0		; check if even
0000DEE4                            	beq.s	.ok		; if is, branch
0000DEE4                            .fail
0000DEE4                            	if def(RaiseError)	; check if Vladik's debugger is active
0000DEE4                            		RaiseError2 "Volume envelope command invalid: %<.b d0>", AMPS_Debug_Console_Channel
0000DEE4                            	else
0000DEE4                            		bra.w	*
0000DEE4                            	endif
0000DEE4                            .ok
0000DEE4                                endm
0000DEE4                            ; ===========================================================================
0000DEE4                            ; ---------------------------------------------------------------------------
0000DEE4                            ; PSG note check
0000DEE4                            ; ---------------------------------------------------------------------------
0000DEE4                            
0000DEE4                            AMPS_Debug_NotePSG	macro
0000DEE4                            	cmp.b	#dFreqPSG_-dFreqPSG,d5; check against max
0000DEE4                            	blo.s	.ok		; if too little, bra
0000DEE4                            .fail
0000DEE4                            	if def(RaiseError)	; check if Vladik's debugger is active
0000DEE4                            		jsr	AMPS_DebugR_NotePSG
0000DEE4                            	else
0000DEE4                            		bra.w	*
0000DEE4                            	endif
0000DEE4                            .ok
0000DEE4                                endm
0000DEE4                            
0000DEE4                            AMPS_DebugR_NotePSG:
0000DEE4 E24D                       		lsr.w	#1,d5	; get real note
0000DEE6                            		RaiseError2 "Invalid PSG note: %<.b d5>", AMPS_Debug_Console_Channel
0000DEE6 40E7                     M 	move.w	sr,-(sp)
0000DEE8                          M 	__fstring_generateargumentscode	"Invalid PSG note: %<.b d5>"
0000DEE8 =00000013                M 	__pos:	set instr("Invalid PSG note: %<.b d5>",'%<')
0000DEE8 =00000000                M 	__stack:set	0
0000DEE8 =00000000                M 	__sp:	set 0
0000DEE8                          M 	while	(__pos)
0000DEE8 =0000001A                M 	__endpos:	set instr(__pos+1,"Invalid PSG note: %<.b d5>",'>')
0000DEE8 =00000000                M 	__midpos:	set instr(__pos+5,"Invalid PSG note: %<.b d5>",' ')
0000DEE8 =0000001A                M 	__midpos:	= __endpos
0000DEE8                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid PSG note: %<.b d5>"
0000DEE8                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid PSG note: %<.b d5>"
0000DEE8                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid PSG note: %<.b d5>"
0000DEE8                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid PSG note: %<.b d5>"
0000DEE8                          M 	pushp	"move.b d5,1(sp)"
0000DEE8                          M 	pushp	"subq.w	#2, sp"
0000DEE8 =00000002                M 	__stack:	= __stack+2
0000DEE8 =00000002                M 	__sp:	= __sp+2
0000DEE8 =00000000                M 	__pos:	set instr(__pos+1,"Invalid PSG note: %<.b d5>",'%<')
0000DEE8                          M 	rept	__stack
0000DEE8                          M 	popp	__command
0000DEE8 554F                     M 	subq.w	#2,sp
0000DEEA                          M 	popp	__command
0000DEEA 1F45 0001                M 	move.b	d5,1(sp)
0000DEEE 4EB9 0000 0000           M 	jsr	errorhandler
0000DEF4                          M 	__fstring_generatedecodedstring	"Invalid PSG note: %<.b d5>"
0000DEF4 =00000001                M 	__lpos:	set 1
0000DEF4 =00000013                M 	__pos:	set instr("Invalid PSG note: %<.b d5>",'%<')
0000DEF4                          M 	while	(__pos)
0000DEF4                          M 	__substr:	substr __lpos,__pos-1,"Invalid PSG note: %<.b d5>"
0000DEF4 496E 7661 6C69 6420 5053+M 	dc.b	"Invalid PSG note: "
0000DF06 =0000001A                M 	__endpos:	set instr(__pos+1,"Invalid PSG note: %<.b d5>",'>')
0000DF06 =00000000                M 	__midpos:	set instr(__pos+5,"Invalid PSG note: %<.b d5>",' ')
0000DF06 =0000001A                M 	__midpos:	= __endpos
0000DF06                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid PSG note: %<.b d5>"
0000DF06                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid PSG note: %<.b d5>"
0000DF06                          M 	__param:	substr ,,"hex"
0000DF06 80                       M 	dc.b	hex
0000DF07 =0000001B                M 	__lpos:	set __endpos+1
0000DF07 =00000000                M 	__pos:	set instr(__pos+1,"Invalid PSG note: %<.b d5>",'%<')
0000DF07                          M 	__substr:	substr __lpos,,"Invalid PSG note: %<.b d5>"
0000DF07                          M 	dc.b	""
0000DF07 00                       M 	dc.b	0
0000DF08 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000DF0A 00                       M 	even
0000DF0A 4EFA F370                M 	jmp	amps_debug_console_channel
0000DF0E                          M 	even
0000DF0E                            ; ===========================================================================
0000DF0E                            ; ---------------------------------------------------------------------------
0000DF0E                            ; FM note check
0000DF0E                            ; ---------------------------------------------------------------------------
0000DF0E                            
0000DF0E                            AMPS_Debug_NoteFM	macro
0000DF0E                            	cmp.b	#dFreqFM_-dFreqFM,d5; check against max
0000DF0E                            	blo.s	.ok		; if too little, bra
0000DF0E                            .fail
0000DF0E                            	if def(RaiseError)	; check if Vladik's debugger is active
0000DF0E                            		jsr	AMPS_DebugR_NoteFM
0000DF0E                            	else
0000DF0E                            		bra.w	*
0000DF0E                            	endif
0000DF0E                            .ok
0000DF0E                                endm
0000DF0E                            
0000DF0E                            AMPS_DebugR_NoteFM:
0000DF0E E24D                       		lsr.w	#1,d5	; get real note
0000DF10                            		RaiseError2 "Invalid FM note: %<.b d5>", AMPS_Debug_Console_Channel
0000DF10 40E7                     M 	move.w	sr,-(sp)
0000DF12                          M 	__fstring_generateargumentscode	"Invalid FM note: %<.b d5>"
0000DF12 =00000012                M 	__pos:	set instr("Invalid FM note: %<.b d5>",'%<')
0000DF12 =00000000                M 	__stack:set	0
0000DF12 =00000000                M 	__sp:	set 0
0000DF12                          M 	while	(__pos)
0000DF12 =00000019                M 	__endpos:	set instr(__pos+1,"Invalid FM note: %<.b d5>",'>')
0000DF12 =00000000                M 	__midpos:	set instr(__pos+5,"Invalid FM note: %<.b d5>",' ')
0000DF12 =00000019                M 	__midpos:	= __endpos
0000DF12                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid FM note: %<.b d5>"
0000DF12                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid FM note: %<.b d5>"
0000DF12                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid FM note: %<.b d5>"
0000DF12                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid FM note: %<.b d5>"
0000DF12                          M 	pushp	"move.b d5,1(sp)"
0000DF12                          M 	pushp	"subq.w	#2, sp"
0000DF12 =00000002                M 	__stack:	= __stack+2
0000DF12 =00000002                M 	__sp:	= __sp+2
0000DF12 =00000000                M 	__pos:	set instr(__pos+1,"Invalid FM note: %<.b d5>",'%<')
0000DF12                          M 	rept	__stack
0000DF12                          M 	popp	__command
0000DF12 554F                     M 	subq.w	#2,sp
0000DF14                          M 	popp	__command
0000DF14 1F45 0001                M 	move.b	d5,1(sp)
0000DF18 4EB9 0000 0000           M 	jsr	errorhandler
0000DF1E                          M 	__fstring_generatedecodedstring	"Invalid FM note: %<.b d5>"
0000DF1E =00000001                M 	__lpos:	set 1
0000DF1E =00000012                M 	__pos:	set instr("Invalid FM note: %<.b d5>",'%<')
0000DF1E                          M 	while	(__pos)
0000DF1E                          M 	__substr:	substr __lpos,__pos-1,"Invalid FM note: %<.b d5>"
0000DF1E 496E 7661 6C69 6420 464D+M 	dc.b	"Invalid FM note: "
0000DF2F =00000019                M 	__endpos:	set instr(__pos+1,"Invalid FM note: %<.b d5>",'>')
0000DF2F =00000000                M 	__midpos:	set instr(__pos+5,"Invalid FM note: %<.b d5>",' ')
0000DF2F =00000019                M 	__midpos:	= __endpos
0000DF2F                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid FM note: %<.b d5>"
0000DF2F                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid FM note: %<.b d5>"
0000DF2F                          M 	__param:	substr ,,"hex"
0000DF2F 80                       M 	dc.b	hex
0000DF30 =0000001A                M 	__lpos:	set __endpos+1
0000DF30 =00000000                M 	__pos:	set instr(__pos+1,"Invalid FM note: %<.b d5>",'%<')
0000DF30                          M 	__substr:	substr __lpos,,"Invalid FM note: %<.b d5>"
0000DF30                          M 	dc.b	""
0000DF30 00                       M 	dc.b	0
0000DF31 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000DF32                          M 	even
0000DF32 4EFA F348                M 	jmp	amps_debug_console_channel
0000DF36                          M 	even
0000DF36                            ; ===========================================================================
0000DF36                            ; ---------------------------------------------------------------------------
0000DF36                            ; DAC frequency check
0000DF36                            ; ---------------------------------------------------------------------------
0000DF36                            
0000DF36                            AMPS_Debug_FreqDAC	macro
0000DF36                            	cmp.w	#MaxPitch,d6	; check if frequency is too large
0000DF36                            	bgt.s	.fail		; if so, branch
0000DF36                            	cmp.w	#-MaxPitch,d6	; check if frequency is too small
0000DF36                            	bge.s	.ok		; if not, branch
0000DF36                            .fail
0000DF36                            	if def(RaiseError)	; check if Vladik's debugger is active
0000DF36                            		jsr	AMPS_DebugR_FreqDAC
0000DF36                            	else
0000DF36                            		bra.w	*
0000DF36                            	endif
0000DF36                            .ok
0000DF36                                endm
0000DF36                            
0000DF36                            AMPS_DebugR_FreqDAC:
0000DF36                            		RaiseError "Out of range DAC frequency: %<.w d6>", AMPS_Debug_Console_Channel
0000DF36 487A FFFE                M 	pea	*(pc)
0000DF3A                          M 	raiseerror2	"Out of range DAC frequency: %<.w d6>",amps_debug_console_channel
0000DF3A 40E7                     M 	move.w	sr,-(sp)
0000DF3C                          M 	__fstring_generateargumentscode	"Out of range DAC frequency: %<.w d6>"
0000DF3C =0000001D                M 	__pos:	set instr("Out of range DAC frequency: %<.w d6>",'%<')
0000DF3C =00000000                M 	__stack:set	0
0000DF3C =00000000                M 	__sp:	set 0
0000DF3C                          M 	while	(__pos)
0000DF3C =00000024                M 	__endpos:	set instr(__pos+1,"Out of range DAC frequency: %<.w d6>",'>')
0000DF3C =00000000                M 	__midpos:	set instr(__pos+5,"Out of range DAC frequency: %<.w d6>",' ')
0000DF3C =00000024                M 	__midpos:	= __endpos
0000DF3C                          M 	__substr:	substr __pos+1+1,__endpos-1,"Out of range DAC frequency: %<.w d6>"
0000DF3C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Out of range DAC frequency: %<.w d6>"
0000DF3C                          M 	__operand:	substr __pos+1+1,__midpos-1,"Out of range DAC frequency: %<.w d6>"
0000DF3C                          M 	__param:	substr __midpos+1,__endpos-1,"Out of range DAC frequency: %<.w d6>"
0000DF3C                          M 	pushp	"move.w d6,-(sp)"
0000DF3C =00000001                M 	__stack:	= __stack+1
0000DF3C =00000002                M 	__sp:	= __sp+2
0000DF3C =00000000                M 	__pos:	set instr(__pos+1,"Out of range DAC frequency: %<.w d6>",'%<')
0000DF3C                          M 	rept	__stack
0000DF3C                          M 	popp	__command
0000DF3C 3F06                     M 	move.w	d6,-(sp)
0000DF3E 4EB9 0000 0000           M 	jsr	errorhandler
0000DF44                          M 	__fstring_generatedecodedstring	"Out of range DAC frequency: %<.w d6>"
0000DF44 =00000001                M 	__lpos:	set 1
0000DF44 =0000001D                M 	__pos:	set instr("Out of range DAC frequency: %<.w d6>",'%<')
0000DF44                          M 	while	(__pos)
0000DF44                          M 	__substr:	substr __lpos,__pos-1,"Out of range DAC frequency: %<.w d6>"
0000DF44 4F75 7420 6F66 2072 616E+M 	dc.b	"Out of range DAC frequency: "
0000DF60 =00000024                M 	__endpos:	set instr(__pos+1,"Out of range DAC frequency: %<.w d6>",'>')
0000DF60 =00000000                M 	__midpos:	set instr(__pos+5,"Out of range DAC frequency: %<.w d6>",' ')
0000DF60 =00000024                M 	__midpos:	= __endpos
0000DF60                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Out of range DAC frequency: %<.w d6>"
0000DF60                          M 	__param:	substr __midpos+1,__endpos-1,"Out of range DAC frequency: %<.w d6>"
0000DF60                          M 	__param:	substr ,,"hex"
0000DF60 81                       M 	dc.b	hex|1
0000DF61 =00000025                M 	__lpos:	set __endpos+1
0000DF61 =00000000                M 	__pos:	set instr(__pos+1,"Out of range DAC frequency: %<.w d6>",'%<')
0000DF61                          M 	__substr:	substr __lpos,,"Out of range DAC frequency: %<.w d6>"
0000DF61                          M 	dc.b	""
0000DF61 00                       M 	dc.b	0
0000DF62 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000DF64 00                       M 	even
0000DF64 4EFA F316                M 	jmp	amps_debug_console_channel
0000DF68                          M 	even
0000DF68                            ; ===========================================================================
0000DF68                            ; ---------------------------------------------------------------------------
0000DF68                            ; Invalid tracker command handlers
0000DF68                            ; ---------------------------------------------------------------------------
0000DF68                            
0000DF68                            AMPS_Debug_dcInvalid	macro
0000DF68                            	if def(RaiseError)	; check if Vladik's debugger is active
0000DF68                            		RaiseError "Invalid command detected!", AMPS_Debug_Console_Channel
0000DF68                            	else
0000DF68                            		bra.w	*
0000DF68                            	endif
0000DF68                                endm
0000DF68                            ; ===========================================================================
0000DF68                            ; ---------------------------------------------------------------------------
0000DF68                            ; PSG on sPan handler
0000DF68                            ; ---------------------------------------------------------------------------
0000DF68                            
0000DF68                            AMPS_Debug_dcPan	macro
0000DF68                            	tst.b	cType(a5)	; check for PSG channel
0000DF68                            	bpl.s	.ok		; if no, branch
0000DF68                            	if def(RaiseError)	; check if Vladik's debugger is active
0000DF68                            		RaiseError "sPan on a PSG channel!", AMPS_Debug_Console_Channel
0000DF68                            	else
0000DF68                            		bra.w	*
0000DF68                            	endif
0000DF68                            .ok
0000DF68                                endm
0000DF68                            ; ===========================================================================
0000DF68                            ; ---------------------------------------------------------------------------
0000DF68                            ; Timeout command on SFX channel handler
0000DF68                            ; ---------------------------------------------------------------------------
0000DF68                            
0000DF68                            AMPS_Debug_dcTimeout	macro
0000DF68                            	cmp.w	#mSFXDAC1,a5	; check for SFX channel
0000DF68                            	blo.s	.ok		; if no, branch
0000DF68                            	if def(RaiseError)	; check if Vladik's debugger is active
0000DF68                            		RaiseError "sNoteTimeOut on a SFX channel!", AMPS_Debug_Console_Channel
0000DF68                            	else
0000DF68                            		bra.w	*
0000DF68                            	endif
0000DF68                            .ok
0000DF68                                endm
0000DF68                            ; ===========================================================================
0000DF68                            ; ---------------------------------------------------------------------------
0000DF68                            ; Call command handlers
0000DF68                            ; ---------------------------------------------------------------------------
0000DF68                            
0000DF68                            AMPS_Debug_dcCall1	macro
0000DF68                            	cmp.w	#mSFXDAC1,a5	; check for SFX channel
0000DF68                            	blo.s	.ok1		; if no, branch
0000DF68                            	if def(RaiseError)	; check if Vladik's debugger is active
0000DF68                            		RaiseError "sCall on a SFX channel!", AMPS_Debug_Console_Channel
0000DF68                            	else
0000DF68                            		bra.w	*
0000DF68                            	endif
0000DF68                            .ok1
0000DF68                                endm
0000DF68                            
0000DF68                            AMPS_Debug_dcCall2	macro
0000DF68                            	cmp.b	#cNoteTimeCur,d0; check for invalid stack address
0000DF68                            	bhi.s	.ok2		; if no, branch
0000DF68                            	if def(RaiseError)	; check if Vladik's debugger is active
0000DF68                            		RaiseError "sCall stack too deep!", AMPS_Debug_Console_Channel
0000DF68                            	else
0000DF68                            		bra.w	*
0000DF68                            	endif
0000DF68                            .ok2
0000DF68                                endm
0000DF68                            ; ===========================================================================
0000DF68                            ; ---------------------------------------------------------------------------
0000DF68                            ; Loop command handler
0000DF68                            ; ---------------------------------------------------------------------------
0000DF68                            
0000DF68                            AMPS_Debug_dcLoop	macro
0000DF68                            	cmp.b	#3,d0		; check for invalid call number
0000DF68                            	bhi.s	.fail		; if is, branch
0000DF68                            	cmp.w	#mSFXDAC1,a5	; check for SFX channel
0000DF68                            	blo.s	.nosfx		; if no, branch
0000DF68                            	cmp.b	#1,d0		; check if cPrio
0000DF68                            	beq.s	.fail		; if so, branch
0000DF68                            .nosfx
0000DF68                            	cmp.b	#$C0,cType(a5)	; check if PSG3 or PSG4
0000DF68                            	blo.s	AMPS_Debug_dcLoop_ok; if no, branch
0000DF68                            	cmp.b	#2,d0		; check if cStatPSG4
0000DF68                            	bne.s	AMPS_Debug_dcLoop_ok; if no, branch
0000DF68                            .fail
0000DF68                            	if def(RaiseError)	; check if Vladik's debugger is active
0000DF68                            		RaiseError "sLoop ID is invalid!", AMPS_Debug_Console_Channel
0000DF68                            	else
0000DF68                            		bra.w	*
0000DF68                            	endif
0000DF68                            AMPS_Debug_dcLoop_ok
0000DF68                                endm
0000DF68                            ; ===========================================================================
0000DF68                            ; ---------------------------------------------------------------------------
0000DF68                            ; Return command handlers
0000DF68                            ; ---------------------------------------------------------------------------
0000DF68                            
0000DF68                            AMPS_Debug_dcReturn1	macro
0000DF68                            	cmp.w	#mSFXDAC1,a5	; check for SFX channel
0000DF68                            	blo.s	.ok1		; if no, branch
0000DF68                            	if def(RaiseError)	; check if Vladik's debugger is active
0000DF68                            		RaiseError "sRet on a SFX channel!", AMPS_Debug_Console_Channel
0000DF68                            	else
0000DF68                            		bra.w	*
0000DF68                            	endif
0000DF68                            .ok1
0000DF68                                endm
0000DF68                            
0000DF68                            AMPS_Debug_dcReturn2	macro
0000DF68                            	cmp.b	#cSize,d0	; check for invalid stack address
0000DF68                            	bls.s	.ok2		; if no, branch
0000DF68                            	if def(RaiseError)	; check if Vladik's debugger is active
0000DF68                            		RaiseError "sRet stack too shallow!", AMPS_Debug_Console_Channel
0000DF68                            	else
0000DF68                            		bra.w	*
0000DF68                            	endif
0000DF68                            .ok2
0000DF68                                endm
0000DF68                            ; ===========================================================================
0000DF68                            ; ---------------------------------------------------------------------------
0000DF68                            ; Update FM voice handler
0000DF68                            ; ---------------------------------------------------------------------------
0000DF68                            
0000DF68                            AMPS_Debug_UpdVoiceFM	macro
0000DF68                            	cmp.b	#'N',(a1)+	; check if this is valid voice
0000DF68                            	bne.s	.fail		; if not, branch
0000DF68                            	cmp.w	#'AT',(a1)+	; check if this is valid voice
0000DF68                            	beq.s	.ok		; if is, branch
0000DF68                            .fail
0000DF68                            	if def(RaiseError)	; check if Vladik's debugger is active
0000DF68                            		RaiseError "FM voice Update invalid voice: %<.b cVoice(a5)>", AMPS_Debug_Console_Channel
0000DF68                            	else
0000DF68                            		bra.w	*
0000DF68                            	endif
0000DF68                            .ok
0000DF68                                endm
0000DF68                            ; ===========================================================================
0000DF68                            ; ---------------------------------------------------------------------------
0000DF68                            ; Update FM Volume handler
0000DF68                            ; ---------------------------------------------------------------------------
0000DF68                            
0000DF68                            AMPS_Debug_UpdVolFM	macro
0000DF68                            	cmp.b	#'N',(a1)+	; check if this is valid voice
0000DF68                            	bne.s	.fail		; if not, branch
0000DF68                            	cmp.w	#'AT',(a1)+	; check if this is valid voice
0000DF68                            	beq.s	.ok		; if is, branch
0000DF68                            .fail
0000DF68                            	if def(RaiseError)	; check if Vladik's debugger is active
0000DF68                            		jsr	AMPS_DebugR_UpdVolFM
0000DF68                            	else
0000DF68                            		bra.w	*
0000DF68                            	endif
0000DF68                            .ok
0000DF68                                endm
0000DF68                            
0000DF68                            AMPS_DebugR_UpdVolFM:
0000DF68                            	RaiseError2 "FM Volume Update invalid voice: %<.b cVoice(a5)>", AMPS_Debug_Console_Channel
0000DF68 40E7                     M 	move.w	sr,-(sp)
0000DF6A                          M 	__fstring_generateargumentscode	"FM Volume Update invalid voice: %<.b cVoice(a5)>"
0000DF6A =00000021                M 	__pos:	set instr("FM Volume Update invalid voice: %<.b cVoice(a5)>",'%<')
0000DF6A =00000000                M 	__stack:set	0
0000DF6A =00000000                M 	__sp:	set 0
0000DF6A                          M 	while	(__pos)
0000DF6A =00000030                M 	__endpos:	set instr(__pos+1,"FM Volume Update invalid voice: %<.b cVoice(a5)>",'>')
0000DF6A =00000000                M 	__midpos:	set instr(__pos+5,"FM Volume Update invalid voice: %<.b cVoice(a5)>",' ')
0000DF6A =00000030                M 	__midpos:	= __endpos
0000DF6A                          M 	__substr:	substr __pos+1+1,__endpos-1,"FM Volume Update invalid voice: %<.b cVoice(a5)>"
0000DF6A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"FM Volume Update invalid voice: %<.b cVoice(a5)>"
0000DF6A                          M 	__operand:	substr __pos+1+1,__midpos-1,"FM Volume Update invalid voice: %<.b cVoice(a5)>"
0000DF6A                          M 	__param:	substr __midpos+1,__endpos-1,"FM Volume Update invalid voice: %<.b cVoice(a5)>"
0000DF6A                          M 	pushp	"move.b cVoice(a5),1(sp)"
0000DF6A                          M 	pushp	"subq.w	#2, sp"
0000DF6A =00000002                M 	__stack:	= __stack+2
0000DF6A =00000002                M 	__sp:	= __sp+2
0000DF6A =00000000                M 	__pos:	set instr(__pos+1,"FM Volume Update invalid voice: %<.b cVoice(a5)>",'%<')
0000DF6A                          M 	rept	__stack
0000DF6A                          M 	popp	__command
0000DF6A 554F                     M 	subq.w	#2,sp
0000DF6C                          M 	popp	__command
0000DF6C 1F6D 000B 0001           M 	move.b	cvoice(a5),1(sp)
0000DF72 4EB9 0000 0000           M 	jsr	errorhandler
0000DF78                          M 	__fstring_generatedecodedstring	"FM Volume Update invalid voice: %<.b cVoice(a5)>"
0000DF78 =00000001                M 	__lpos:	set 1
0000DF78 =00000021                M 	__pos:	set instr("FM Volume Update invalid voice: %<.b cVoice(a5)>",'%<')
0000DF78                          M 	while	(__pos)
0000DF78                          M 	__substr:	substr __lpos,__pos-1,"FM Volume Update invalid voice: %<.b cVoice(a5)>"
0000DF78 464D 2056 6F6C 756D 6520+M 	dc.b	"FM Volume Update invalid voice: "
0000DF98 =00000030                M 	__endpos:	set instr(__pos+1,"FM Volume Update invalid voice: %<.b cVoice(a5)>",'>')
0000DF98 =00000000                M 	__midpos:	set instr(__pos+5,"FM Volume Update invalid voice: %<.b cVoice(a5)>",' ')
0000DF98 =00000030                M 	__midpos:	= __endpos
0000DF98                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"FM Volume Update invalid voice: %<.b cVoice(a5)>"
0000DF98                          M 	__param:	substr __midpos+1,__endpos-1,"FM Volume Update invalid voice: %<.b cVoice(a5)>"
0000DF98                          M 	__param:	substr ,,"hex"
0000DF98 80                       M 	dc.b	hex
0000DF99 =00000031                M 	__lpos:	set __endpos+1
0000DF99 =00000000                M 	__pos:	set instr(__pos+1,"FM Volume Update invalid voice: %<.b cVoice(a5)>",'%<')
0000DF99                          M 	__substr:	substr __lpos,,"FM Volume Update invalid voice: %<.b cVoice(a5)>"
0000DF99                          M 	dc.b	""
0000DF99 00                       M 	dc.b	0
0000DF9A 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000DF9C 00                       M 	even
0000DF9C 4EFA F2DE                M 	jmp	amps_debug_console_channel
0000DFA0                          M 	even
0000DFA0                            ; ===========================================================================
0000DFA0                            ; ---------------------------------------------------------------------------
0000DFA0                            ; Invalid cue handler
0000DFA0                            ; ---------------------------------------------------------------------------
0000DFA0                            
0000DFA0                            AMPS_Debug_CuePtr	macro id
0000DFA0                            	cmp.l	#$A00000+YM_Buffer1,a0	; check against min
0000DFA0                            	blo.s	.fail\@			; if not in range, branch
0000DFA0                            	cmp.l	#$A00000+YM_Buffer2+$400,a0; check against max
0000DFA0                            	blo.s	.ok\@			; if in range, branch
0000DFA0                            .fail\@
0000DFA0                            	if def(RaiseError)	; check if Vladik's debugger is active
0000DFA0                            		jsr	AMPS_Debug_CuePtr\id
0000DFA0                            	else
0000DFA0                            		bra.w	*
0000DFA0                            	endif
0000DFA0                            .ok\@
0000DFA0                                endm
0000DFA0                            
0000DFA0                            AMPS_Debug_CuePtr1:
0000DFA0                            		RaiseError2 "CUE invalid at WriteYM_Pt1: %<.l a0>", AMPS_Debug_Console_Channel
0000DFA0 40E7                     M 	move.w	sr,-(sp)
0000DFA2                          M 	__fstring_generateargumentscode	"CUE invalid at WriteYM_Pt1: %<.l a0>"
0000DFA2 =0000001D                M 	__pos:	set instr("CUE invalid at WriteYM_Pt1: %<.l a0>",'%<')
0000DFA2 =00000000                M 	__stack:set	0
0000DFA2 =00000000                M 	__sp:	set 0
0000DFA2                          M 	while	(__pos)
0000DFA2 =00000024                M 	__endpos:	set instr(__pos+1,"CUE invalid at WriteYM_Pt1: %<.l a0>",'>')
0000DFA2 =00000000                M 	__midpos:	set instr(__pos+5,"CUE invalid at WriteYM_Pt1: %<.l a0>",' ')
0000DFA2 =00000024                M 	__midpos:	= __endpos
0000DFA2                          M 	__substr:	substr __pos+1+1,__endpos-1,"CUE invalid at WriteYM_Pt1: %<.l a0>"
0000DFA2                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"CUE invalid at WriteYM_Pt1: %<.l a0>"
0000DFA2                          M 	__operand:	substr __pos+1+1,__midpos-1,"CUE invalid at WriteYM_Pt1: %<.l a0>"
0000DFA2                          M 	__param:	substr __midpos+1,__endpos-1,"CUE invalid at WriteYM_Pt1: %<.l a0>"
0000DFA2                          M 	pushp	"move.l a0,-(sp)"
0000DFA2 =00000001                M 	__stack:	= __stack+1
0000DFA2 =00000004                M 	__sp:	= __sp+4
0000DFA2 =00000000                M 	__pos:	set instr(__pos+1,"CUE invalid at WriteYM_Pt1: %<.l a0>",'%<')
0000DFA2                          M 	rept	__stack
0000DFA2                          M 	popp	__command
0000DFA2 2F08                     M 	move.l	a0,-(sp)
0000DFA4 4EB9 0000 0000           M 	jsr	errorhandler
0000DFAA                          M 	__fstring_generatedecodedstring	"CUE invalid at WriteYM_Pt1: %<.l a0>"
0000DFAA =00000001                M 	__lpos:	set 1
0000DFAA =0000001D                M 	__pos:	set instr("CUE invalid at WriteYM_Pt1: %<.l a0>",'%<')
0000DFAA                          M 	while	(__pos)
0000DFAA                          M 	__substr:	substr __lpos,__pos-1,"CUE invalid at WriteYM_Pt1: %<.l a0>"
0000DFAA 4355 4520 696E 7661 6C69+M 	dc.b	"CUE invalid at WriteYM_Pt1: "
0000DFC6 =00000024                M 	__endpos:	set instr(__pos+1,"CUE invalid at WriteYM_Pt1: %<.l a0>",'>')
0000DFC6 =00000000                M 	__midpos:	set instr(__pos+5,"CUE invalid at WriteYM_Pt1: %<.l a0>",' ')
0000DFC6 =00000024                M 	__midpos:	= __endpos
0000DFC6                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"CUE invalid at WriteYM_Pt1: %<.l a0>"
0000DFC6                          M 	__param:	substr __midpos+1,__endpos-1,"CUE invalid at WriteYM_Pt1: %<.l a0>"
0000DFC6                          M 	__param:	substr ,,"hex"
0000DFC6 83                       M 	dc.b	hex|3
0000DFC7 =00000025                M 	__lpos:	set __endpos+1
0000DFC7 =00000000                M 	__pos:	set instr(__pos+1,"CUE invalid at WriteYM_Pt1: %<.l a0>",'%<')
0000DFC7                          M 	__substr:	substr __lpos,,"CUE invalid at WriteYM_Pt1: %<.l a0>"
0000DFC7                          M 	dc.b	""
0000DFC7 00                       M 	dc.b	0
0000DFC8 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000DFCA 00                       M 	even
0000DFCA 4EFA F2B0                M 	jmp	amps_debug_console_channel
0000DFCE                          M 	even
0000DFCE                            AMPS_Debug_CuePtr2:
0000DFCE                            		RaiseError2 "CUE invalid at WriteYM_Pt2: %<.l a0>", AMPS_Debug_Console_Channel
0000DFCE 40E7                     M 	move.w	sr,-(sp)
0000DFD0                          M 	__fstring_generateargumentscode	"CUE invalid at WriteYM_Pt2: %<.l a0>"
0000DFD0 =0000001D                M 	__pos:	set instr("CUE invalid at WriteYM_Pt2: %<.l a0>",'%<')
0000DFD0 =00000000                M 	__stack:set	0
0000DFD0 =00000000                M 	__sp:	set 0
0000DFD0                          M 	while	(__pos)
0000DFD0 =00000024                M 	__endpos:	set instr(__pos+1,"CUE invalid at WriteYM_Pt2: %<.l a0>",'>')
0000DFD0 =00000000                M 	__midpos:	set instr(__pos+5,"CUE invalid at WriteYM_Pt2: %<.l a0>",' ')
0000DFD0 =00000024                M 	__midpos:	= __endpos
0000DFD0                          M 	__substr:	substr __pos+1+1,__endpos-1,"CUE invalid at WriteYM_Pt2: %<.l a0>"
0000DFD0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"CUE invalid at WriteYM_Pt2: %<.l a0>"
0000DFD0                          M 	__operand:	substr __pos+1+1,__midpos-1,"CUE invalid at WriteYM_Pt2: %<.l a0>"
0000DFD0                          M 	__param:	substr __midpos+1,__endpos-1,"CUE invalid at WriteYM_Pt2: %<.l a0>"
0000DFD0                          M 	pushp	"move.l a0,-(sp)"
0000DFD0 =00000001                M 	__stack:	= __stack+1
0000DFD0 =00000004                M 	__sp:	= __sp+4
0000DFD0 =00000000                M 	__pos:	set instr(__pos+1,"CUE invalid at WriteYM_Pt2: %<.l a0>",'%<')
0000DFD0                          M 	rept	__stack
0000DFD0                          M 	popp	__command
0000DFD0 2F08                     M 	move.l	a0,-(sp)
0000DFD2 4EB9 0000 0000           M 	jsr	errorhandler
0000DFD8                          M 	__fstring_generatedecodedstring	"CUE invalid at WriteYM_Pt2: %<.l a0>"
0000DFD8 =00000001                M 	__lpos:	set 1
0000DFD8 =0000001D                M 	__pos:	set instr("CUE invalid at WriteYM_Pt2: %<.l a0>",'%<')
0000DFD8                          M 	while	(__pos)
0000DFD8                          M 	__substr:	substr __lpos,__pos-1,"CUE invalid at WriteYM_Pt2: %<.l a0>"
0000DFD8 4355 4520 696E 7661 6C69+M 	dc.b	"CUE invalid at WriteYM_Pt2: "
0000DFF4 =00000024                M 	__endpos:	set instr(__pos+1,"CUE invalid at WriteYM_Pt2: %<.l a0>",'>')
0000DFF4 =00000000                M 	__midpos:	set instr(__pos+5,"CUE invalid at WriteYM_Pt2: %<.l a0>",' ')
0000DFF4 =00000024                M 	__midpos:	= __endpos
0000DFF4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"CUE invalid at WriteYM_Pt2: %<.l a0>"
0000DFF4                          M 	__param:	substr __midpos+1,__endpos-1,"CUE invalid at WriteYM_Pt2: %<.l a0>"
0000DFF4                          M 	__param:	substr ,,"hex"
0000DFF4 83                       M 	dc.b	hex|3
0000DFF5 =00000025                M 	__lpos:	set __endpos+1
0000DFF5 =00000000                M 	__pos:	set instr(__pos+1,"CUE invalid at WriteYM_Pt2: %<.l a0>",'%<')
0000DFF5                          M 	__substr:	substr __lpos,,"CUE invalid at WriteYM_Pt2: %<.l a0>"
0000DFF5                          M 	dc.b	""
0000DFF5 00                       M 	dc.b	0
0000DFF6 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000DFF8 00                       M 	even
0000DFF8 4EFA F282                M 	jmp	amps_debug_console_channel
0000DFFC                          M 	even
0000DFFC                            AMPS_Debug_CuePtr0:
0000DFFC                            		RaiseError2 "CUE invalid at dUpdateVoiceFM: %<.l a0>", AMPS_Debug_Console_Channel
0000DFFC 40E7                     M 	move.w	sr,-(sp)
0000DFFE                          M 	__fstring_generateargumentscode	"CUE invalid at dUpdateVoiceFM: %<.l a0>"
0000DFFE =00000020                M 	__pos:	set instr("CUE invalid at dUpdateVoiceFM: %<.l a0>",'%<')
0000DFFE =00000000                M 	__stack:set	0
0000DFFE =00000000                M 	__sp:	set 0
0000DFFE                          M 	while	(__pos)
0000DFFE =00000027                M 	__endpos:	set instr(__pos+1,"CUE invalid at dUpdateVoiceFM: %<.l a0>",'>')
0000DFFE =00000000                M 	__midpos:	set instr(__pos+5,"CUE invalid at dUpdateVoiceFM: %<.l a0>",' ')
0000DFFE =00000027                M 	__midpos:	= __endpos
0000DFFE                          M 	__substr:	substr __pos+1+1,__endpos-1,"CUE invalid at dUpdateVoiceFM: %<.l a0>"
0000DFFE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"CUE invalid at dUpdateVoiceFM: %<.l a0>"
0000DFFE                          M 	__operand:	substr __pos+1+1,__midpos-1,"CUE invalid at dUpdateVoiceFM: %<.l a0>"
0000DFFE                          M 	__param:	substr __midpos+1,__endpos-1,"CUE invalid at dUpdateVoiceFM: %<.l a0>"
0000DFFE                          M 	pushp	"move.l a0,-(sp)"
0000DFFE =00000001                M 	__stack:	= __stack+1
0000DFFE =00000004                M 	__sp:	= __sp+4
0000DFFE =00000000                M 	__pos:	set instr(__pos+1,"CUE invalid at dUpdateVoiceFM: %<.l a0>",'%<')
0000DFFE                          M 	rept	__stack
0000DFFE                          M 	popp	__command
0000DFFE 2F08                     M 	move.l	a0,-(sp)
0000E000 4EB9 0000 0000           M 	jsr	errorhandler
0000E006                          M 	__fstring_generatedecodedstring	"CUE invalid at dUpdateVoiceFM: %<.l a0>"
0000E006 =00000001                M 	__lpos:	set 1
0000E006 =00000020                M 	__pos:	set instr("CUE invalid at dUpdateVoiceFM: %<.l a0>",'%<')
0000E006                          M 	while	(__pos)
0000E006                          M 	__substr:	substr __lpos,__pos-1,"CUE invalid at dUpdateVoiceFM: %<.l a0>"
0000E006 4355 4520 696E 7661 6C69+M 	dc.b	"CUE invalid at dUpdateVoiceFM: "
0000E025 =00000027                M 	__endpos:	set instr(__pos+1,"CUE invalid at dUpdateVoiceFM: %<.l a0>",'>')
0000E025 =00000000                M 	__midpos:	set instr(__pos+5,"CUE invalid at dUpdateVoiceFM: %<.l a0>",' ')
0000E025 =00000027                M 	__midpos:	= __endpos
0000E025                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"CUE invalid at dUpdateVoiceFM: %<.l a0>"
0000E025                          M 	__param:	substr __midpos+1,__endpos-1,"CUE invalid at dUpdateVoiceFM: %<.l a0>"
0000E025                          M 	__param:	substr ,,"hex"
0000E025 83                       M 	dc.b	hex|3
0000E026 =00000028                M 	__lpos:	set __endpos+1
0000E026 =00000000                M 	__pos:	set instr(__pos+1,"CUE invalid at dUpdateVoiceFM: %<.l a0>",'%<')
0000E026                          M 	__substr:	substr __lpos,,"CUE invalid at dUpdateVoiceFM: %<.l a0>"
0000E026                          M 	dc.b	""
0000E026 00                       M 	dc.b	0
0000E027 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000E028                          M 	even
0000E028 4EFA F252                M 	jmp	amps_debug_console_channel
0000E02C                          M 	even
0000E02C                            AMPS_Debug_CuePtr3:
0000E02C                            		RaiseError2 "CUE invalid at dAMPSend: %<.l a0>", AMPS_Debug_Console_Channel
0000E02C 40E7                     M 	move.w	sr,-(sp)
0000E02E                          M 	__fstring_generateargumentscode	"CUE invalid at dAMPSend: %<.l a0>"
0000E02E =0000001A                M 	__pos:	set instr("CUE invalid at dAMPSend: %<.l a0>",'%<')
0000E02E =00000000                M 	__stack:set	0
0000E02E =00000000                M 	__sp:	set 0
0000E02E                          M 	while	(__pos)
0000E02E =00000021                M 	__endpos:	set instr(__pos+1,"CUE invalid at dAMPSend: %<.l a0>",'>')
0000E02E =00000000                M 	__midpos:	set instr(__pos+5,"CUE invalid at dAMPSend: %<.l a0>",' ')
0000E02E =00000021                M 	__midpos:	= __endpos
0000E02E                          M 	__substr:	substr __pos+1+1,__endpos-1,"CUE invalid at dAMPSend: %<.l a0>"
0000E02E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"CUE invalid at dAMPSend: %<.l a0>"
0000E02E                          M 	__operand:	substr __pos+1+1,__midpos-1,"CUE invalid at dAMPSend: %<.l a0>"
0000E02E                          M 	__param:	substr __midpos+1,__endpos-1,"CUE invalid at dAMPSend: %<.l a0>"
0000E02E                          M 	pushp	"move.l a0,-(sp)"
0000E02E =00000001                M 	__stack:	= __stack+1
0000E02E =00000004                M 	__sp:	= __sp+4
0000E02E =00000000                M 	__pos:	set instr(__pos+1,"CUE invalid at dAMPSend: %<.l a0>",'%<')
0000E02E                          M 	rept	__stack
0000E02E                          M 	popp	__command
0000E02E 2F08                     M 	move.l	a0,-(sp)
0000E030 4EB9 0000 0000           M 	jsr	errorhandler
0000E036                          M 	__fstring_generatedecodedstring	"CUE invalid at dAMPSend: %<.l a0>"
0000E036 =00000001                M 	__lpos:	set 1
0000E036 =0000001A                M 	__pos:	set instr("CUE invalid at dAMPSend: %<.l a0>",'%<')
0000E036                          M 	while	(__pos)
0000E036                          M 	__substr:	substr __lpos,__pos-1,"CUE invalid at dAMPSend: %<.l a0>"
0000E036 4355 4520 696E 7661 6C69+M 	dc.b	"CUE invalid at dAMPSend: "
0000E04F =00000021                M 	__endpos:	set instr(__pos+1,"CUE invalid at dAMPSend: %<.l a0>",'>')
0000E04F =00000000                M 	__midpos:	set instr(__pos+5,"CUE invalid at dAMPSend: %<.l a0>",' ')
0000E04F =00000021                M 	__midpos:	= __endpos
0000E04F                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"CUE invalid at dAMPSend: %<.l a0>"
0000E04F                          M 	__param:	substr __midpos+1,__endpos-1,"CUE invalid at dAMPSend: %<.l a0>"
0000E04F                          M 	__param:	substr ,,"hex"
0000E04F 83                       M 	dc.b	hex|3
0000E050 =00000022                M 	__lpos:	set __endpos+1
0000E050 =00000000                M 	__pos:	set instr(__pos+1,"CUE invalid at dAMPSend: %<.l a0>",'%<')
0000E050                          M 	__substr:	substr __lpos,,"CUE invalid at dAMPSend: %<.l a0>"
0000E050                          M 	dc.b	""
0000E050 00                       M 	dc.b	0
0000E051 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000E052                          M 	even
0000E052 4EFA F228                M 	jmp	amps_debug_console_channel
0000E056                          M 	even
0000E056                            ; ===========================================================================
0000E056                            ; ---------------------------------------------------------------------------
0000E056                            ; Play Command handler
0000E056                            ; ---------------------------------------------------------------------------
0000E056                            
0000E056                            AMPS_Debug_PlayCmd	macro
0000E056                            	cmp.b	#(dSoundCommands_End-dSoundCommands)/4,d7; check if this is valid command
0000E056                            	bls.s	.ok		; if is, branch
0000E056                            	if def(RaiseError)	; check if Vladik's debugger is active
0000E056                            		RaiseError "Invalid command in queue: %<.b d7>", AMPS_Debug_Console_Channel
0000E056                            	else
0000E056                            		bra.w	*
0000E056                            	endif
0000E056                            .ok
0000E056                                endm
0000E056                            ; ===========================================================================
0000E056                            ; ---------------------------------------------------------------------------
0000E056                            ; Tracker address handlers
0000E056                            ; ---------------------------------------------------------------------------
0000E056                            
0000E056                            AMPS_Debug_PlayTrackMus	macro
0000E056                            	cmp.l	#musaddr,d0	; check if this is valid tracker
0000E056                            	blo.s	.fail\@		; if no, branch
0000E056                            	cmp.l	#musend,d0	; check if this is valid tracker
0000E056                            	blo.s	.ok\@		; if is, branch
0000E056                            .fail\@
0000E056                            	if def(RaiseError)	; check if Vladik's debugger is active
0000E056                            		lsr.w	#2,d7	; get actual ID
0000E056                            		RaiseError "Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>", AMPS_Debug_Console_Main
0000E056                            	else
0000E056                            		bra.w	*
0000E056                            	endif
0000E056                            .ok\@
0000E056                                endm
0000E056                            
0000E056                            AMPS_Debug_PlayTrackMus2	macro ch
0000E056                            	and.l	#$FFFFFF,d0	; remove high byte
0000E056                            	cmp.l	#musaddr,d0	; check if this is valid tracker
0000E056                            	blo.s	.fail\@		; if no, branch
0000E056                            	cmp.l	#dacaddr,d0	; check if this is valid tracker
0000E056                            	blo.s	.ok\@		; if is, branch
0000E056                            .fail\@
0000E056                            	if def(RaiseError)	; check if Vladik's debugger is active
0000E056                            		RaiseError "Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>", AMPS_Debug_Console_Main
0000E056                            	else
0000E056                            		bra.w	*
0000E056                            	endif
0000E056                            .ok\@
0000E056                                endm
0000E056                            
0000E056                            AMPS_Debug_PlayTrackSFX	macro
0000E056                            	cmp.l	#sfxaddr,d0	; check if this is valid tracker
0000E056                            	blo.s	.fail\@		; if no, branch
0000E056                            	cmp.l	#musaddr,d0	; check if this is valid tracker
0000E056                            	blo.s	.ok\@		; if is, branch
0000E056                            .fail\@
0000E056                            	if def(RaiseError)	; check if Vladik's debugger is active
0000E056                            		RaiseError "Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>", AMPS_Debug_Console_Main
0000E056                            	else
0000E056                            		bra.w	*
0000E056                            	endif
0000E056                            .ok\@
0000E056                                endm
0000E056                            
0000E056                            AMPS_Debug_PlayTrackSFX2	macro
0000E056                            	cmp.l	#sfxaddr,d0	; check if this is valid tracker
0000E056                            	blo.s	.fail\@		; if no, branch
0000E056                            	cmp.l	#musaddr,d0	; check if this is valid tracker
0000E056                            	blo.s	.ok\@		; if is, branch
0000E056                            .fail\@
0000E056                            	if def(RaiseError)	; check if Vladik's debugger is active
0000E056                            		RaiseError "Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>", AMPS_Debug_Console_Main
0000E056                            	else
0000E056                            		bra.w	*
0000E056                            	endif
0000E056                            .ok\@
0000E056                                endm
0000E056                            
0000E056                            AMPS_Debug_TrackUpd	macro
0000E056                            	move.l	a4,d1		; copy to d1
0000E056                            	and.l	#$FFFFFF,d1	; remove high byte
0000E056                            	cmp.l	#sfxaddr,d1	; check if this is valid tracker
0000E056                            	blo.s	.fail2		; if no, branch
0000E056                            	cmp.l	#dacaddr,d1	; check if this is valid tracker
0000E056                            	blo.s	.data		; if is, branch
0000E056                            .fail2
0000E056                            	if def(RaiseError)	; check if Vladik's debugger is active
0000E056                            		RaiseError "Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>", AMPS_Debug_Console_Channel
0000E056                            	else
0000E056                            		bra.w	*
0000E056                            	endif
0000E056                                endm
0000E056                            ; ===========================================================================
0000E056                            ; ---------------------------------------------------------------------------
0000E056                            ; Tracker debugger handler and console code
0000E056                            ; ---------------------------------------------------------------------------
0000E056                            
0000E056                            AMPS_Debug_ChkTracker	macro
0000E056                            .fail
0000E056                            	if def(RaiseError)	; check if Vladik's debugger is active
0000E056                            		jsr	AMPS_DebugR_ChkTracker
0000E056                            	else
0000E056                            		bra.w	*
0000E056                            	endif
0000E056                                endm
0000E056                            
0000E056                            AMPS_DebugR_ChkTracker:
0000E056 4EBA 0000                  		jsr	AMPS_Debug_CalcMax(pc)
0000E05A 4847                       		swap	d7			; swap d7 words
0000E05C                            
0000E05C                            AMPS_DebugR_ChkTracker_loop
0000E05C 23C7 00FF 0000             		move.l	d7,$FF0000		; save stuff in RAM
0000E062                            		Console.Run AMPS_DebugR_ChkTracker2, "NAT"
0000E062 4EB9 0000 0000           M 	jsr	errorhandler.__extern__console_only
0000E068 4EB9 0000 0000           M 	jsr	amps_debugr_chktracker2
0000E06E 2E39 00FF 0000             		move.l	$FF0000,d7		; get stuff back
0000E074                            
0000E074                            AMPS_DebugR_ChkTracker_nodraw
0000E074 7CFF                       		moveq	#-1,d6
0000E076 51CE FFFE                  		dbf	d6,*			; delay a lot
0000E07A                            
0000E07A                            	; implement reading control data
0000E07A 43F9 00A1 0003             		lea	$A10003,a1
0000E080 12BC 0000                  		move.b	#0,(a1)			; set TH low
0000E084 8080                       		or.l	d0,d0			; delay
0000E086 12BC 0040                  		move.b	#$40,(a1)		; set TH high
0000E08A 8080                       		or.l	d0,d0			; delay
0000E08C 1011                       		move.b	(a1),d0			; get dpad stat
0000E08E                            
0000E08E 3A07                       		move.w	d7,d5			; copy to d5
0000E090 0800 0000                  		btst	#0,d0			; check if up held
0000E094 6600                       		bne.s	AMPS_Debug_Writekd			; if not ,branch
0000E096                            
0000E096 5347                       		subq.w	#1,d7			; move up
0000E098 6A00                       		bpl.s	AMPS_Debug_Writekd			; if positive, branch
0000E09A 4247                       		clr.w	d7			; else force to 0
0000E09C                            
0000E09C                            AMPS_Debug_Writekd
0000E09C 0800 0001                  		btst	#1,d0			; check if down held
0000E0A0 6600                       		bne.s	AMPS_Debug_Writekdraw			; if not ,branch
0000E0A2                            
0000E0A2 4847                       		swap	d7
0000E0A4 3C07                       		move.w	d7,d6			; copy high word to d6
0000E0A6 4847                       		swap	d7
0000E0A8                            
0000E0A8 BE46                       		cmp.w	d6,d7			; check if we can move up
0000E0AA 6C00                       		bge.s	AMPS_Debug_Writekdraw			; if not, branch
0000E0AC 5247                       		addq.w	#1,d7			; move down
0000E0AE                            
0000E0AE                            AMPS_Debug_Writekdraw
0000E0AE BA47                       		cmp.w	d7,d5			; check if we need to redraw
0000E0B0 67C2                       		beq.s	AMPS_DebugR_ChkTracker_nodraw; if not, branch
0000E0B2 6000 FFA8                  		bra.w	AMPS_DebugR_ChkTracker_loop
0000E0B6                            
0000E0B6                            AMPS_Debug_CalcMax:
0000E0B6 7C1C                       		moveq	#28,d6	; max lines count
0000E0B8 7E09                       		moveq	#10-1,d7	; run for 10 chs
0000E0BA 7A2C                       		moveq	#cSize,d5	; prepare size
0000E0BC 4BF8 C650                  		lea	mPSG3.w,a5	; start at PSG3
0000E0C0                            
0000E0C0                            AMPS_Debug_Writehkloop
0000E0C0 4A46                       		tst.w	d6		; check if we have no lines left
0000E0C2                            	;	ble.s	.rts		; if so, we found it
0000E0C2 5746                       		subq.w	#3,d6		; we need at least 3 lines
0000E0C4 6B00                       		bmi.s	.add		; if not enough lines, branch
0000E0C6                            
0000E0C6 320D                       		move.w	a5,d1		; copy ch to d1
0000E0C8 0641 002C                  		add.w	#cSize,d1	; go to end of it
0000E0CC                            
0000E0CC 7000                       		moveq	#0,d0
0000E0CE 102D 001E                  		move.b	cStack(a5),d0	; get stack to d0
0000E0D2 4DF5 0000                  		lea	(a5,d0.w),a6	; and get first element to a6
0000E0D6                            
0000E0D6                            .stack
0000E0D6 B24E                       		cmp.w	a6,d1		; check if stack is dry now
0000E0D8 6200                       		bhi.s	.inc		; if not, branch
0000E0DA                            
0000E0DA 9AC5                       		sub.w	d5,a5		; sub ch size
0000E0DC 51CF FFE2                  		dbf	d7,AMPS_Debug_Writehkloop	; loop for all chans
0000E0E0 6000                       		bra.s	.add
0000E0E2                            
0000E0E2                            .inc
0000E0E2 584E                       		addq.w	#4,a6		; go to next long
0000E0E4 5346                       		subq.w	#1,d6		; sub 1 line
0000E0E6 6AEE                       		bpl.s	.stack		; if lines left, branch
0000E0E8                            
0000E0E8                            .add
0000E0E8 5247                       		addq.w	#1,d7		; increase ch by 1
0000E0EA                            .rts
0000E0EA 4E75                       		rts
0000E0EC                            
0000E0EC                            AMPS_DebugR_ChkTracker_Ch:
0000E0EC 5347                       		subq.w	#1,d7		; sub 1 from offset
0000E0EE 6A00 0000                  		bpl.w	AMPS_Debug_Write_n; branch if positive
0000E0F2 4A46                       		tst.w	d6		; check if we need to render anymore
0000E0F4 6B00 0000                  		bmi.w	AMPS_Debug_Write_n; if not, branch
0000E0F8                            
0000E0F8                            ; fmt: <addr> lstdur, dur, freq, sample, loop0, loop1, loop2
0000E0F8 4E90                       		jsr	(a0)
0000E0FA                            	Console.Write	  ": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E0FA 40E7                     M 	move.w	sr,-(sp)
0000E0FC                          M 	__fstring_generateargumentscode	": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E0FC =00000003                M 	__pos:	set instr(": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'%<')
0000E0FC =00000000                M 	__stack:set	0
0000E0FC =00000000                M 	__sp:	set 0
0000E0FC                          M 	while	(__pos)
0000E0FC =0000000A                M 	__endpos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'>')
0000E0FC =0000000F                M 	__midpos:	set instr(__pos+5,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",' ')
0000E0FC =0000000A                M 	__midpos:	= __endpos
0000E0FC                          M 	__substr:	substr __pos+1+1,__endpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E0FC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E0FC =0000000B                M 	__pos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'%<')
0000E0FC =00000012                M 	__endpos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'>')
0000E0FC =00000013                M 	__midpos:	set instr(__pos+5,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",' ')
0000E0FC =00000012                M 	__midpos:	= __endpos
0000E0FC                          M 	__substr:	substr __pos+1+1,__endpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E0FC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E0FC                          M 	__operand:	substr __pos+1+1,__midpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E0FC                          M 	__param:	substr __midpos+1,__endpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E0FC                          M 	pushp	"move.w a5,-(sp)"
0000E0FC =00000001                M 	__stack:	= __stack+1
0000E0FC =00000002                M 	__sp:	= __sp+2
0000E0FC =00000014                M 	__pos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'%<')
0000E0FC =00000025                M 	__endpos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'>')
0000E0FC =00000026                M 	__midpos:	set instr(__pos+5,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",' ')
0000E0FC =00000025                M 	__midpos:	= __endpos
0000E0FC                          M 	__substr:	substr __pos+1+1,__endpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E0FC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E0FC                          M 	__operand:	substr __pos+1+1,__midpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E0FC                          M 	__param:	substr __midpos+1,__endpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E0FC                          M 	pushp	"move.b cLastDur(a5),1(sp)"
0000E0FC                          M 	pushp	"subq.w	#2, sp"
0000E0FC =00000003                M 	__stack:	= __stack+2
0000E0FC =00000004                M 	__sp:	= __sp+2
0000E0FC =00000027                M 	__pos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'%<')
0000E0FC =00000039                M 	__endpos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'>')
0000E0FC =0000003A                M 	__midpos:	set instr(__pos+5,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",' ')
0000E0FC =00000039                M 	__midpos:	= __endpos
0000E0FC                          M 	__substr:	substr __pos+1+1,__endpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E0FC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E0FC                          M 	__operand:	substr __pos+1+1,__midpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E0FC                          M 	__param:	substr __midpos+1,__endpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E0FC                          M 	pushp	"move.b cDuration(a5),1(sp)"
0000E0FC                          M 	pushp	"subq.w	#2, sp"
0000E0FC =00000005                M 	__stack:	= __stack+2
0000E0FC =00000006                M 	__sp:	= __sp+2
0000E0FC =0000003B                M 	__pos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'%<')
0000E0FC =00000049                M 	__endpos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'>')
0000E0FC =00000000                M 	__midpos:	set instr(__pos+5,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",' ')
0000E0FC =00000049                M 	__midpos:	= __endpos
0000E0FC                          M 	__substr:	substr __pos+1+1,__endpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E0FC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E0FC                          M 	__operand:	substr __pos+1+1,__midpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E0FC                          M 	__param:	substr __midpos+1,__endpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E0FC                          M 	pushp	"move.w cFreq(a5),-(sp)"
0000E0FC =00000006                M 	__stack:	= __stack+1
0000E0FC =00000008                M 	__sp:	= __sp+2
0000E0FC =00000000                M 	__pos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'%<')
0000E0FC                          M 	rept	__stack
0000E0FC                          M 	popp	__command
0000E0FC 3F2D 000E                M 	move.w	cfreq(a5),-(sp)
0000E100                          M 	popp	__command
0000E100 554F                     M 	subq.w	#2,sp
0000E102                          M 	popp	__command
0000E102 1F6D 000C 0001           M 	move.b	cduration(a5),1(sp)
0000E108                          M 	popp	__command
0000E108 554F                     M 	subq.w	#2,sp
0000E10A                          M 	popp	__command
0000E10A 1F6D 000D 0001           M 	move.b	clastdur(a5),1(sp)
0000E110                          M 	popp	__command
0000E110 3F0D                     M 	move.w	a5,-(sp)
0000E112 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000E116 45EF 0010                M 	lea	4*4(sp),a2
0000E11A 43FA 0000                M 	lea	.str_485(pc),a1
0000E11E 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000E124 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000E128 504F                     M 	addq.w	#__sp,sp
0000E12A 46DF                     M 	move.w	(sp)+,sr
0000E12C 6000 0000                M 	bra.w	.instr_end_485
0000E130                          M 	.str_485:
0000E130                          M 	__fstring_generatedecodedstring	": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E130 =00000001                M 	__lpos:	set 1
0000E130 =00000003                M 	__pos:	set instr(": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'%<')
0000E130                          M 	while	(__pos)
0000E130                          M 	__substr:	substr __lpos,__pos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E130 3A20                     M 	dc.b	": "
0000E132 =0000000A                M 	__endpos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'>')
0000E132 =0000000F                M 	__midpos:	set instr(__pos+5,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",' ')
0000E132 =0000000A                M 	__midpos:	= __endpos
0000E132                          M 	__type:	substr __pos+1+1,__pos+1+1+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E132                          M 	__substr:	substr __pos+1+1,__endpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E132 EC                       M 	dc.b	fpal2
0000E133 =0000000B                M 	__lpos:	set __endpos+1
0000E133 =0000000B                M 	__pos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'%<')
0000E133                          M 	__substr:	substr __lpos,__pos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E133                          M 	dc.b	""
0000E133 =00000012                M 	__endpos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'>')
0000E133 =00000013                M 	__midpos:	set instr(__pos+5,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",' ')
0000E133 =00000012                M 	__midpos:	= __endpos
0000E133                          M 	__type:	substr __pos+1+1,__pos+1+1+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E133                          M 	__param:	substr __midpos+1,__endpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E133                          M 	__param:	substr ,,"hex"
0000E133 81                       M 	dc.b	hex|1
0000E134 =00000013                M 	__lpos:	set __endpos+1
0000E134 =00000014                M 	__pos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'%<')
0000E134                          M 	__substr:	substr __lpos,__pos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E134 20                       M 	dc.b	" "
0000E135 =00000025                M 	__endpos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'>')
0000E135 =00000026                M 	__midpos:	set instr(__pos+5,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",' ')
0000E135 =00000025                M 	__midpos:	= __endpos
0000E135                          M 	__type:	substr __pos+1+1,__pos+1+1+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E135                          M 	__param:	substr __midpos+1,__endpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E135                          M 	__param:	substr ,,"hex"
0000E135 80                       M 	dc.b	hex
0000E136 =00000026                M 	__lpos:	set __endpos+1
0000E136 =00000027                M 	__pos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'%<')
0000E136                          M 	__substr:	substr __lpos,__pos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E136 20                       M 	dc.b	" "
0000E137 =00000039                M 	__endpos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'>')
0000E137 =0000003A                M 	__midpos:	set instr(__pos+5,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",' ')
0000E137 =00000039                M 	__midpos:	= __endpos
0000E137                          M 	__type:	substr __pos+1+1,__pos+1+1+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E137                          M 	__param:	substr __midpos+1,__endpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E137                          M 	__param:	substr ,,"hex"
0000E137 80                       M 	dc.b	hex
0000E138 =0000003A                M 	__lpos:	set __endpos+1
0000E138 =0000003B                M 	__pos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'%<')
0000E138                          M 	__substr:	substr __lpos,__pos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E138 20                       M 	dc.b	" "
0000E139 =00000049                M 	__endpos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'>')
0000E139 =00000000                M 	__midpos:	set instr(__pos+5,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",' ')
0000E139 =00000049                M 	__midpos:	= __endpos
0000E139                          M 	__type:	substr __pos+1+1,__pos+1+1+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E139                          M 	__param:	substr __midpos+1,__endpos-1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E139                          M 	__param:	substr ,,"hex"
0000E139 81                       M 	dc.b	hex|1
0000E13A =0000004A                M 	__lpos:	set __endpos+1
0000E13A =00000000                M 	__pos:	set instr(__pos+1,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>",'%<')
0000E13A                          M 	__substr:	substr __lpos,,": %<fpal2>%<.w a5> %<.b cLastDur(a5)> %<.b cDuration(a5)> %<.w cFreq(a5)>"
0000E13A                          M 	dc.b	""
0000E13A 00                       M 	dc.b	0
0000E13C 00                       M 	even
0000E13C                          M 	.instr_end_485:
0000E13C                            	Console.WriteLine " %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E13C 40E7                     M 	move.w	sr,-(sp)
0000E13E                          M 	__fstring_generateargumentscode	" %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E13E =00000002                M 	__pos:	set instr(" %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'%<')
0000E13E =00000000                M 	__stack:set	0
0000E13E =00000000                M 	__sp:	set 0
0000E13E                          M 	while	(__pos)
0000E13E =00000012                M 	__endpos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'>')
0000E13E =00000013                M 	__midpos:	set instr(__pos+5," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",' ')
0000E13E =00000012                M 	__midpos:	= __endpos
0000E13E                          M 	__substr:	substr __pos+1+1,__endpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E13E                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E13E                          M 	__operand:	substr __pos+1+1,__midpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E13E                          M 	__param:	substr __midpos+1,__endpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E13E                          M 	pushp	"move.b cSample(a5),1(sp)"
0000E13E                          M 	pushp	"subq.w	#2, sp"
0000E13E =00000002                M 	__stack:	= __stack+2
0000E13E =00000002                M 	__sp:	= __sp+2
0000E13E =00000014                M 	__pos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'%<')
0000E13E =00000022                M 	__endpos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'>')
0000E13E =00000023                M 	__midpos:	set instr(__pos+5," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",' ')
0000E13E =00000022                M 	__midpos:	= __endpos
0000E13E                          M 	__substr:	substr __pos+1+1,__endpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E13E                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E13E                          M 	__operand:	substr __pos+1+1,__midpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E13E                          M 	__param:	substr __midpos+1,__endpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E13E                          M 	pushp	"move.b cLoop(a5),1(sp)"
0000E13E                          M 	pushp	"subq.w	#2, sp"
0000E13E =00000004                M 	__stack:	= __stack+2
0000E13E =00000004                M 	__sp:	= __sp+2
0000E13E =00000024                M 	__pos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'%<')
0000E13E =00000034                M 	__endpos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'>')
0000E13E =00000035                M 	__midpos:	set instr(__pos+5," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",' ')
0000E13E =00000034                M 	__midpos:	= __endpos
0000E13E                          M 	__substr:	substr __pos+1+1,__endpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E13E                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E13E                          M 	__operand:	substr __pos+1+1,__midpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E13E                          M 	__param:	substr __midpos+1,__endpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E13E                          M 	pushp	"move.b cLoop+1(a5),1(sp)"
0000E13E                          M 	pushp	"subq.w	#2, sp"
0000E13E =00000006                M 	__stack:	= __stack+2
0000E13E =00000006                M 	__sp:	= __sp+2
0000E13E =00000036                M 	__pos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'%<')
0000E13E =00000046                M 	__endpos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'>')
0000E13E =00000000                M 	__midpos:	set instr(__pos+5," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",' ')
0000E13E =00000046                M 	__midpos:	= __endpos
0000E13E                          M 	__substr:	substr __pos+1+1,__endpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E13E                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E13E                          M 	__operand:	substr __pos+1+1,__midpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E13E                          M 	__param:	substr __midpos+1,__endpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E13E                          M 	pushp	"move.b cLoop+2(a5),1(sp)"
0000E13E                          M 	pushp	"subq.w	#2, sp"
0000E13E =00000008                M 	__stack:	= __stack+2
0000E13E =00000008                M 	__sp:	= __sp+2
0000E13E =00000000                M 	__pos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'%<')
0000E13E                          M 	rept	__stack
0000E13E                          M 	popp	__command
0000E13E 554F                     M 	subq.w	#2,sp
0000E140                          M 	popp	__command
0000E140 1F6D 001B 0001           M 	move.b	cloop+2(a5),1(sp)
0000E146                          M 	popp	__command
0000E146 554F                     M 	subq.w	#2,sp
0000E148                          M 	popp	__command
0000E148 1F6D 001A 0001           M 	move.b	cloop+1(a5),1(sp)
0000E14E                          M 	popp	__command
0000E14E 554F                     M 	subq.w	#2,sp
0000E150                          M 	popp	__command
0000E150 1F6D 0019 0001           M 	move.b	cloop(a5),1(sp)
0000E156                          M 	popp	__command
0000E156 554F                     M 	subq.w	#2,sp
0000E158                          M 	popp	__command
0000E158 1F6D 000B 0001           M 	move.b	csample(a5),1(sp)
0000E15E 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000E162 45EF 0010                M 	lea	4*4(sp),a2
0000E166 43FA 0000                M 	lea	.str_488(pc),a1
0000E16A 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000E170 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000E174 504F                     M 	addq.w	#__sp,sp
0000E176 46DF                     M 	move.w	(sp)+,sr
0000E178 6000 0000                M 	bra.w	.instr_end_488
0000E17C                          M 	.str_488:
0000E17C                          M 	__fstring_generatedecodedstring	" %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E17C =00000001                M 	__lpos:	set 1
0000E17C =00000002                M 	__pos:	set instr(" %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'%<')
0000E17C                          M 	while	(__pos)
0000E17C                          M 	__substr:	substr __lpos,__pos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E17C 20                       M 	dc.b	" "
0000E17D =00000012                M 	__endpos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'>')
0000E17D =00000013                M 	__midpos:	set instr(__pos+5," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",' ')
0000E17D =00000012                M 	__midpos:	= __endpos
0000E17D                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E17D                          M 	__param:	substr __midpos+1,__endpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E17D                          M 	__param:	substr ,,"hex"
0000E17D 80                       M 	dc.b	hex
0000E17E =00000013                M 	__lpos:	set __endpos+1
0000E17E =00000014                M 	__pos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'%<')
0000E17E                          M 	__substr:	substr __lpos,__pos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E17E 20                       M 	dc.b	" "
0000E17F =00000022                M 	__endpos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'>')
0000E17F =00000023                M 	__midpos:	set instr(__pos+5," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",' ')
0000E17F =00000022                M 	__midpos:	= __endpos
0000E17F                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E17F                          M 	__param:	substr __midpos+1,__endpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E17F                          M 	__param:	substr ,,"hex"
0000E17F 80                       M 	dc.b	hex
0000E180 =00000023                M 	__lpos:	set __endpos+1
0000E180 =00000024                M 	__pos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'%<')
0000E180                          M 	__substr:	substr __lpos,__pos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E180 20                       M 	dc.b	" "
0000E181 =00000034                M 	__endpos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'>')
0000E181 =00000035                M 	__midpos:	set instr(__pos+5," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",' ')
0000E181 =00000034                M 	__midpos:	= __endpos
0000E181                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E181                          M 	__param:	substr __midpos+1,__endpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E181                          M 	__param:	substr ,,"hex"
0000E181 80                       M 	dc.b	hex
0000E182 =00000035                M 	__lpos:	set __endpos+1
0000E182 =00000036                M 	__pos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'%<')
0000E182                          M 	__substr:	substr __lpos,__pos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E182 20                       M 	dc.b	" "
0000E183 =00000046                M 	__endpos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'>')
0000E183 =00000000                M 	__midpos:	set instr(__pos+5," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",' ')
0000E183 =00000046                M 	__midpos:	= __endpos
0000E183                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E183                          M 	__param:	substr __midpos+1,__endpos-1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E183                          M 	__param:	substr ,,"hex"
0000E183 80                       M 	dc.b	hex
0000E184 =00000047                M 	__lpos:	set __endpos+1
0000E184 =00000000                M 	__pos:	set instr(__pos+1," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>",'%<')
0000E184                          M 	__substr:	substr __lpos,," %<.b cSample(a5)> %<.b cLoop(a5)> %<.b cLoop+1(a5)> %<.b cLoop+2(a5)>"
0000E184                          M 	dc.b	""
0000E184 00                       M 	dc.b	0
0000E186 00                       M 	even
0000E186                          M 	.instr_end_488:
0000E186                            	Console.WriteLine " %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E186 40E7                     M 	move.w	sr,-(sp)
0000E188                          M 	__fstring_generateargumentscode	" %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E188 =00000002                M 	__pos:	set instr(" %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E188 =00000000                M 	__stack:set	0
0000E188 =00000000                M 	__sp:	set 0
0000E188                          M 	while	(__pos)
0000E188 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E188 =0000000F                M 	__midpos:	set instr(__pos+5," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E188 =00000009                M 	__midpos:	= __endpos
0000E188                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E188                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E188 =00000010                M 	__pos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E188 =00000017                M 	__endpos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E188 =0000001C                M 	__midpos:	set instr(__pos+5," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E188 =00000017                M 	__midpos:	= __endpos
0000E188                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E188                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E188 =00000018                M 	__pos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E188 =00000031                M 	__endpos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E188 =00000026                M 	__midpos:	set instr(__pos+5," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E188                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E188                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E188                          M 	__operand:	substr __pos+1+1,__midpos-1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E188                          M 	__param:	substr __midpos+1,__endpos-1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E188                          M 	pushp	"move.l cData(a5),-(sp)"
0000E188 =00000001                M 	__stack:	= __stack+1
0000E188 =00000004                M 	__sp:	= __sp+4
0000E188 =00000032                M 	__pos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E188 =00000042                M 	__endpos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E188 =00000000                M 	__midpos:	set instr(__pos+5," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E188 =00000042                M 	__midpos:	= __endpos
0000E188                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E188                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E188 =00000000                M 	__pos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E188                          M 	rept	__stack
0000E188                          M 	popp	__command
0000E188 2F2D 0002                M 	move.l	cdata(a5),-(sp)
0000E18C 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000E190 45EF 0010                M 	lea	4*4(sp),a2
0000E194 43FA 0000                M 	lea	.str_491(pc),a1
0000E198 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000E19E 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000E1A2 584F                     M 	addq.w	#__sp,sp
0000E1A4 46DF                     M 	move.w	(sp)+,sr
0000E1A6 6000 0000                M 	bra.w	.instr_end_491
0000E1AA                          M 	.str_491:
0000E1AA                          M 	__fstring_generatedecodedstring	" %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E1AA =00000001                M 	__lpos:	set 1
0000E1AA =00000002                M 	__pos:	set instr(" %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E1AA                          M 	while	(__pos)
0000E1AA                          M 	__substr:	substr __lpos,__pos-1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E1AA 20                       M 	dc.b	" "
0000E1AB =00000009                M 	__endpos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E1AB =0000000F                M 	__midpos:	set instr(__pos+5," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E1AB =00000009                M 	__midpos:	= __endpos
0000E1AB                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E1AB                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E1AB EA                       M 	dc.b	fpal1
0000E1AC =0000000A                M 	__lpos:	set __endpos+1
0000E1AC =00000010                M 	__pos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E1AC                          M 	__substr:	substr __lpos,__pos-1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E1AC 4164 6472 3A20           M 	dc.b	"Addr: "
0000E1B2 =00000017                M 	__endpos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E1B2 =0000001C                M 	__midpos:	set instr(__pos+5," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E1B2 =00000017                M 	__midpos:	= __endpos
0000E1B2                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E1B2                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E1B2 E8                       M 	dc.b	fpal0
0000E1B3 =00000018                M 	__lpos:	set __endpos+1
0000E1B3 =00000018                M 	__pos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E1B3                          M 	__substr:	substr __lpos,__pos-1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E1B3                          M 	dc.b	""
0000E1B3 =00000031                M 	__endpos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E1B3 =00000026                M 	__midpos:	set instr(__pos+5," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E1B3                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E1B3                          M 	__param:	substr __midpos+1,__endpos-1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E1B3 BB                       M 	dc.b	sym|fsplit|3
0000E1B4 =00000032                M 	__lpos:	set __endpos+1
0000E1B4 =00000032                M 	__pos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E1B4                          M 	__substr:	substr __lpos,__pos-1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E1B4                          M 	dc.b	""
0000E1B4 =00000042                M 	__endpos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E1B4 =00000000                M 	__midpos:	set instr(__pos+5," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E1B4 =00000042                M 	__midpos:	= __endpos
0000E1B4                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E1B4                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E1B4 ECC0                     M 	dc.b	fpal2,fsymdisp
0000E1B6 =00000043                M 	__lpos:	set __endpos+1
0000E1B6 =00000000                M 	__pos:	set instr(__pos+1," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E1B6                          M 	__substr:	substr __lpos,," %<fpal1>Addr: %<fpal0>%<.l cData(a5) sym|fsplit>%<fpal2,fsymdisp>"
0000E1B6                          M 	dc.b	""
0000E1B6 00                       M 	dc.b	0
0000E1B8 00                       M 	even
0000E1B8                          M 	.instr_end_491:
0000E1B8                            
0000E1B8 5546                       		subq.w	#2,d6		; sub those 2 lines from stuff
0000E1BA 6B00 0000                  		bmi.w	AMPS_Debug_Write_n; if drawn all, branch
0000E1BE 320D                       		move.w	a5,d1		; copy ch to d1
0000E1C0 D245                       		add.w	d5,d1		; go to end of it
0000E1C2                            
0000E1C2 7000                       		moveq	#0,d0
0000E1C4 102D 001E                  		move.b	cStack(a5),d0	; get stack to d0
0000E1C8 4DF5 0000                  		lea	(a5,d0.w),a6	; and get first element to a6
0000E1CC                            
0000E1CC B24E                       		cmp.w	a6,d1		; check if stack is dry
0000E1CE 6300                       		bls.s	AMPS_Debug_Write		; if is, branch
0000E1D0                            	Console.WriteLine " %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E1D0 40E7                     M 	move.w	sr,-(sp)
0000E1D2                          M 	__fstring_generateargumentscode	" %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E1D2 =00000002                M 	__pos:	set instr(" %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E1D2 =00000000                M 	__stack:set	0
0000E1D2 =00000000                M 	__sp:	set 0
0000E1D2                          M 	while	(__pos)
0000E1D2 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E1D2 =0000001C                M 	__midpos:	set instr(__pos+5," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E1D2 =00000009                M 	__midpos:	= __endpos
0000E1D2                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E1D2                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E1D2 =00000010                M 	__pos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E1D2 =00000017                M 	__endpos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E1D2 =0000001C                M 	__midpos:	set instr(__pos+5," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E1D2 =00000017                M 	__midpos:	= __endpos
0000E1D2                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E1D2                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E1D2 =00000018                M 	__pos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E1D2 =0000002D                M 	__endpos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E1D2 =00000022                M 	__midpos:	set instr(__pos+5," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E1D2                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E1D2                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E1D2                          M 	__operand:	substr __pos+1+1,__midpos-1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E1D2                          M 	__param:	substr __midpos+1,__endpos-1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E1D2                          M 	pushp	"move.l (a6)+,-(sp)"
0000E1D2 =00000001                M 	__stack:	= __stack+1
0000E1D2 =00000004                M 	__sp:	= __sp+4
0000E1D2 =0000002E                M 	__pos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E1D2 =0000003E                M 	__endpos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E1D2 =00000000                M 	__midpos:	set instr(__pos+5," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E1D2 =0000003E                M 	__midpos:	= __endpos
0000E1D2                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E1D2                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E1D2 =00000000                M 	__pos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E1D2                          M 	rept	__stack
0000E1D2                          M 	popp	__command
0000E1D2 2F1E                     M 	move.l	(a6)+,-(sp)
0000E1D4 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000E1D8 45EF 0010                M 	lea	4*4(sp),a2
0000E1DC 43FA 0000                M 	lea	.str_494(pc),a1
0000E1E0 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000E1E6 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000E1EA 584F                     M 	addq.w	#__sp,sp
0000E1EC 46DF                     M 	move.w	(sp)+,sr
0000E1EE 6000 0000                M 	bra.w	.instr_end_494
0000E1F2                          M 	.str_494:
0000E1F2                          M 	__fstring_generatedecodedstring	" %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E1F2 =00000001                M 	__lpos:	set 1
0000E1F2 =00000002                M 	__pos:	set instr(" %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E1F2                          M 	while	(__pos)
0000E1F2                          M 	__substr:	substr __lpos,__pos-1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E1F2 20                       M 	dc.b	" "
0000E1F3 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E1F3 =0000001C                M 	__midpos:	set instr(__pos+5," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E1F3 =00000009                M 	__midpos:	= __endpos
0000E1F3                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E1F3                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E1F3 EA                       M 	dc.b	fpal1
0000E1F4 =0000000A                M 	__lpos:	set __endpos+1
0000E1F4 =00000010                M 	__pos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E1F4                          M 	__substr:	substr __lpos,__pos-1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E1F4 5374 6163 6B3A           M 	dc.b	"Stack:"
0000E1FA =00000017                M 	__endpos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E1FA =0000001C                M 	__midpos:	set instr(__pos+5," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E1FA =00000017                M 	__midpos:	= __endpos
0000E1FA                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E1FA                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E1FA E8                       M 	dc.b	fpal0
0000E1FB =00000018                M 	__lpos:	set __endpos+1
0000E1FB =00000018                M 	__pos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E1FB                          M 	__substr:	substr __lpos,__pos-1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E1FB                          M 	dc.b	""
0000E1FB =0000002D                M 	__endpos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E1FB =00000022                M 	__midpos:	set instr(__pos+5," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E1FB                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E1FB                          M 	__param:	substr __midpos+1,__endpos-1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E1FB BB                       M 	dc.b	sym|fsplit|3
0000E1FC =0000002E                M 	__lpos:	set __endpos+1
0000E1FC =0000002E                M 	__pos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E1FC                          M 	__substr:	substr __lpos,__pos-1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E1FC                          M 	dc.b	""
0000E1FC =0000003E                M 	__endpos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E1FC =00000000                M 	__midpos:	set instr(__pos+5," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E1FC =0000003E                M 	__midpos:	= __endpos
0000E1FC                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E1FC                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E1FC ECC0                     M 	dc.b	fpal2,fsymdisp
0000E1FE =0000003F                M 	__lpos:	set __endpos+1
0000E1FE =00000000                M 	__pos:	set instr(__pos+1," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E1FE                          M 	__substr:	substr __lpos,," %<fpal1>Stack:%<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E1FE                          M 	dc.b	""
0000E1FE 00                       M 	dc.b	0
0000E200 00                       M 	even
0000E200                          M 	.instr_end_494:
0000E200 5346                       		subq.w	#1,d6		; sub a line
0000E202 6B00                       		bmi.s	AMPS_Debug_Write_n; if drawn all, branch
0000E204                            
0000E204                            AMPS_DebugR_ChkTracker_Ch_loop
0000E204 B24E                       		cmp.w	a6,d1		; check if we printed full stack
0000E206 6300                       		bls.s	AMPS_Debug_Write		; if not though, branch
0000E208                            	Console.WriteLine "   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E208 40E7                     M 	move.w	sr,-(sp)
0000E20A                          M 	__fstring_generateargumentscode	"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E20A =00000004                M 	__pos:	set instr("   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E20A =00000000                M 	__stack:set	0
0000E20A =00000000                M 	__sp:	set 0
0000E20A                          M 	while	(__pos)
0000E20A =0000000B                M 	__endpos:	set instr(__pos+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E20A =00000010                M 	__midpos:	set instr(__pos+5,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E20A =0000000B                M 	__midpos:	= __endpos
0000E20A                          M 	__substr:	substr __pos+1+1,__endpos-1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E20A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E20A =0000000C                M 	__pos:	set instr(__pos+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E20A =00000021                M 	__endpos:	set instr(__pos+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E20A =00000016                M 	__midpos:	set instr(__pos+5,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E20A                          M 	__substr:	substr __pos+1+1,__endpos-1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E20A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E20A                          M 	__operand:	substr __pos+1+1,__midpos-1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E20A                          M 	__param:	substr __midpos+1,__endpos-1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E20A                          M 	pushp	"move.l (a6)+,-(sp)"
0000E20A =00000001                M 	__stack:	= __stack+1
0000E20A =00000004                M 	__sp:	= __sp+4
0000E20A =00000022                M 	__pos:	set instr(__pos+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E20A =00000032                M 	__endpos:	set instr(__pos+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E20A =00000000                M 	__midpos:	set instr(__pos+5,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E20A =00000032                M 	__midpos:	= __endpos
0000E20A                          M 	__substr:	substr __pos+1+1,__endpos-1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E20A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E20A =00000000                M 	__pos:	set instr(__pos+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E20A                          M 	rept	__stack
0000E20A                          M 	popp	__command
0000E20A 2F1E                     M 	move.l	(a6)+,-(sp)
0000E20C 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000E210 45EF 0010                M 	lea	4*4(sp),a2
0000E214 43FA 0000                M 	lea	.str_497(pc),a1
0000E218 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_writeline_formatted
0000E21E 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000E222 584F                     M 	addq.w	#__sp,sp
0000E224 46DF                     M 	move.w	(sp)+,sr
0000E226 6000 0000                M 	bra.w	.instr_end_497
0000E22A                          M 	.str_497:
0000E22A                          M 	__fstring_generatedecodedstring	"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E22A =00000001                M 	__lpos:	set 1
0000E22A =00000004                M 	__pos:	set instr("   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E22A                          M 	while	(__pos)
0000E22A                          M 	__substr:	substr __lpos,__pos-1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E22A 2020 20                  M 	dc.b	"   "
0000E22D =0000000B                M 	__endpos:	set instr(__pos+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E22D =00000010                M 	__midpos:	set instr(__pos+5,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E22D =0000000B                M 	__midpos:	= __endpos
0000E22D                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E22D                          M 	__substr:	substr __pos+1+1,__endpos-1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E22D E8                       M 	dc.b	fpal0
0000E22E =0000000C                M 	__lpos:	set __endpos+1
0000E22E =0000000C                M 	__pos:	set instr(__pos+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E22E                          M 	__substr:	substr __lpos,__pos-1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E22E                          M 	dc.b	""
0000E22E =00000021                M 	__endpos:	set instr(__pos+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E22E =00000016                M 	__midpos:	set instr(__pos+5,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E22E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E22E                          M 	__param:	substr __midpos+1,__endpos-1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E22E BB                       M 	dc.b	sym|fsplit|3
0000E22F =00000022                M 	__lpos:	set __endpos+1
0000E22F =00000022                M 	__pos:	set instr(__pos+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E22F                          M 	__substr:	substr __lpos,__pos-1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E22F                          M 	dc.b	""
0000E22F =00000032                M 	__endpos:	set instr(__pos+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'>')
0000E22F =00000000                M 	__midpos:	set instr(__pos+5,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",' ')
0000E22F =00000032                M 	__midpos:	= __endpos
0000E22F                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E22F                          M 	__substr:	substr __pos+1+1,__endpos-1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E22F ECC0                     M 	dc.b	fpal2,fsymdisp
0000E231 =00000033                M 	__lpos:	set __endpos+1
0000E231 =00000000                M 	__pos:	set instr(__pos+1,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>",'%<')
0000E231                          M 	__substr:	substr __lpos,,"   %<fpal0>%<.l (a6)+ sym|fsplit>%<fpal2,fsymdisp>"
0000E231                          M 	dc.b	""
0000E231 00                       M 	dc.b	0
0000E232                          M 	even
0000E232                          M 	.instr_end_497:
0000E232 5346                       		subq.w	#1,d6		; sub a line
0000E234 6ACE                       		bpl.s	AMPS_DebugR_ChkTracker_Ch_loop; if we havent drawn all, branch
0000E236                            
0000E236                            AMPS_Debug_Write
0000E236                            	Console.BreakLine
0000E236 40E7                     M 	move.w	sr,-(sp)
0000E238 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_startnewline
0000E23E 46DF                     M 	move.w	(sp)+,sr
0000E240 5346                       		subq.w	#1,d6		; sub a line
0000E242                            AMPS_Debug_Write_n
0000E242 DAC5                       		add.w	d5,a5		; go to next ch
0000E244 4E75                       		rts
0000E246                            
0000E246                            AMPS_DebugR_ChkTracker2:
0000E246 7C27                       		moveq	#40-1,d6
0000E248 7A2C                       		moveq	#cSize,d5
0000E24A 4BF8 C4C4                  		lea	mDAC1.w,a5
0000E24E                            
0000E24E                            
0000E24E 41FA 0000                  		lea	AMPS_DebugR_ChkTracker2_dac1(pc),a0
0000E252 4EBA FE98                  		jsr	AMPS_DebugR_ChkTracker_Ch(pc)
0000E256 41FA 0000                  		lea	AMPS_DebugR_ChkTracker2_dac2(pc),a0
0000E25A 4EBA FE90                  		jsr	AMPS_DebugR_ChkTracker_Ch(pc)
0000E25E                            
0000E25E 41FA 0000                  		lea	AMPS_DebugR_ChkTracker2_fm1(pc),a0
0000E262 4EBA FE88                  		jsr	AMPS_DebugR_ChkTracker_Ch(pc)
0000E266 41FA 0000                  		lea	AMPS_DebugR_ChkTracker2_fm2(pc),a0
0000E26A 4EBA FE80                  		jsr	AMPS_DebugR_ChkTracker_Ch(pc)
0000E26E 41FA 0000                  		lea	AMPS_DebugR_ChkTracker2_fm3(pc),a0
0000E272 4EBA FE78                  		jsr	AMPS_DebugR_ChkTracker_Ch(pc)
0000E276 41FA 0000                  		lea	AMPS_DebugR_ChkTracker2_fm4(pc),a0
0000E27A 4EBA FE70                  		jsr	AMPS_DebugR_ChkTracker_Ch(pc)
0000E27E 41FA 0000                  		lea	AMPS_DebugR_ChkTracker2_fm5(pc),a0
0000E282 4EBA FE68                  		jsr	AMPS_DebugR_ChkTracker_Ch(pc)
0000E286                            
0000E286 41FA 0000                  		lea	AMPS_DebugR_ChkTracker2_psg1(pc),a0
0000E28A 4EBA FE60                  		jsr	AMPS_DebugR_ChkTracker_Ch(pc)
0000E28E 41FA 0000                  		lea	AMPS_DebugR_ChkTracker2_psg2(pc),a0
0000E292 4EBA FE58                  		jsr	AMPS_DebugR_ChkTracker_Ch(pc)
0000E296 41FA 0000                  		lea	AMPS_DebugR_ChkTracker2_psg3(pc),a0
0000E29A 4EFA FE50                  		jmp	AMPS_DebugR_ChkTracker_Ch(pc)
0000E29E                            
0000E29E                            AMPS_DebugR_ChkTracker2_dac1
0000E29E                            	Console.Write " %<fpal0>DAC1"
0000E29E 40E7                     M 	move.w	sr,-(sp)
0000E2A0                          M 	__fstring_generateargumentscode	" %<fpal0>DAC1"
0000E2A0 =00000002                M 	__pos:	set instr(" %<fpal0>DAC1",'%<')
0000E2A0 =00000000                M 	__stack:set	0
0000E2A0 =00000000                M 	__sp:	set 0
0000E2A0                          M 	while	(__pos)
0000E2A0 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0>DAC1",'>')
0000E2A0 =00000000                M 	__midpos:	set instr(__pos+5," %<fpal0>DAC1",' ')
0000E2A0 =00000009                M 	__midpos:	= __endpos
0000E2A0                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0>DAC1"
0000E2A0                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0>DAC1"
0000E2A0 =00000000                M 	__pos:	set instr(__pos+1," %<fpal0>DAC1",'%<')
0000E2A0                          M 	rept	__stack
0000E2A0 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000E2A4 43FA 0000                M 	lea	.str_501(pc),a1
0000E2A8 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000E2AE 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000E2B2 46DF                     M 	move.w	(sp)+,sr
0000E2B4 6000 0000                M 	bra.w	.instr_end_501
0000E2B8                          M 	.str_501:
0000E2B8                          M 	__fstring_generatedecodedstring	" %<fpal0>DAC1"
0000E2B8 =00000001                M 	__lpos:	set 1
0000E2B8 =00000002                M 	__pos:	set instr(" %<fpal0>DAC1",'%<')
0000E2B8                          M 	while	(__pos)
0000E2B8                          M 	__substr:	substr __lpos,__pos-1," %<fpal0>DAC1"
0000E2B8 20                       M 	dc.b	" "
0000E2B9 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0>DAC1",'>')
0000E2B9 =00000000                M 	__midpos:	set instr(__pos+5," %<fpal0>DAC1",' ')
0000E2B9 =00000009                M 	__midpos:	= __endpos
0000E2B9                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0>DAC1"
0000E2B9                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0>DAC1"
0000E2B9 E8                       M 	dc.b	fpal0
0000E2BA =0000000A                M 	__lpos:	set __endpos+1
0000E2BA =00000000                M 	__pos:	set instr(__pos+1," %<fpal0>DAC1",'%<')
0000E2BA                          M 	__substr:	substr __lpos,," %<fpal0>DAC1"
0000E2BA 4441 4331                M 	dc.b	"DAC1"
0000E2BE 00                       M 	dc.b	0
0000E2C0 00                       M 	even
0000E2C0                          M 	.instr_end_501:
0000E2C0 4E75                       		rts
0000E2C2                            
0000E2C2                            AMPS_DebugR_ChkTracker2_dac2
0000E2C2                            	Console.Write " %<fpal0>DAC2"
0000E2C2 40E7                     M 	move.w	sr,-(sp)
0000E2C4                          M 	__fstring_generateargumentscode	" %<fpal0>DAC2"
0000E2C4 =00000002                M 	__pos:	set instr(" %<fpal0>DAC2",'%<')
0000E2C4 =00000000                M 	__stack:set	0
0000E2C4 =00000000                M 	__sp:	set 0
0000E2C4                          M 	while	(__pos)
0000E2C4 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0>DAC2",'>')
0000E2C4 =00000000                M 	__midpos:	set instr(__pos+5," %<fpal0>DAC2",' ')
0000E2C4 =00000009                M 	__midpos:	= __endpos
0000E2C4                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0>DAC2"
0000E2C4                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0>DAC2"
0000E2C4 =00000000                M 	__pos:	set instr(__pos+1," %<fpal0>DAC2",'%<')
0000E2C4                          M 	rept	__stack
0000E2C4 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000E2C8 43FA 0000                M 	lea	.str_504(pc),a1
0000E2CC 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000E2D2 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000E2D6 46DF                     M 	move.w	(sp)+,sr
0000E2D8 6000 0000                M 	bra.w	.instr_end_504
0000E2DC                          M 	.str_504:
0000E2DC                          M 	__fstring_generatedecodedstring	" %<fpal0>DAC2"
0000E2DC =00000001                M 	__lpos:	set 1
0000E2DC =00000002                M 	__pos:	set instr(" %<fpal0>DAC2",'%<')
0000E2DC                          M 	while	(__pos)
0000E2DC                          M 	__substr:	substr __lpos,__pos-1," %<fpal0>DAC2"
0000E2DC 20                       M 	dc.b	" "
0000E2DD =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0>DAC2",'>')
0000E2DD =00000000                M 	__midpos:	set instr(__pos+5," %<fpal0>DAC2",' ')
0000E2DD =00000009                M 	__midpos:	= __endpos
0000E2DD                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0>DAC2"
0000E2DD                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0>DAC2"
0000E2DD E8                       M 	dc.b	fpal0
0000E2DE =0000000A                M 	__lpos:	set __endpos+1
0000E2DE =00000000                M 	__pos:	set instr(__pos+1," %<fpal0>DAC2",'%<')
0000E2DE                          M 	__substr:	substr __lpos,," %<fpal0>DAC2"
0000E2DE 4441 4332                M 	dc.b	"DAC2"
0000E2E2 00                       M 	dc.b	0
0000E2E4 00                       M 	even
0000E2E4                          M 	.instr_end_504:
0000E2E4 4E75                       		rts
0000E2E6                            
0000E2E6                            AMPS_DebugR_ChkTracker2_fm1
0000E2E6                            	Console.Write " %<fpal0> FM1"
0000E2E6 40E7                     M 	move.w	sr,-(sp)
0000E2E8                          M 	__fstring_generateargumentscode	" %<fpal0> FM1"
0000E2E8 =00000002                M 	__pos:	set instr(" %<fpal0> FM1",'%<')
0000E2E8 =00000000                M 	__stack:set	0
0000E2E8 =00000000                M 	__sp:	set 0
0000E2E8                          M 	while	(__pos)
0000E2E8 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0> FM1",'>')
0000E2E8 =0000000A                M 	__midpos:	set instr(__pos+5," %<fpal0> FM1",' ')
0000E2E8 =00000009                M 	__midpos:	= __endpos
0000E2E8                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0> FM1"
0000E2E8                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0> FM1"
0000E2E8 =00000000                M 	__pos:	set instr(__pos+1," %<fpal0> FM1",'%<')
0000E2E8                          M 	rept	__stack
0000E2E8 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000E2EC 43FA 0000                M 	lea	.str_507(pc),a1
0000E2F0 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000E2F6 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000E2FA 46DF                     M 	move.w	(sp)+,sr
0000E2FC 6000 0000                M 	bra.w	.instr_end_507
0000E300                          M 	.str_507:
0000E300                          M 	__fstring_generatedecodedstring	" %<fpal0> FM1"
0000E300 =00000001                M 	__lpos:	set 1
0000E300 =00000002                M 	__pos:	set instr(" %<fpal0> FM1",'%<')
0000E300                          M 	while	(__pos)
0000E300                          M 	__substr:	substr __lpos,__pos-1," %<fpal0> FM1"
0000E300 20                       M 	dc.b	" "
0000E301 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0> FM1",'>')
0000E301 =0000000A                M 	__midpos:	set instr(__pos+5," %<fpal0> FM1",' ')
0000E301 =00000009                M 	__midpos:	= __endpos
0000E301                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0> FM1"
0000E301                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0> FM1"
0000E301 E8                       M 	dc.b	fpal0
0000E302 =0000000A                M 	__lpos:	set __endpos+1
0000E302 =00000000                M 	__pos:	set instr(__pos+1," %<fpal0> FM1",'%<')
0000E302                          M 	__substr:	substr __lpos,," %<fpal0> FM1"
0000E302 2046 4D31                M 	dc.b	" FM1"
0000E306 00                       M 	dc.b	0
0000E308 00                       M 	even
0000E308                          M 	.instr_end_507:
0000E308 4E75                       		rts
0000E30A                            
0000E30A                            AMPS_DebugR_ChkTracker2_fm2
0000E30A                            	Console.Write " %<fpal0> FM2"
0000E30A 40E7                     M 	move.w	sr,-(sp)
0000E30C                          M 	__fstring_generateargumentscode	" %<fpal0> FM2"
0000E30C =00000002                M 	__pos:	set instr(" %<fpal0> FM2",'%<')
0000E30C =00000000                M 	__stack:set	0
0000E30C =00000000                M 	__sp:	set 0
0000E30C                          M 	while	(__pos)
0000E30C =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0> FM2",'>')
0000E30C =0000000A                M 	__midpos:	set instr(__pos+5," %<fpal0> FM2",' ')
0000E30C =00000009                M 	__midpos:	= __endpos
0000E30C                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0> FM2"
0000E30C                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0> FM2"
0000E30C =00000000                M 	__pos:	set instr(__pos+1," %<fpal0> FM2",'%<')
0000E30C                          M 	rept	__stack
0000E30C 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000E310 43FA 0000                M 	lea	.str_510(pc),a1
0000E314 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000E31A 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000E31E 46DF                     M 	move.w	(sp)+,sr
0000E320 6000 0000                M 	bra.w	.instr_end_510
0000E324                          M 	.str_510:
0000E324                          M 	__fstring_generatedecodedstring	" %<fpal0> FM2"
0000E324 =00000001                M 	__lpos:	set 1
0000E324 =00000002                M 	__pos:	set instr(" %<fpal0> FM2",'%<')
0000E324                          M 	while	(__pos)
0000E324                          M 	__substr:	substr __lpos,__pos-1," %<fpal0> FM2"
0000E324 20                       M 	dc.b	" "
0000E325 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0> FM2",'>')
0000E325 =0000000A                M 	__midpos:	set instr(__pos+5," %<fpal0> FM2",' ')
0000E325 =00000009                M 	__midpos:	= __endpos
0000E325                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0> FM2"
0000E325                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0> FM2"
0000E325 E8                       M 	dc.b	fpal0
0000E326 =0000000A                M 	__lpos:	set __endpos+1
0000E326 =00000000                M 	__pos:	set instr(__pos+1," %<fpal0> FM2",'%<')
0000E326                          M 	__substr:	substr __lpos,," %<fpal0> FM2"
0000E326 2046 4D32                M 	dc.b	" FM2"
0000E32A 00                       M 	dc.b	0
0000E32C 00                       M 	even
0000E32C                          M 	.instr_end_510:
0000E32C 4E75                       		rts
0000E32E                            
0000E32E                            AMPS_DebugR_ChkTracker2_fm3
0000E32E                            	Console.Write " %<fpal0> FM3"
0000E32E 40E7                     M 	move.w	sr,-(sp)
0000E330                          M 	__fstring_generateargumentscode	" %<fpal0> FM3"
0000E330 =00000002                M 	__pos:	set instr(" %<fpal0> FM3",'%<')
0000E330 =00000000                M 	__stack:set	0
0000E330 =00000000                M 	__sp:	set 0
0000E330                          M 	while	(__pos)
0000E330 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0> FM3",'>')
0000E330 =0000000A                M 	__midpos:	set instr(__pos+5," %<fpal0> FM3",' ')
0000E330 =00000009                M 	__midpos:	= __endpos
0000E330                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0> FM3"
0000E330                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0> FM3"
0000E330 =00000000                M 	__pos:	set instr(__pos+1," %<fpal0> FM3",'%<')
0000E330                          M 	rept	__stack
0000E330 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000E334 43FA 0000                M 	lea	.str_513(pc),a1
0000E338 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000E33E 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000E342 46DF                     M 	move.w	(sp)+,sr
0000E344 6000 0000                M 	bra.w	.instr_end_513
0000E348                          M 	.str_513:
0000E348                          M 	__fstring_generatedecodedstring	" %<fpal0> FM3"
0000E348 =00000001                M 	__lpos:	set 1
0000E348 =00000002                M 	__pos:	set instr(" %<fpal0> FM3",'%<')
0000E348                          M 	while	(__pos)
0000E348                          M 	__substr:	substr __lpos,__pos-1," %<fpal0> FM3"
0000E348 20                       M 	dc.b	" "
0000E349 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0> FM3",'>')
0000E349 =0000000A                M 	__midpos:	set instr(__pos+5," %<fpal0> FM3",' ')
0000E349 =00000009                M 	__midpos:	= __endpos
0000E349                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0> FM3"
0000E349                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0> FM3"
0000E349 E8                       M 	dc.b	fpal0
0000E34A =0000000A                M 	__lpos:	set __endpos+1
0000E34A =00000000                M 	__pos:	set instr(__pos+1," %<fpal0> FM3",'%<')
0000E34A                          M 	__substr:	substr __lpos,," %<fpal0> FM3"
0000E34A 2046 4D33                M 	dc.b	" FM3"
0000E34E 00                       M 	dc.b	0
0000E350 00                       M 	even
0000E350                          M 	.instr_end_513:
0000E350 4E75                       		rts
0000E352                            
0000E352                            AMPS_DebugR_ChkTracker2_fm4
0000E352                            	Console.Write " %<fpal0> FM4"
0000E352 40E7                     M 	move.w	sr,-(sp)
0000E354                          M 	__fstring_generateargumentscode	" %<fpal0> FM4"
0000E354 =00000002                M 	__pos:	set instr(" %<fpal0> FM4",'%<')
0000E354 =00000000                M 	__stack:set	0
0000E354 =00000000                M 	__sp:	set 0
0000E354                          M 	while	(__pos)
0000E354 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0> FM4",'>')
0000E354 =0000000A                M 	__midpos:	set instr(__pos+5," %<fpal0> FM4",' ')
0000E354 =00000009                M 	__midpos:	= __endpos
0000E354                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0> FM4"
0000E354                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0> FM4"
0000E354 =00000000                M 	__pos:	set instr(__pos+1," %<fpal0> FM4",'%<')
0000E354                          M 	rept	__stack
0000E354 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000E358 43FA 0000                M 	lea	.str_516(pc),a1
0000E35C 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000E362 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000E366 46DF                     M 	move.w	(sp)+,sr
0000E368 6000 0000                M 	bra.w	.instr_end_516
0000E36C                          M 	.str_516:
0000E36C                          M 	__fstring_generatedecodedstring	" %<fpal0> FM4"
0000E36C =00000001                M 	__lpos:	set 1
0000E36C =00000002                M 	__pos:	set instr(" %<fpal0> FM4",'%<')
0000E36C                          M 	while	(__pos)
0000E36C                          M 	__substr:	substr __lpos,__pos-1," %<fpal0> FM4"
0000E36C 20                       M 	dc.b	" "
0000E36D =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0> FM4",'>')
0000E36D =0000000A                M 	__midpos:	set instr(__pos+5," %<fpal0> FM4",' ')
0000E36D =00000009                M 	__midpos:	= __endpos
0000E36D                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0> FM4"
0000E36D                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0> FM4"
0000E36D E8                       M 	dc.b	fpal0
0000E36E =0000000A                M 	__lpos:	set __endpos+1
0000E36E =00000000                M 	__pos:	set instr(__pos+1," %<fpal0> FM4",'%<')
0000E36E                          M 	__substr:	substr __lpos,," %<fpal0> FM4"
0000E36E 2046 4D34                M 	dc.b	" FM4"
0000E372 00                       M 	dc.b	0
0000E374 00                       M 	even
0000E374                          M 	.instr_end_516:
0000E374 4E75                       		rts
0000E376                            
0000E376                            AMPS_DebugR_ChkTracker2_fm5
0000E376                            	Console.Write " %<fpal0> FM5"
0000E376 40E7                     M 	move.w	sr,-(sp)
0000E378                          M 	__fstring_generateargumentscode	" %<fpal0> FM5"
0000E378 =00000002                M 	__pos:	set instr(" %<fpal0> FM5",'%<')
0000E378 =00000000                M 	__stack:set	0
0000E378 =00000000                M 	__sp:	set 0
0000E378                          M 	while	(__pos)
0000E378 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0> FM5",'>')
0000E378 =0000000A                M 	__midpos:	set instr(__pos+5," %<fpal0> FM5",' ')
0000E378 =00000009                M 	__midpos:	= __endpos
0000E378                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0> FM5"
0000E378                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0> FM5"
0000E378 =00000000                M 	__pos:	set instr(__pos+1," %<fpal0> FM5",'%<')
0000E378                          M 	rept	__stack
0000E378 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000E37C 43FA 0000                M 	lea	.str_519(pc),a1
0000E380 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000E386 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000E38A 46DF                     M 	move.w	(sp)+,sr
0000E38C 6000 0000                M 	bra.w	.instr_end_519
0000E390                          M 	.str_519:
0000E390                          M 	__fstring_generatedecodedstring	" %<fpal0> FM5"
0000E390 =00000001                M 	__lpos:	set 1
0000E390 =00000002                M 	__pos:	set instr(" %<fpal0> FM5",'%<')
0000E390                          M 	while	(__pos)
0000E390                          M 	__substr:	substr __lpos,__pos-1," %<fpal0> FM5"
0000E390 20                       M 	dc.b	" "
0000E391 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0> FM5",'>')
0000E391 =0000000A                M 	__midpos:	set instr(__pos+5," %<fpal0> FM5",' ')
0000E391 =00000009                M 	__midpos:	= __endpos
0000E391                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0> FM5"
0000E391                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0> FM5"
0000E391 E8                       M 	dc.b	fpal0
0000E392 =0000000A                M 	__lpos:	set __endpos+1
0000E392 =00000000                M 	__pos:	set instr(__pos+1," %<fpal0> FM5",'%<')
0000E392                          M 	__substr:	substr __lpos,," %<fpal0> FM5"
0000E392 2046 4D35                M 	dc.b	" FM5"
0000E396 00                       M 	dc.b	0
0000E398 00                       M 	even
0000E398                          M 	.instr_end_519:
0000E398 4E75                       		rts
0000E39A                            
0000E39A                            AMPS_DebugR_ChkTracker2_psg1
0000E39A                            	Console.Write " %<fpal0>PSG1"
0000E39A 40E7                     M 	move.w	sr,-(sp)
0000E39C                          M 	__fstring_generateargumentscode	" %<fpal0>PSG1"
0000E39C =00000002                M 	__pos:	set instr(" %<fpal0>PSG1",'%<')
0000E39C =00000000                M 	__stack:set	0
0000E39C =00000000                M 	__sp:	set 0
0000E39C                          M 	while	(__pos)
0000E39C =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0>PSG1",'>')
0000E39C =00000000                M 	__midpos:	set instr(__pos+5," %<fpal0>PSG1",' ')
0000E39C =00000009                M 	__midpos:	= __endpos
0000E39C                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0>PSG1"
0000E39C                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0>PSG1"
0000E39C =00000000                M 	__pos:	set instr(__pos+1," %<fpal0>PSG1",'%<')
0000E39C                          M 	rept	__stack
0000E39C 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000E3A0 43FA 0000                M 	lea	.str_522(pc),a1
0000E3A4 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000E3AA 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000E3AE 46DF                     M 	move.w	(sp)+,sr
0000E3B0 6000 0000                M 	bra.w	.instr_end_522
0000E3B4                          M 	.str_522:
0000E3B4                          M 	__fstring_generatedecodedstring	" %<fpal0>PSG1"
0000E3B4 =00000001                M 	__lpos:	set 1
0000E3B4 =00000002                M 	__pos:	set instr(" %<fpal0>PSG1",'%<')
0000E3B4                          M 	while	(__pos)
0000E3B4                          M 	__substr:	substr __lpos,__pos-1," %<fpal0>PSG1"
0000E3B4 20                       M 	dc.b	" "
0000E3B5 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0>PSG1",'>')
0000E3B5 =00000000                M 	__midpos:	set instr(__pos+5," %<fpal0>PSG1",' ')
0000E3B5 =00000009                M 	__midpos:	= __endpos
0000E3B5                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0>PSG1"
0000E3B5                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0>PSG1"
0000E3B5 E8                       M 	dc.b	fpal0
0000E3B6 =0000000A                M 	__lpos:	set __endpos+1
0000E3B6 =00000000                M 	__pos:	set instr(__pos+1," %<fpal0>PSG1",'%<')
0000E3B6                          M 	__substr:	substr __lpos,," %<fpal0>PSG1"
0000E3B6 5053 4731                M 	dc.b	"PSG1"
0000E3BA 00                       M 	dc.b	0
0000E3BC 00                       M 	even
0000E3BC                          M 	.instr_end_522:
0000E3BC 4E75                       		rts
0000E3BE                            
0000E3BE                            AMPS_DebugR_ChkTracker2_psg2
0000E3BE                            	Console.Write " %<fpal0>PSG2"
0000E3BE 40E7                     M 	move.w	sr,-(sp)
0000E3C0                          M 	__fstring_generateargumentscode	" %<fpal0>PSG2"
0000E3C0 =00000002                M 	__pos:	set instr(" %<fpal0>PSG2",'%<')
0000E3C0 =00000000                M 	__stack:set	0
0000E3C0 =00000000                M 	__sp:	set 0
0000E3C0                          M 	while	(__pos)
0000E3C0 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0>PSG2",'>')
0000E3C0 =00000000                M 	__midpos:	set instr(__pos+5," %<fpal0>PSG2",' ')
0000E3C0 =00000009                M 	__midpos:	= __endpos
0000E3C0                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0>PSG2"
0000E3C0                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0>PSG2"
0000E3C0 =00000000                M 	__pos:	set instr(__pos+1," %<fpal0>PSG2",'%<')
0000E3C0                          M 	rept	__stack
0000E3C0 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000E3C4 43FA 0000                M 	lea	.str_525(pc),a1
0000E3C8 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000E3CE 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000E3D2 46DF                     M 	move.w	(sp)+,sr
0000E3D4 6000 0000                M 	bra.w	.instr_end_525
0000E3D8                          M 	.str_525:
0000E3D8                          M 	__fstring_generatedecodedstring	" %<fpal0>PSG2"
0000E3D8 =00000001                M 	__lpos:	set 1
0000E3D8 =00000002                M 	__pos:	set instr(" %<fpal0>PSG2",'%<')
0000E3D8                          M 	while	(__pos)
0000E3D8                          M 	__substr:	substr __lpos,__pos-1," %<fpal0>PSG2"
0000E3D8 20                       M 	dc.b	" "
0000E3D9 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0>PSG2",'>')
0000E3D9 =00000000                M 	__midpos:	set instr(__pos+5," %<fpal0>PSG2",' ')
0000E3D9 =00000009                M 	__midpos:	= __endpos
0000E3D9                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0>PSG2"
0000E3D9                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0>PSG2"
0000E3D9 E8                       M 	dc.b	fpal0
0000E3DA =0000000A                M 	__lpos:	set __endpos+1
0000E3DA =00000000                M 	__pos:	set instr(__pos+1," %<fpal0>PSG2",'%<')
0000E3DA                          M 	__substr:	substr __lpos,," %<fpal0>PSG2"
0000E3DA 5053 4732                M 	dc.b	"PSG2"
0000E3DE 00                       M 	dc.b	0
0000E3E0 00                       M 	even
0000E3E0                          M 	.instr_end_525:
0000E3E0 4E75                       		rts
0000E3E2                            
0000E3E2                            AMPS_DebugR_ChkTracker2_psg3
0000E3E2                            	Console.Write " %<fpal0>PSG3"
0000E3E2 40E7                     M 	move.w	sr,-(sp)
0000E3E4                          M 	__fstring_generateargumentscode	" %<fpal0>PSG3"
0000E3E4 =00000002                M 	__pos:	set instr(" %<fpal0>PSG3",'%<')
0000E3E4 =00000000                M 	__stack:set	0
0000E3E4 =00000000                M 	__sp:	set 0
0000E3E4                          M 	while	(__pos)
0000E3E4 =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0>PSG3",'>')
0000E3E4 =00000000                M 	__midpos:	set instr(__pos+5," %<fpal0>PSG3",' ')
0000E3E4 =00000009                M 	__midpos:	= __endpos
0000E3E4                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0>PSG3"
0000E3E4                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0>PSG3"
0000E3E4 =00000000                M 	__pos:	set instr(__pos+1," %<fpal0>PSG3",'%<')
0000E3E4                          M 	rept	__stack
0000E3E4 48E7 01E0                M 	movem.l	a0-a2/d7,-(sp)
0000E3E8 43FA 0000                M 	lea	.str_528(pc),a1
0000E3EC 4EB9 0000 0000           M 	jsr	errorhandler.__global__console_write_formatted
0000E3F2 4CDF 0780                M 	movem.l	(sp)+,a0-a2/d7
0000E3F6 46DF                     M 	move.w	(sp)+,sr
0000E3F8 6000 0000                M 	bra.w	.instr_end_528
0000E3FC                          M 	.str_528:
0000E3FC                          M 	__fstring_generatedecodedstring	" %<fpal0>PSG3"
0000E3FC =00000001                M 	__lpos:	set 1
0000E3FC =00000002                M 	__pos:	set instr(" %<fpal0>PSG3",'%<')
0000E3FC                          M 	while	(__pos)
0000E3FC                          M 	__substr:	substr __lpos,__pos-1," %<fpal0>PSG3"
0000E3FC 20                       M 	dc.b	" "
0000E3FD =00000009                M 	__endpos:	set instr(__pos+1," %<fpal0>PSG3",'>')
0000E3FD =00000000                M 	__midpos:	set instr(__pos+5," %<fpal0>PSG3",' ')
0000E3FD =00000009                M 	__midpos:	= __endpos
0000E3FD                          M 	__type:	substr __pos+1+1,__pos+1+1+1," %<fpal0>PSG3"
0000E3FD                          M 	__substr:	substr __pos+1+1,__endpos-1," %<fpal0>PSG3"
0000E3FD E8                       M 	dc.b	fpal0
0000E3FE =0000000A                M 	__lpos:	set __endpos+1
0000E3FE =00000000                M 	__pos:	set instr(__pos+1," %<fpal0>PSG3",'%<')
0000E3FE                          M 	__substr:	substr __lpos,," %<fpal0>PSG3"
0000E3FE 5053 4733                M 	dc.b	"PSG3"
0000E402 00                       M 	dc.b	0
0000E404 00                       M 	even
0000E404                          M 	.instr_end_528:
0000E404 4E75                       		rts
0000E406                            ; ===========================================================================
0000E406                            ; ---------------------------------------------------------------------------
0000E406                            ; Routine for loading the Dual PCM driver into Z80 RAM
0000E406                            ; ---------------------------------------------------------------------------
0000E406                            
0000E406                            LoadDualPCM:
0000E406 33FC 0100 00A1 1100        		move.w	#$0100,$A11100		; request Z80 stop
0000E40E 33FC 0100 00A1 1200        		move.w	#$0100,$A11200		; Z80 reset off
0000E416                            
0000E416 41F9 0000 0000             		lea	DualPCM,a0		; load Dual PCM address into a0
0000E41C 43F9 00A0 0000             		lea	dZ80,a1			; load Z80 RAM address into a1
0000E422 323C 0000                  		move.w	#DualPCM_sz-1,d1	; get lenght counter for dbf into d1
0000E426                            
0000E426                            .z80
0000E426 0839 0000 00A1 1100        		btst	#$00,$A11100		; check if Z80 has stopped
0000E42E 66F6                       		bne.s	.z80			; if not, wait more
0000E430                            
0000E430                            .load
0000E430 12D8                       		move.b	(a0)+,(a1)+		; copy the Dual PCM driver into Z80 RAM
0000E432 51C9 FFFC                  		dbf	d1,.load		; write every single byte
0000E436                            
0000E436 41FA 0000                  		lea	SampleList(pc),a0	; load address for the stop sample data into a0
0000E43A 43F9 0000 0000             		lea	dZ80+MuteSample,a1	; load address in Dual PCM to write into a1
0000E440                            
0000E440                            	rept 6
0000E440                            		move.b	(a0)+,(a1)+		; copy all required data
0000E440                            	endr
0000E440 12D8                     M 	move.b	(a0)+,(a1)+
0000E442 12D8                     M 	move.b	(a0)+,(a1)+
0000E444 12D8                     M 	move.b	(a0)+,(a1)+
0000E446 12D8                     M 	move.b	(a0)+,(a1)+
0000E448 12D8                     M 	move.b	(a0)+,(a1)+
0000E44A 12D8                     M 	move.b	(a0)+,(a1)+
0000E44C                            
0000E44C 7002                       		moveq	#2,d0			; set flush timer for 60hz systems
0000E44E 0838 0006 C746             		btst	#6,hwVersion.w	; is this a PAL Mega Drive?
0000E454 6700                       		beq.s	.ntsc			; if not, branch
0000E456 7003                       		moveq	#3,d0			; set flush timer for 50hz systems
0000E458                            .ntsc
0000E458 13C0 0000 0000             		move.b	d0,dZ80+YM_FlushTimer+2	; save flush timer
0000E45E                            
0000E45E 33FC 0000 00A1 1200        		move.w	#$0000,$A11200		; request Z80 reset
0000E466 727F                       		moveq	#$7F,d1			; wait for a little bit
0000E468 51C9 FFFE                  		dbf	d1,*			; we can't check for reset, so we need to delay
0000E46C                            
0000E46C 33FC 0000 00A1 1100        		move.w	#$0000,$A11100		; enable Z80
0000E474 33FC 0100 00A1 1200        		move.w	#$0100,$A11200		; Z80 reset off
0000E47C 4E75                       		rts
0000E47E                            ; ---------------------------------------------------------------------------
0000E47E                            ; Play DAC
0000E47E                            ; ---------------------------------------------------------------------------
0000E47E                            
0000E47E                            PlayDAC2:
0000E47E 43F9 0000 0000             		lea	dZ80+PCM2_Sample,a1	; load addresses for PCM 1
0000E484                            	StopZ80					; wait for Z80 to stop
0000E484 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0000E48C                          M 	waitz80stop
0000E48C 0839 0000 00A1 1100      M .wait_532:	btst	#0,z80_bus_req
0000E494 66F6                     M 	bne.s	.wait_532
0000E496                            	rept 12
0000E496                            		move.b	(a3)+,(a1)+		; send sample data to Dual PCM
0000E496                            	endr
0000E496 12DB                     M 	move.b	(a3)+,(a1)+
0000E498 12DB                     M 	move.b	(a3)+,(a1)+
0000E49A 12DB                     M 	move.b	(a3)+,(a1)+
0000E49C 12DB                     M 	move.b	(a3)+,(a1)+
0000E49E 12DB                     M 	move.b	(a3)+,(a1)+
0000E4A0 12DB                     M 	move.b	(a3)+,(a1)+
0000E4A2 12DB                     M 	move.b	(a3)+,(a1)+
0000E4A4 12DB                     M 	move.b	(a3)+,(a1)+
0000E4A6 12DB                     M 	move.b	(a3)+,(a1)+
0000E4A8 12DB                     M 	move.b	(a3)+,(a1)+
0000E4AA 12DB                     M 	move.b	(a3)+,(a1)+
0000E4AC 12DB                     M 	move.b	(a3)+,(a1)+
0000E4AE 101B                       		move.b	(a3)+,d0
0000E4B0 5200                       		addq.b	#1,d0
0000E4B2 13C0 0000 0000             		move.b	d0,dZ80+PCM2_PitchHigh+1
0000E4B8 13DB 0000 0000             		move.b	(a3)+,dZ80+PCM2_PitchLow+1
0000E4BE 13FC 00D2 0000 0000        		move.b	#$D2,dZ80+PCM2_ChangePitch; change "JP C" to "JP NC"
0000E4C6                            
0000E4C6 13FC 00DA 0000 0000        		move.b	#$DA,dZ80+PCM2_NewRET	; activate sample switch (change instruction)
0000E4CE                            	StartZ80				; enable Z80 execution
0000E4CE 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0000E4D6 4E75                       		rts
0000E4D8                            
0000E4D8                            ; ---------------------------------------------------------------------------
0000E4D8                            
0000E4D8                            PlayDAC1:
0000E4D8 43F9 0000 0000             		lea	dZ80+PCM1_Sample,a1	; load addresses for PCM 1
0000E4DE                            	StopZ80					; wait for Z80 to stop
0000E4DE 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0000E4E6                          M 	waitz80stop
0000E4E6 0839 0000 00A1 1100      M .wait_535:	btst	#0,z80_bus_req
0000E4EE 66F6                     M 	bne.s	.wait_535
0000E4F0                            	rept 12
0000E4F0                            		move.b	(a3)+,(a1)+		; send sample data to Dual PCM
0000E4F0                            	endr
0000E4F0 12DB                     M 	move.b	(a3)+,(a1)+
0000E4F2 12DB                     M 	move.b	(a3)+,(a1)+
0000E4F4 12DB                     M 	move.b	(a3)+,(a1)+
0000E4F6 12DB                     M 	move.b	(a3)+,(a1)+
0000E4F8 12DB                     M 	move.b	(a3)+,(a1)+
0000E4FA 12DB                     M 	move.b	(a3)+,(a1)+
0000E4FC 12DB                     M 	move.b	(a3)+,(a1)+
0000E4FE 12DB                     M 	move.b	(a3)+,(a1)+
0000E500 12DB                     M 	move.b	(a3)+,(a1)+
0000E502 12DB                     M 	move.b	(a3)+,(a1)+
0000E504 12DB                     M 	move.b	(a3)+,(a1)+
0000E506 12DB                     M 	move.b	(a3)+,(a1)+
0000E508 101B                       		move.b	(a3)+,d0
0000E50A 5200                       		addq.b	#1,d0
0000E50C 13C0 0000 0000             		move.b	d0,dZ80+PCM1_PitchHigh+1
0000E512 13DB 0000 0000             		move.b	(a3)+,dZ80+PCM1_PitchLow+1
0000E518 13FC 00D2 0000 0000        		move.b	#$D2,dZ80+PCM1_ChangePitch; change "JP C" to "JP NC"
0000E520                            
0000E520 13FC 00DA 0000 0000        		move.b	#$DA,dZ80+PCM1_NewRET	; activate sample switch (change instruction)
0000E528                            	StartZ80				; enable Z80 execution
0000E528 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0000E530 4E75                       		rts
0000E532                            ; ===========================================================================
0000E532                            ; ---------------------------------------------------------------------------
0000E532                            ; Handle Dual PCM YM Cue correctly
0000E532                            ; ---------------------------------------------------------------------------
0000E532                            
0000E532                            UpdateAMPS:
0000E532                            	StopZ80					; wait for Z80 to stop
0000E532 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0000E53A                          M 	waitz80stop
0000E53A 0839 0000 00A1 1100      M .wait_538:	btst	#0,z80_bus_req
0000E542 66F6                     M 	bne.s	.wait_538
0000E544 1039 0000 0000             		move.b	dZ80+YM_Buffer,d0	; load current cue buffer in use
0000E54A                            	StartZ80				; enable Z80 execution
0000E54A 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0000E552                            
0000E552 207C 0000 0000             		move.l	#dZ80+YM_Buffer1,a0	; set the cue address to buffer 1
0000E558 4A00                       		tst.b	d0			; check buffer to use
0000E55A 6600                       		bne.s	.gotbuffer		; if Z80 is reading buffer 2, branch
0000E55C D0FC 0000                  		add.w	#YM_Buffer2-YM_Buffer1,a0; set the cue address to buffer 2
0000E560                            
0000E560                            .gotbuffer
0000E560 6100                       		bsr.s	dUpdateAllAMPS		; process the driver
0000E562                            		AMPS_Debug_CuePtr 3		; check if the cue is still valid
0000E562 B1FC 0000 0000           M 	cmp.l	#$a00000+ym_buffer1,a0
0000E568 6500                     M 	blo.s	.fail_540
0000E56A B1FC 0000 0000           M 	cmp.l	#$a00000+ym_buffer2+$400,a0
0000E570 6500                     M 	blo.s	.ok_540
0000E572                          M .fail_540
0000E572 4EBA FAB8                M 	jsr	amps_debug_cueptr3
0000E576                          M .ok_540
0000E576                            
0000E576                            	StopZ80					; wait for Z80 to stop
0000E576 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0000E57E                          M 	waitz80stop
0000E57E 0839 0000 00A1 1100      M .wait_542:	btst	#0,z80_bus_req
0000E586 66F6                     M 	bne.s	.wait_542
0000E588 50D0                       		st	(a0)			; make sure cue is marked as completed
0000E58A                            	StartZ80				; enable Z80 execution
0000E58A 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0000E592                            
0000E592                            dPaused:
0000E592 4E75                       		rts
0000E594                            ; ===========================================================================
0000E594                            ; ---------------------------------------------------------------------------
0000E594                            ; Main routine for updating the AMPS driver
0000E594                            ; ---------------------------------------------------------------------------
0000E594                            
0000E594                            dUpdateAllAMPS:
0000E594 4EBA 0000                  		jsr	dPlaySnd(pc)		; check if any music needs playing
0000E598 4A38 C4A6                  		tst.b	mFlags.w		; is music paused?
0000E59C 6BF4                       		bmi.s	dPaused			; if yes, branch
0000E59E                            ; ---------------------------------------------------------------------------
0000E59E                            ; This is the new fading feature I created, to make custom fading
0000E59E                            ; types easier to program. You can define series of 3 bytes, each
0000E59E                            ; representing FM, PSG and DAC volumes. Each group of 3 is executed
0000E59E                            ; once per frame. If the first value in a frame is a command flag,
0000E59E                            ; instead its code is executed. Additionally, no fade program may
0000E59E                            ; appear before ROM offset $10000, or else it will never be executed.
0000E59E                            ; ---------------------------------------------------------------------------
0000E59E                            
0000E59E 4A38 C4B5                  .notempo	tst.b	mFadeAddr+1.w		; check if a fade program is already executing
0000E5A2 6700 0000                  		beq.w	.chkregion		; branch if not
0000E5A6                            
0000E5A6 2278 C4B4                  		move.l	mFadeAddr.w,a1		; get the fade porogram address to a1
0000E5AA 56B8 C4B4                  		addq.l	#3,mFadeAddr.w		; set the fade address to next group
0000E5AE                            
0000E5AE 7220                       		moveq	#(1<<cfbVol),d1		; prepare volume update to d1
0000E5B0 7000                       		moveq	#0,d0
0000E5B2 1019                       		move.b	(a1)+,d0		; get FM/command byte from fade data
0000E5B4 6A00                       		bpl.s	.nofadeend		; branch if this is not a command
0000E5B6                            
0000E5B6                            		AMPS_Debug_FadeCmd		; check if this command is valid
0000E5B6 0C00 0090                M 	cmp.b	#flast,d0
0000E5BA 6400                     M 	bhs.s	.fail
0000E5BC 0C00 0080                M 	cmp.b	#$80,d0
0000E5C0 6500                     M 	blo.s	.fail
0000E5C2 0800 0001                M 	btst	#1,d0
0000E5C6 6600                     M 	bne.s	.fail
0000E5C8 0800 0000                M 	btst	#0,d0
0000E5CC 6700                     M 	beq.s	.ok
0000E5CE                          M .fail
0000E5CE 4EBA F8B2                M 	jsr	amps_debugr_fadecmd
0000E5D2                          M .ok
0000E5D2 45FA 0000                  		lea	dFadeCommands-$80(pc),a2; load fade commands pointer table to a2
0000E5D6 4EB2 0000                  		jsr	(a2,d0.w)		; run the fade command code
0000E5DA 4238 C4B5                  		clr.b	mFadeAddr+1.w		; mark the fade program as completed
0000E5DE 6000                       		bra.s	.chkregion		; go check the region
0000E5E0                            
0000E5E0                            .nofadeend
0000E5E0 B038 C4B4                  		cmp.b	mMasterVolFM.w,d0	; check if volume did not change
0000E5E4 6700                       		beq.s	.fadedac		; if did not, branch
0000E5E6 11C0 C4B4                  		move.b	d0,mMasterVolFM.w	; save the new volume
0000E5EA 4EBA 0000                  		jsr	dReqVolUpFM(pc)		; go request volume update for FM
0000E5EE                            
0000E5EE                            .fadedac
0000E5EE 1019                       		move.b	(a1)+,d0		; get DAC volume byte from fade data
0000E5F0 B038 C4C0                  		cmp.b	mMasterVolDAC.w,d0	; check if volume did not change
0000E5F4 6700                       		beq.s	.fadepsg		; if did not, branch
0000E5F6 11C0 C4C0                  		move.b	d0,mMasterVolDAC.w	; save new volume
0000E5FA                            
0000E5FA =FFFFC4C4                  .ch =	mDAC1					; start at DAC1
0000E5FA                            	rept Mus_DAC				; do for all music DAC channels
0000E5FA                            		or.b	d1,.ch.w		; tell the channel to update its volume
0000E5FA                            .ch =		.ch+cSize			; go to next channel
0000E5FA                            	endr
0000E5FA 8338 C4C4                M 	or.b	d1,.ch.w
0000E5FE =FFFFC4F0                M .ch	=	.ch+csize
0000E5FE 8338 C4F0                M 	or.b	d1,.ch.w
0000E602 =FFFFC51C                M .ch	=	.ch+csize
0000E602 8338 C67C                  		or.b	d1,mSFXDAC1.w		; tell SFX DAC1 to update its volume
0000E606                            
0000E606                            .fadepsg
0000E606 1019                       		move.b	(a1)+,d0		; get PSG volume byte from fade data
0000E608 B038 C4BF                  		cmp.b	mMasterVolPSG.w,d0	; check if volume did not change
0000E60C 6700                       		beq.s	.chkregion		; if did not, branch
0000E60E 11C0 C4BF                  		move.b	d0,mMasterVolPSG.w	; save new volume
0000E612                            
0000E612 =FFFFC5F8                  .ch =	mPSG1					; start at PSG1
0000E612                            	rept Mus_PSG				; do for all music PSG channels
0000E612                            		or.b	d1,.ch.w		; tell the channel to update its volume
0000E612                            .ch =		.ch+cSize			; go to next channel
0000E612                            	endr
0000E612 8338 C5F8                M 	or.b	d1,.ch.w
0000E616 =FFFFC624                M .ch	=	.ch+csize
0000E616 8338 C624                M 	or.b	d1,.ch.w
0000E61A =FFFFC650                M .ch	=	.ch+csize
0000E61A 8338 C650                M 	or.b	d1,.ch.w
0000E61E =FFFFC67C                M .ch	=	.ch+csize
0000E61E                            
0000E61E =FFFFC6EC                  .ch =	mSFXPSG1				; start at SFX PSG1
0000E61E                            	rept SFX_PSG				; do for all SFX PSG channels
0000E61E                            		or.b	d1,.ch.w		; tell the channel to update its volume
0000E61E                            .ch =		.ch+cSizeSFX			; go to next channel
0000E61E                            	endr
0000E61E 8338 C6EC                M 	or.b	d1,.ch.w
0000E622 =FFFFC708                M .ch	=	.ch+csizesfx
0000E622 8338 C708                M 	or.b	d1,.ch.w
0000E626 =FFFFC724                M .ch	=	.ch+csizesfx
0000E626 8338 C724                M 	or.b	d1,.ch.w
0000E62A =FFFFC740                M .ch	=	.ch+csizesfx
0000E62A                            ; ---------------------------------------------------------------------------
0000E62A                            ; Since PAL Mega Drive's run slower than NTSC, if we want the music to
0000E62A                            ; sound consistent, we need to run the sound driver 1.2 times as fast
0000E62A                            ; on PAL systems. This will cause issues with some songs that rely on
0000E62A                            ; game engine to seem "in sync". Because of that, I added a flag to
0000E62A                            ; disable the PAL fix (much like in Sonic 2's driver). Unlike the fix
0000E62A                            ; in SMPS drivers (and Sonic 3 and above), this fix will make the music
0000E62A                            ; play at the exact right speed, instead of slightly too slow.
0000E62A                            ; ---------------------------------------------------------------------------
0000E62A                            
0000E62A 0838 0006 C746             .chkregion	btst	#6,hwVersion.w	; is this PAL system?
0000E630 6700                       		beq.s	.driver			; if not, branch
0000E632 5338 C4A7                  		subq.b	#1,mCtrPal.w		; decrease PAL frame counter
0000E636 6E00                       		bgt.s	.driver			; if hasn't become 0 (or lower!), branch
0000E638                            
0000E638 0838 0003 C4A6             		btst	#mfbNoPAL,mFlags.w	; check if we have disabled the PAL fix
0000E63E 6600                       		bne.s	.nofix			; if yes, run music and SFX
0000E640 6100                       		bsr.s	.nosfx			; run the sound driver
0000E642                            
0000E642                            .nofix
0000E642 11FC 0005 C4A7             		move.b	#6-1,mCtrPal.w		; reset counter
0000E648                            .driver
0000E648 6100 0000                  		bsr.w	dAMPSdoSFX		; run SFX this time
0000E64C                            
0000E64C                            .nosfx		; continue to run sound driver again
0000E64C                            ; ---------------------------------------------------------------------------
0000E64C                            ; There are 2 methods of handling tempo adjustments in SMPS,
0000E64C                            ; overflow (where a value is added to the accumulator, and when it
0000E64C                            ; range overflows, tick of delay is added), and counter (where a
0000E64C                            ; counter is copied to the tempo, which is then decreased each frame,
0000E64C                            ; until it becomes 0, after which a tick of delay is added). AMPS
0000E64C                            ; supports these both too, because there is no single right answer,
0000E64C                            ; and users may prefer one over the other. The overflow method is
0000E64C                            ; really good for low values, as it provides very fine control over
0000E64C                            ; the tempo, but at high ranges it gets worse. Meanwhile the counter
0000E64C                            ; method isn't as good for small values, but for large value it works
0000E64C                            ; better. You may choose this setting in the macro.asm file,
0000E64C                            ; ---------------------------------------------------------------------------
0000E64C                            
0000E64C 1038 C4BA                  		move.b	mTempo.w,d0		; get tempo to d0
0000E650 D138 C4BB                  		add.b	d0,mTempoCur.w		; add to accumulator
0000E654 6400                       		bcc.s	dAMPSdoAll		; if carry clear, branch
0000E656                            
0000E656                            
0000E656 =FFFFC4D0                  .ch =	mDAC1+cDuration				; start at DAC1 duration
0000E656                            	rept Mus_Ch				; loop through all music channels
0000E656                            		addq.b	#1,.ch.w		; add 1 to duration
0000E656                            .ch =		.ch+cSize			; go to next channel
0000E656                            	endr
0000E656 5238 C4D0                M 	addq.b	#1,.ch.w
0000E65A =FFFFC4FC                M .ch	=	.ch+csize
0000E65A 5238 C4FC                M 	addq.b	#1,.ch.w
0000E65E =FFFFC528                M .ch	=	.ch+csize
0000E65E 5238 C528                M 	addq.b	#1,.ch.w
0000E662 =FFFFC554                M .ch	=	.ch+csize
0000E662 5238 C554                M 	addq.b	#1,.ch.w
0000E666 =FFFFC580                M .ch	=	.ch+csize
0000E666 5238 C580                M 	addq.b	#1,.ch.w
0000E66A =FFFFC5AC                M .ch	=	.ch+csize
0000E66A 5238 C5AC                M 	addq.b	#1,.ch.w
0000E66E =FFFFC5D8                M .ch	=	.ch+csize
0000E66E 5238 C5D8                M 	addq.b	#1,.ch.w
0000E672 =FFFFC604                M .ch	=	.ch+csize
0000E672 5238 C604                M 	addq.b	#1,.ch.w
0000E676 =FFFFC630                M .ch	=	.ch+csize
0000E676 5238 C630                M 	addq.b	#1,.ch.w
0000E67A =FFFFC65C                M .ch	=	.ch+csize
0000E67A 5238 C65C                M 	addq.b	#1,.ch.w
0000E67E =FFFFC688                M .ch	=	.ch+csize
0000E67E                            ; ===========================================================================
0000E67E                            ; ---------------------------------------------------------------------------
0000E67E                            ; Process music DAC channels
0000E67E                            ; ---------------------------------------------------------------------------
0000E67E                            
0000E67E                            dAMPSdoAll:
0000E67E 4DFA 0000                  		lea	SampleList(pc),a6	; get SampleList to a6 for quick access
0000E682 4BF8 C498                  		lea	mDAC1-cSize.w,a5	; get DAC1 channel RAM address into a5
0000E686 7E01                       		moveq	#Mus_DAC-1,d7		; get total number of DAC channels to d7
0000E688                            
0000E688                            dAMPSdoDAC:
0000E688 DAFC 002C                  		add.w	#cSize,a5		; go to the next channel (first time its mDAC1!)
0000E68C 4A15                       		tst.b	(a5)			; check if channel is running a tracker
0000E68E 6A00 0000                  		bpl.w	.next			; if not, branch
0000E692 532D 000C                  		subq.b	#1,cDuration(a5)	; decrease note duration
0000E696 6700 0000                  		beq.w	.update			; if timed out, update channel
0000E69A                            	dNoteToutDAC	 			; handle DAC-specific note timeout behavior
0000E69A                          M 	dnotetouthandler
0000E69A 4A2D 001C                M 	tst.b	cnotetimecur(a5)
0000E69E 6700                     M 	beq.s	.endt
0000E6A0 532D 001C                M 	subq.b	#1,cnotetimecur(a5)
0000E6A4 6600                     M 	bne.s	.endt
0000E6A6 7000                     M 	moveq	#0,d0
0000E6A8 6000 0000                M 	bra.w	dnoteondac2
0000E6AC                          M .endt
0000E6AC                            
0000E6AC                            	dCalcFreq				; calculate channel base frequency
0000E6AC 1C2D 0007                M 	move.b	cdetune(a5),d6
0000E6B0 4886                     M 	ext.w	d6
0000E6B2 DC6D 000E                M 	add.w	cfreq(a5),d6
0000E6B6                            	dModulate dAMPSdoFM, dAMPSdoDAC, 4	; run modulation code
0000E6B6 0815 0003                M 	btst	#cfbmod,(a5)
0000E6BA 6700                     M 	beq.s	.noret
0000E6BC 4A2D 0010                M 	tst.b	cmoddelay(a5)
0000E6C0 6700                     M 	beq.s	.started
0000E6C2 532D 0010                M 	subq.b	#1,cmoddelay(a5)
0000E6C6                          M .noret
0000E6C6 0895 0005                M 	bclr	#cfbvol,(a5)
0000E6CA 6700                     M 	beq.s	.noupdatevol
0000E6CC 4EBA 0000                M 	jsr	dupdatevoldac(pc)
0000E6D0                          M 	.noupdatevol:
0000E6D0 51CF FFB6                M 	dbf	d7,dampsdodac
0000E6D4 6000 0000                M 	bra.w	dampsdofm
0000E6D8                          M .started
0000E6D8 532D 0016                M 	subq.b	#1,cmodspeed(a5)
0000E6DC 66E8                     M 	bne.s	.noret
0000E6DE 226D 0010                M 	movea.l	cmod(a5),a1
0000E6E2 1B69 0001 0016           M 	move.b	1(a1),cmodspeed(a5)
0000E6E8 4A2D 0018                M 	tst.b	cmodcount(a5)
0000E6EC 6600                     M 	bne.s	.norev
0000E6EE 1B69 0003 0018           M 	move.b	3(a1),cmodcount(a5)
0000E6F4 442D 0017                M 	neg.b	cmodstep(a5)
0000E6F8                          M .norev
0000E6F8 532D 0018                M 	subq.b	#1,cmodcount(a5)
0000E6FC 1A2D 0017                M 	move.b	cmodstep(a5),d5
0000E700 4885                     M 	ext.w	d5
0000E702 DA6D 0014                M 	add.w	cmodfreq(a5),d5
0000E706 3B45 0014                M 	move.w	d5,cmodfreq(a5)
0000E70A DC45                     M 	add.w	d5,d6
0000E70C 6100 0000                  		bsr.w	dUpdateFreqDAC		; if frequency needs changing, do it
0000E710                            
0000E710 0895 0005                  		bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0000E714 6700                       		beq.s	.next			; if not, skip
0000E716 6100 0000                  		bsr.w	dUpdateVolDAC		; update DAC volume
0000E71A                            
0000E71A                            .next
0000E71A 51CF FF6C                  		dbf	d7,dAMPSdoDAC		; make sure to run all the channels
0000E71E 4EFA 0000                  		jmp	dAMPSdoFM(pc)		; after that, process music FM channels
0000E722                            
0000E722                            .update
0000E722 0215 00FB                  		and.b	#$FF-(1<<cfbHold),(a5)	; clear hold flag
0000E726                            	dDoTracker				; process tracker
0000E726 286D 0002                M 	movea.l	cdata(a5),a4
0000E72A                          M 	amps_debug_trackupd
0000E72A 220C                     M 	move.l	a4,d1
0000E72C 0281 00FF FFFF           M 	and.l	#$ffffff,d1
0000E732 0C81 0000 0000           M 	cmp.l	#sfxaddr,d1
0000E738 6500                     M 	blo.s	.fail2
0000E73A 0C81 0000 0000           M 	cmp.l	#dacaddr,d1
0000E740 6500                     M 	blo.s	.data
0000E742                          M .fail2
0000E742                          M 	raiseerror	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_channel
0000E742 487A FFFE                M 	pea	*(pc)
0000E746                          M 	raiseerror2	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_channel
0000E746 40E7                     M 	move.w	sr,-(sp)
0000E748                          M 	__fstring_generateargumentscode	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E748 =0000001A                M 	__pos:	set instr("Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000E748 =00000000                M 	__stack:set	0
0000E748 =00000000                M 	__sp:	set 0
0000E748                          M 	while	(__pos)
0000E748 =00000021                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000E748 =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000E748 =00000021                M 	__midpos:	= __endpos
0000E748                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E748                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E748                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E748                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E748                          M 	pushp	"move.l a4,-(sp)"
0000E748 =00000001                M 	__stack:	= __stack+1
0000E748 =00000004                M 	__sp:	= __sp+4
0000E748 =00000022                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000E748 =00000029                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000E748 =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000E748 =00000029                M 	__midpos:	= __endpos
0000E748                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E748                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E748 =0000002A                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000E748 =00000035                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000E748 =00000031                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000E748                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E748                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E748                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E748                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E748                          M 	pushp	"move.l a4,-(sp)"
0000E748 =00000002                M 	__stack:	= __stack+1
0000E748 =00000008                M 	__sp:	= __sp+4
0000E748 =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000E748                          M 	rept	__stack
0000E748                          M 	popp	__command
0000E748 2F0C                     M 	move.l	a4,-(sp)
0000E74A                          M 	popp	__command
0000E74A 2F0C                     M 	move.l	a4,-(sp)
0000E74C 4EB9 0000 0000           M 	jsr	errorhandler
0000E752                          M 	__fstring_generatedecodedstring	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E752 =00000001                M 	__lpos:	set 1
0000E752 =0000001A                M 	__pos:	set instr("Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000E752                          M 	while	(__pos)
0000E752                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E752 496E 7661 6C69 6420 7472+M 	dc.b	"Invalid tracker address: "
0000E76B =00000021                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000E76B =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000E76B =00000021                M 	__midpos:	= __endpos
0000E76B                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E76B                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E76B                          M 	__param:	substr ,,"hex"
0000E76B 83                       M 	dc.b	hex|3
0000E76C =00000022                M 	__lpos:	set __endpos+1
0000E76C =00000022                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000E76C                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E76C                          M 	dc.b	""
0000E76C =00000029                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000E76C =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000E76C =00000029                M 	__midpos:	= __endpos
0000E76C                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E76C                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E76C E0                       M 	dc.b	fendl
0000E76D =0000002A                M 	__lpos:	set __endpos+1
0000E76D =0000002A                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000E76D                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E76D                          M 	dc.b	""
0000E76D =00000035                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000E76D =00000031                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000E76D                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E76D                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E76D B3                       M 	dc.b	sym|3
0000E76E =00000036                M 	__lpos:	set __endpos+1
0000E76E =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000E76E                          M 	__substr:	substr __lpos,,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000E76E                          M 	dc.b	""
0000E76E 00                       M 	dc.b	0
0000E76F 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000E770                          M 	even
0000E770 4EFA EB0A                M 	jmp	amps_debug_console_channel
0000E774                          M 	even
0000E774                          M .data
0000E774 7A00                     M 	moveq	#0,d5
0000E776 1A1C                     M 	move.b	(a4)+,d5
0000E778 0C05 00E0                M 	cmpi.b	#$e0,d5
0000E77C 6500                     M 	blo.s	.notcomm
0000E77E 4EBA 0000                M 	jsr	dcommands(pc)
0000E782 60F0                     M 	bra.s	.data
0000E784 6094                     M 	bra.s	.next
0000E786                          M .notcomm
0000E786 7C00                       		moveq	#0,d6			; clear rest flag
0000E788 4A05                       		tst.b	d5			; check if note is being played
0000E78A 6A00                       		bpl.s	.timer			; if not, it must be a timer. Branch
0000E78C                            
0000E78C                            	dTrackNoteDAC				; calculate frequency or update sample
0000E78C 0815 0000                M 	btst	#cfbmode,(a5)
0000E790 6600                     M 	bne.s	.pitch
0000E792 1B45 000B                M 	move.b	d5,csample(a5)
0000E796 6000                     M 	bra.s	.cont
0000E798                          M .pitch
0000E798 0405 0080                M 	subi.b	#$80,d5
0000E79C 6600                     M 	bne.s	.noprest
0000E79E 7000                     M 	moveq	#0,d0
0000E7A0 6100 0000                M 	bsr.w	dnoteondac2
0000E7A4 7C80                     M 	moveq	#-$80,d6
0000E7A6 6000                     M 	bra.s	.cont
0000E7A8                          M .noprest
0000E7A8 DA2D 0008                M 	add.b	cpitch(a5),d5
0000E7AC DA45                     M 	add.w	d5,d5
0000E7AE 43FA 0000                M 	lea	dfreqdac(pc),a1
0000E7B2 3B71 5000 000E           M 	move.w	(a1,d5.w),cfreq(a5)
0000E7B8                          M .cont
0000E7B8 1A1C                       		move.b	(a4)+,d5		; check if next note is a timer
0000E7BA 6A00                       		bpl.s	.timer			; if yes, handle timer
0000E7BC 534C                       		subq.w	#1,a4			; else, undo the increment
0000E7BE 6000                       		bra.s	.pcnote			; do not calculate duration
0000E7C0                            
0000E7C0                            .timer
0000E7C0 4EBA 0000                  		jsr	dCalcDuration(pc)	; calculate duration
0000E7C4                            .pcnote
0000E7C4                            	dProcNote 0, 0				; reset necessary channel memory
0000E7C4 2B4C 0002                M 	move.l	a4,cdata(a5)
0000E7C8 1B6D 000D 000C           M 	move.b	clastdur(a5),cduration(a5)
0000E7CE 0815 0002                M 	btst	#cfbhold,(a5)
0000E7D2 6600                     M 	bne.s	.endpn
0000E7D4 1B6D 001D 001C           M 	move.b	cnotetimemain(a5),cnotetimecur(a5)
0000E7DA 0815 0003                M 	btst	#cfbmod,(a5)
0000E7DE 6700                     M 	beq.s	.endpn
0000E7E0 226D 0010                M 	movea.l	cmod(a5),a1
0000E7E4 1B59 0010                M 	move.b	(a1)+,cmoddelay(a5)
0000E7E8 1B59 0016                M 	move.b	(a1)+,cmodspeed(a5)
0000E7EC 1B59 0017                M 	move.b	(a1)+,cmodstep(a5)
0000E7F0 1011                     M 	move.b	(a1),d0
0000E7F2 E208                     M 	lsr.b	#1,d0
0000E7F4 1B40 0018                M 	move.b	d0,cmodcount(a5)
0000E7F8 426D 0014                M 	clr.w	cmodfreq(a5)
0000E7FC                          M .endpn
0000E7FC                            
0000E7FC 4A06                       		tst.b	d6			; check if channel was resting
0000E7FE 6B00                       		bmi.s	.noplay			; if yes, we do not want to note on anymore
0000E800 6100                       		bsr.s	dNoteOnDAC		; do hardware note-on behavior
0000E802                            
0000E802 51CF FE84                  .noplay		dbf	d7,dAMPSdoDAC		; make sure to run all the channels
0000E806 4EFA 0000                  		jmp	dAMPSdoFM(pc)		; after that, process FM channels
0000E80A                            ; ===========================================================================
0000E80A                            ; ---------------------------------------------------------------------------
0000E80A                            ; Write DAC sample information to Dual PCM
0000E80A                            ; ---------------------------------------------------------------------------
0000E80A                            
0000E80A                            dNoteOnDAC2:
0000E80A 0815 0001                  		btst	#cfbInt,(a5)		; is the channel interrupted by SFX?
0000E80E 6700                       		beq.s	dNoteOnDAC3		; if not, process note
0000E810 4E75                       		rts
0000E812                            
0000E812                            dNoteOnDAC:
0000E812 0815 0001                  		btst	#cfbInt,(a5)		; is the channel interrupted by SFX?
0000E816 6600                       		bne.s	locret_dNoteOnDAC4	; if so, do not note on or update frequency
0000E818                            
0000E818 7000                       		moveq	#0,d0			; make sure the upper byte is clear
0000E81A 102D 000B                  		move.b	cSample(a5),d0		; get sample ID to d0
0000E81E 0A00 0080                  		eor.b	#$80,d0			; this allows us to have the full $100 range safely
0000E822 0815 0002                  		btst	#cfbHold,(a5)		; check if note is held
0000E826 6600 0000                  		bne.w	dUpdateFreqOffDAC2	; if so, only update frequency
0000E82A                            
0000E82A                            dNoteOnDAC3:
0000E82A E948                       		lsl.w	#4,d0			; multiply sample ID by $10 (size of each entry)
0000E82C 47F6 0000                  		lea	(a6,d0.w),a3		; get sample data to a3
0000E830                            
0000E830 487A 0000                  		pea	dUpdateFreqOffDAC(pc)	; update frequency after loading sample
0000E834 082D 0002 0001             		btst	#ctbPt2,cType(a5)	; check if this channel is DAC1
0000E83A 6700                       		beq.s	dNoteWriteDAC1		; if is, branch
0000E83C                            ; ---------------------------------------------------------------------------
0000E83C                            ; This code is for updating the note to Dual PCM. We have tracker commands
0000E83C                            ; for also playing notes on DAC channels, which is why the code seems a
0000E83C                            ; little weird.
0000E83C                            ; ---------------------------------------------------------------------------
0000E83C                            
0000E83C                            dNoteWriteDAC2:
0000E83C 43F9 0000 0000             		lea	dZ80+PCM2_Sample,a1	; load addresses for PCM 1
0000E842 45F9 0000 0000             		lea	dZ80+PCM2_NewRET,a2	; ''
0000E848 6000                       		bra.s	dNoteOnDAC4
0000E84A                            
0000E84A                            dNoteWriteDAC1:
0000E84A                            
0000E84A 43F9 0000 0000             		lea	dZ80+PCM1_Sample,a1	; load addresses for PCM 2
0000E850 45F9 0000 0000             		lea	dZ80+PCM1_NewRET,a2	; ''
0000E856                            
0000E856                            dNoteOnDAC4:
0000E856                            	StopZ80					; wait for Z80 to stop
0000E856 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0000E85E                          M 	waitz80stop
0000E85E 0839 0000 00A1 1100      M .wait_558:	btst	#0,z80_bus_req
0000E866 66F6                     M 	bne.s	.wait_558
0000E868                            	rept 12
0000E868                            		move.b	(a3)+,(a1)+		; send sample data to Dual PCM
0000E868                            	endr
0000E868 12DB                     M 	move.b	(a3)+,(a1)+
0000E86A 12DB                     M 	move.b	(a3)+,(a1)+
0000E86C 12DB                     M 	move.b	(a3)+,(a1)+
0000E86E 12DB                     M 	move.b	(a3)+,(a1)+
0000E870 12DB                     M 	move.b	(a3)+,(a1)+
0000E872 12DB                     M 	move.b	(a3)+,(a1)+
0000E874 12DB                     M 	move.b	(a3)+,(a1)+
0000E876 12DB                     M 	move.b	(a3)+,(a1)+
0000E878 12DB                     M 	move.b	(a3)+,(a1)+
0000E87A 12DB                     M 	move.b	(a3)+,(a1)+
0000E87C 12DB                     M 	move.b	(a3)+,(a1)+
0000E87E 12DB                     M 	move.b	(a3)+,(a1)+
0000E880                            
0000E880 14BC 00DA                  		move.b	#$DA,(a2)		; activate sample switch (change instruction)
0000E884                            	StartZ80				; enable Z80 execution
0000E884 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0000E88C                            
0000E88C                            locret_dNoteOnDAC4:
0000E88C 4E75                       		rts
0000E88E                            ; ===========================================================================
0000E88E                            ; ---------------------------------------------------------------------------
0000E88E                            ; Write DAC frequency to Dual PCM
0000E88E                            ; ---------------------------------------------------------------------------
0000E88E                            
0000E88E                            dUpdateFreqOffDAC2:
0000E88E E948                       		lsl.w	#4,d0			; multiply sample ID by $10 (size of each entry)
0000E890 47F6 000C                  		lea	$0C(a6,d0.w),a3		; get sample pitch to a3
0000E894                            
0000E894                            dUpdateFreqOffDAC:
0000E894 3C2D 000E                  		move.w	cFreq(a5),d6		; get channel base frequency to d6
0000E898 DC5B                       		add.w	(a3)+,d6		; add sample frequency offset to d6
0000E89A                            
0000E89A 102D 0007                  		move.b	cDetune(a5),d0		; get detune value
0000E89E 4880                       		ext.w	d0			; extend to word
0000E8A0 DC40                       		add.w	d0,d6			; add it to d6
0000E8A2                            
0000E8A2 0815 0003                  		btst	#cfbMod,(a5)		; check if channel is modulating
0000E8A6 6700                       		beq.s	dUpdateFreqDAC3		; if not, branch
0000E8A8 DC6D 0014                  		add.w	cModFreq(a5),d6		; add modulation frequency offset to d6
0000E8AC 6000                       		bra.s	dUpdateFreqDAC3
0000E8AE                            
0000E8AE                            dUpdateFreqDAC:
0000E8AE 0815 0001                  		btst	#cfbInt,(a5)		; is the channel interrupted by SFX?
0000E8B2 6600                       		bne.s	locret_UpdFreqDAC	; if so, branch
0000E8B4                            
0000E8B4                            dUpdateFreqDAC2:
0000E8B4 7000                       		moveq	#0,d0			; make sure the upper byte is clear
0000E8B6 102D 000B                  		move.b	cSample(a5),d0		; get sample ID to d0
0000E8BA 0A00 0080                  		eor.b	#$80,d0			; this allows us to have the full $100 range safely
0000E8BE E948                       		lsl.w	#4,d0			; multiply ID by $10 (size of each entry)
0000E8C0 DC76 000C                  		add.w	$0C(a6,d0.w),d6		; add sample frequency offset to d6
0000E8C4                            
0000E8C4                            dUpdateFreqDAC3:
0000E8C4                            		AMPS_Debug_FreqDAC		; check if DAC frequency is in bounds
0000E8C4 0C46 1000                M 	cmp.w	#maxpitch,d6
0000E8C8 6E00                     M 	bgt.s	.fail
0000E8CA 0C46 F000                M 	cmp.w	#-maxpitch,d6
0000E8CE 6C00                     M 	bge.s	.ok
0000E8D0                          M .fail
0000E8D0 4EBA F664                M 	jsr	amps_debugr_freqdac
0000E8D4                          M .ok
0000E8D4                            
0000E8D4 1006                       		move.b	d6,d0			; copy the frequency to d0
0000E8D6 E04E                       		lsr.w	#8,d6			; get the upper byte to the lower byte
0000E8D8 082D 0002 0001             		btst	#ctbPt2,cType(a5)	; check if DAC1
0000E8DE 6700                       		beq.s	dFreqDAC1		; if is, branch
0000E8E0                            
0000E8E0                            	StopZ80					; wait for Z80 to stop
0000E8E0 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0000E8E8                          M 	waitz80stop
0000E8E8 0839 0000 00A1 1100      M .wait_562:	btst	#0,z80_bus_req
0000E8F0 66F6                     M 	bne.s	.wait_562
0000E8F2 13C6 0000 0000             		move.b	d6,dZ80+PCM2_PitchHigh+1
0000E8F8 13C0 0000 0000             		move.b	d0,dZ80+PCM2_PitchLow+1
0000E8FE 13FC 00D2 0000 0000        		move.b	#$D2,dZ80+PCM2_ChangePitch; change "JP C" to "JP NC"
0000E906                            	StartZ80				; enable Z80 execution
0000E906 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0000E90E                            
0000E90E                            locret_UpdFreqDAC;
0000E90E 4E75                       		rts
0000E910                            
0000E910                            dFreqDAC1:
0000E910                            	StopZ80					; wait for Z80 to stop
0000E910 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0000E918                          M 	waitz80stop
0000E918 0839 0000 00A1 1100      M .wait_565:	btst	#0,z80_bus_req
0000E920 66F6                     M 	bne.s	.wait_565
0000E922 13C6 0000 0000             		move.b	d6,dZ80+PCM1_PitchHigh+1
0000E928 13C0 0000 0000             		move.b	d0,dZ80+PCM1_PitchLow+1
0000E92E 13FC 00D2 0000 0000        		move.b	#$D2,dZ80+PCM1_ChangePitch; change "JP C" to "JP NC"
0000E936                            	StartZ80				; enable Z80 execution
0000E936 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0000E93E 4E75                       		rts
0000E940                            ; ===========================================================================
0000E940                            ; ---------------------------------------------------------------------------
0000E940                            ; Routine to multiply duration by tick rate
0000E940                            ; We actually use a dbf loop instead of mulu, because 2 rounds
0000E940                            ; around the loop will be faster than a single mulu instruction
0000E940                            ; ---------------------------------------------------------------------------
0000E940                            
0000E940                            dCalcDuration:
0000E940 7000                       		moveq	#0,d0			; clear duration
0000E942 7200                       		moveq	#0,d1			; clear upper bytes (for dbf)
0000E944 122D 000A                  		move.b	cTick(a5),d1		; get tick multiplier to d1
0000E948                            
0000E948 D005                       .multiply	add.b	d5,d0			; add duration value to d0
0000E94A 51C9 FFFC                  		dbf	d1,.multiply		; multiply by tick rate
0000E94E                            
0000E94E 1B40 000D                  		move.b	d0,cLastDur(a5)		; save as the new duration
0000E952 4E75                       		rts				; get copied to duration by later code
0000E954                            ; ===========================================================================
0000E954                            ; ---------------------------------------------------------------------------
0000E954                            ; Process SFX DAC channels
0000E954                            ; ---------------------------------------------------------------------------
0000E954                            
0000E954                            dAMPSdoSFX:
0000E954 4BF8 C660                  		lea	mSFXDAC1-cSizeSFX.w,a5	; get SFX DAC1 channel RAM address into a5
0000E958                            
0000E958                            dAMPSdoDACSFX:
0000E958 DAFC 001C                  		add.w	#cSizeSFX,a5		; go to the next channel
0000E95C 4A15                       		tst.b	(a5)			; check if channel is running a tracker
0000E95E 6A00                       		bpl.s	.next			; if not, branch
0000E960                            
0000E960 4DFA 0000                  		lea	SampleList(pc),a6	; get SampleList to a6 for quick access
0000E964 532D 000C                  		subq.b	#1,cDuration(a5)	; decrease note duration
0000E968 6700 0000                  		beq.w	.update			; if timed out, update channel
0000E96C                            
0000E96C                            	dCalcFreq				; calculate channel base frequency
0000E96C 1C2D 0007                M 	move.b	cdetune(a5),d6
0000E970 4886                     M 	ext.w	d6
0000E972 DC6D 000E                M 	add.w	cfreq(a5),d6
0000E976                            	dModulate dAMPSdoFMSFX, dAMPSdoDAC, 5	; run modulation code
0000E976 0815 0003                M 	btst	#cfbmod,(a5)
0000E97A 6700                     M 	beq.s	.noret
0000E97C 4A2D 0010                M 	tst.b	cmoddelay(a5)
0000E980 6700                     M 	beq.s	.started
0000E982 532D 0010                M 	subq.b	#1,cmoddelay(a5)
0000E986                          M .noret
0000E986 0895 0005                M 	bclr	#cfbvol,(a5)
0000E98A 6700                     M 	beq.s	.noupdatevol
0000E98C 4EBA 0000                M 	jsr	dupdatevoldac(pc)
0000E990                          M 	.noupdatevol:
0000E990 6000 0000                M 	bra.w	dampsdofmsfx
0000E994                          M .started
0000E994 532D 0016                M 	subq.b	#1,cmodspeed(a5)
0000E998 66EC                     M 	bne.s	.noret
0000E99A 226D 0010                M 	movea.l	cmod(a5),a1
0000E99E 1B69 0001 0016           M 	move.b	1(a1),cmodspeed(a5)
0000E9A4 4A2D 0018                M 	tst.b	cmodcount(a5)
0000E9A8 6600                     M 	bne.s	.norev
0000E9AA 1B69 0003 0018           M 	move.b	3(a1),cmodcount(a5)
0000E9B0 442D 0017                M 	neg.b	cmodstep(a5)
0000E9B4                          M .norev
0000E9B4 532D 0018                M 	subq.b	#1,cmodcount(a5)
0000E9B8 1A2D 0017                M 	move.b	cmodstep(a5),d5
0000E9BC 4885                     M 	ext.w	d5
0000E9BE DA6D 0014                M 	add.w	cmodfreq(a5),d5
0000E9C2 3B45 0014                M 	move.w	d5,cmodfreq(a5)
0000E9C6 DC45                     M 	add.w	d5,d6
0000E9C8 6100 FEEA                  		bsr.w	dUpdateFreqDAC2		; if frequency needs changing, do it
0000E9CC                            
0000E9CC 0895 0005                  		bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0000E9D0 6700                       		beq.s	.next			; if not, skip
0000E9D2 6100 0000                  		bsr.w	dUpdateVolDAC2		; update DAC volume
0000E9D6                            
0000E9D6                            .next
0000E9D6 4EFA 0000                  		jmp	dAMPSdoFMSFX(pc)	; after that, process SFX FM channels
0000E9DA                            
0000E9DA                            .update
0000E9DA 0215 00FB                  		and.b	#$FF-(1<<cfbHold),(a5)	; clear hold flag
0000E9DE                            	dDoTracker				; process tracker
0000E9DE 286D 0002                M 	movea.l	cdata(a5),a4
0000E9E2                          M 	amps_debug_trackupd
0000E9E2 220C                     M 	move.l	a4,d1
0000E9E4 0281 00FF FFFF           M 	and.l	#$ffffff,d1
0000E9EA 0C81 0000 0000           M 	cmp.l	#sfxaddr,d1
0000E9F0 6500                     M 	blo.s	.fail2
0000E9F2 0C81 0000 0000           M 	cmp.l	#dacaddr,d1
0000E9F8 6500                     M 	blo.s	.data
0000E9FA                          M .fail2
0000E9FA                          M 	raiseerror	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_channel
0000E9FA 487A FFFE                M 	pea	*(pc)
0000E9FE                          M 	raiseerror2	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_channel
0000E9FE 40E7                     M 	move.w	sr,-(sp)
0000EA00                          M 	__fstring_generateargumentscode	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EA00 =0000001A                M 	__pos:	set instr("Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000EA00 =00000000                M 	__stack:set	0
0000EA00 =00000000                M 	__sp:	set 0
0000EA00                          M 	while	(__pos)
0000EA00 =00000021                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000EA00 =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000EA00 =00000021                M 	__midpos:	= __endpos
0000EA00                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EA00                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EA00                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EA00                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EA00                          M 	pushp	"move.l a4,-(sp)"
0000EA00 =00000001                M 	__stack:	= __stack+1
0000EA00 =00000004                M 	__sp:	= __sp+4
0000EA00 =00000022                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000EA00 =00000029                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000EA00 =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000EA00 =00000029                M 	__midpos:	= __endpos
0000EA00                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EA00                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EA00 =0000002A                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000EA00 =00000035                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000EA00 =00000031                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000EA00                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EA00                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EA00                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EA00                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EA00                          M 	pushp	"move.l a4,-(sp)"
0000EA00 =00000002                M 	__stack:	= __stack+1
0000EA00 =00000008                M 	__sp:	= __sp+4
0000EA00 =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000EA00                          M 	rept	__stack
0000EA00                          M 	popp	__command
0000EA00 2F0C                     M 	move.l	a4,-(sp)
0000EA02                          M 	popp	__command
0000EA02 2F0C                     M 	move.l	a4,-(sp)
0000EA04 4EB9 0000 0000           M 	jsr	errorhandler
0000EA0A                          M 	__fstring_generatedecodedstring	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EA0A =00000001                M 	__lpos:	set 1
0000EA0A =0000001A                M 	__pos:	set instr("Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000EA0A                          M 	while	(__pos)
0000EA0A                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EA0A 496E 7661 6C69 6420 7472+M 	dc.b	"Invalid tracker address: "
0000EA23 =00000021                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000EA23 =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000EA23 =00000021                M 	__midpos:	= __endpos
0000EA23                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EA23                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EA23                          M 	__param:	substr ,,"hex"
0000EA23 83                       M 	dc.b	hex|3
0000EA24 =00000022                M 	__lpos:	set __endpos+1
0000EA24 =00000022                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000EA24                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EA24                          M 	dc.b	""
0000EA24 =00000029                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000EA24 =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000EA24 =00000029                M 	__midpos:	= __endpos
0000EA24                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EA24                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EA24 E0                       M 	dc.b	fendl
0000EA25 =0000002A                M 	__lpos:	set __endpos+1
0000EA25 =0000002A                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000EA25                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EA25                          M 	dc.b	""
0000EA25 =00000035                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000EA25 =00000031                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000EA25                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EA25                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EA25 B3                       M 	dc.b	sym|3
0000EA26 =00000036                M 	__lpos:	set __endpos+1
0000EA26 =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000EA26                          M 	__substr:	substr __lpos,,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000EA26                          M 	dc.b	""
0000EA26 00                       M 	dc.b	0
0000EA27 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000EA28                          M 	even
0000EA28 4EFA E852                M 	jmp	amps_debug_console_channel
0000EA2C                          M 	even
0000EA2C                          M .data
0000EA2C 7A00                     M 	moveq	#0,d5
0000EA2E 1A1C                     M 	move.b	(a4)+,d5
0000EA30 0C05 00E0                M 	cmpi.b	#$e0,d5
0000EA34 6500                     M 	blo.s	.notcomm
0000EA36 4EBA 0000                M 	jsr	dcommands(pc)
0000EA3A 60F0                     M 	bra.s	.data
0000EA3C 6098                     M 	bra.s	.next
0000EA3E                          M .notcomm
0000EA3E 7C00                       		moveq	#0,d6			; clear rest flag
0000EA40 4A05                       		tst.b	d5			; check if note is being played
0000EA42 6A00                       		bpl.s	.timer			; if not, it must be a timer. Branch
0000EA44                            
0000EA44                            	dTrackNoteDAC				; calculate frequency or update sample
0000EA44 0815 0000                M 	btst	#cfbmode,(a5)
0000EA48 6600                     M 	bne.s	.pitch
0000EA4A 1B45 000B                M 	move.b	d5,csample(a5)
0000EA4E 6000                     M 	bra.s	.cont
0000EA50                          M .pitch
0000EA50 0405 0080                M 	subi.b	#$80,d5
0000EA54 6600                     M 	bne.s	.noprest
0000EA56 7000                     M 	moveq	#0,d0
0000EA58 6100 FDB0                M 	bsr.w	dnoteondac2
0000EA5C 7C80                     M 	moveq	#-$80,d6
0000EA5E 6000                     M 	bra.s	.cont
0000EA60                          M .noprest
0000EA60 DA2D 0008                M 	add.b	cpitch(a5),d5
0000EA64 DA45                     M 	add.w	d5,d5
0000EA66 43FA 0000                M 	lea	dfreqdac(pc),a1
0000EA6A 3B71 5000 000E           M 	move.w	(a1,d5.w),cfreq(a5)
0000EA70                          M .cont
0000EA70 1A1C                       		move.b	(a4)+,d5		; check if next note is a timer
0000EA72 6A00                       		bpl.s	.timer			; if yes, handle timer
0000EA74 534C                       		subq.w	#1,a4			; else, undo the increment
0000EA76 6000                       		bra.s	.pcnote			; do not calculate duration
0000EA78                            
0000EA78                            .timer
0000EA78 4EBA FEC6                  		jsr	dCalcDuration(pc)	; calculate duration
0000EA7C                            .pcnote
0000EA7C                            	dProcNote 1, 0				; reset necessary channel memory
0000EA7C 2B4C 0002                M 	move.l	a4,cdata(a5)
0000EA80 1B6D 000D 000C           M 	move.b	clastdur(a5),cduration(a5)
0000EA86 0815 0002                M 	btst	#cfbhold,(a5)
0000EA8A 6600                     M 	bne.s	.endpn
0000EA8C 0815 0003                M 	btst	#cfbmod,(a5)
0000EA90 6700                     M 	beq.s	.endpn
0000EA92 226D 0010                M 	movea.l	cmod(a5),a1
0000EA96 1B59 0010                M 	move.b	(a1)+,cmoddelay(a5)
0000EA9A 1B59 0016                M 	move.b	(a1)+,cmodspeed(a5)
0000EA9E 1B59 0017                M 	move.b	(a1)+,cmodstep(a5)
0000EAA2 1011                     M 	move.b	(a1),d0
0000EAA4 E208                     M 	lsr.b	#1,d0
0000EAA6 1B40 0018                M 	move.b	d0,cmodcount(a5)
0000EAAA 426D 0014                M 	clr.w	cmodfreq(a5)
0000EAAE                          M .endpn
0000EAAE 4A06                       		tst.b	d6			; check if channel was resting
0000EAB0 6B00                       		bmi.s	.noplay			; if yes, we do not want to note on anymore
0000EAB2 6100 FD5E                  		bsr.w	dNoteOnDAC		; do hardware note-on behavior
0000EAB6                            
0000EAB6                            .noplay
0000EAB6 4EFA 0000                  		jmp	dAMPSdoFMSFX(pc)	; after that, process SFX FM channels
0000EABA                            ; ===========================================================================
0000EABA                            ; ---------------------------------------------------------------------------
0000EABA                            ; Write DAC volume to Dual PCM
0000EABA                            ; ---------------------------------------------------------------------------
0000EABA                            
0000EABA                            dUpdateVolDAC:
0000EABA 0815 0001                  		btst	#cfbInt,(a5)		; is the channel interrupted by SFX?
0000EABE 6600                       		bne.s	locret_VolDAC		; if yes, do not update
0000EAC0                            
0000EAC0                            dUpdateVolDAC2:
0000EAC0 162D 0009                  		move.b	cVolume(a5),d3		; get channel volume to d3
0000EAC4 D638 C4C0                  		add.b	mMasterVolDAC.w,d3	; add master volume to it
0000EAC8 6A00                       		bpl.s	.gotvol			; if positive (in range), branch
0000EACA 7680                       		moveq	#$FFFFFF80,d3		; force volume to mute ($80 is the last valid volume)
0000EACC                            
0000EACC                            .gotvol
0000EACC                            	StopZ80					; wait for Z80 to stop
0000EACC 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0000EAD4                          M 	waitz80stop
0000EAD4 0839 0000 00A1 1100      M .wait_578:	btst	#0,z80_bus_req
0000EADC 66F6                     M 	bne.s	.wait_578
0000EADE 13FC 00D2 0000 0000        		move.b	#$D2,dZ80+PCM_ChangeVolume; set volume change flag
0000EAE6                            
0000EAE6 082D 0002 0001             		btst	#ctbPt2,cType(a5)	; check if this channel is DAC1
0000EAEC 6700                       		beq.s	.dac1			; if is, branch
0000EAEE 13C3 0000 0000             		move.b	d3,dZ80+PCM2_Volume+1	; save volume for PCM 1
0000EAF4                            	StartZ80				; enable Z80 execution
0000EAF4 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0000EAFC 4E75                       		rts
0000EAFE                            
0000EAFE                            .dac1
0000EAFE 13C3 0000 0000             		move.b	d3,dZ80+PCM1_Volume+1	; save volume for PCM 2
0000EB04                            	StartZ80				; enable Z80 execution
0000EB04 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0000EB0C                            
0000EB0C                            locret_VolDAC:
0000EB0C 4E75                       		rts
0000EB0E                            ; ===========================================================================
0000EB0E                            ; ---------------------------------------------------------------------------
0000EB0E                            ; Routine for unpausing the sound driver
0000EB0E                            ; ---------------------------------------------------------------------------
0000EB0E                            
0000EB0E                            dPlaySnd_Unpause:
0000EB0E 08B8 0007 C4A6             		bclr	#mfbPaused,mFlags.w	; unpause music
0000EB14 67F6                       		beq.s	locret_VolDAC		; if was already unpaused, skip
0000EB16                            ; ---------------------------------------------------------------------------
0000EB16                            ; The following code will reset the panning values for each running
0000EB16                            ; channel. It also makes sure that the channel is not interrupted
0000EB16                            ; by sound effects, and that each running sound effect channel gets
0000EB16                            ; updated. We do not handle key on's, since that could potentially
0000EB16                            ; cause issues if notes are half-done. The next time tracker plays
0000EB16                            ; notes, they start being audible again.
0000EB16                            ; ---------------------------------------------------------------------------
0000EB16                            
0000EB16 4BF8 C51C                  		lea	mFM1.w,a5		; start from FM1 channel
0000EB1A 7804                       		moveq	#Mus_FM-1,d4		; load the number of music FM channels to d4
0000EB1C 762C                       		moveq	#cSize,d3		; get the size of each music channel to d3
0000EB1E                            
0000EB1E                            .musloop
0000EB1E 4A15                       		tst.b	(a5)			; check if the channel is running a tracker
0000EB20 6A00                       		bpl.s	.skipmus		; if not, do not update
0000EB22 0815 0001                  		btst	#cfbInt,(a5)		; is the channel interrupted by SFX?
0000EB26 6600                       		bne.s	.skipmus		; if is, do not update
0000EB28                            
0000EB28 70B4                       		moveq	#$FFFFFFB4,d0		; YM address: Panning and LFO
0000EB2A 122D 0006                  		move.b	cPanning(a5),d1		; read panning and LFO value from channel
0000EB2E 4EBA 0000                  		jsr	WriteChYM(pc)		; write to appropriate YM register
0000EB32                            
0000EB32                            .skipmus
0000EB32 DAC3                       		adda.w	d3,a5			; go to next channel
0000EB34 51CC FFE8                  		dbf	d4,.musloop		; repeat for all music FM channels
0000EB38                            
0000EB38 4BF8 C698                  		lea	mSFXFM3.w,a5		; start from SFX FM1 channel
0000EB3C 7802                       		moveq	#SFX_FM-1,d4		; load the number of SFX FM channels to d4
0000EB3E 761C                       		moveq	#cSizeSFX,d3		; get the size of each SFX channel to d3
0000EB40                            
0000EB40                            .sfxloop
0000EB40 4A15                       		tst.b	(a5)			; check if the channel is running a tracker
0000EB42 6A00                       		bpl.s	.skipsfx		; if not, do not update
0000EB44                            
0000EB44 70B4                       		moveq	#$FFFFFFB4,d0		; YM address: Panning and LFO
0000EB46 122D 0006                  		move.b	cPanning(a5),d1		; read panning and LFO value from channel
0000EB4A 4EBA 0000                  		jsr	WriteChYM(pc)		; write to appropriate YM register
0000EB4E                            
0000EB4E                            .skipsfx
0000EB4E DAC3                       		adda.w  d3,a5			; go to next channel
0000EB50 51CC FFEE                  		dbf     d4,.sfxloop		; repeat for all SFX FM channels
0000EB54                            ; ---------------------------------------------------------------------------
0000EB54                            ; Since the DAC channels have or based panning behavior, we need this
0000EB54                            ; piece of code to update its panning
0000EB54                            ; ---------------------------------------------------------------------------
0000EB54                            
0000EB54 1238 C4CA                  		move.b	mDAC1+cPanning.w,d1	; read panning value from music DAC1
0000EB58 0838 0001 C4C4             		btst	#cfbInt,mDAC1+cFlags.w	; check if music DAC1 is interrupted by SFX
0000EB5E 6700                       		beq.s	.nodacsfx		; if not, use music DAC1 panning
0000EB60 1238 C682                  		move.b	mSFXDAC1+cPanning.w,d1	; read panning value from SFX DAC1
0000EB64                            
0000EB64                            .nodacsfx
0000EB64 8238 C4F6                  		or.b	mDAC2+cPanning.w,d1	; or the panning value from music DAC2
0000EB68 70B6                       		moveq	#$FFFFFFB4+2,d0		; YM address: Panning and LFO (FM3/6)
0000EB6A 4EFA 0000                  		jmp	WriteYM_Pt2(pc)		; write to part 2 channel
0000EB6E                            ; ===========================================================================
0000EB6E                            ; ---------------------------------------------------------------------------
0000EB6E                            ; Routine for pausing the sound driver
0000EB6E                            ; ---------------------------------------------------------------------------
0000EB6E                            
0000EB6E                            dPlaySnd_Pause:
0000EB6E 08F8 0007 C4A6             		bset	#mfbPaused,mFlags.w	; pause music
0000EB74 6696                       		bne.s	locret_VolDAC		; if was already paused, skip
0000EB76                            ; ---------------------------------------------------------------------------
0000EB76                            ; The following code will set channel panning to none for all FM channels.
0000EB76                            ; This will ensure they are muted while we are pausing.
0000EB76                            ; ---------------------------------------------------------------------------
0000EB76                            
0000EB76 7602                       		moveq	#3-1,d3			; 3 channels per YM2616 "part"
0000EB78 70B4                       		moveq	#$FFFFFFB4,d0		; YM address: Panning and LFO
0000EB7A 7200                       		moveq	#0,d1			; pan to neither speaker and remove LFO
0000EB7C                            
0000EB7C                            .muteFM
0000EB7C 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to part 1 channel
0000EB80 4EBA 0000                  		jsr	WriteYM_Pt2(pc)		; write to part 2 channel
0000EB84 5200                       		addq.b	#1,d0			; go to next FM channel
0000EB86 51CB FFF4                  		dbf	d3,.muteFM		; write each 3 channels per part
0000EB8A                            ; ---------------------------------------------------------------------------
0000EB8A                            ; The following code will key off all FM channels. There is a special
0000EB8A                            ; behavior in that, we must write all channels into part 1, and we
0000EB8A                            ; control the channel we are writing in the data portion.
0000EB8A                            ; 4 bits are reserved for which operators are active (in this case,
0000EB8A                            ; none), and 3 bits are reserved for the channel we want to affect.
0000EB8A                            ; ---------------------------------------------------------------------------
0000EB8A                            
0000EB8A 7028                       		moveq	#$28,d0			; YM address: Key on/off
0000EB8C 7602                       		moveq	#%00000010,d3		; turn keys off, and start from YM channel 3
0000EB8E                            
0000EB8E                            .note
0000EB8E 1203                       		move.b	d3,d1			; copy value into d1
0000EB90 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to part 1 channel
0000EB94 5801                       		addq.b	#4,d1			; set this to part 2 channel
0000EB96 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to part 2 channel
0000EB9A 51CB FFF2                  		dbf	d3,.note		; loop for all 3 channel groups
0000EB9E                            
0000EB9E 4EBA 0000                  		jsr	dMutePSG(pc)		; mute all PSG channels
0000EBA2                            	; continue to mute all DAC channels
0000EBA2                            ; ===========================================================================
0000EBA2                            ; ---------------------------------------------------------------------------
0000EBA2                            ; Routine for muting all DAC channels
0000EBA2                            ; ---------------------------------------------------------------------------
0000EBA2                            
0000EBA2                            dMuteDAC:
0000EBA2                            	StopZ80					; wait for Z80 to stop
0000EBA2 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0000EBAA                          M 	waitz80stop
0000EBAA 0839 0000 00A1 1100      M .wait_582:	btst	#0,z80_bus_req
0000EBB2 66F6                     M 	bne.s	.wait_582
0000EBB4 45FA 0000                  		lea	SampleList(pc),a2	; load address for the stop sample data into a2
0000EBB8 43F9 0000 0000             		lea	dZ80+PCM1_Sample,a1	; load addresses for PCM 1 sample to a1
0000EBBE                            
0000EBBE                            	rept 12
0000EBBE                            		move.b	(a2)+,(a1)+		; send sample data to Dual PCM
0000EBBE                            	endr
0000EBBE 12DA                     M 	move.b	(a2)+,(a1)+
0000EBC0 12DA                     M 	move.b	(a2)+,(a1)+
0000EBC2 12DA                     M 	move.b	(a2)+,(a1)+
0000EBC4 12DA                     M 	move.b	(a2)+,(a1)+
0000EBC6 12DA                     M 	move.b	(a2)+,(a1)+
0000EBC8 12DA                     M 	move.b	(a2)+,(a1)+
0000EBCA 12DA                     M 	move.b	(a2)+,(a1)+
0000EBCC 12DA                     M 	move.b	(a2)+,(a1)+
0000EBCE 12DA                     M 	move.b	(a2)+,(a1)+
0000EBD0 12DA                     M 	move.b	(a2)+,(a1)+
0000EBD2 12DA                     M 	move.b	(a2)+,(a1)+
0000EBD4 12DA                     M 	move.b	(a2)+,(a1)+
0000EBD6                            
0000EBD6 13FC 00CA 0000 0000        		move.b	#$CA,dZ80+PCM1_NewRET	; activate sample switch (change instruction)
0000EBDE                            
0000EBDE 45FA 0000                  		lea	SampleList(pc),a2	; load address for the stop sample data into a2
0000EBE2 43F9 0000 0000             		lea	dZ80+PCM2_Sample,a1	; load addresses for PCM 2 sample to a1
0000EBE8                            
0000EBE8                            	rept 12
0000EBE8                            		move.b	(a2)+,(a1)+		; send sample data to Dual PCM
0000EBE8                            	endr
0000EBE8 12DA                     M 	move.b	(a2)+,(a1)+
0000EBEA 12DA                     M 	move.b	(a2)+,(a1)+
0000EBEC 12DA                     M 	move.b	(a2)+,(a1)+
0000EBEE 12DA                     M 	move.b	(a2)+,(a1)+
0000EBF0 12DA                     M 	move.b	(a2)+,(a1)+
0000EBF2 12DA                     M 	move.b	(a2)+,(a1)+
0000EBF4 12DA                     M 	move.b	(a2)+,(a1)+
0000EBF6 12DA                     M 	move.b	(a2)+,(a1)+
0000EBF8 12DA                     M 	move.b	(a2)+,(a1)+
0000EBFA 12DA                     M 	move.b	(a2)+,(a1)+
0000EBFC 12DA                     M 	move.b	(a2)+,(a1)+
0000EBFE 12DA                     M 	move.b	(a2)+,(a1)+
0000EC00                            
0000EC00 13FC 00CA 0000 0000        		move.b	#$CA,dZ80+PCM2_NewRET	; activate sample switch (change instruction)
0000EC08                            	StartZ80				; enable Z80 execution
0000EC08 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0000EC10                            
0000EC10                            locret_MuteDAC:
0000EC10 4E75                       		rts
0000EC12                            ; ===========================================================================
0000EC12                            ; ---------------------------------------------------------------------------
0000EC12                            ; Subroutine to play any queued music tracks, sound effects or commands
0000EC12                            ; ---------------------------------------------------------------------------
0000EC12                            
0000EC12                            dPlaySnd:
0000EC12 4DF8 C4BC                  		lea	mQueue.w,a6		; get address to the sound queue
0000EC16 7E00                       		moveq	#0,d7
0000EC18 1E1E                       		move.b	(a6)+,d7		; get sound ID for this slot
0000EC1A 6600                       		bne.s	.found			; if nonzero, a sound is queued
0000EC1C 1E1E                       		move.b	(a6)+,d7		; get sound ID for this slot
0000EC1E 6600                       		bne.s	.found			; if nonzero, a sound is queued
0000EC20 1E1E                       		move.b	(a6)+,d7		; get sound ID for this slot
0000EC22 67EC                       		beq.s	locret_MuteDAC		; if 0, no sounds were queued, return
0000EC24                            
0000EC24                            .found
0000EC24 422E FFFF                  		clr.b	-1(a6)			; clear the slot we are processing
0000EC28 0C07 0082                  		cmpi.b	#SFXoff,d7		; check if this sound was a sound effect
0000EC2C 6400 0000                  		bhs.w	dPlaySnd_SFX		; if so, handle it
0000EC30 0C07 000A                  		cmpi.b	#MusOff,d7		; check if this sound was a command
0000EC34 6500 0000                  		blo.w	dPlaySnd_Comm		; if so, handle it
0000EC38                            	; it was music, handle it below
0000EC38                            ; ===========================================================================
0000EC38                            ; ---------------------------------------------------------------------------
0000EC38                            ; Subroutine to play a queued music track
0000EC38                            ; ---------------------------------------------------------------------------
0000EC38                            
0000EC38                            dPlaySnd_Music:
0000EC38 4EBA 0000                  		jsr	dStopMusic(pc)		; mute hardware and reset all driver memory
0000EC3C 4EBA 0000                  		jsr	dResetVolume(pc)	; reset volumes and end any fades
0000EC40                            ; ---------------------------------------------------------------------------
0000EC40                            ; To save few cycles, we don't directly substract the music offset from
0000EC40                            ; the ID, and instead offset the table position. In practice this will
0000EC40                            ; have the same effect, but saves us 8 cycles overall.
0000EC40                            ; ---------------------------------------------------------------------------
0000EC40                            
0000EC40 49FA 0000                  		lea	MusicIndex-(MusOff*4)(pc),a4; get music pointer table with an offset
0000EC44 DE47                       		add.w	d7,d7			; quadruple music ID
0000EC46 DE47                       		add.w	d7,d7			; since each entry is 4 bytes in size
0000EC48 11F4 7000 C4B9             		move.b	(a4,d7.w),mTempoSpeed.w	; load speed shoes tempo from the unused 8 bits
0000EC4E 2874 7000                  		movea.l	(a4,d7.w),a4		; get music header pointer from the table
0000EC52                            
0000EC52 200C                       		move.l	a4,d0			; copy pointer to d0
0000EC54 0280 00FF FFFF             		and.l	#$FFFFFF,d0		; clearing the upper 8 bits allows the debugger
0000EC5A 2840                       		move.l	d0,a4			; to show the address correctly. Move ptr back to a4
0000EC5C                            		AMPS_Debug_PlayTrackMus		; check if this was valid music
0000EC5C 0C80 0000 0000           M 	cmp.l	#musaddr,d0
0000EC62 6500                     M 	blo.s	.fail_584
0000EC64 0C80 0000 0000           M 	cmp.l	#musend,d0
0000EC6A 6500                     M 	blo.s	.ok_584
0000EC6C                          M .fail_584
0000EC6C E44F                     M 	lsr.w	#2,d7
0000EC6E                          M 	raiseerror	"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_main
0000EC6E 487A FFFE                M 	pea	*(pc)
0000EC72                          M 	raiseerror2	"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_main
0000EC72 40E7                     M 	move.w	sr,-(sp)
0000EC74                          M 	__fstring_generateargumentscode	"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EC74 =0000001A                M 	__pos:	set instr("Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000EC74 =00000000                M 	__stack:set	0
0000EC74 =00000000                M 	__sp:	set 0
0000EC74                          M 	while	(__pos)
0000EC74 =00000021                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000EC74 =00000023                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000EC74 =00000021                M 	__midpos:	= __endpos
0000EC74                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EC74                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EC74                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EC74                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EC74                          M 	pushp	"move.b d7,1(sp)"
0000EC74                          M 	pushp	"subq.w	#2, sp"
0000EC74 =00000002                M 	__stack:	= __stack+2
0000EC74 =00000002                M 	__sp:	= __sp+2
0000EC74 =00000024                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000EC74 =0000002B                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000EC74 =00000038                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000EC74 =0000002B                M 	__midpos:	= __endpos
0000EC74                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EC74                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EC74                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EC74                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EC74                          M 	pushp	"move.l a4,-(sp)"
0000EC74 =00000003                M 	__stack:	= __stack+1
0000EC74 =00000006                M 	__sp:	= __sp+4
0000EC74 =0000002C                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000EC74 =00000033                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000EC74 =00000038                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000EC74 =00000033                M 	__midpos:	= __endpos
0000EC74                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EC74                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EC74 =00000034                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000EC74 =0000003F                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000EC74 =0000003B                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000EC74                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EC74                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EC74                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EC74                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EC74                          M 	pushp	"move.l a4,-(sp)"
0000EC74 =00000004                M 	__stack:	= __stack+1
0000EC74 =0000000A                M 	__sp:	= __sp+4
0000EC74 =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000EC74                          M 	rept	__stack
0000EC74                          M 	popp	__command
0000EC74 2F0C                     M 	move.l	a4,-(sp)
0000EC76                          M 	popp	__command
0000EC76 2F0C                     M 	move.l	a4,-(sp)
0000EC78                          M 	popp	__command
0000EC78 554F                     M 	subq.w	#2,sp
0000EC7A                          M 	popp	__command
0000EC7A 1F47 0001                M 	move.b	d7,1(sp)
0000EC7E 4EB9 0000 0000           M 	jsr	errorhandler
0000EC84                          M 	__fstring_generatedecodedstring	"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EC84 =00000001                M 	__lpos:	set 1
0000EC84 =0000001A                M 	__pos:	set instr("Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000EC84                          M 	while	(__pos)
0000EC84                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EC84 496E 7661 6C69 6420 7472+M 	dc.b	"Invalid tracker at Music "
0000EC9D =00000021                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000EC9D =00000023                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000EC9D =00000021                M 	__midpos:	= __endpos
0000EC9D                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EC9D                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EC9D                          M 	__param:	substr ,,"hex"
0000EC9D 80                       M 	dc.b	hex
0000EC9E =00000022                M 	__lpos:	set __endpos+1
0000EC9E =00000024                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000EC9E                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EC9E 3A20                     M 	dc.b	": "
0000ECA0 =0000002B                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000ECA0 =00000038                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000ECA0 =0000002B                M 	__midpos:	= __endpos
0000ECA0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ECA0                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ECA0                          M 	__param:	substr ,,"hex"
0000ECA0 83                       M 	dc.b	hex|3
0000ECA1 =0000002C                M 	__lpos:	set __endpos+1
0000ECA1 =0000002C                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000ECA1                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ECA1                          M 	dc.b	""
0000ECA1 =00000033                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000ECA1 =00000038                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000ECA1 =00000033                M 	__midpos:	= __endpos
0000ECA1                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ECA1                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ECA1 E0                       M 	dc.b	fendl
0000ECA2 =00000034                M 	__lpos:	set __endpos+1
0000ECA2 =00000034                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000ECA2                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ECA2                          M 	dc.b	""
0000ECA2 =0000003F                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000ECA2 =0000003B                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000ECA2                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ECA2                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ECA2 B3                       M 	dc.b	sym|3
0000ECA3 =00000040                M 	__lpos:	set __endpos+1
0000ECA3 =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000ECA3                          M 	__substr:	substr __lpos,,"Invalid tracker at Music %<.b d7>: %<.l a4>%<fendl>%<.l a4 sym>"
0000ECA3                          M 	dc.b	""
0000ECA3 00                       M 	dc.b	0
0000ECA4 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000ECA6 00                       M 	even
0000ECA6 4EFA ED7A                M 	jmp	amps_debug_console_main
0000ECAA                          M 	even
0000ECAA                          M .ok_584
0000ECAA                            
0000ECAA 264C                       		move.l	a4,a3			; copy pointer to a3
0000ECAC 584C                       		addq.w	#4,a4			; go to DAC1 data section
0000ECAE                            
0000ECAE 7000                       		moveq	#0,d0
0000ECB0 102B 0001                  		move.b	1(a3),d0		; load song tempo to d0
0000ECB4 11C0 C4B8                  		move.b	d0,mTempoMain.w		; save as regular tempo
0000ECB8 0838 0001 C4A6             		btst	#mfbSpeed,mFlags.w	; check if speed shoes flag was set
0000ECBE 6700                       		beq.s	.tempogot		; if not, use main tempo
0000ECC0 1038 C4B9                  		move.b	mTempoSpeed.w,d0	; load speed shoes tempo to d0 instead
0000ECC4                            
0000ECC4                            .tempogot
0000ECC4 11C0 C4BA                  		move.b	d0,mTempo.w		; save as the current tempo
0000ECC8 11C0 C4BB                  		move.b	d0,mTempoCur.w		; copy into the accumulator/counter
0000ECCC 0238 00F7 C4A6             		and.b	#$FF-(1<<mfbNoPAL),mFlags.w; enable PAL fix
0000ECD2                            ; ---------------------------------------------------------------------------
0000ECD2                            ; If the 7th bit (msb) of tick multiplier is set, PAL fix gets
0000ECD2                            ; disabled. I know, very weird place to put it, but we dont have
0000ECD2                            ; much free room in the song header
0000ECD2                            ; ---------------------------------------------------------------------------
0000ECD2                            
0000ECD2 1813                       		move.b	(a3),d4			; load the tick multiplier to d4
0000ECD4 6A00                       		bpl.s	.noPAL			; branch if the loaded value was positive
0000ECD6 0244 007F                  		and.w	#$7F,d4			; keep value in range
0000ECDA 0038 0008 C4A6             		or.b	#1<<mfbNoPAL,mFlags.w	; disable PAL fix
0000ECE0                            
0000ECE0                            .noPAL
0000ECE0 74A0                       		moveq	#$FFFFFF00|(1<<cfbRun)|(1<<cfbVol),d2; prepare running tracker and volume flags into d2
0000ECE2 72C0                       		moveq	#$FFFFFFC0,d1		; prepare panning value of centre to d1
0000ECE4 7C2C                       		moveq	#cSize,d6		; prepare channel size to d6
0000ECE6 7A01                       		moveq	#1,d5			; prepare duration of 0 frames to d5
0000ECE8                            
0000ECE8 43F8 C4C4                  		lea	mDAC1.w,a1		; start from DAC1 channel
0000ECEC 45FA 0000                  		lea	dDACtypeVals(pc),a2	; prepare DAC (and FM) type value list into a2
0000ECF0 7E01                       		moveq	#2-1,d7			; always run for 2 DAC channels
0000ECF2 363C 0100                  		move.w	#$100,d3		; prepare default DAC frequency
0000ECF6                            
0000ECF6                            .loopDAC
0000ECF6 1282                       		move.b	d2,(a1)			; save channel flags
0000ECF8 135A 0001                  		move.b	(a2)+,cType(a1)		; load channel type from list
0000ECFC 1344 000A                  		move.b	d4,cTick(a1)		; set channel tick multiplier
0000ED00 1346 001E                  		move.b	d6,cStack(a1)		; reset channel stack pointer
0000ED04 1341 0006                  		move.b	d1,cPanning(a1)		; reset panning to centre
0000ED08 1345 000C                  		move.b	d5,cDuration(a1)	; reset channel duration
0000ED0C 3343 000E                  		move.w	d3,cFreq(a1)		; reset channel base frequency
0000ED10                            
0000ED10 7000                       		moveq	#0,d0
0000ED12 301C                       		move.w	(a4)+,d0		; load tracker offset to d0
0000ED14 D08B                       		add.l	a3,d0			; add music header offset to d0
0000ED16 2340 0002                  		move.l	d0,cData(a1)		; save as the tracker address of the channel
0000ED1A                            		AMPS_Debug_PlayTrackMus2 DAC	; make sure the tracker address is valid
0000ED1A 0280 00FF FFFF           M 	and.l	#$ffffff,d0
0000ED20 0C80 0000 0000           M 	cmp.l	#musaddr,d0
0000ED26 6500                     M 	blo.s	.fail_589
0000ED28 0C80 0000 0000           M 	cmp.l	#dacaddr,d0
0000ED2E 6500                     M 	blo.s	.ok_589
0000ED30                          M .fail_589
0000ED30                          M 	raiseerror	"Invalid tracker at Music dac: %<.l d0>%<fendl>%<.l d0 sym>",amps_debug_console_main
0000ED30 487A FFFE                M 	pea	*(pc)
0000ED34                          M 	raiseerror2	"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",amps_debug_console_main
0000ED34 40E7                     M 	move.w	sr,-(sp)
0000ED36                          M 	__fstring_generateargumentscode	"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000ED36 =00000020                M 	__pos:	set instr("Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000ED36 =00000000                M 	__stack:set	0
0000ED36 =00000000                M 	__sp:	set 0
0000ED36                          M 	while	(__pos)
0000ED36 =00000027                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000ED36 =00000034                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000ED36 =00000027                M 	__midpos:	= __endpos
0000ED36                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000ED36                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000ED36                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000ED36                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000ED36                          M 	pushp	"move.l d0,-(sp)"
0000ED36 =00000001                M 	__stack:	= __stack+1
0000ED36 =00000004                M 	__sp:	= __sp+4
0000ED36 =00000028                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000ED36 =0000002F                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000ED36 =00000034                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000ED36 =0000002F                M 	__midpos:	= __endpos
0000ED36                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000ED36                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000ED36 =00000030                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000ED36 =0000003B                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000ED36 =00000037                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000ED36                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000ED36                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000ED36                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000ED36                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000ED36                          M 	pushp	"move.l d0,-(sp)"
0000ED36 =00000002                M 	__stack:	= __stack+1
0000ED36 =00000008                M 	__sp:	= __sp+4
0000ED36 =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000ED36                          M 	rept	__stack
0000ED36                          M 	popp	__command
0000ED36 2F00                     M 	move.l	d0,-(sp)
0000ED38                          M 	popp	__command
0000ED38 2F00                     M 	move.l	d0,-(sp)
0000ED3A 4EB9 0000 0000           M 	jsr	errorhandler
0000ED40                          M 	__fstring_generatedecodedstring	"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000ED40 =00000001                M 	__lpos:	set 1
0000ED40 =00000020                M 	__pos:	set instr("Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000ED40                          M 	while	(__pos)
0000ED40                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000ED40 496E 7661 6C69 6420 7472+M 	dc.b	"Invalid tracker at Music \ch\: "
0000ED5F =00000027                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000ED5F =00000034                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000ED5F =00000027                M 	__midpos:	= __endpos
0000ED5F                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000ED5F                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000ED5F                          M 	__param:	substr ,,"hex"
0000ED5F 83                       M 	dc.b	hex|3
0000ED60 =00000028                M 	__lpos:	set __endpos+1
0000ED60 =00000028                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000ED60                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000ED60                          M 	dc.b	""
0000ED60 =0000002F                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000ED60 =00000034                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000ED60 =0000002F                M 	__midpos:	= __endpos
0000ED60                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000ED60                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000ED60 E0                       M 	dc.b	fendl
0000ED61 =00000030                M 	__lpos:	set __endpos+1
0000ED61 =00000030                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000ED61                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000ED61                          M 	dc.b	""
0000ED61 =0000003B                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000ED61 =00000037                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000ED61                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000ED61                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000ED61 B3                       M 	dc.b	sym|3
0000ED62 =0000003C                M 	__lpos:	set __endpos+1
0000ED62 =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000ED62                          M 	__substr:	substr __lpos,,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000ED62                          M 	dc.b	""
0000ED62 00                       M 	dc.b	0
0000ED63 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000ED64                          M 	even
0000ED64 4EFA ECBC                M 	jmp	amps_debug_console_main
0000ED68                          M 	even
0000ED68                          M .ok_589
0000ED68                            
0000ED68 135C 0009                  		move.b	(a4)+,cVolume(a1)	; load channel volume
0000ED6C 135C 000B                  		move.b	(a4)+,cSample(a1)	; load channel sample ID
0000ED70 6700                       		beq.s	.sampmode		; if 0, we are in sample mode
0000ED72 08D1 0000                  		bset	#cfbMode,(a1)		; if not 0, enable pitch mode
0000ED76                            
0000ED76                            .sampmode
0000ED76 D2C6                       		add.w	d6,a1			; go to the next channel
0000ED78 51CF FF7C                  		dbf	d7,.loopDAC		; repeat for all DAC channels
0000ED7C                            
0000ED7C 7E00                       		moveq	#0,d7
0000ED7E 7481                       		moveq	#$FFFFFF00|(1<<cfbRun)|(1<<cfbRest),d2; prepare running tracker and channel rest flags
0000ED80 1E2B 0002                  		move.b	2(a3),d7		; load the FM channel count to d7
0000ED84 6B00                       		bmi.s	.doPSG			; if no FM channels are loaded, branch
0000ED86                            
0000ED86                            .loopFM
0000ED86 1282                       		move.b	d2,(a1)			; save channel flags
0000ED88 135A 0001                  		move.b	(a2)+,cType(a1)		; load channel type from list
0000ED8C 1344 000A                  		move.b	d4,cTick(a1)		; set channel tick multiplier
0000ED90 1346 001E                  		move.b	d6,cStack(a1)		; reset channel stack pointer
0000ED94 1341 0006                  		move.b	d1,cPanning(a1)		; reset panning to centre
0000ED98 1345 000C                  		move.b	d5,cDuration(a1)	; reset channel duration
0000ED9C                            
0000ED9C 7000                       		moveq	#0,d0
0000ED9E 301C                       		move.w	(a4)+,d0		; load tracker offset to d0
0000EDA0 D08B                       		add.l	a3,d0			; add music header offset to d0
0000EDA2 2340 0002                  		move.l	d0,cData(a1)		; save as the tracker address of the channel
0000EDA6                            		AMPS_Debug_PlayTrackMus2 FM	; make sure the tracker address is valid
0000EDA6 0280 00FF FFFF           M 	and.l	#$ffffff,d0
0000EDAC 0C80 0000 0000           M 	cmp.l	#musaddr,d0
0000EDB2 6500                     M 	blo.s	.fail_594
0000EDB4 0C80 0000 0000           M 	cmp.l	#dacaddr,d0
0000EDBA 6500                     M 	blo.s	.ok_594
0000EDBC                          M .fail_594
0000EDBC                          M 	raiseerror	"Invalid tracker at Music fm: %<.l d0>%<fendl>%<.l d0 sym>",amps_debug_console_main
0000EDBC 487A FFFE                M 	pea	*(pc)
0000EDC0                          M 	raiseerror2	"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",amps_debug_console_main
0000EDC0 40E7                     M 	move.w	sr,-(sp)
0000EDC2                          M 	__fstring_generateargumentscode	"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EDC2 =00000020                M 	__pos:	set instr("Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EDC2 =00000000                M 	__stack:set	0
0000EDC2 =00000000                M 	__sp:	set 0
0000EDC2                          M 	while	(__pos)
0000EDC2 =00000027                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000EDC2 =00000034                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000EDC2 =00000027                M 	__midpos:	= __endpos
0000EDC2                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EDC2                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EDC2                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EDC2                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EDC2                          M 	pushp	"move.l d0,-(sp)"
0000EDC2 =00000001                M 	__stack:	= __stack+1
0000EDC2 =00000004                M 	__sp:	= __sp+4
0000EDC2 =00000028                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EDC2 =0000002F                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000EDC2 =00000034                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000EDC2 =0000002F                M 	__midpos:	= __endpos
0000EDC2                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EDC2                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EDC2 =00000030                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EDC2 =0000003B                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000EDC2 =00000037                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000EDC2                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EDC2                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EDC2                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EDC2                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EDC2                          M 	pushp	"move.l d0,-(sp)"
0000EDC2 =00000002                M 	__stack:	= __stack+1
0000EDC2 =00000008                M 	__sp:	= __sp+4
0000EDC2 =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EDC2                          M 	rept	__stack
0000EDC2                          M 	popp	__command
0000EDC2 2F00                     M 	move.l	d0,-(sp)
0000EDC4                          M 	popp	__command
0000EDC4 2F00                     M 	move.l	d0,-(sp)
0000EDC6 4EB9 0000 0000           M 	jsr	errorhandler
0000EDCC                          M 	__fstring_generatedecodedstring	"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EDCC =00000001                M 	__lpos:	set 1
0000EDCC =00000020                M 	__pos:	set instr("Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EDCC                          M 	while	(__pos)
0000EDCC                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EDCC 496E 7661 6C69 6420 7472+M 	dc.b	"Invalid tracker at Music \ch\: "
0000EDEB =00000027                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000EDEB =00000034                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000EDEB =00000027                M 	__midpos:	= __endpos
0000EDEB                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EDEB                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EDEB                          M 	__param:	substr ,,"hex"
0000EDEB 83                       M 	dc.b	hex|3
0000EDEC =00000028                M 	__lpos:	set __endpos+1
0000EDEC =00000028                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EDEC                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EDEC                          M 	dc.b	""
0000EDEC =0000002F                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000EDEC =00000034                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000EDEC =0000002F                M 	__midpos:	= __endpos
0000EDEC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EDEC                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EDEC E0                       M 	dc.b	fendl
0000EDED =00000030                M 	__lpos:	set __endpos+1
0000EDED =00000030                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EDED                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EDED                          M 	dc.b	""
0000EDED =0000003B                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000EDED =00000037                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000EDED                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EDED                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EDED B3                       M 	dc.b	sym|3
0000EDEE =0000003C                M 	__lpos:	set __endpos+1
0000EDEE =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EDEE                          M 	__substr:	substr __lpos,,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EDEE                          M 	dc.b	""
0000EDEE 00                       M 	dc.b	0
0000EDEF 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000EDF0                          M 	even
0000EDF0 4EFA EC30                M 	jmp	amps_debug_console_main
0000EDF4                          M 	even
0000EDF4                          M .ok_594
0000EDF4                            
0000EDF4 335C 0008                  		move.w	(a4)+,cPitch(a1)	; load pitch offset and channel volume
0000EDF8 D2C6                       		adda.w	d6,a1			; go to the next channel
0000EDFA 51CF FF8A                  		dbf	d7,.loopFM		; repeat for all FM channels
0000EDFE                            
0000EDFE                            .doPSG
0000EDFE 7E00                       		moveq	#0,d7
0000EE00 1E2B 0003                  		move.b	3(a3),d7		; load the FM channel count to d7
0000EE04 6B00 0000                  		bmi.w	.intSFX			; if no PSG channels are loaded, branch
0000EE08                            ; ---------------------------------------------------------------------------
0000EE08                            ; The reason why we delay PSG by 1 extra frame, is because of Dual PCM.
0000EE08                            ; It adds a delay of 1 frame to DAC and FM due to the YMCue, and PCM
0000EE08                            ; buffering to avoid quality loss from DMA's. This means that, since PSG
0000EE08                            ; is controlled by the 68000, we would be off by a single frame without
0000EE08                            ; this fix.
0000EE08                            ; ---------------------------------------------------------------------------
0000EE08                            
0000EE08 7A02                       		moveq	#2,d5			; prepare duration of 1 frames to d5
0000EE0A 45FA 0000                  		lea	dPSGtypeVals(pc),a2	; prepare PSG type value list into a2
0000EE0E 43F8 C5F8                  		lea	mPSG1.w,a1		; start from PSG1 channel
0000EE12                            
0000EE12                            .loopPSG
0000EE12 1282                       		move.b	d2,(a1)			; save channel flags
0000EE14 135A 0001                  		move.b	(a2)+,cType(a1)		; load channel type from list
0000EE18 1344 000A                  		move.b	d4,cTick(a1)		; set channel tick multiplier
0000EE1C 1346 001E                  		move.b	d6,cStack(a1)		; reset channel stack pointer
0000EE20 1345 000C                  		move.b	d5,cDuration(a1)	; reset channel duration
0000EE24                            
0000EE24 7000                       		moveq	#0,d0
0000EE26 301C                       		move.w	(a4)+,d0		; load tracker offset to d0
0000EE28 D08B                       		add.l	a3,d0			; add music header offset to d0
0000EE2A 2340 0002                  		move.l	d0,cData(a1)		; save as the tracker address of the channel
0000EE2E                            		AMPS_Debug_PlayTrackMus2 PSG	; make sure the tracker address is valid
0000EE2E 0280 00FF FFFF           M 	and.l	#$ffffff,d0
0000EE34 0C80 0000 0000           M 	cmp.l	#musaddr,d0
0000EE3A 6500                     M 	blo.s	.fail_599
0000EE3C 0C80 0000 0000           M 	cmp.l	#dacaddr,d0
0000EE42 6500                     M 	blo.s	.ok_599
0000EE44                          M .fail_599
0000EE44                          M 	raiseerror	"Invalid tracker at Music psg: %<.l d0>%<fendl>%<.l d0 sym>",amps_debug_console_main
0000EE44 487A FFFE                M 	pea	*(pc)
0000EE48                          M 	raiseerror2	"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",amps_debug_console_main
0000EE48 40E7                     M 	move.w	sr,-(sp)
0000EE4A                          M 	__fstring_generateargumentscode	"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE4A =00000020                M 	__pos:	set instr("Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EE4A =00000000                M 	__stack:set	0
0000EE4A =00000000                M 	__sp:	set 0
0000EE4A                          M 	while	(__pos)
0000EE4A =00000027                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000EE4A =00000034                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000EE4A =00000027                M 	__midpos:	= __endpos
0000EE4A                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE4A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE4A                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE4A                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE4A                          M 	pushp	"move.l d0,-(sp)"
0000EE4A =00000001                M 	__stack:	= __stack+1
0000EE4A =00000004                M 	__sp:	= __sp+4
0000EE4A =00000028                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EE4A =0000002F                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000EE4A =00000034                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000EE4A =0000002F                M 	__midpos:	= __endpos
0000EE4A                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE4A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE4A =00000030                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EE4A =0000003B                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000EE4A =00000037                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000EE4A                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE4A                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE4A                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE4A                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE4A                          M 	pushp	"move.l d0,-(sp)"
0000EE4A =00000002                M 	__stack:	= __stack+1
0000EE4A =00000008                M 	__sp:	= __sp+4
0000EE4A =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EE4A                          M 	rept	__stack
0000EE4A                          M 	popp	__command
0000EE4A 2F00                     M 	move.l	d0,-(sp)
0000EE4C                          M 	popp	__command
0000EE4C 2F00                     M 	move.l	d0,-(sp)
0000EE4E 4EB9 0000 0000           M 	jsr	errorhandler
0000EE54                          M 	__fstring_generatedecodedstring	"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE54 =00000001                M 	__lpos:	set 1
0000EE54 =00000020                M 	__pos:	set instr("Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EE54                          M 	while	(__pos)
0000EE54                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE54 496E 7661 6C69 6420 7472+M 	dc.b	"Invalid tracker at Music \ch\: "
0000EE73 =00000027                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000EE73 =00000034                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000EE73 =00000027                M 	__midpos:	= __endpos
0000EE73                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE73                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE73                          M 	__param:	substr ,,"hex"
0000EE73 83                       M 	dc.b	hex|3
0000EE74 =00000028                M 	__lpos:	set __endpos+1
0000EE74 =00000028                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EE74                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE74                          M 	dc.b	""
0000EE74 =0000002F                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000EE74 =00000034                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000EE74 =0000002F                M 	__midpos:	= __endpos
0000EE74                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE74                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE74 E0                       M 	dc.b	fendl
0000EE75 =00000030                M 	__lpos:	set __endpos+1
0000EE75 =00000030                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EE75                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE75                          M 	dc.b	""
0000EE75 =0000003B                M 	__endpos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000EE75 =00000037                M 	__midpos:	set instr(__pos+5,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000EE75                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE75                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE75 B3                       M 	dc.b	sym|3
0000EE76 =0000003C                M 	__lpos:	set __endpos+1
0000EE76 =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000EE76                          M 	__substr:	substr __lpos,,"Invalid tracker at Music \ch\: %<.l d0>%<fendl>%<.l d0 sym>"
0000EE76                          M 	dc.b	""
0000EE76 00                       M 	dc.b	0
0000EE77 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000EE78                          M 	even
0000EE78 4EFA EBA8                M 	jmp	amps_debug_console_main
0000EE7C                          M 	even
0000EE7C                          M .ok_599
0000EE7C                            
0000EE7C 335C 0008                  		move.w	(a4)+,cPitch(a1)	; load pitch offset and channel volume
0000EE80 135C 0007                  		move.b	(a4)+,cDetune(a1)	; load detune offset
0000EE84 135C 000B                  		move.b	(a4)+,cVolEnv(a1)	; load volume envelope ID
0000EE88 D2C6                       		adda.w	d6,a1			; go to the next channel
0000EE8A 51CF FF86                  		dbf	d7,.loopPSG		; repeat for all FM channels
0000EE8E                            
0000EE8E                            .intSFX
0000EE8E                            ; ---------------------------------------------------------------------------
0000EE8E                            ; Now follows initializing FM6 to be ready for PCM streaming,
0000EE8E                            ; and resetting the PCM filter for Dual PCM. Simply, this just
0000EE8E                            ; clears some YM registers.
0000EE8E                            ; ---------------------------------------------------------------------------
0000EE8E                            
0000EE8E 7028                       		moveq	#$28,d0			; YM address: Key on/off
0000EE90 7206                       		moveq	#6,d1			; FM6, all operators off
0000EE92 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to part 2 channel
0000EE96                            
0000EE96 727F                       		moveq	#$7F,d1			; set total level to $7F (silent)
0000EE98 7042                       		moveq	#$42,d0			; YM address: Total Level Operator 1 (FM3/6)
0000EE9A 4EBA 0000                  		jsr	WriteYM_Pt2(pc)		; write to part 2 channel
0000EE9E 704A                       		moveq	#$4A,d0			; YM address: Total Level Operator 2 (FM3/6)
0000EEA0 4EBA 0000                  		jsr	WriteYM_Pt2(pc)		; write to part 2 channel
0000EEA4 7046                       		moveq	#$46,d0			; YM address: Total Level Operator 3 (FM3/6)
0000EEA6 4EBA 0000                  		jsr	WriteYM_Pt2(pc)		; write to part 2 channel
0000EEAA 704E                       		moveq	#$4E,d0			; YM address: Total Level Operator 4 (FM3/6)
0000EEAC 4EBA 0000                  		jsr	WriteYM_Pt2(pc)		; write to part 2 channel
0000EEB0                            
0000EEB0 72C0                       		moveq	#$FFFFFFC0,d1		; set panning to centre
0000EEB2 70B6                       		moveq	#$FFFFFFB4+2,d0		; YM address: Panning and LFO (FM3/6)
0000EEB4 4EBA 0000                  		jsr	WriteYM_Pt2(pc)		; write to part 2 channel
0000EEB8                            
0000EEB8 303C 0000                  		move.w	#fLog>>$0F,d0		; use linear filter
0000EEBC 4EBA 0000                  		jsr	dSetFilter(pc)		; set filter
0000EEC0                            ; ---------------------------------------------------------------------------
0000EEC0                            ; This piece of code here handles SFX overriding our newly loaded
0000EEC0                            ; music channels. Since we did not do this at the initialization
0000EEC0                            ; step, we will handle it here instead.
0000EEC0                            ; ---------------------------------------------------------------------------
0000EEC0                            
0000EEC0 45FA 0000                  		lea	dSFXoverList(pc),a2	; load quick reference to the SFX override list
0000EEC4 43F8 C67C                  		lea	mSFXDAC1.w,a1		; start from SFX DAC1 channel
0000EEC8 7E06                       		moveq	#SFX_Ch-1,d7		; prepare total number of SFX channels into d7
0000EECA 7C1C                       		moveq	#cSizeSFX,d6		; prepare SFX channel size to d6
0000EECC                            
0000EECC                            .loopSFX
0000EECC 4A11                       		tst.b	(a1)			; check if SFX channel is running a tracker
0000EECE 6A00                       		bpl.s	.nextSFX		; if not, skip this channel
0000EED0                            
0000EED0 7000                       		moveq	#0,d0
0000EED2 1029 0001                  		move.b	cType(a1),d0		; load SFX channel type to d0
0000EED6 6B00                       		bmi.s	.SFXPSG			; if negative, it is a PSG channel
0000EED8                            
0000EED8 0240 0007                  		and.w	#$07,d0			; get only the necessary bits to d3
0000EEDC 5540                       		subq.w	#2,d0			; since FM 1 and 2 are not used, skip over them
0000EEDE D040                       		add.w	d0,d0			; double offset (each entry is 1 word in size)
0000EEE0 6000                       		bra.s	.override
0000EEE2                            ; ---------------------------------------------------------------------------
0000EEE2                            
0000EEE2                            .SFXPSG
0000EEE2 E808                       		lsr.b	#4,d0			; make it easier to reference the right offset in the table
0000EEE4                            .override
0000EEE4 3672 0000                  		move.w	(a2,d0.w),a3		; get music channel RAM address to a3
0000EEE8 08D3 0001                  		bset	#cfbInt,(a3)		; set as interrupted
0000EEEC                            
0000EEEC                            .nextSFX
0000EEEC D2C6                       		adda.w	d6,a1			; go to the next channel
0000EEEE 51CF FFDC                  		dbf	d7,.loopSFX		; repeat for all SFX channels
0000EEF2                            ; ---------------------------------------------------------------------------
0000EEF2                            ; Here we mute all non-interrupted FM and PSG channels
0000EEF2                            ; ---------------------------------------------------------------------------
0000EEF2                            
0000EEF2 4BF8 C51C                  		lea	mFM1.w,a5		; start from FM1 channel
0000EEF6 7804                       		moveq	#Mus_FM-1,d4		; prepare total number of FM channels into d7
0000EEF8                            .stopFM
0000EEF8 4EBA 0000                  		jsr	dKeyOffFM(pc)		; send key off even if not interrupted
0000EEFC DAC6                       		adda.w	d6,a5			; go to the next channel
0000EEFE 51CC FFF8                  		dbf	d4,.stopFM		; repeat for all FM channels
0000EF02                            
0000EF02 7802                       		moveq	#Mus_PSG-1,d4		; start from PSG1 channel
0000EF04                            .mutePSG
0000EF04 4EBA 0000                  		jsr	dMutePSGmus(pc)		; mute PSG channel if not interrupted
0000EF08 DAC6                       		adda.w	d6,a5			; go to the next channel
0000EF0A 51CC FFF8                  		dbf	d4,.mutePSG		; repeat for all FM channels
0000EF0E 4E75                       		rts
0000EF10                            
0000EF10                            ; ===========================================================================
0000EF10                            ; ---------------------------------------------------------------------------
0000EF10                            ; Type values for different channels. Used for playing music
0000EF10                            ; ---------------------------------------------------------------------------
0000EF10 0B0E                       dDACtypeVals:	dc.b ctDAC1, ctDAC2
0000EF12 0001 0204 05               dFMtypeVals:	dc.b ctFM1, ctFM2, ctFM3, ctFM4, ctFM5
0000EF17 80A0 C0                    dPSGtypeVals:	dc.b ctPSG1, ctPSG2, ctPSG3
0000EF1A                            		even
0000EF1A                            ; ===========================================================================
0000EF1A                            ; ---------------------------------------------------------------------------
0000EF1A                            ; Subroutine to play a queued sound effect
0000EF1A                            ; ---------------------------------------------------------------------------
0000EF1A                            
0000EF1A                            dPlaySnd_SFX:
0000EF1A                            ; ---------------------------------------------------------------------------
0000EF1A                            ; This is a little special case with Sonic 1 - 3K, where the ring
0000EF1A                            ; sound effect would change panning each time it is played. AMPS
0000EF1A                            ; emulates this behavior like the original drivers did, by
0000EF1A                            ; playing a different sound effect ID.
0000EF1A                            ; ---------------------------------------------------------------------------
0000EF1A                            
0000EF1A                            		;cmpi.b	#sfx_RingRight,d7	; check if the sound effect was the ring sound effect
0000EF1A                            		;bne.s	.noring			; if not, skip
0000EF1A                            		;bchg	#mfbRing,mFlags.w	; swap flag and check if it was set
0000EF1A                            		;beq.s	.noring			; if was not, do not change sound effect
0000EF1A                            		;move.w	#sfx_RingLeft,d7	; switch to left panned sound effect instead
0000EF1A                            ; ---------------------------------------------------------------------------
0000EF1A                            ; To save few cycles, we don't directly substract the SFX offset from
0000EF1A                            ; the ID, and instead offset the table position. In practice this will
0000EF1A                            ; have the same effect, but saves us 8 cycles overall.
0000EF1A                            ; ---------------------------------------------------------------------------
0000EF1A                            
0000EF1A                            .noring
0000EF1A 43FA 0000                  		lea	SoundIndex-(SFXoff*4)(pc),a1; get sfx pointer table with an offset to a4
0000EF1E 1207                       		move.b	d7,d1			; copy sfx ID to d1 (used later)
0000EF20 DE47                       		add.w	d7,d7			; quadruple sfx ID
0000EF22 DE47                       		add.w	d7,d7			; since each entry is 4 bytes in size
0000EF24 2871 7000                  		movea.l	(a1,d7.w),a4		; get SFX header pointer from the table
0000EF28                            
0000EF28 200C                       		move.l	a4,d0			; copy pointer to d0
0000EF2A 0280 00FF FFFF             		and.l	#$FFFFFF,d0		; clearing the upper 8 bits allows the debugger
0000EF30 2840                       		move.l	d0,a4			; to show the address correctly. Move ptr back to a4
0000EF32                            		AMPS_Debug_PlayTrackSFX		; check if this was valid sound effect
0000EF32 0C80 0000 0000           M 	cmp.l	#sfxaddr,d0
0000EF38 6500                     M 	blo.s	.fail_604
0000EF3A 0C80 0000 0000           M 	cmp.l	#musaddr,d0
0000EF40 6500                     M 	blo.s	.ok_604
0000EF42                          M .fail_604
0000EF42                          M 	raiseerror	"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_main
0000EF42 487A FFFE                M 	pea	*(pc)
0000EF46                          M 	raiseerror2	"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_main
0000EF46 40E7                     M 	move.w	sr,-(sp)
0000EF48                          M 	__fstring_generateargumentscode	"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EF48 =00000018                M 	__pos:	set instr("Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000EF48 =00000000                M 	__stack:set	0
0000EF48 =00000000                M 	__sp:	set 0
0000EF48                          M 	while	(__pos)
0000EF48 =0000001F                M 	__endpos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000EF48 =00000021                M 	__midpos:	set instr(__pos+5,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000EF48 =0000001F                M 	__midpos:	= __endpos
0000EF48                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EF48                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EF48                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EF48                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EF48                          M 	pushp	"move.b d0,1(sp)"
0000EF48                          M 	pushp	"subq.w	#2, sp"
0000EF48 =00000002                M 	__stack:	= __stack+2
0000EF48 =00000002                M 	__sp:	= __sp+2
0000EF48 =00000022                M 	__pos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000EF48 =00000029                M 	__endpos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000EF48 =00000036                M 	__midpos:	set instr(__pos+5,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000EF48 =00000029                M 	__midpos:	= __endpos
0000EF48                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EF48                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EF48                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EF48                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EF48                          M 	pushp	"move.l a4,-(sp)"
0000EF48 =00000003                M 	__stack:	= __stack+1
0000EF48 =00000006                M 	__sp:	= __sp+4
0000EF48 =0000002A                M 	__pos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000EF48 =00000031                M 	__endpos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000EF48 =00000036                M 	__midpos:	set instr(__pos+5,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000EF48 =00000031                M 	__midpos:	= __endpos
0000EF48                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EF48                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EF48 =00000032                M 	__pos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000EF48 =0000003D                M 	__endpos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000EF48 =00000039                M 	__midpos:	set instr(__pos+5,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000EF48                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EF48                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EF48                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EF48                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EF48                          M 	pushp	"move.l a4,-(sp)"
0000EF48 =00000004                M 	__stack:	= __stack+1
0000EF48 =0000000A                M 	__sp:	= __sp+4
0000EF48 =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000EF48                          M 	rept	__stack
0000EF48                          M 	popp	__command
0000EF48 2F0C                     M 	move.l	a4,-(sp)
0000EF4A                          M 	popp	__command
0000EF4A 2F0C                     M 	move.l	a4,-(sp)
0000EF4C                          M 	popp	__command
0000EF4C 554F                     M 	subq.w	#2,sp
0000EF4E                          M 	popp	__command
0000EF4E 1F40 0001                M 	move.b	d0,1(sp)
0000EF52 4EB9 0000 0000           M 	jsr	errorhandler
0000EF58                          M 	__fstring_generatedecodedstring	"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EF58 =00000001                M 	__lpos:	set 1
0000EF58 =00000018                M 	__pos:	set instr("Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000EF58                          M 	while	(__pos)
0000EF58                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EF58 496E 7661 6C69 6420 7472+M 	dc.b	"Invalid tracker at SFX "
0000EF6F =0000001F                M 	__endpos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000EF6F =00000021                M 	__midpos:	set instr(__pos+5,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000EF6F =0000001F                M 	__midpos:	= __endpos
0000EF6F                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EF6F                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EF6F                          M 	__param:	substr ,,"hex"
0000EF6F 80                       M 	dc.b	hex
0000EF70 =00000020                M 	__lpos:	set __endpos+1
0000EF70 =00000022                M 	__pos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000EF70                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EF70 3A20                     M 	dc.b	": "
0000EF72 =00000029                M 	__endpos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000EF72 =00000036                M 	__midpos:	set instr(__pos+5,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000EF72 =00000029                M 	__midpos:	= __endpos
0000EF72                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EF72                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EF72                          M 	__param:	substr ,,"hex"
0000EF72 83                       M 	dc.b	hex|3
0000EF73 =0000002A                M 	__lpos:	set __endpos+1
0000EF73 =0000002A                M 	__pos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000EF73                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EF73                          M 	dc.b	""
0000EF73 =00000031                M 	__endpos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000EF73 =00000036                M 	__midpos:	set instr(__pos+5,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000EF73 =00000031                M 	__midpos:	= __endpos
0000EF73                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EF73                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EF73 E0                       M 	dc.b	fendl
0000EF74 =00000032                M 	__lpos:	set __endpos+1
0000EF74 =00000032                M 	__pos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000EF74                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EF74                          M 	dc.b	""
0000EF74 =0000003D                M 	__endpos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000EF74 =00000039                M 	__midpos:	set instr(__pos+5,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000EF74                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EF74                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EF74 B3                       M 	dc.b	sym|3
0000EF75 =0000003E                M 	__lpos:	set __endpos+1
0000EF75 =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000EF75                          M 	__substr:	substr __lpos,,"Invalid tracker at SFX %<.b d0>: %<.l a4>%<fendl>%<.l a4 sym>"
0000EF75                          M 	dc.b	""
0000EF75 00                       M 	dc.b	0
0000EF76 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000EF78 00                       M 	even
0000EF78 4EFA EAA8                M 	jmp	amps_debug_console_main
0000EF7C                          M 	even
0000EF7C                          M .ok_604
0000EF7C                            ; ---------------------------------------------------------------------------
0000EF7C                            ; Continous SFX is a very special type of sound effect. Unlike other
0000EF7C                            ; sound effects, when a continous SFX is played, it will run a loop
0000EF7C                            ; again, until it is no longer queued. This is very useful for sound
0000EF7C                            ; effects that need to be queued very often, but that really do not
0000EF7C                            ; sound good when restarted (plus, it requires more CPU time, anyway).
0000EF7C                            ; Even the Marble Zone block pushing sound effect had similar behavior,
0000EF7C                            ; but the code was not quite as matured as this here. Only one continous
0000EF7C                            ; SFX may be running at once, when other type is loaded, the earlier one
0000EF7C                            ; is stopped and replaced.
0000EF7C                            ; ---------------------------------------------------------------------------
0000EF7C                            
0000EF7C 4A31 7000                  		tst.b	(a1,d7.w)		; check if this sound effect is continously looping
0000EF80 6A00                       		bpl.s	.nocont			; if not, skip
0000EF82 11EC 0001 C4C2             		move.b	1(a4),mContCtr.w	; copy the number of channels as the new continous loop counter
0000EF88 B238 C4C3                  		cmp.b	mContLast.w,d1		; check if the last continous SFX had the same ID
0000EF8C 6600                       		bne.s	.setcont		; if not, play as a new sound effect anyway
0000EF8E 4E75                       		rts
0000EF90                            
0000EF90                            .setcont
0000EF90 11C1 C4C3                  		move.b	d1,mContLast.w		; save new continous SFX ID
0000EF94                            .nocont
0000EF94 224C                       		movea.l	a4,a1			; copy tracker header pointer to a1
0000EF96                            
0000EF96 7E00                       		moveq	#0,d7
0000EF98 47FA 0000                  		lea	dSFXoverList(pc),a3	; load quick reference to the SFX override list to a3
0000EF9C 45FA 0000                  		lea	dSFXoffList(pc),a2	; load quick reference to the SFX channel list to a2
0000EFA0 1A19                       		move.b	(a1)+,d5		; load sound effect priority to d5
0000EFA2 1E19                       		move.b	(a1)+,d7		; load number of SFX channels to d7
0000EFA4 7C1C                       		moveq	#cSizeSFX,d6		; prepare SFX channel size to d6
0000EFA6                            ; ---------------------------------------------------------------------------
0000EFA6                            ; The reason why we delay PSG by 1 extra frame, is because of Dual PCM.
0000EFA6                            ; It adds a delay of 1 frame to DAC and FM due to the YMCue, and PCM
0000EFA6                            ; buffering to avoid quality loss from DMA's. This means that, since PSG
0000EFA6                            ; is controlled by the 68000, we would be off by a single frame without
0000EFA6                            ; this fix.
0000EFA6                            ; ---------------------------------------------------------------------------
0000EFA6                            
0000EFA6                            .loopSFX
0000EFA6 7600                       		moveq	#0,d3
0000EFA8 7402                       		moveq	#2,d2			; prepare duration of 1 frames to d5
0000EFAA 1629 0001                  		move.b	1(a1),d3		; load sound effect channel type to d3
0000EFAE 1803                       		move.b	d3,d4			; copy type to d4
0000EFB0 6B00                       		bmi.s	.chPSG			; if channel is a PSG channel, branch
0000EFB2                            
0000EFB2 0243 0007                  		and.w	#$07,d3			; get only the necessary bits to d3
0000EFB6 5543                       		subq.w	#2,d3			; since FM 1 and 2 are not used, skip over them
0000EFB8 D643                       		add.w	d3,d3			; double offset (each entry is 1 word in size)
0000EFBA                            
0000EFBA 3A72 3000                  		move.w	(a2,d3.w),a5		; get the SFX channel we are trying to load to
0000EFBE BA2D 001A                  		cmp.b	cPrio(a5),d5		; check if this sound effect has higher priority
0000EFC2 6500                       		blo.s	.skip			; if not, we can not override it
0000EFC4                            
0000EFC4 3C73 3000                  		move.w	(a3,d3.w),a6		; get the music channel we should override
0000EFC8 08D6 0001                  		bset	#cfbInt,(a6)		; override music channel with sound effect
0000EFCC 7401                       		moveq	#1,d2			; prepare duration of 0 frames to d5
0000EFCE 6000                       		bra.s	.clearCh
0000EFD0                            ; ---------------------------------------------------------------------------
0000EFD0                            
0000EFD0                            .skip
0000EFD0 5C89                       		addq.l	#6,a1			; skip this sound effect channel
0000EFD2 51CF FFD2                  		dbf	d7,.loopSFX		; repeat for each requested channel
0000EFD6 4E75                       		rts
0000EFD8                            ; ---------------------------------------------------------------------------
0000EFD8                            
0000EFD8                            .chPSG
0000EFD8 E84B                       		lsr.w	#4,d3			; make it easier to reference the right offset in the table
0000EFDA 3A72 3000                  		move.w	(a2,d3.w),a5		; get the SFX channel we are trying to load to
0000EFDE BA2D 001A                  		cmp.b	cPrio(a5),d5		; check if this sound effect has higher priority
0000EFE2 65EC                       		blo.s	.skip			; if not, we can not override it
0000EFE4                            
0000EFE4 3C73 3000                  		move.w	(a3,d3.w),a6		; get the music channel we should override
0000EFE8 08D6 0001                  		bset	#cfbInt,(a6)		; override music channel with sound effect
0000EFEC 0004 001F                  		ori.b	#$1F,d4			; add volume update and max volume to channel type
0000EFF0 13C4 00C0 0011             		move.b	d4,dPSG			; send volume mute command to PSG
0000EFF6                            
0000EFF6 0C04 00DF                  		cmpi.b	#ctPSG3|$1F,d4		; check if we sent command about PSG3
0000EFFA 6600                       		bne.s	.clearCh		; if not, skip
0000EFFC 13FC 00FF 00C0 0011        		move.b	#ctPSG4|$1F,dPSG	; send volume mute command for PSG4 to PSG
0000F004                            
0000F004                            .clearCh
0000F004 3C4D                       		move.w	a5,a6			; copy sound effect channel RAM pointer to a6
0000F006 7006                       		moveq	#cSizeSFX/4-1,d0	; prepare SFX channel size / 4 to d0
0000F008                            .clear
0000F008 429E                       		clr.l	(a6)+			; clear 4 bytes of channel data
0000F00A 51C8 FFFC                  		dbf	d0,.clear		; clear the entire channel
0000F00E                            
0000F00E                            
0000F00E 3A99                       		move.w	(a1)+,(a5)		; load channel flags and type
0000F010 1B45 001A                  		move.b	d5,cPrio(a5)		; set channel priority
0000F014 1B42 000C                  		move.b	d2,cDuration(a5)	; reset channel duration
0000F018                            
0000F018 7000                       		moveq	#0,d0
0000F01A 3019                       		move.w	(a1)+,d0		; load tracker offset to d0
0000F01C D08C                       		add.l	a4,d0			; add music header offset to d0
0000F01E 2B40 0002                  		move.l	d0,cData(a5)		; save as the tracker address of the channel
0000F022                            		AMPS_Debug_PlayTrackSFX2	; make sure the tracker address is valid
0000F022 0C80 0000 0000           M 	cmp.l	#sfxaddr,d0
0000F028 6500                     M 	blo.s	.fail_609
0000F02A 0C80 0000 0000           M 	cmp.l	#musaddr,d0
0000F030 6500                     M 	blo.s	.ok_609
0000F032                          M .fail_609
0000F032                          M 	raiseerror	"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",amps_debug_console_main
0000F032 487A FFFE                M 	pea	*(pc)
0000F036                          M 	raiseerror2	"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",amps_debug_console_main
0000F036 40E7                     M 	move.w	sr,-(sp)
0000F038                          M 	__fstring_generateargumentscode	"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F038 =0000001C                M 	__pos:	set instr("Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000F038 =00000000                M 	__stack:set	0
0000F038 =00000000                M 	__sp:	set 0
0000F038                          M 	while	(__pos)
0000F038 =00000023                M 	__endpos:	set instr(__pos+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000F038 =00000030                M 	__midpos:	set instr(__pos+5,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000F038 =00000023                M 	__midpos:	= __endpos
0000F038                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F038                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F038                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F038                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F038                          M 	pushp	"move.l d0,-(sp)"
0000F038 =00000001                M 	__stack:	= __stack+1
0000F038 =00000004                M 	__sp:	= __sp+4
0000F038 =00000024                M 	__pos:	set instr(__pos+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000F038 =0000002B                M 	__endpos:	set instr(__pos+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000F038 =00000030                M 	__midpos:	set instr(__pos+5,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000F038 =0000002B                M 	__midpos:	= __endpos
0000F038                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F038                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F038 =0000002C                M 	__pos:	set instr(__pos+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000F038 =00000037                M 	__endpos:	set instr(__pos+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000F038 =00000033                M 	__midpos:	set instr(__pos+5,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000F038                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F038                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F038                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F038                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F038                          M 	pushp	"move.l d0,-(sp)"
0000F038 =00000002                M 	__stack:	= __stack+1
0000F038 =00000008                M 	__sp:	= __sp+4
0000F038 =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000F038                          M 	rept	__stack
0000F038                          M 	popp	__command
0000F038 2F00                     M 	move.l	d0,-(sp)
0000F03A                          M 	popp	__command
0000F03A 2F00                     M 	move.l	d0,-(sp)
0000F03C 4EB9 0000 0000           M 	jsr	errorhandler
0000F042                          M 	__fstring_generatedecodedstring	"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F042 =00000001                M 	__lpos:	set 1
0000F042 =0000001C                M 	__pos:	set instr("Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000F042                          M 	while	(__pos)
0000F042                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F042 496E 7661 6C69 6420 7472+M 	dc.b	"Invalid tracker at SFX ch: "
0000F05D =00000023                M 	__endpos:	set instr(__pos+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000F05D =00000030                M 	__midpos:	set instr(__pos+5,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000F05D =00000023                M 	__midpos:	= __endpos
0000F05D                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F05D                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F05D                          M 	__param:	substr ,,"hex"
0000F05D 83                       M 	dc.b	hex|3
0000F05E =00000024                M 	__lpos:	set __endpos+1
0000F05E =00000024                M 	__pos:	set instr(__pos+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000F05E                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F05E                          M 	dc.b	""
0000F05E =0000002B                M 	__endpos:	set instr(__pos+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000F05E =00000030                M 	__midpos:	set instr(__pos+5,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000F05E =0000002B                M 	__midpos:	= __endpos
0000F05E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F05E                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F05E E0                       M 	dc.b	fendl
0000F05F =0000002C                M 	__lpos:	set __endpos+1
0000F05F =0000002C                M 	__pos:	set instr(__pos+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000F05F                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F05F                          M 	dc.b	""
0000F05F =00000037                M 	__endpos:	set instr(__pos+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",'>')
0000F05F =00000033                M 	__midpos:	set instr(__pos+5,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",' ')
0000F05F                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F05F                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F05F B3                       M 	dc.b	sym|3
0000F060 =00000038                M 	__lpos:	set __endpos+1
0000F060 =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>",'%<')
0000F060                          M 	__substr:	substr __lpos,,"Invalid tracker at SFX ch: %<.l d0>%<fendl>%<.l d0 sym>"
0000F060                          M 	dc.b	""
0000F060 00                       M 	dc.b	0
0000F061 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000F062                          M 	even
0000F062 4EFA E9BE                M 	jmp	amps_debug_console_main
0000F066                          M 	even
0000F066                          M .ok_609
0000F066                            
0000F066 3B59 0008                  		move.w	(a1)+,cPitch(a5)	; load pitch offset and channel volume
0000F06A 4A04                       		tst.b	d4			; check if this channel is a PSG channel
0000F06C 6B00                       		bmi.s	.loop			; if is, skip over this
0000F06E                            
0000F06E 72C0                       		moveq	#$FFFFFFC0,d1		; set panning to centre
0000F070 1B41 0006                  		move.b	d1,cPanning(a5)		; save to channel memory too
0000F074 70B4                       		moveq	#$FFFFFFB4,d0		; YM address: Panning and LFO
0000F076 4EBA 0000                  		jsr	WriteChYM(pc)		; write to part 2 channel
0000F07A                            
0000F07A BAFC C67C                  		cmp.w	#mSFXDAC1,a5		; check if this channel is a DAC channel
0000F07E 6600                       		bne.s	.fm			; if not, branch
0000F080 3B7C 0100 000E             		move.w	#$100,cFreq(a5)		; DAC default frequency is $100, NOT $000
0000F086                            
0000F086                            .loop
0000F086 51CF FF1E                  		dbf	d7,.loopSFX		; repeat for each requested channel
0000F08A 4E75                       		rts
0000F08C                            ; ---------------------------------------------------------------------------
0000F08C                            ; The instant release for FM channels behavior was not in the Sonic 1
0000F08C                            ; SMPS driver by default, but it has been added since it fixes an
0000F08C                            ; issue with YM2612, where sometimes subsequent sound effect activations
0000F08C                            ; would sound different over time. This fix will help to mitigate that.
0000F08C                            ; ---------------------------------------------------------------------------
0000F08C                            
0000F08C                            .fm
0000F08C 720F                       		moveq	#$F,d1			; set to release note instantly
0000F08E 7080                       		moveq	#$FFFFFF80,d0		; YM address: Release Rate Operator 1
0000F090 4EBA 0000                  		jsr	WriteChYM(pc)		; write to YM according to channel
0000F094 7088                       		moveq	#$FFFFFF88,d0		; YM address: Release Rate Operator 3
0000F096 4EBA 0000                  		jsr	WriteChYM(pc)		; write to YM according to channel
0000F09A 7084                       		moveq	#$FFFFFF84,d0		; YM address: Release Rate Operator 2
0000F09C 4EBA 0000                  		jsr	WriteChYM(pc)		; write to YM according to channel
0000F0A0 708C                       		moveq	#$FFFFFF8C,d0		; YM address: Release Rate Operator 4
0000F0A2 4EBA 0000                  		jsr	WriteChYM(pc)		; write to YM according to channel
0000F0A6                            
0000F0A6 7028                       		moveq	#$28,d0			; YM address: Key on/off
0000F0A8 122D 0001                  		move.b	cType(a5),d1		; FM channel, all operators off
0000F0AC 6100 0000                  		bsr.w	WriteYM_Pt1		; write to part 1 or 2 channel
0000F0B0                            
0000F0B0 51CF FEF4                  		dbf	d7,.loopSFX		; repeat for each requested channel
0000F0B4 4E75                       		rts
0000F0B6                            ; ===========================================================================
0000F0B6                            ; ---------------------------------------------------------------------------
0000F0B6                            ; pointers for music channels SFX can override and addresses of SFX channels
0000F0B6                            ; ---------------------------------------------------------------------------
0000F0B6                            
0000F0B6 C698                       dSFXoffList:	dc.w mSFXFM3			; FM3
0000F0B8 C67C                       		dc.w mSFXDAC1			; DAC1
0000F0BA C6B4                       		dc.w mSFXFM4			; FM4
0000F0BC C6D0                       		dc.w mSFXFM5			; FM5
0000F0BE C6EC                       		dc.w mSFXPSG1			; PSG1
0000F0C0 C708                       		dc.w mSFXPSG2			; PSG2
0000F0C2 C724                       		dc.w mSFXPSG3			; PSG3
0000F0C4 C724                       		dc.w mSFXPSG3			; PSG4
0000F0C6                            
0000F0C6 C574                       dSFXoverList:	dc.w mFM3			; SFX FM3
0000F0C8 C4C4                       		dc.w mDAC1			; SFX DAC1
0000F0CA C5A0                       		dc.w mFM4			; SFX FM4
0000F0CC C5CC                       		dc.w mFM5			; SFX FM5
0000F0CE C5F8                       		dc.w mPSG1			; SFX PSG1
0000F0D0 C624                       		dc.w mPSG2			; SFX PSG2
0000F0D2 C650                       		dc.w mPSG3			; SFX PSG3
0000F0D4 C650                       		dc.w mPSG3			; SFX PSG4
0000F0D6                            ; ===========================================================================
0000F0D6                            ; ---------------------------------------------------------------------------
0000F0D6                            ; Play queued command
0000F0D6                            ; ---------------------------------------------------------------------------
0000F0D6                            
0000F0D6                            dPlaySnd_Comm:
0000F0D6                            		AMPS_Debug_PlayCmd		; check if the command is valid
0000F0D6 0C07 0000                M 	cmp.b	#(dsoundcommands_end-dsoundcommands)/4,d7
0000F0DA 6300                     M 	bls.s	.ok
0000F0DC                          M 	raiseerror	"Invalid command in queue: %<.b d7>",amps_debug_console_channel
0000F0DC 487A FFFE                M 	pea	*(pc)
0000F0E0                          M 	raiseerror2	"Invalid command in queue: %<.b d7>",amps_debug_console_channel
0000F0E0 40E7                     M 	move.w	sr,-(sp)
0000F0E2                          M 	__fstring_generateargumentscode	"Invalid command in queue: %<.b d7>"
0000F0E2 =0000001B                M 	__pos:	set instr("Invalid command in queue: %<.b d7>",'%<')
0000F0E2 =00000000                M 	__stack:set	0
0000F0E2 =00000000                M 	__sp:	set 0
0000F0E2                          M 	while	(__pos)
0000F0E2 =00000022                M 	__endpos:	set instr(__pos+1,"Invalid command in queue: %<.b d7>",'>')
0000F0E2 =00000000                M 	__midpos:	set instr(__pos+5,"Invalid command in queue: %<.b d7>",' ')
0000F0E2 =00000022                M 	__midpos:	= __endpos
0000F0E2                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid command in queue: %<.b d7>"
0000F0E2                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid command in queue: %<.b d7>"
0000F0E2                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid command in queue: %<.b d7>"
0000F0E2                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid command in queue: %<.b d7>"
0000F0E2                          M 	pushp	"move.b d7,1(sp)"
0000F0E2                          M 	pushp	"subq.w	#2, sp"
0000F0E2 =00000002                M 	__stack:	= __stack+2
0000F0E2 =00000002                M 	__sp:	= __sp+2
0000F0E2 =00000000                M 	__pos:	set instr(__pos+1,"Invalid command in queue: %<.b d7>",'%<')
0000F0E2                          M 	rept	__stack
0000F0E2                          M 	popp	__command
0000F0E2 554F                     M 	subq.w	#2,sp
0000F0E4                          M 	popp	__command
0000F0E4 1F47 0001                M 	move.b	d7,1(sp)
0000F0E8 4EB9 0000 0000           M 	jsr	errorhandler
0000F0EE                          M 	__fstring_generatedecodedstring	"Invalid command in queue: %<.b d7>"
0000F0EE =00000001                M 	__lpos:	set 1
0000F0EE =0000001B                M 	__pos:	set instr("Invalid command in queue: %<.b d7>",'%<')
0000F0EE                          M 	while	(__pos)
0000F0EE                          M 	__substr:	substr __lpos,__pos-1,"Invalid command in queue: %<.b d7>"
0000F0EE 496E 7661 6C69 6420 636F+M 	dc.b	"Invalid command in queue: "
0000F108 =00000022                M 	__endpos:	set instr(__pos+1,"Invalid command in queue: %<.b d7>",'>')
0000F108 =00000000                M 	__midpos:	set instr(__pos+5,"Invalid command in queue: %<.b d7>",' ')
0000F108 =00000022                M 	__midpos:	= __endpos
0000F108                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid command in queue: %<.b d7>"
0000F108                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid command in queue: %<.b d7>"
0000F108                          M 	__param:	substr ,,"hex"
0000F108 80                       M 	dc.b	hex
0000F109 =00000023                M 	__lpos:	set __endpos+1
0000F109 =00000000                M 	__pos:	set instr(__pos+1,"Invalid command in queue: %<.b d7>",'%<')
0000F109                          M 	__substr:	substr __lpos,,"Invalid command in queue: %<.b d7>"
0000F109                          M 	dc.b	""
0000F109 00                       M 	dc.b	0
0000F10A 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000F10C 00                       M 	even
0000F10C 4EFA E16E                M 	jmp	amps_debug_console_channel
0000F110                          M 	even
0000F110                          M .ok
0000F110                            
0000F110 DE47                       		add.w	d7,d7			; quadruple ID
0000F112 DE47                       		add.w	d7,d7			; because each entry is 1 long word
0000F114 4EFB 7000                  		jmp	dSoundCommands-4(pc,d7.w); jump to appropriate command handler
0000F118                            
0000F118                            ; ---------------------------------------------------------------------------
0000F118                            dSoundCommands:
0000F118 6000 0000                  		bra.w	dPlaySnd_Reset		; 01 - Reset underwater and speed shoes flags, update volume
0000F11C 6000 0000                  		bra.w	dPlaySnd_FadeOut	; 02 - Initialize a music fade out
0000F120 6000 0000                  		bra.w	dPlaySnd_Stop		; 03 - Stop all music
0000F124 6000 0000                  		bra.w	dPlaySnd_ShoesOn	; 04 - Enable speed shoes mode
0000F128 6000 0000                  		bra.w	dPlaySnd_ShoesOff	; 05 - Disable speed shoes mode
0000F12C 6000 0000                  		bra.w	dPlaySnd_ToWater	; 06 - Enable underwater mode
0000F130 6000 0000                  		bra.w	dPlaySnd_OutWater	; 07 - Disable underwater mode
0000F134 6000 FA38                  		bra.w	dPlaySnd_Pause		; 08 - Pause the sound driver
0000F138 6000 F9D4                  		bra.w	dPlaySnd_Unpause	; 09 - Unpause the sound driver
0000F13C                            dSoundCommands_End:
0000F13C                            ; ===========================================================================
0000F13C                            ; ---------------------------------------------------------------------------
0000F13C                            ; Commands for what to do after a volume fade
0000F13C                            ; ---------------------------------------------------------------------------
0000F13C                            
0000F13C                            dFadeCommands:
0000F13C 4E75                       		rts				; 80 - Do nothing
0000F13E 4E75                       		rts
0000F140 6000                       .stop		bra.s	dPlaySnd_Stop		; 84 - Stop all music
0000F142 4E75                       		rts
0000F144 6000 0000                  .resv		bra.w	dResetVolume		; 88 - Reset volume and update
0000F148 61FA                       		bsr.s	.resv			; 8C - Stop music playing and reset volume
0000F14A 60F4                       		bra.s	.stop
0000F14C                            ; ===========================================================================
0000F14C                            ; ---------------------------------------------------------------------------
0000F14C                            ; Stop music and SFX from playing (This code clears SFX RAM also)
0000F14C                            ; ---------------------------------------------------------------------------
0000F14C                            
0000F14C                            dPlaySnd_Stop:
0000F14C                            ; Not needed,	moveq	#$2B,d0			; YM command: DAC Enable
0000F14C                            ; Dual PCM does	moveq	#$FFFFFF80,d1		; FM6 acts as DAC
0000F14C                            ; this for us	jsr	WriteYM_Pt1(pc)		; write to YM global register
0000F14C                            
0000F14C 7027                       		moveq	#$27,d0			; YM command: Channel 3 Mode & Timer Control
0000F14E 7200                       		moveq	#0,d1			; disable timers and channel 3 special mode
0000F150 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to YM global register
0000F154                            
0000F154 43F8 C67C                  		lea	mSFXDAC1.w,a1		; prepare SFX DAC 1 to start clearing fromn
0000F158                            
0000F158                            	rept (mSize-mSFXDAC1)/4
0000F158                            		clr.l	(a1)+			; clear entire SFX RAM (others done below)
0000F158                            	endr
0000F158 4299                     M 	clr.l	(a1)+
0000F15A 4299                     M 	clr.l	(a1)+
0000F15C 4299                     M 	clr.l	(a1)+
0000F15E 4299                     M 	clr.l	(a1)+
0000F160 4299                     M 	clr.l	(a1)+
0000F162 4299                     M 	clr.l	(a1)+
0000F164 4299                     M 	clr.l	(a1)+
0000F166 4299                     M 	clr.l	(a1)+
0000F168 4299                     M 	clr.l	(a1)+
0000F16A 4299                     M 	clr.l	(a1)+
0000F16C 4299                     M 	clr.l	(a1)+
0000F16E 4299                     M 	clr.l	(a1)+
0000F170 4299                     M 	clr.l	(a1)+
0000F172 4299                     M 	clr.l	(a1)+
0000F174 4299                     M 	clr.l	(a1)+
0000F176 4299                     M 	clr.l	(a1)+
0000F178 4299                     M 	clr.l	(a1)+
0000F17A 4299                     M 	clr.l	(a1)+
0000F17C 4299                     M 	clr.l	(a1)+
0000F17E 4299                     M 	clr.l	(a1)+
0000F180 4299                     M 	clr.l	(a1)+
0000F182 4299                     M 	clr.l	(a1)+
0000F184 4299                     M 	clr.l	(a1)+
0000F186 4299                     M 	clr.l	(a1)+
0000F188 4299                     M 	clr.l	(a1)+
0000F18A 4299                     M 	clr.l	(a1)+
0000F18C 4299                     M 	clr.l	(a1)+
0000F18E 4299                     M 	clr.l	(a1)+
0000F190 4299                     M 	clr.l	(a1)+
0000F192 4299                     M 	clr.l	(a1)+
0000F194 4299                     M 	clr.l	(a1)+
0000F196 4299                     M 	clr.l	(a1)+
0000F198 4299                     M 	clr.l	(a1)+
0000F19A 4299                     M 	clr.l	(a1)+
0000F19C 4299                     M 	clr.l	(a1)+
0000F19E 4299                     M 	clr.l	(a1)+
0000F1A0 4299                     M 	clr.l	(a1)+
0000F1A2 4299                     M 	clr.l	(a1)+
0000F1A4 4299                     M 	clr.l	(a1)+
0000F1A6 4299                     M 	clr.l	(a1)+
0000F1A8 4299                     M 	clr.l	(a1)+
0000F1AA 4299                     M 	clr.l	(a1)+
0000F1AC 4299                     M 	clr.l	(a1)+
0000F1AE 4299                     M 	clr.l	(a1)+
0000F1B0 4299                     M 	clr.l	(a1)+
0000F1B2 4299                     M 	clr.l	(a1)+
0000F1B4 4299                     M 	clr.l	(a1)+
0000F1B6 4299                     M 	clr.l	(a1)+
0000F1B8 4299                     M 	clr.l	(a1)+
0000F1BA                            
0000F1BA 4251                       		clr.w	(a1)			; if there is an extra word, clear it too
0000F1BC                            	; continue straight to stopping music
0000F1BC                            ; ===========================================================================
0000F1BC                            ; ---------------------------------------------------------------------------
0000F1BC                            ; Stop music from playing, reset driver memory and mute hardware
0000F1BC                            ; ---------------------------------------------------------------------------
0000F1BC                            
0000F1BC                            dStopMusic:
0000F1BC 43F8 C4A6                  		lea	mFlags.w,a1		; load driver RAM start to a1
0000F1C0 3611                       		move.w	(a1),d3			; load driver flags and PAL counter to d3
0000F1C2 1838 C4C0                  		move.b	mMasterVolDAC.w,d4	; load DAC master volume to d4
0000F1C6 2A38 C4BC                  		move.l	mQueue.w,d5		; load sound queue and PSG master volume to d5
0000F1CA 4CF8 0007 C4AC             		movem.l	mComm.w,d0-d2		; load communications bytes, FM master volume and fade address to d0-d2
0000F1D0                            
0000F1D0                            	rept (mSFXDAC1-mFlags)/4
0000F1D0                            		clr.l	(a1)+			; clear driver and music channel memory
0000F1D0                            	endr
0000F1D0 4299                     M 	clr.l	(a1)+
0000F1D2 4299                     M 	clr.l	(a1)+
0000F1D4 4299                     M 	clr.l	(a1)+
0000F1D6 4299                     M 	clr.l	(a1)+
0000F1D8 4299                     M 	clr.l	(a1)+
0000F1DA 4299                     M 	clr.l	(a1)+
0000F1DC 4299                     M 	clr.l	(a1)+
0000F1DE 4299                     M 	clr.l	(a1)+
0000F1E0 4299                     M 	clr.l	(a1)+
0000F1E2 4299                     M 	clr.l	(a1)+
0000F1E4 4299                     M 	clr.l	(a1)+
0000F1E6 4299                     M 	clr.l	(a1)+
0000F1E8 4299                     M 	clr.l	(a1)+
0000F1EA 4299                     M 	clr.l	(a1)+
0000F1EC 4299                     M 	clr.l	(a1)+
0000F1EE 4299                     M 	clr.l	(a1)+
0000F1F0 4299                     M 	clr.l	(a1)+
0000F1F2 4299                     M 	clr.l	(a1)+
0000F1F4 4299                     M 	clr.l	(a1)+
0000F1F6 4299                     M 	clr.l	(a1)+
0000F1F8 4299                     M 	clr.l	(a1)+
0000F1FA 4299                     M 	clr.l	(a1)+
0000F1FC 4299                     M 	clr.l	(a1)+
0000F1FE 4299                     M 	clr.l	(a1)+
0000F200 4299                     M 	clr.l	(a1)+
0000F202 4299                     M 	clr.l	(a1)+
0000F204 4299                     M 	clr.l	(a1)+
0000F206 4299                     M 	clr.l	(a1)+
0000F208 4299                     M 	clr.l	(a1)+
0000F20A 4299                     M 	clr.l	(a1)+
0000F20C 4299                     M 	clr.l	(a1)+
0000F20E 4299                     M 	clr.l	(a1)+
0000F210 4299                     M 	clr.l	(a1)+
0000F212 4299                     M 	clr.l	(a1)+
0000F214 4299                     M 	clr.l	(a1)+
0000F216 4299                     M 	clr.l	(a1)+
0000F218 4299                     M 	clr.l	(a1)+
0000F21A 4299                     M 	clr.l	(a1)+
0000F21C 4299                     M 	clr.l	(a1)+
0000F21E 4299                     M 	clr.l	(a1)+
0000F220 4299                     M 	clr.l	(a1)+
0000F222 4299                     M 	clr.l	(a1)+
0000F224 4299                     M 	clr.l	(a1)+
0000F226 4299                     M 	clr.l	(a1)+
0000F228 4299                     M 	clr.l	(a1)+
0000F22A 4299                     M 	clr.l	(a1)+
0000F22C 4299                     M 	clr.l	(a1)+
0000F22E 4299                     M 	clr.l	(a1)+
0000F230 4299                     M 	clr.l	(a1)+
0000F232 4299                     M 	clr.l	(a1)+
0000F234 4299                     M 	clr.l	(a1)+
0000F236 4299                     M 	clr.l	(a1)+
0000F238 4299                     M 	clr.l	(a1)+
0000F23A 4299                     M 	clr.l	(a1)+
0000F23C 4299                     M 	clr.l	(a1)+
0000F23E 4299                     M 	clr.l	(a1)+
0000F240 4299                     M 	clr.l	(a1)+
0000F242 4299                     M 	clr.l	(a1)+
0000F244 4299                     M 	clr.l	(a1)+
0000F246 4299                     M 	clr.l	(a1)+
0000F248 4299                     M 	clr.l	(a1)+
0000F24A 4299                     M 	clr.l	(a1)+
0000F24C 4299                     M 	clr.l	(a1)+
0000F24E 4299                     M 	clr.l	(a1)+
0000F250 4299                     M 	clr.l	(a1)+
0000F252 4299                     M 	clr.l	(a1)+
0000F254 4299                     M 	clr.l	(a1)+
0000F256 4299                     M 	clr.l	(a1)+
0000F258 4299                     M 	clr.l	(a1)+
0000F25A 4299                     M 	clr.l	(a1)+
0000F25C 4299                     M 	clr.l	(a1)+
0000F25E 4299                     M 	clr.l	(a1)+
0000F260 4299                     M 	clr.l	(a1)+
0000F262 4299                     M 	clr.l	(a1)+
0000F264 4299                     M 	clr.l	(a1)+
0000F266 4299                     M 	clr.l	(a1)+
0000F268 4299                     M 	clr.l	(a1)+
0000F26A 4299                     M 	clr.l	(a1)+
0000F26C 4299                     M 	clr.l	(a1)+
0000F26E 4299                     M 	clr.l	(a1)+
0000F270 4299                     M 	clr.l	(a1)+
0000F272 4299                     M 	clr.l	(a1)+
0000F274 4299                     M 	clr.l	(a1)+
0000F276 4299                     M 	clr.l	(a1)+
0000F278 4299                     M 	clr.l	(a1)+
0000F27A 4299                     M 	clr.l	(a1)+
0000F27C 4299                     M 	clr.l	(a1)+
0000F27E 4299                     M 	clr.l	(a1)+
0000F280 4299                     M 	clr.l	(a1)+
0000F282 4299                     M 	clr.l	(a1)+
0000F284 4299                     M 	clr.l	(a1)+
0000F286 4299                     M 	clr.l	(a1)+
0000F288 4299                     M 	clr.l	(a1)+
0000F28A 4299                     M 	clr.l	(a1)+
0000F28C 4299                     M 	clr.l	(a1)+
0000F28E 4299                     M 	clr.l	(a1)+
0000F290 4299                     M 	clr.l	(a1)+
0000F292 4299                     M 	clr.l	(a1)+
0000F294 4299                     M 	clr.l	(a1)+
0000F296 4299                     M 	clr.l	(a1)+
0000F298 4299                     M 	clr.l	(a1)+
0000F29A 4299                     M 	clr.l	(a1)+
0000F29C 4299                     M 	clr.l	(a1)+
0000F29E 4299                     M 	clr.l	(a1)+
0000F2A0 4299                     M 	clr.l	(a1)+
0000F2A2 4299                     M 	clr.l	(a1)+
0000F2A4 4299                     M 	clr.l	(a1)+
0000F2A6 4299                     M 	clr.l	(a1)+
0000F2A8 4299                     M 	clr.l	(a1)+
0000F2AA 4299                     M 	clr.l	(a1)+
0000F2AC 4299                     M 	clr.l	(a1)+
0000F2AE 4299                     M 	clr.l	(a1)+
0000F2B0 4299                     M 	clr.l	(a1)+
0000F2B2 4299                     M 	clr.l	(a1)+
0000F2B4 4299                     M 	clr.l	(a1)+
0000F2B6 4299                     M 	clr.l	(a1)+
0000F2B8 4299                     M 	clr.l	(a1)+
0000F2BA                            
0000F2BA 4251                       		clr.w	(a1)			; if there is an extra word, clear it too
0000F2BC                            
0000F2BC 31C3 C4A6                  		move.w	d3,mFlags.w		; save driver flags and PAL counter
0000F2C0 11C4 C4C0                  		move.b	d4,mMasterVolDAC.w	; save DAC master volume
0000F2C4 21C5 C4BC                  		move.l	d5,mQueue.w		; save sound queue and PSG master volume
0000F2C8 48F8 0007 C4AC             		movem.l	d0-d2,mComm.w		; save communications bytes, FM master volume and fade address
0000F2CE                            
0000F2CE 6100                       		bsr.s	dMutePSG		; hardware mute PSG
0000F2D0 4EBA F8D0                  		jsr	dMuteDAC(pc)		; hardware mute DAC
0000F2D4                            	; continue straight to hardware muting FM
0000F2D4                            ; ===========================================================================
0000F2D4                            ; ---------------------------------------------------------------------------
0000F2D4                            ; Mute all FM channels
0000F2D4                            ; ---------------------------------------------------------------------------
0000F2D4                            
0000F2D4                            dMuteFM:
0000F2D4 7028                       		moveq	#$28,d0			; YM address: Key on/off
0000F2D6 7602                       		moveq	#%00000010,d3		; turn keys off, and start from YM channel 3
0000F2D8                            
0000F2D8                            .noteoff
0000F2D8 1203                       		move.b	d3,d1			; copy value into d1
0000F2DA 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to part 1 channel
0000F2DE 5801                       		addq.b	#4,d1			; set this to part 2 channel
0000F2E0 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to part 2 channel
0000F2E4 51CB FFF2                  		dbf	d3,.noteoff		; loop for all 3 channel groups
0000F2E8                            
0000F2E8 7040                       		moveq	#$40,d0			; YM command: Total Level Operator 1
0000F2EA 727F                       		moveq	#$7F,d1			; set total level to $7F (silent)
0000F2EC 7802                       		moveq	#3-1,d4			; prepare 3 groups of channels to d4
0000F2EE                            
0000F2EE                            .chloop
0000F2EE 7603                       		moveq	#4-1,d3			; prepare 4 operator writes per channel to d3
0000F2F0 7A0F                       		moveq	#$10-1,d5		; prepare the value for going to next channel to d5
0000F2F2                            
0000F2F2                            .oploop
0000F2F2 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to part 1 channel
0000F2F6 4EBA 0000                  		jsr	WriteYM_Pt2(pc)		; write to part 2 channel
0000F2FA 5840                       		addq.w	#4,d0			; go to next operator (1 2 3 4)
0000F2FC 51CB FFF4                  		dbf	d3,.oploop		; repeat for each operator
0000F300                            
0000F300 9005                       		sub.b	d5,d0			; go to next FM channel
0000F302 51CC FFEA                  		dbf	d4,.chloop		; repeat for each channel
0000F306 4E75                       		rts
0000F308                            ; ===========================================================================
0000F308                            ; ---------------------------------------------------------------------------
0000F308                            ; Routine for muting all PSG channels
0000F308                            ; ---------------------------------------------------------------------------
0000F308                            
0000F308                            dMutePSG:
0000F308 43F9 00C0 0011             		lea	dPSG,a1			; load PSG data port address to a1
0000F30E 12BC 009F                  		move.b	#ctPSG1|$1F,(a1)	; send volume mute command for PSG1 to PSG
0000F312 12BC 00BF                  		move.b	#ctPSG2|$1F,(a1)	; send volume mute command for PSG2 to PSG
0000F316 12BC 00DF                  		move.b	#ctPSG3|$1F,(a1)	; send volume mute command for PSG3 to PSG
0000F31A 12BC 00FF                  		move.b	#ctPSG4|$1F,(a1)	; send volume mute command for PSG4 to PSG
0000F31E 4E75                       		rts
0000F320                            ; ===========================================================================
0000F320                            ; ---------------------------------------------------------------------------
0000F320                            ; Normal fade out data
0000F320                            ; ---------------------------------------------------------------------------
0000F320                            
0000F320                            dFadeOutDataLog:
0000F320 0101 0002 0200 0204 0103+  	dc.b $01, $01, $00,  $02, $02, $00,  $02, $04, $01,  $03, $05, $01
0000F32C 0405 0104 0602 0507 0206+  	dc.b $04, $05, $01,  $04, $06, $02,  $05, $07, $02,  $06, $08, $02
0000F338 0709 0309 0B03 0A0C 030C+  	dc.b $07, $09, $03,  $09, $0B, $03,  $0A, $0C, $03,  $0C, $0E, $03
0000F344 0E10 0410 1104 1113 0414+  	dc.b $0E, $10, $04,  $10, $11, $04,  $11, $13, $04,  $14, $15, $05
0000F350 1618 051A 1C05 1C1F 0620+  	dc.b $16, $18, $05,  $1A, $1C, $05,  $1C, $1F, $06,  $20, $24, $06
0000F35C 2228 0726 2E07 2C34 0830+  	dc.b $22, $28, $07,  $26, $2E, $07,  $2C, $34, $08,  $30, $39, $08
0000F368 343E 093C 440A 404C 0A46+  	dc.b $34, $3E, $09,  $3C, $44, $0A,  $40, $4C, $0A,  $46, $54, $0B
0000F374 4C5A 0C54 620D 5C6B 0D60+  	dc.b $4C, $5A, $0C,  $54, $62, $0D,  $5C, $6B, $0D,  $60, $76, $0E
0000F380 6C7C 0E74 7F0F 7F7F 0F8C   	dc.b $6C, $7C, $0E,  $74, $7F, $0F,  $7F, $7F, $0F,  fReset
0000F38A                            
0000F38A                            ;dFadeOutDataLinear:
0000F38A                            ;	dc.b $01, $00, $00,  $02, $01, $00,  $02, $01, $01,  $03, $02, $01
0000F38A                            ;	dc.b $04, $02, $01,  $04, $03, $02,  $05, $03, $02,  $06, $04, $02
0000F38A                            ;	dc.b $07, $05, $03,  $09, $06, $03,  $0A, $08, $03,  $0C, $0A, $03
0000F38A                            ;	dc.b $0E, $0D, $04,  $10, $0F, $04,  $11, $10, $04,  $14, $13, $05
0000F38A                            ;	dc.b $16, $16, $05,  $1A, $1A, $05,  $1C, $1E, $06,  $20, $22, $06
0000F38A                            ;	dc.b $22, $27, $07,  $26, $2A, $07,  $2C, $2E, $08,  $30, $34, $08
0000F38A                            ;	dc.b $34, $39, $09,  $3C, $3E, $0A,  $40, $3F, $0A,  $46, $40, $0B
0000F38A                            ;	dc.b $4C, $40, $0C,  $54, $40, $0D,  $5C, $40, $0D,  $60, $40, $0E
0000F38A                            ;	dc.b $6C, $40, $0E,  $74, $40, $0F,  $7F, $40, $0F,  fReset
0000F38A                            	even
0000F38A                            ; ===========================================================================
0000F38A                            ; ---------------------------------------------------------------------------
0000F38A                            ; Subroutine for initializing a fade effect.
0000F38A                            ; Since the driver allows for such an extensive and customizable
0000F38A                            ; fading code, we may hit a snag if we use fades too fast. It is
0000F38A                            ; possible, for example, to fade out, then in the middle of that,
0000F38A                            ; start fading in. This would normally cause a quick jump in the
0000F38A                            ; volume level from maybe half to completely mute. This routine
0000F38A                            ; aims to combat this by actually searching for the closest FM
0000F38A                            ; volume level in the fade program, and to start the new fade from
0000F38A                            ; where that byte appears. This can alter how long a volume fade
0000F38A                            ; lasts however, and if PSG and DAC volume are not correct faded,
0000F38A                            ; it may still cause a jump in their volume (especially if only,
0000F38A                            ; say, DAC fades volume). In the future, there might be a fix for
0000F38A                            ; that.
0000F38A                            ; ---------------------------------------------------------------------------
0000F38A                            
0000F38A                            dPlaySnd_FadeOut:
0000F38A 43FA FF94                  		lea	dFadeOutDataLog(pc),a1	; prepare stock fade out program to a1
0000F38E                            
0000F38E                            dLoadFade:
0000F38E 1038 C4B4                  		move.b	mMasterVolFM.w,d0	; load FM master volume to d0
0000F392 4A38 C4B5                  		tst.b	mFadeAddr+1.w		; check if a fade program is already executing
0000F396 6700                       		beq.s	.nofade			; if not, load fade as is
0000F398                            
0000F398 2449                       		move.l	a1,a2			; copy fade program address to a2
0000F39A 74FF                       		moveq	#-1,d2			; prepare max byter difference
0000F39C                            
0000F39C                            .find
0000F39C 1212                       		move.b	(a2),d1			; load the next FM volume from fade program
0000F39E 6A00                       		bpl.s	.search			; branch if this is not a command
0000F3A0                            
0000F3A0                            .nofade
0000F3A0 21C9 C4B4                  		move.l	a1,mFadeAddr.w		; save new fade program address to memory
0000F3A4 11C0 C4B4                  		move.b	d0,mMasterVolFM.w	; save new FM master volume
0000F3A8 4E75                       		rts
0000F3AA                            
0000F3AA                            .search
0000F3AA 568A                       		addq.l	#3,a2			; skip over the current volume group
0000F3AC 9200                       		sub.b	d0,d1			; sub current FM volume from read volume
0000F3AE 6A00                       		bpl.s	.abs			; if positive, do not negate
0000F3B0 4401                       		neg.b	d1			; negative to positive
0000F3B2                            
0000F3B2                            .abs
0000F3B2 B202                       		cmp.b	d2,d1			; check if volume difference was smaller than before
0000F3B4 64E6                       		bhs.s	.find			; if not, read next group
0000F3B6                            
0000F3B6 1401                       		move.b	d1,d2			; else save the new difference
0000F3B8 224A                       		move.l	a2,a1			; also save the fade program address where we found it
0000F3BA 60E0                       		bra.s	.find			; loop through each group in the program
0000F3BC                            ; ===========================================================================
0000F3BC                            ; ---------------------------------------------------------------------------
0000F3BC                            ; Routine for loading a volume filter into Dual PCM ROM.
0000F3BC                            ; This routine will actually write the bank number the volume filter
0000F3BC                            ; is in. This requires volume filters are aligned to Z80 banks, and
0000F3BC                            ; just because we can, we write 9 bits (yeah its not necessary, but
0000F3BC                            ; what the hell, you have to have fun sometimes!)
0000F3BC                            ; ---------------------------------------------------------------------------
0000F3BC                            
0000F3BC                            dSetFilter:
0000F3BC 43F9 0000 0000             		lea	dZ80+SV_VolumeBank,a1	; load volume bank instructions address to a1
0000F3C2 7274                       		moveq	#$74,d1			; prepare the "ld  (hl),h" instruction to d1
0000F3C4 7408                       		moveq	#9-1,d2			; prepare number of instructions to write to d2
0000F3C6                            	StopZ80					; wait for Z80 to stop
0000F3C6 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0000F3CE                          M 	waitz80stop
0000F3CE 0839 0000 00A1 1100      M .wait_620:	btst	#0,z80_bus_req
0000F3D6 66F6                     M 	bne.s	.wait_620
0000F3D8                            ; ---------------------------------------------------------------------------
0000F3D8                            ; addx in Motorola 68000 is much like adc in Z80. It allows us to add
0000F3D8                            ; a register AND the carry to another register. What this means, is if
0000F3D8                            ; we push 1 into carry (so, carry set), we will be loading $75 instead
0000F3D8                            ; of $74 into the carry, making us able to switch between the Z80
0000F3D8                            ; instructions  "ld  (hl),h" and "ld  (hl),l", which in turn allows
0000F3D8                            ; Dual PCM to bank switch into the appropriate bank.
0000F3D8                            ; ---------------------------------------------------------------------------
0000F3D8                            
0000F3D8                            .loop
0000F3D8 7600                       		moveq	#0,d3			; prepare 0 into d3 (because of addx)
0000F3DA E248                       		lsr.w	#1,d0			; shift lsb into carry
0000F3DC D701                       		addx.b	d1,d3			; add instruction and carry into d3
0000F3DE                            
0000F3DE 12C3                       		move.b	d3,(a1)+		; save instruction into Z80 memory
0000F3E0 51CA FFF6                  		dbf	d2,.loop		; repeat for each bit/instruction
0000F3E4                            	StartZ80				; enable Z80 execution
0000F3E4 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0000F3EC 4E75                       		rts
0000F3EE                            
0000F3EE                            ; ===========================================================================
0000F3EE                            ; ---------------------------------------------------------------------------
0000F3EE                            ; Routine for resetting master volumes, filters and disabling fading
0000F3EE                            ; ---------------------------------------------------------------------------
0000F3EE                            
0000F3EE                            dResetVolume:
0000F3EE 42B8 C4B4                  		clr.l	mFadeAddr.w		; stop fading program and reset FM master volume
0000F3F2 4238 C4BF                  		clr.b	mMasterVolPSG.w		; reset PSG master volume
0000F3F6 4238 C4C0                  		clr.b	mMasterVolDAC.w		; reset DAC master volume
0000F3FA 303C 0000                  		move.w	#fLog>>$0F,d0		; load value for linear filter
0000F3FE 61BC                       		bsr.s	dSetFilter		; load filter instructions
0000F400                            
0000F400                            dUpdateVolumeAll:
0000F400 6100                       		bsr.s	dReqVolUpFM		; request FM volume update
0000F402 8138 C67C                  		or.b	d0,mSFXDAC1.w		; request update for SFX DAC1 channel
0000F406                            
0000F406 =FFFFC4C4                  .ch =	mDAC1					; start at DAC1
0000F406                            	rept Mus_DAC				; loop through all music DAC channels
0000F406                            		or.b	d0,.ch.w		; request channel volume update
0000F406                            .ch =		.ch+cSize			; go to next channel
0000F406                            	endr
0000F406 8138 C4C4                M 	or.b	d0,.ch.w
0000F40A =FFFFC4F0                M .ch	=	.ch+csize
0000F40A 8138 C4F0                M 	or.b	d0,.ch.w
0000F40E =FFFFC51C                M .ch	=	.ch+csize
0000F40E                            
0000F40E =FFFFC5F8                  .ch =	mPSG1					; start at PSG1
0000F40E                            	rept Mus_PSG				; loop through all music PSG channels
0000F40E                            		or.b	d0,.ch.w		; request channel volume update
0000F40E                            .ch =		.ch+cSize			; go to next channel
0000F40E                            	endr
0000F40E 8138 C5F8                M 	or.b	d0,.ch.w
0000F412 =FFFFC624                M .ch	=	.ch+csize
0000F412 8138 C624                M 	or.b	d0,.ch.w
0000F416 =FFFFC650                M .ch	=	.ch+csize
0000F416 8138 C650                M 	or.b	d0,.ch.w
0000F41A =FFFFC67C                M .ch	=	.ch+csize
0000F41A                            
0000F41A =FFFFC6EC                  .ch =	mSFXPSG1				; start at SFX PSG1
0000F41A                            	rept SFX_PSG				; loop through all SFX PSG channels
0000F41A                            		or.b	d0,.ch.w		; request channel volume update
0000F41A                            .ch =		.ch+cSizeSFX			; go to next channel
0000F41A                            	endr
0000F41A 8138 C6EC                M 	or.b	d0,.ch.w
0000F41E =FFFFC708                M .ch	=	.ch+csizesfx
0000F41E 8138 C708                M 	or.b	d0,.ch.w
0000F422 =FFFFC724                M .ch	=	.ch+csizesfx
0000F422 8138 C724                M 	or.b	d0,.ch.w
0000F426 =FFFFC740                M .ch	=	.ch+csizesfx
0000F426 4E75                       		rts
0000F428                            ; ===========================================================================
0000F428                            ; ---------------------------------------------------------------------------
0000F428                            ; Enable speed shoes mode
0000F428                            ; ---------------------------------------------------------------------------
0000F428                            
0000F428                            dPlaySnd_ShoesOn:
0000F428 11F8 C4B9 C4BB             		move.b	mTempoSpeed.w,mTempoCur.w; set tempo accumulator/counter to speed shoes one
0000F42E 11F8 C4B9 C4BA             		move.b	mTempoSpeed.w,mTempo.w	; set main tempor to speed shoes one
0000F434 08F8 0001 C4A6             		bset	#mfbSpeed,mFlags.w	; enable speed shoes flag
0000F43A 4E75                       		rts
0000F43C                            ; ===========================================================================
0000F43C                            ; ---------------------------------------------------------------------------
0000F43C                            ; Reset music flags (underwater mode and tempo mode)
0000F43C                            ; ---------------------------------------------------------------------------
0000F43C                            
0000F43C                            dPlaySnd_Reset:
0000F43C 6100                       		bsr.s	dPlaySnd_OutWater	; gp reset underwater flag and request volume update
0000F43E                            ; ===========================================================================
0000F43E                            ; ---------------------------------------------------------------------------
0000F43E                            ; Disable speed shoes mode
0000F43E                            ; ---------------------------------------------------------------------------
0000F43E                            
0000F43E                            dPlaySnd_ShoesOff:
0000F43E 11F8 C4B8 C4BB             		move.b	mTempoMain.w,mTempoCur.w; set tempo accumulator/counter to normal one
0000F444 11F8 C4B8 C4BA             		move.b	mTempoMain.w,mTempo.w	; set main tempor to normal one
0000F44A 08B8 0001 C4A6             		bclr	#mfbSpeed,mFlags.w	; disable speed shoes flag
0000F450 4E75                       		rts
0000F452                            ; ===========================================================================
0000F452                            ; ---------------------------------------------------------------------------
0000F452                            ; Enable Underwater mode
0000F452                            ; ---------------------------------------------------------------------------
0000F452                            
0000F452                            dPlaySnd_ToWater:
0000F452 08F8 0002 C4A6             		bset	#mfbWater,mFlags.w	; enable underwater mode
0000F458 6000                       		bra.s	dReqVolUpFM		; request FM volume update
0000F45A                            ; ===========================================================================
0000F45A                            ; ---------------------------------------------------------------------------
0000F45A                            ; Disable Underwater mode
0000F45A                            ; ---------------------------------------------------------------------------
0000F45A                            
0000F45A                            dPlaySnd_OutWater:
0000F45A 08B8 0002 C4A6             		bclr	#mfbWater,mFlags.w	; disable underwater mode
0000F460                            ; ===========================================================================
0000F460                            ; ---------------------------------------------------------------------------
0000F460                            ; force volume update on all FM channels
0000F460                            ; ---------------------------------------------------------------------------
0000F460                            
0000F460                            dReqVolUpFM;
0000F460 7020                       		moveq	#1<<cfbVol,d0		; prepare volume update flag to d0
0000F462 =FFFFC51C                  .ch =	mFM1					; start at FM1
0000F462                            	rept Mus_FM				; loop through all music FM channels
0000F462                            		or.b	d0,.ch.w		; request channel volume update
0000F462                            .ch =		.ch+cSize			; go to next channel
0000F462                            	endr
0000F462 8138 C51C                M 	or.b	d0,.ch.w
0000F466 =FFFFC548                M .ch	=	.ch+csize
0000F466 8138 C548                M 	or.b	d0,.ch.w
0000F46A =FFFFC574                M .ch	=	.ch+csize
0000F46A 8138 C574                M 	or.b	d0,.ch.w
0000F46E =FFFFC5A0                M .ch	=	.ch+csize
0000F46E 8138 C5A0                M 	or.b	d0,.ch.w
0000F472 =FFFFC5CC                M .ch	=	.ch+csize
0000F472 8138 C5CC                M 	or.b	d0,.ch.w
0000F476 =FFFFC5F8                M .ch	=	.ch+csize
0000F476                            
0000F476 =FFFFC698                  .ch =	mSFXFM3					; start at SFX FM3
0000F476                            	rept SFX_FM				; loop through all SFX FM channels
0000F476                            		or.b	d0,.ch.w		; request channel volume update
0000F476                            .ch =		.ch+cSizeSFX			; go to next channel
0000F476                            	endr
0000F476 8138 C698                M 	or.b	d0,.ch.w
0000F47A =FFFFC6B4                M .ch	=	.ch+csizesfx
0000F47A 8138 C6B4                M 	or.b	d0,.ch.w
0000F47E =FFFFC6D0                M .ch	=	.ch+csizesfx
0000F47E 8138 C6D0                M 	or.b	d0,.ch.w
0000F482 =FFFFC6EC                M .ch	=	.ch+csizesfx
0000F482 4E75                       		rts
0000F484                            ; ===========================================================================
0000F484                            ; ---------------------------------------------------------------------------
0000F484                            ; Subroutine for updating Total Levels for FM channel
0000F484                            ; ---------------------------------------------------------------------------
0000F484                            
0000F484                            dUpdateVolFM:
0000F484 0815 0001                  		btst	#cfbInt,(a5)		; is the channel interrupted by SFX?
0000F488 6600                       		bne.s	locret_VolFM		; if yes, do not update
0000F48A                            
0000F48A 162D 0009                  		move.b	cVolume(a5),d3		; load FM channel volume to d3
0000F48E D638 C4B4                  		add.b	mMasterVolFM.w,d3	; add master FM volume to d3
0000F492 6A00                       		bpl.s	.noover			; if volume did not overflow, skio
0000F494 767F                       		moveq	#$7F,d3			; force FM volume to silence
0000F496                            
0000F496                            .noover
0000F496 7000                       		moveq	#0,d0
0000F498 102D 000B                  		move.b	cVoice(a5),d0		; load FM voice ID of the channel to d0
0000F49C 224E                       		move.l	a6,a1			; copy music voice table address to a1
0000F49E                            
0000F49E                            	dCALC_VOICE				; get address of the specific voice to a1
0000F49E EB48                     M 	lsl.w	#5,d0
0000F4A0 D2C0                     M 	add.w	d0,a1
0000F4A2 1011                       		move.b	(a1),d0			; load algorithm and feedback to d0
0000F4A4 7C00                       		moveq	#0,d6			; reset the modulator offset
0000F4A6                            
0000F4A6 0838 0002 C4A6             		btst	#mfbWater,mFlags.w	; check if underwater mode is enabled
0000F4AC 6700                       		beq.s	.uwdone			; if not, skip
0000F4AE 1C00                       		move.b	d0,d6			; copy algorithm and feedback to d6
0000F4B0 0246 0007                  		and.w	#7,d6			; mask out everything but the algorithm
0000F4B4 D606                       		add.b	d6,d3			; add algorithm to Total Level carrier offset
0000F4B6 1C00                       		move.b	d0,d6			; set algorithm and feedback to modulator offset
0000F4B8                            
0000F4B8                            .uwdone
0000F4B8 7A03                       		moveq	#4-1,d5			; prepare 4 operators to d5
0000F4BA D2FC 0019                  		add.w	#VoiceTL,a1		; go to the Total Level offset of the voice
0000F4BE 45FA 0000                  		lea	dOpTLFM(pc),a2		; load Total Level address table to a3
0000F4C2                            
0000F4C2                            .tlloop
0000F4C2 101A                       		move.b	(a2)+,d0		; load YM address to write to
0000F4C4 1219                       		move.b	(a1)+,d1		; get Total Level value from voice to d1
0000F4C6 6A00                       		bpl.s	.noslot			; if slot operator bit was not set, branch
0000F4C8                            
0000F4C8 D203                       		add.b	d3,d1			; add carrier offset to loaded value
0000F4CA 6B00                       		bmi.s	.slot			; if we did not overflow, branch
0000F4CC 727F                       		moveq	#$7F,d1			; cap to silent volume
0000F4CE 6000                       		bra.s	.slot
0000F4D0                            
0000F4D0                            .noslot
0000F4D0 D206                       		add.b	d6,d1			; add modulator offset to loaded value
0000F4D2                            .slot
0000F4D2 4EBA 0000                  		jsr	WriteChYM(pc)		; write Total Level to YM according to channel
0000F4D6                            .ignore
0000F4D6 51CD FFEA                  		dbf	d5,.tlloop		; repeat for each Total Level operator
0000F4DA                            
0000F4DA                            		AMPS_Debug_UpdVolFM		; check if the voice was valid
0000F4DA 0C19 004E                M 	cmp.b	#'N',(a1)+
0000F4DE 6600                     M 	bne.s	.fail
0000F4E0 0C59 4154                M 	cmp.w	#'AT',(a1)+
0000F4E4 6700                     M 	beq.s	.ok
0000F4E6                          M .fail
0000F4E6 4EBA EA80                M 	jsr	amps_debugr_updvolfm
0000F4EA                          M .ok
0000F4EA                            
0000F4EA                            locret_VolFM:
0000F4EA 4E75                       		rts
0000F4EC                            ; ===========================================================================
0000F4EC                            ; ---------------------------------------------------------------------------
0000F4EC                            ; YM2612 register update list
0000F4EC                            ; ---------------------------------------------------------------------------
0000F4EC                            
0000F4EC 3038 343C                  dOpListYM:	dc.b $30, $38, $34, $3C		; Detune, Multiple
0000F4F0 5058 545C                  		dc.b $50, $58, $54, $5C		; Rate Scale, Attack Rate
0000F4F4 6068 646C                  dAMSEn_Ops:	dc.b $60, $68, $64, $6C		; Decay 1 Rate
0000F4F8 7078 747C                  		dc.b $70, $78, $74, $7C		; Decay 2 Rate
0000F4FC 8088 848C                  		dc.b $80, $88, $84, $8C		; Decay 1 level, Release Rate
0000F500 9098 949C                  		dc.b $90, $98, $94, $9C		; SSG-EG
0000F504 4048 444C                  dOpTLFM:	dc.b $40, $48, $44, $4C		; Total Level
0000F508                            ; ===========================================================================
0000F508                            ; ---------------------------------------------------------------------------
0000F508                            ; Process SFX FM channels
0000F508                            ; ---------------------------------------------------------------------------
0000F508                            
0000F508                            dAMPSdoFMSFX:
0000F508 4DFA 0000                  		lea	VoiceBankSFX(pc),a6	; load sound effects voice table into a6
0000F50C 7E02                       		moveq	#SFX_FM-1,d7		; get total number of SFX FM channels to d7
0000F50E                            
0000F50E                            dAMPSnextFMSFX:
0000F50E DAFC 001C                  		add.w	#cSizeSFX,a5		; go to the next channel
0000F512 4A15                       		tst.b	(a5)			; check if channel is running a tracker
0000F514 6A00 0000                  		bpl.w	.next			; if not, branch
0000F518 532D 000C                  		subq.b	#1,cDuration(a5)	; decrease note duration
0000F51C 6700 0000                  		beq.w	.update			; if timed out, update channel
0000F520                            
0000F520                            	dCalcFreq				; calculate channel base frequency
0000F520 1C2D 0007                M 	move.b	cdetune(a5),d6
0000F524 4886                     M 	ext.w	d6
0000F526 DC6D 000E                M 	add.w	cfreq(a5),d6
0000F52A                            	dModulate dAMPSdoPSGSFX, dAMPSnextFMSFX, 1; run modulation code
0000F52A 0815 0003                M 	btst	#cfbmod,(a5)
0000F52E 6700                     M 	beq.s	.noret
0000F530 4A2D 0010                M 	tst.b	cmoddelay(a5)
0000F534 6700                     M 	beq.s	.started
0000F536 532D 0010                M 	subq.b	#1,cmoddelay(a5)
0000F53A                          M .noret
0000F53A 0895 0005                M 	bclr	#cfbvol,(a5)
0000F53E 6700                     M 	beq.s	.noupdatevol
0000F540 4EBA FF42                M 	jsr	dupdatevolfm(pc)
0000F544                          M 	.noupdatevol:
0000F544 51CF FFC8                M 	dbf	d7,dampsnextfmsfx
0000F548 6000 0000                M 	bra.w	dampsdopsgsfx
0000F54C                          M .started
0000F54C 532D 0016                M 	subq.b	#1,cmodspeed(a5)
0000F550 66E8                     M 	bne.s	.noret
0000F552 226D 0010                M 	movea.l	cmod(a5),a1
0000F556 1B69 0001 0016           M 	move.b	1(a1),cmodspeed(a5)
0000F55C 4A2D 0018                M 	tst.b	cmodcount(a5)
0000F560 6600                     M 	bne.s	.norev
0000F562 1B69 0003 0018           M 	move.b	3(a1),cmodcount(a5)
0000F568 442D 0017                M 	neg.b	cmodstep(a5)
0000F56C                          M .norev
0000F56C 532D 0018                M 	subq.b	#1,cmodcount(a5)
0000F570 1A2D 0017                M 	move.b	cmodstep(a5),d5
0000F574 4885                     M 	ext.w	d5
0000F576 DA6D 0014                M 	add.w	cmodfreq(a5),d5
0000F57A 3B45 0014                M 	move.w	d5,cmodfreq(a5)
0000F57E DC45                     M 	add.w	d5,d6
0000F580 6100 0000                  		bsr.w	dUpdateFreqFM3		; send FM frequency to hardware
0000F584                            
0000F584 0895 0005                  		bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0000F588 6700                       		beq.s	.next			; if not, skip
0000F58A 4EBA FEF8                  		jsr	dUpdateVolFM(pc)	; update FM volume
0000F58E                            
0000F58E                            .next
0000F58E 51CF FF7E                  		dbf	d7,dAMPSnextFMSFX	; make sure to run all the channels
0000F592 4EFA 0000                  		jmp	dAMPSdoPSGSFX(pc)	; after that, process SFX PSG channels
0000F596                            
0000F596                            .update
0000F596 0215 00FA                  		and.b	#$FF-(1<<cfbHold)-(1<<cfbRest),(a5); clear hold and rest flags
0000F59A                            	dDoTracker				; process tracker
0000F59A 286D 0002                M 	movea.l	cdata(a5),a4
0000F59E                          M 	amps_debug_trackupd
0000F59E 220C                     M 	move.l	a4,d1
0000F5A0 0281 00FF FFFF           M 	and.l	#$ffffff,d1
0000F5A6 0C81 0000 0000           M 	cmp.l	#sfxaddr,d1
0000F5AC 6500                     M 	blo.s	.fail2
0000F5AE 0C81 0000 0000           M 	cmp.l	#dacaddr,d1
0000F5B4 6500                     M 	blo.s	.data
0000F5B6                          M .fail2
0000F5B6                          M 	raiseerror	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_channel
0000F5B6 487A FFFE                M 	pea	*(pc)
0000F5BA                          M 	raiseerror2	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_channel
0000F5BA 40E7                     M 	move.w	sr,-(sp)
0000F5BC                          M 	__fstring_generateargumentscode	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F5BC =0000001A                M 	__pos:	set instr("Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F5BC =00000000                M 	__stack:set	0
0000F5BC =00000000                M 	__sp:	set 0
0000F5BC                          M 	while	(__pos)
0000F5BC =00000021                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000F5BC =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000F5BC =00000021                M 	__midpos:	= __endpos
0000F5BC                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F5BC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F5BC                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F5BC                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F5BC                          M 	pushp	"move.l a4,-(sp)"
0000F5BC =00000001                M 	__stack:	= __stack+1
0000F5BC =00000004                M 	__sp:	= __sp+4
0000F5BC =00000022                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F5BC =00000029                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000F5BC =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000F5BC =00000029                M 	__midpos:	= __endpos
0000F5BC                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F5BC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F5BC =0000002A                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F5BC =00000035                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000F5BC =00000031                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000F5BC                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F5BC                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F5BC                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F5BC                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F5BC                          M 	pushp	"move.l a4,-(sp)"
0000F5BC =00000002                M 	__stack:	= __stack+1
0000F5BC =00000008                M 	__sp:	= __sp+4
0000F5BC =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F5BC                          M 	rept	__stack
0000F5BC                          M 	popp	__command
0000F5BC 2F0C                     M 	move.l	a4,-(sp)
0000F5BE                          M 	popp	__command
0000F5BE 2F0C                     M 	move.l	a4,-(sp)
0000F5C0 4EB9 0000 0000           M 	jsr	errorhandler
0000F5C6                          M 	__fstring_generatedecodedstring	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F5C6 =00000001                M 	__lpos:	set 1
0000F5C6 =0000001A                M 	__pos:	set instr("Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F5C6                          M 	while	(__pos)
0000F5C6                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F5C6 496E 7661 6C69 6420 7472+M 	dc.b	"Invalid tracker address: "
0000F5DF =00000021                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000F5DF =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000F5DF =00000021                M 	__midpos:	= __endpos
0000F5DF                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F5DF                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F5DF                          M 	__param:	substr ,,"hex"
0000F5DF 83                       M 	dc.b	hex|3
0000F5E0 =00000022                M 	__lpos:	set __endpos+1
0000F5E0 =00000022                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F5E0                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F5E0                          M 	dc.b	""
0000F5E0 =00000029                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000F5E0 =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000F5E0 =00000029                M 	__midpos:	= __endpos
0000F5E0                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F5E0                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F5E0 E0                       M 	dc.b	fendl
0000F5E1 =0000002A                M 	__lpos:	set __endpos+1
0000F5E1 =0000002A                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F5E1                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F5E1                          M 	dc.b	""
0000F5E1 =00000035                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000F5E1 =00000031                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000F5E1                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F5E1                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F5E1 B3                       M 	dc.b	sym|3
0000F5E2 =00000036                M 	__lpos:	set __endpos+1
0000F5E2 =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F5E2                          M 	__substr:	substr __lpos,,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F5E2                          M 	dc.b	""
0000F5E2 00                       M 	dc.b	0
0000F5E3 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000F5E4                          M 	even
0000F5E4 4EFA DC96                M 	jmp	amps_debug_console_channel
0000F5E8                          M 	even
0000F5E8                          M .data
0000F5E8 7A00                     M 	moveq	#0,d5
0000F5EA 1A1C                     M 	move.b	(a4)+,d5
0000F5EC 0C05 00E0                M 	cmpi.b	#$e0,d5
0000F5F0 6500                     M 	blo.s	.notcomm
0000F5F2 4EBA 0000                M 	jsr	dcommands(pc)
0000F5F6 60F0                     M 	bra.s	.data
0000F5F8 6094                     M 	bra.s	.next
0000F5FA                          M .notcomm
0000F5FA 4EBA 0000                  		jsr	dKeyOffFM2(pc)		; send key-off command to YM
0000F5FE 4A05                       		tst.b	d5			; check if note is being played
0000F600 6A00                       		bpl.s	.timer			; if not, it must be a timer. branch
0000F602                            
0000F602 6100 0000                  		bsr.w	dGetFreqFM		; get frequency
0000F606 1A1C                       		move.b	(a4)+,d5		; check next byte
0000F608 6A00                       		bpl.s	.timer			; if positive, process a tiemr too
0000F60A 534C                       		subq.w	#1,a4			; if not, then return back
0000F60C 6000                       		bra.s	.pcnote			; do some extra clearing
0000F60E                            
0000F60E                            .timer
0000F60E 4EBA F330                  		jsr	dCalcDuration(pc)	; calculate duration
0000F612                            .pcnote
0000F612                            	dProcNote 1, 0				; reset necessary channel memory
0000F612 2B4C 0002                M 	move.l	a4,cdata(a5)
0000F616 1B6D 000D 000C           M 	move.b	clastdur(a5),cduration(a5)
0000F61C 0815 0002                M 	btst	#cfbhold,(a5)
0000F620 6600                     M 	bne.s	.endpn
0000F622 0815 0003                M 	btst	#cfbmod,(a5)
0000F626 6700                     M 	beq.s	.endpn
0000F628 226D 0010                M 	movea.l	cmod(a5),a1
0000F62C 1B59 0010                M 	move.b	(a1)+,cmoddelay(a5)
0000F630 1B59 0016                M 	move.b	(a1)+,cmodspeed(a5)
0000F634 1B59 0017                M 	move.b	(a1)+,cmodstep(a5)
0000F638 1011                     M 	move.b	(a1),d0
0000F63A E208                     M 	lsr.b	#1,d0
0000F63C 1B40 0018                M 	move.b	d0,cmodcount(a5)
0000F640 426D 0014                M 	clr.w	cmodfreq(a5)
0000F644                          M .endpn
0000F644 6100 0000                  		bsr.w	dUpdateFreqFM		; send FM frequency to hardware
0000F648                            	dKeyOnFM 1				; send key-on command to YM
0000F648 0815 0002                M 	btst	#cfbhold,(a5)
0000F64C 6600                     M 	bne.s	.k
0000F64E 0815 0000                M 	btst	#cfbrest,(a5)
0000F652 6600                     M 	bne.s	.k
0000F654 7028                     M 	moveq	#$28,d0
0000F656 122D 0001                M 	move.b	ctype(a5),d1
0000F65A 0001 00F0                M 	ori.b	#$f0,d1
0000F65E 6100 0000                M 	bsr.w	writeym_pt1
0000F662                          M .k
0000F662                            
0000F662 0895 0005                  		bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0000F666 6700                       		beq.s	.noupdate		; if not, branch
0000F668 4EBA FE1A                  		jsr	dUpdateVolFM(pc)	; update FM volume
0000F66C                            
0000F66C 51CF FEA0                  .noupdate	dbf	d7,dAMPSnextFMSFX	; make sure to run all the channels
0000F670 4EFA 0000                  		jmp	dAMPSdoPSGSFX(pc)	; after that, process SFX PSG channels
0000F674                            ; ===========================================================================
0000F674                            ; ---------------------------------------------------------------------------
0000F674                            ; Process music FM channels
0000F674                            ; ---------------------------------------------------------------------------
0000F674                            
0000F674                            dAMPSdoFM:
0000F674 4DFA 0000                  		lea	VoiceBankMusic(pc),a6	; load music voice table into a6
0000F678 7E04                       		moveq	#Mus_FM-1,d7		; get total number of music FM channels to d7
0000F67A                            
0000F67A                            dAMPSnextFM:
0000F67A DAFC 002C                  		add.w	#cSize,a5		; go to the next channel
0000F67E 4A15                       		tst.b	(a5)			; check if channel is running a tracker
0000F680 6A00 0000                  		bpl.w	.next			; if not, branch
0000F684 532D 000C                  		subq.b	#1,cDuration(a5)	; decrease note duration
0000F688 6700 0000                  		beq.w	.update			; if timed out, update channel
0000F68C                            
0000F68C                            	dNoteToutFM.w				; handle FM-specific note timeout behavior
0000F68C                          M 	dnotetouthandler
0000F68C 4A2D 001C                M 	tst.b	cnotetimecur(a5)
0000F690 6700                     M 	beq.s	.endt
0000F692 532D 001C                M 	subq.b	#1,cnotetimecur(a5)
0000F696 6600                     M 	bne.s	.endt
0000F698 08D5 0000                M 	bset	#cfbrest,(a5)
0000F69C 6100 0000                M 	bsr.w	dkeyofffm
0000F6A0 6000 0000                M 	bra.w	.next
0000F6A4                          M .endt
0000F6A4                            	dCalcFreq				; calculate channel base frequency
0000F6A4 1C2D 0007                M 	move.b	cdetune(a5),d6
0000F6A8 4886                     M 	ext.w	d6
0000F6AA DC6D 000E                M 	add.w	cfreq(a5),d6
0000F6AE                            	dModulate dAMPSdoPSG, dAMPSnextFM, 0	; run modulation code
0000F6AE 0815 0003                M 	btst	#cfbmod,(a5)
0000F6B2 6700                     M 	beq.s	.noret
0000F6B4 4A2D 0010                M 	tst.b	cmoddelay(a5)
0000F6B8 6700                     M 	beq.s	.started
0000F6BA 532D 0010                M 	subq.b	#1,cmoddelay(a5)
0000F6BE                          M .noret
0000F6BE 0895 0005                M 	bclr	#cfbvol,(a5)
0000F6C2 6700                     M 	beq.s	.noupdatevol
0000F6C4 4EBA FDBE                M 	jsr	dupdatevolfm(pc)
0000F6C8                          M 	.noupdatevol:
0000F6C8 51CF FFB0                M 	dbf	d7,dampsnextfm
0000F6CC 6000 0000                M 	bra.w	dampsdopsg
0000F6D0                          M .started
0000F6D0 532D 0016                M 	subq.b	#1,cmodspeed(a5)
0000F6D4 66E8                     M 	bne.s	.noret
0000F6D6 226D 0010                M 	movea.l	cmod(a5),a1
0000F6DA 1B69 0001 0016           M 	move.b	1(a1),cmodspeed(a5)
0000F6E0 4A2D 0018                M 	tst.b	cmodcount(a5)
0000F6E4 6600                     M 	bne.s	.norev
0000F6E6 1B69 0003 0018           M 	move.b	3(a1),cmodcount(a5)
0000F6EC 442D 0017                M 	neg.b	cmodstep(a5)
0000F6F0                          M .norev
0000F6F0 532D 0018                M 	subq.b	#1,cmodcount(a5)
0000F6F4 1A2D 0017                M 	move.b	cmodstep(a5),d5
0000F6F8 4885                     M 	ext.w	d5
0000F6FA DA6D 0014                M 	add.w	cmodfreq(a5),d5
0000F6FE 3B45 0014                M 	move.w	d5,cmodfreq(a5)
0000F702 DC45                     M 	add.w	d5,d6
0000F704 6100 0000                  		bsr.w	dUpdateFreqFM2		; send FM frequency to hardware
0000F708                            
0000F708 0895 0005                  		bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0000F70C 6700                       		beq.s	.next			; if not, skip
0000F70E 4EBA FD74                  		jsr	dUpdateVolFM(pc)	; update FM volume
0000F712                            
0000F712                            .next
0000F712 51CF FF66                  		dbf	d7,dAMPSnextFM		; make sure to run all the channels
0000F716 4EFA 0000                  		jmp	dAMPSdoPSG(pc)		; after that, process music PSG channels
0000F71A                            
0000F71A                            .update
0000F71A 0215 00FA                  		and.b	#$FF-(1<<cfbHold)-(1<<cfbRest),(a5); clear hold and rest flags
0000F71E                            	dDoTracker				; process tracker
0000F71E 286D 0002                M 	movea.l	cdata(a5),a4
0000F722                          M 	amps_debug_trackupd
0000F722 220C                     M 	move.l	a4,d1
0000F724 0281 00FF FFFF           M 	and.l	#$ffffff,d1
0000F72A 0C81 0000 0000           M 	cmp.l	#sfxaddr,d1
0000F730 6500                     M 	blo.s	.fail2
0000F732 0C81 0000 0000           M 	cmp.l	#dacaddr,d1
0000F738 6500                     M 	blo.s	.data
0000F73A                          M .fail2
0000F73A                          M 	raiseerror	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_channel
0000F73A 487A FFFE                M 	pea	*(pc)
0000F73E                          M 	raiseerror2	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_channel
0000F73E 40E7                     M 	move.w	sr,-(sp)
0000F740                          M 	__fstring_generateargumentscode	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F740 =0000001A                M 	__pos:	set instr("Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F740 =00000000                M 	__stack:set	0
0000F740 =00000000                M 	__sp:	set 0
0000F740                          M 	while	(__pos)
0000F740 =00000021                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000F740 =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000F740 =00000021                M 	__midpos:	= __endpos
0000F740                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F740                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F740                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F740                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F740                          M 	pushp	"move.l a4,-(sp)"
0000F740 =00000001                M 	__stack:	= __stack+1
0000F740 =00000004                M 	__sp:	= __sp+4
0000F740 =00000022                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F740 =00000029                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000F740 =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000F740 =00000029                M 	__midpos:	= __endpos
0000F740                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F740                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F740 =0000002A                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F740 =00000035                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000F740 =00000031                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000F740                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F740                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F740                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F740                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F740                          M 	pushp	"move.l a4,-(sp)"
0000F740 =00000002                M 	__stack:	= __stack+1
0000F740 =00000008                M 	__sp:	= __sp+4
0000F740 =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F740                          M 	rept	__stack
0000F740                          M 	popp	__command
0000F740 2F0C                     M 	move.l	a4,-(sp)
0000F742                          M 	popp	__command
0000F742 2F0C                     M 	move.l	a4,-(sp)
0000F744 4EB9 0000 0000           M 	jsr	errorhandler
0000F74A                          M 	__fstring_generatedecodedstring	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F74A =00000001                M 	__lpos:	set 1
0000F74A =0000001A                M 	__pos:	set instr("Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F74A                          M 	while	(__pos)
0000F74A                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F74A 496E 7661 6C69 6420 7472+M 	dc.b	"Invalid tracker address: "
0000F763 =00000021                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000F763 =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000F763 =00000021                M 	__midpos:	= __endpos
0000F763                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F763                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F763                          M 	__param:	substr ,,"hex"
0000F763 83                       M 	dc.b	hex|3
0000F764 =00000022                M 	__lpos:	set __endpos+1
0000F764 =00000022                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F764                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F764                          M 	dc.b	""
0000F764 =00000029                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000F764 =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000F764 =00000029                M 	__midpos:	= __endpos
0000F764                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F764                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F764 E0                       M 	dc.b	fendl
0000F765 =0000002A                M 	__lpos:	set __endpos+1
0000F765 =0000002A                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F765                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F765                          M 	dc.b	""
0000F765 =00000035                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000F765 =00000031                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000F765                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F765                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F765 B3                       M 	dc.b	sym|3
0000F766 =00000036                M 	__lpos:	set __endpos+1
0000F766 =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000F766                          M 	__substr:	substr __lpos,,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000F766                          M 	dc.b	""
0000F766 00                       M 	dc.b	0
0000F767 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000F768                          M 	even
0000F768 4EFA DB12                M 	jmp	amps_debug_console_channel
0000F76C                          M 	even
0000F76C                          M .data
0000F76C 7A00                     M 	moveq	#0,d5
0000F76E 1A1C                     M 	move.b	(a4)+,d5
0000F770 0C05 00E0                M 	cmpi.b	#$e0,d5
0000F774 6500                     M 	blo.s	.notcomm
0000F776 4EBA 0000                M 	jsr	dcommands(pc)
0000F77A 60F0                     M 	bra.s	.data
0000F77C 6094                     M 	bra.s	.next
0000F77E                          M .notcomm
0000F77E 4EBA 0000                  		jsr	dKeyOffFM(pc)		; send key-off command to YM
0000F782 4A05                       		tst.b	d5			; check if note is being played
0000F784 6A00                       		bpl.s	.timer			; if not, it must be a timer. branch
0000F786                            
0000F786 6100 0000                  		bsr.w	dGetFreqFM		; get frequency
0000F78A 1A1C                       		move.b	(a4)+,d5		; check next byte
0000F78C 6A00                       		bpl.s	.timer			; if positive, process a tiemr too
0000F78E 534C                       		subq.w	#1,a4			; if not, then return back
0000F790 6000                       		bra.s	.pcnote			; do some extra clearing
0000F792                            
0000F792                            .timer
0000F792 4EBA F1AC                  		jsr	dCalcDuration(pc)	; calculate duration
0000F796                            .pcnote
0000F796                            	dProcNote 0, 0				; reset necessary channel memory
0000F796 2B4C 0002                M 	move.l	a4,cdata(a5)
0000F79A 1B6D 000D 000C           M 	move.b	clastdur(a5),cduration(a5)
0000F7A0 0815 0002                M 	btst	#cfbhold,(a5)
0000F7A4 6600                     M 	bne.s	.endpn
0000F7A6 1B6D 001D 001C           M 	move.b	cnotetimemain(a5),cnotetimecur(a5)
0000F7AC 0815 0003                M 	btst	#cfbmod,(a5)
0000F7B0 6700                     M 	beq.s	.endpn
0000F7B2 226D 0010                M 	movea.l	cmod(a5),a1
0000F7B6 1B59 0010                M 	move.b	(a1)+,cmoddelay(a5)
0000F7BA 1B59 0016                M 	move.b	(a1)+,cmodspeed(a5)
0000F7BE 1B59 0017                M 	move.b	(a1)+,cmodstep(a5)
0000F7C2 1011                     M 	move.b	(a1),d0
0000F7C4 E208                     M 	lsr.b	#1,d0
0000F7C6 1B40 0018                M 	move.b	d0,cmodcount(a5)
0000F7CA 426D 0014                M 	clr.w	cmodfreq(a5)
0000F7CE                          M .endpn
0000F7CE 6100                       		bsr.s	dUpdateFreqFM		; send FM frequency to hardware
0000F7D0                            	dKeyOnFM				; send key-on command to YM
0000F7D0 0815 0002                M 	btst	#cfbhold,(a5)
0000F7D4 6600                     M 	bne.s	.k
0000F7D6 0815 0000                M 	btst	#cfbrest,(a5)
0000F7DA 6600                     M 	bne.s	.k
0000F7DC 0815 0001                M 	btst	#cfbint,(a5)
0000F7E0 6600                     M 	bne.s	.k
0000F7E2 7028                     M 	moveq	#$28,d0
0000F7E4 122D 0001                M 	move.b	ctype(a5),d1
0000F7E8 0001 00F0                M 	ori.b	#$f0,d1
0000F7EC 6100 0000                M 	bsr.w	writeym_pt1
0000F7F0                          M .k
0000F7F0                            
0000F7F0 0895 0005                  		bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0000F7F4 6700                       		beq.s	.noupdate		; if not, branch
0000F7F6 4EBA FC8C                  		jsr	dUpdateVolFM(pc)	; update FM volume
0000F7FA                            
0000F7FA                            .noupdate
0000F7FA 51CF FE7E                  		dbf	d7,dAMPSnextFM		; make sure to run all the channels
0000F7FE 4EFA 0000                  		jmp	dAMPSdoPSG(pc)		; after that, process music PSG channels
0000F802                            ; ===========================================================================
0000F802                            ; ---------------------------------------------------------------------------
0000F802                            ; Write FM frequency to Dual PCM YMCue
0000F802                            ; ---------------------------------------------------------------------------
0000F802                            
0000F802                            dUpdateFreqFM:
0000F802 0815 0000                  		btst	#cfbRest,(a5)		; is this channel resting
0000F806 6600                       		bne.s	locret_UpdFreqFM	; if is, skip
0000F808 3C2D 000E                  		move.w	cFreq(a5),d6		; load channel base frequency to d6
0000F80C 6700                       		beq.s	dUpdFreqFMrest		; if 0, this channel should be resting
0000F80E                            
0000F80E 102D 0007                  		move.b	cDetune(a5),d0		; load detune value to d0
0000F812 4880                       		ext.w	d0			; extend to word
0000F814 DC40                       		add.w	d0,d6			; add to channel base frequency to d6
0000F816                            
0000F816 0815 0003                  		btst	#cfbMod,(a5)		; check if channel is modulating
0000F81A 6700                       		beq.s	dUpdateFreqFM2		; if not, branch
0000F81C DC6D 0014                  		add.w	cModFreq(a5),d6		; add channel modulation frequency offset to d6
0000F820                            
0000F820                            dUpdateFreqFM2:
0000F820 0815 0001                  		btst	#cfbInt,(a5)		; is the channel interrupted by SFX?
0000F824 6600                       		bne.s	locret_UpdFreqFM	; if is, do not update frequency anyway
0000F826                            
0000F826                            dUpdateFreqFM3:
0000F826 3206                       		move.w	d6,d1			; copy frequency to d1
0000F828 E049                       		lsr.w	#8,d1			; shift upper byte into lower byte
0000F82A 70A4                       		moveq	#$FFFFFFA4,d0		; YM command: Frequency MSB & Octave
0000F82C 4EBA 0000                  		jsr	WriteChYM(pc)		; write to YM according to channel
0000F830                            
0000F830 1206                       		move.b	d6,d1			; copy lower byte of frequency into d1 (value)
0000F832 103C 00A0                  		move.b	#$FFFFFFA0,d0		; YM command: Frequency LSB
0000F836 4EFA 0000                  		jmp	WriteChYM(pc)		; write to YM according to channel
0000F83A                            
0000F83A                            dUpdFreqFMrest:
0000F83A 08D5 0000                  		bset	#cfbRest,(a5)		; set channel resting flag
0000F83E                            
0000F83E                            locret_UpdFreqFM:
0000F83E 4E75                       		rts
0000F840                            ; ===========================================================================
0000F840                            ; ---------------------------------------------------------------------------
0000F840                            ; Process a note in FM channel (enable resting or get frequency)
0000F840                            ; ---------------------------------------------------------------------------
0000F840                            
0000F840                            dGetFreqFM:
0000F840 0405 0080                  		subi.b	#$80,d5			; sub $80 from the note (notes start at $80)
0000F844 6600                       		bne.s	.norest			; branch if note wasnt $80 (rest)
0000F846 08D5 0000                  		bset	#cfbRest,(a5)		; set channel resting flag
0000F84A 426D 000E                  		clr.w	cFreq(a5)		; set base frequency to 0
0000F84E 4E75                       		rts
0000F850                            
0000F850                            .norest
0000F850 DA2D 0008                  		add.b	cPitch(a5),d5		; add pitch offset to note
0000F854 0245 007F                  		andi.w	#$7F,d5			; keep within $80 notes
0000F858 DA45                       		add.w	d5,d5			; double offset (each entry is a word)
0000F85A                            
0000F85A 43FA 0000                  		lea	dFreqFM(pc),a1		; load FM frequency table to a1
0000F85E 3B71 5000 000E             		move.w	(a1,d5.w),cFreq(a5)	; load and save the requested frequency
0000F864                            
0000F864                            		AMPS_Debug_NoteFM		; check if the note was valid
0000F864 0C05 0000                M 	cmp.b	#dfreqfm_-dfreqfm,d5
0000F868 6500                     M 	blo.s	.ok
0000F86A                          M .fail
0000F86A 4EBA E6A2                M 	jsr	amps_debugr_notefm
0000F86E                          M .ok
0000F86E 4E75                       		rts
0000F870                            ; ===========================================================================
0000F870                            ; ---------------------------------------------------------------------------
0000F870                            ; Subroutine for doing keying-off FM channel
0000F870                            ; ---------------------------------------------------------------------------
0000F870                            
0000F870                            dKeyOffFM:
0000F870 0815 0001                  		btst	#cfbInt,(a5)		; check if overridden by sfx
0000F874 66C8                       		bne.s	locret_UpdFreqFM	; if so, do not note off
0000F876                            
0000F876                            dKeyOffFM2:
0000F876 0815 0002                  		btst	#cfbHold,(a5)		; check if note is held
0000F87A 66C2                       		bne.s	locret_UpdFreqFM	; if so, do not note off
0000F87C                            
0000F87C 7028                       		moveq	#$28,d0			; YM command: Key on
0000F87E 122D 0001                  		move.b	cType(a5),d1		; get channel type bits (and turn all operators off)
0000F882 6000                       		bra.s	WriteYM_Pt1		; write to part 1 channel
0000F884                            ; ===========================================================================
0000F884                            ; ---------------------------------------------------------------------------
0000F884                            ; Write to YMCue according to channel and check if interrupted by sfx
0000F884                            ; ---------------------------------------------------------------------------
0000F884                            
0000F884                            dWriteYMchnInt:
0000F884 0815 0001                  		btst	#cfbInt,(a5)		; check if interrupted by sfx
0000F888 6600                       		bne.s	WriteYM_Pt1_rts		; if was, do not note on
0000F88A                            ; ===========================================================================
0000F88A                            ; ---------------------------------------------------------------------------
0000F88A                            ; Write to YMCue according to channel
0000F88A                            ; ---------------------------------------------------------------------------
0000F88A                            
0000F88A                            WriteChYM:
0000F88A 082D 0002 0001             		btst	#ctbPt2,cType(a5)	; check if this is a YM part 1 or 2 channel
0000F890 6600                       		bne.s	WriteChYM2		; if part 2, branch
0000F892 D02D 0001                  		add.b	cType(a5),d0		; add channel type to address
0000F896                            ; ===========================================================================
0000F896                            ; ---------------------------------------------------------------------------
0000F896                            ; Write to YMCue using part 1
0000F896                            ; ---------------------------------------------------------------------------
0000F896                            
0000F896                            WriteYM_Pt1:
0000F896                            		AMPS_Debug_CuePtr 1		; check if cue pointer is valid
0000F896 B1FC 0000 0000           M 	cmp.l	#$a00000+ym_buffer1,a0
0000F89C 6500                     M 	blo.s	.fail_647
0000F89E B1FC 0000 0000           M 	cmp.l	#$a00000+ym_buffer2+$400,a0
0000F8A4 6500                     M 	blo.s	.ok_647
0000F8A6                          M .fail_647
0000F8A6 4EBA E6F8                M 	jsr	amps_debug_cueptr1
0000F8AA                          M .ok_647
0000F8AA                            	StopZ80					; wait for Z80 to stop
0000F8AA 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0000F8B2                          M 	waitz80stop
0000F8B2 0839 0000 00A1 1100      M .wait_649:	btst	#0,z80_bus_req
0000F8BA 66F6                     M 	bne.s	.wait_649
0000F8BC 51D8                       		sf	(a0)+			; set YM port address as 0
0000F8BE 10C1                       		move.b	d1,(a0)+		; write data value to cue
0000F8C0 10C0                       		move.b	d0,(a0)+		; write address to cue
0000F8C2                            	;	st	(a0)			; mark as the end of the cue data
0000F8C2                            	StartZ80				; enable Z80 execution
0000F8C2 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0000F8CA                            
0000F8CA                            WriteYM_Pt1_rts:
0000F8CA 4E75                       		rts
0000F8CC                            ; ===========================================================================
0000F8CC                            ; ---------------------------------------------------------------------------
0000F8CC                            ; Write to YMCue according to channel in part 2
0000F8CC                            ; ---------------------------------------------------------------------------
0000F8CC                            
0000F8CC                            WriteChYM2:
0000F8CC 142D 0001                  		move.b	cType(a5),d2		; get channel type to d2
0000F8D0 0882 0002                  		bclr	#ctbPt2,d2		; remove part 2 marker from it
0000F8D4 D002                       		add.b	d2,d0			; add to YM address
0000F8D6                            ; ===========================================================================
0000F8D6                            ; ---------------------------------------------------------------------------
0000F8D6                            ; Write to YMCue using part 2
0000F8D6                            ; ---------------------------------------------------------------------------
0000F8D6                            
0000F8D6                            WriteYM_Pt2:
0000F8D6                            		AMPS_Debug_CuePtr 2		; check if cue pointer is valid
0000F8D6 B1FC 0000 0000           M 	cmp.l	#$a00000+ym_buffer1,a0
0000F8DC 6500                     M 	blo.s	.fail_651
0000F8DE B1FC 0000 0000           M 	cmp.l	#$a00000+ym_buffer2+$400,a0
0000F8E4 6500                     M 	blo.s	.ok_651
0000F8E6                          M .fail_651
0000F8E6 4EBA E6E6                M 	jsr	amps_debug_cueptr2
0000F8EA                          M .ok_651
0000F8EA                            	StopZ80					; wait for Z80 to stop
0000F8EA 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0000F8F2                          M 	waitz80stop
0000F8F2 0839 0000 00A1 1100      M .wait_653:	btst	#0,z80_bus_req
0000F8FA 66F6                     M 	bne.s	.wait_653
0000F8FC 10FC 0002                  		move.b	#$02,(a0)+		; set YM port address as 2
0000F900 10C1                       		move.b	d1,(a0)+		; write data value to cue
0000F902 10C0                       		move.b	d0,(a0)+		; write address to cue
0000F904                            	;	st	(a0)			; mark as the end of the cue data
0000F904                            	StartZ80				; enable Z80 execution
0000F904 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0000F90C 4E75                       		rts
0000F90E                            ; ===========================================================================
0000F90E                            ; ---------------------------------------------------------------------------
0000F90E                            ; Note to FM frequency conversion table
0000F90E                            ; ---------------------------------------------------------------------------
0000F90E                            ;	dc.w   C     C#    D     Eb    E     F     F#    G     G#    A     Bb    B
0000F90E 025E                       dFreqFM:dc.w								       $025E; Octave-1 - (80)
0000F910 0284 02AB 02D3 02FE 032D+  	dc.w $0284,$02AB,$02D3,$02FE,$032D,$035C,$038F,$03C5,$03FF,$043C,$047C,$0A5E; Octave 0 - (81 - 8C)
0000F928 0A84 0AAB 0AD3 0AFE 0B2D+  	dc.w $0A84,$0AAB,$0AD3,$0AFE,$0B2D,$0B5C,$0B8F,$0BC5,$0BFF,$0C3C,$0C7C,$125E; Octave 1 - (8D - 98)
0000F940 1284 12AB 12D3 12FE 132D+  	dc.w $1284,$12AB,$12D3,$12FE,$132D,$135C,$138F,$13C5,$13FF,$143C,$147C,$1A5E; Octave 2 - (99 - A4)
0000F958 1A84 1AAB 1AD3 1AFE 1B2D+  	dc.w $1A84,$1AAB,$1AD3,$1AFE,$1B2D,$1B5C,$1B8F,$1BC5,$1BFF,$1C3C,$1C7C,$225E; Octave 3 - (A5 - B0)
0000F970 2284 22AB 22D3 22FE 232D+  	dc.w $2284,$22AB,$22D3,$22FE,$232D,$235C,$238F,$23C5,$23FF,$243C,$247C,$2A5E; Octave 4 - (B1 - BC)
0000F988 2A84 2AAB 2AD3 2AFE 2B2D+  	dc.w $2A84,$2AAB,$2AD3,$2AFE,$2B2D,$2B5C,$2B8F,$2BC5,$2BFF,$2C3C,$2C7C,$325E; Octave 5 - (BD - C8)
0000F9A0 3284 32AB 32D3 32FE 332D+  	dc.w $3284,$32AB,$32D3,$32FE,$332D,$335C,$338F,$33C5,$33FF,$343C,$347C,$3A5E; Octave 6 - (c9 - D4)
0000F9B8 3A84 3AAB 3AD3 3AFE 3B2D+  	dc.w $3A84,$3AAB,$3AD3,$3AFE,$3B2D,$3B5C,$3B8F,$3BC5,$3BFF,$3C3C,$3C7C	    ; Octave 7 - (D5 - DF)
0000F9CE                            dFreqFM_:
0000F9CE =00000160                  .x = $100|((dFreqFM_-dFreqFM)/2)		; to check if we played an invalid note
0000F9CE                            		rept $80-((dFreqFM_-dFreqFM)/2)	; and if so, tell us which note it was
0000F9CE                            			dc.w .x
0000F9CE                            .x =			.x+$101
0000F9CE                            		endr
0000F9CE 0160                     M 	dc.w	.x
0000F9D0 =00000261                M .x	=	.x+$101
0000F9D0 0261                     M 	dc.w	.x
0000F9D2 =00000362                M .x	=	.x+$101
0000F9D2 0362                     M 	dc.w	.x
0000F9D4 =00000463                M .x	=	.x+$101
0000F9D4 0463                     M 	dc.w	.x
0000F9D6 =00000564                M .x	=	.x+$101
0000F9D6 0564                     M 	dc.w	.x
0000F9D8 =00000665                M .x	=	.x+$101
0000F9D8 0665                     M 	dc.w	.x
0000F9DA =00000766                M .x	=	.x+$101
0000F9DA 0766                     M 	dc.w	.x
0000F9DC =00000867                M .x	=	.x+$101
0000F9DC 0867                     M 	dc.w	.x
0000F9DE =00000968                M .x	=	.x+$101
0000F9DE 0968                     M 	dc.w	.x
0000F9E0 =00000A69                M .x	=	.x+$101
0000F9E0 0A69                     M 	dc.w	.x
0000F9E2 =00000B6A                M .x	=	.x+$101
0000F9E2 0B6A                     M 	dc.w	.x
0000F9E4 =00000C6B                M .x	=	.x+$101
0000F9E4 0C6B                     M 	dc.w	.x
0000F9E6 =00000D6C                M .x	=	.x+$101
0000F9E6 0D6C                     M 	dc.w	.x
0000F9E8 =00000E6D                M .x	=	.x+$101
0000F9E8 0E6D                     M 	dc.w	.x
0000F9EA =00000F6E                M .x	=	.x+$101
0000F9EA 0F6E                     M 	dc.w	.x
0000F9EC =0000106F                M .x	=	.x+$101
0000F9EC 106F                     M 	dc.w	.x
0000F9EE =00001170                M .x	=	.x+$101
0000F9EE 1170                     M 	dc.w	.x
0000F9F0 =00001271                M .x	=	.x+$101
0000F9F0 1271                     M 	dc.w	.x
0000F9F2 =00001372                M .x	=	.x+$101
0000F9F2 1372                     M 	dc.w	.x
0000F9F4 =00001473                M .x	=	.x+$101
0000F9F4 1473                     M 	dc.w	.x
0000F9F6 =00001574                M .x	=	.x+$101
0000F9F6 1574                     M 	dc.w	.x
0000F9F8 =00001675                M .x	=	.x+$101
0000F9F8 1675                     M 	dc.w	.x
0000F9FA =00001776                M .x	=	.x+$101
0000F9FA 1776                     M 	dc.w	.x
0000F9FC =00001877                M .x	=	.x+$101
0000F9FC 1877                     M 	dc.w	.x
0000F9FE =00001978                M .x	=	.x+$101
0000F9FE 1978                     M 	dc.w	.x
0000FA00 =00001A79                M .x	=	.x+$101
0000FA00 1A79                     M 	dc.w	.x
0000FA02 =00001B7A                M .x	=	.x+$101
0000FA02 1B7A                     M 	dc.w	.x
0000FA04 =00001C7B                M .x	=	.x+$101
0000FA04 1C7B                     M 	dc.w	.x
0000FA06 =00001D7C                M .x	=	.x+$101
0000FA06 1D7C                     M 	dc.w	.x
0000FA08 =00001E7D                M .x	=	.x+$101
0000FA08 1E7D                     M 	dc.w	.x
0000FA0A =00001F7E                M .x	=	.x+$101
0000FA0A 1F7E                     M 	dc.w	.x
0000FA0C =0000207F                M .x	=	.x+$101
0000FA0C 207F                     M 	dc.w	.x
0000FA0E =00002180                M .x	=	.x+$101
0000FA0E                            ; ===========================================================================
0000FA0E                            ; ---------------------------------------------------------------------------
0000FA0E                            ; Note to Dual PCM frequency conversion table
0000FA0E                            ; ---------------------------------------------------------------------------
0000FA0E                            ;	dc.w   C     C#    D     Eb    E     F     F#    G     G#    A     Bb    B
0000FA0E 0000                       dFreqDAC:dc.w $0000								    ; Octave NOPE - (80)
0000FA10 0010 0011 0012 0013 0014+  	dc.w $0010,$0011,$0012,$0013,$0014,$0015,$0017,$0018,$0019,$001B,$001D,$001E; Octave 0 - (81 - 8C)
0000FA28 0020 0022 0024 0026 0028+  	dc.w $0020,$0022,$0024,$0026,$0028,$002B,$002D,$0030,$0033,$0036,$0039,$003C; Octave 1 - (8D - 98)
0000FA40 0040 0044 0048 004C 0051+  	dc.w $0040,$0044,$0048,$004C,$0051,$0055,$005B,$0060,$0066,$006C,$0072,$0079; Octave 2 - (99 - A4)
0000FA58 0080 0088 0090 0098 00A1+  	dc.w $0080,$0088,$0090,$0098,$00A1,$00AB,$00B5,$00C0,$00CB,$00D7,$00E4,$00F2; Octave 3 - (A5 - B0)
0000FA70 0100 010F 011F 0130 0143+  	dc.w $0100,$010F,$011F,$0130,$0143,$0156,$016A,$0180,$0196,$01AF,$01C8,$01E3; Octave 4 - (B1 - BC)
0000FA88 0200 021E 023F 0261 0285+  	dc.w $0200,$021E,$023F,$0261,$0285,$02AB,$02D4,$02FF,$032D,$035D,$0390,$03C7; Octave 5 - (BD - C8)
0000FAA0 0400 043D 047D 04C2 050A+  	dc.w $0400,$043D,$047D,$04C2,$050A,$0557,$05A8,$05FE,$0659,$06BA,$0721,$078D; Octave 6 - (C9 - D4)
0000FAB8 0800 087A 08FB 0983 0A14+  	dc.w $0800,$087A,$08FB,$0983,$0A14,$0AAE,$0B50,$0BFD,$0CB3,$0D74,$0E41,$0F1A; Octave 7 - (D5 - E0)
0000FAD0 0FFF 0FFF 0FFF 0FFF 0FFF+  	dc.w $0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF; Octave 8 - (E1 - EC)
0000FAE8 0FFF 0FFF 0FFF 0FFF 0FFF+  	dc.w $0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF; Octave 9 - (ED - F8)
0000FB00 0FFF 0FFF 0FFF 0FFF 0FFF+  	dc.w $0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF				    ; Octave 10 -(F9 - FF)
0000FB0E                            
0000FB0E F001 F001 F001 F001 F001+  	dc.w			     -$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF; Octave -10 -(00 - 07)
0000FB1E F001 F001 F001 F001 F001+  	dc.w -$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF; Octave -9 - (08 - 13)
0000FB36 F001 F001 F001 F001 F001+  	dc.w -$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF; Octave -8 - (14 - 1F)
0000FB4E F0E6 F1BF F28C F34D F403+  	dc.w -$F1A,-$E41,-$D74,-$CB3,-$BFD,-$B50,-$AAE,-$A14,-$983,-$8FB,-$87A,-$800; Octave -7 - (20 - 2B)
0000FB66 F873 F8DF F946 F9A7 FA02+  	dc.w -$78D,-$721,-$6BA,-$659,-$5FE,-$5A8,-$557,-$50A,-$4C2,-$47D,-$43D,-$400; Octave -6 - (2C - 37)
0000FB7E FC39 FC70 FCA3 FCD3 FD01+  	dc.w -$3C7,-$390,-$35D,-$32D,-$2FF,-$2D4,-$2AB,-$285,-$261,-$23F,-$21E,-$200; Octave -5 - (38 - 43)
0000FB96 FE1D FE38 FE51 FE6A FE80+  	dc.w -$1E3,-$1C8,-$1AF,-$196,-$180,-$16A,-$156,-$143,-$130,-$11F,-$10F,-$100; Octave -4 - (44 - 4F)
0000FBAE FF0E FF1C FF29 FF35 FF40+  	dc.w -$0F2,-$0E4,-$0D7,-$0CB,-$0C0,-$0B5,-$0AB,-$0A1,-$098,-$090,-$088,-$080; Octave -3 - (50 - 5B)
0000FBC6 FF87 FF8E FF94 FF9A FFA0+  	dc.w -$079,-$072,-$06C,-$066,-$060,-$05B,-$055,-$051,-$04C,-$048,-$044,-$040; Octave -2 - (5C - 67)
0000FBDE FFC4 FFC7 FFCA FFCD FFD0+  	dc.w -$03C,-$039,-$036,-$033,-$030,-$02D,-$02B,-$028,-$026,-$024,-$022,-$020; Octave -1 - (68 - 73)
0000FBF6 FFE2 FFE3 FFE5 FFE7 FFE8+  	dc.w -$01E,-$01D,-$01B,-$019,-$018,-$017,-$015,-$014,-$013,-$012,-$011,-$010; Octave -0 - (74 - 7F)
0000FC0E                            ; ===========================================================================
0000FC0E                            ; ---------------------------------------------------------------------------
0000FC0E                            ; Note to PSG frequency conversion table
0000FC0E                            ; ---------------------------------------------------------------------------
0000FC0E                            ;	dc.w	C     C#    D     Eb    E     F     F#    G     G#    A     Bb    B
0000FC0E 0356 0326 02F9 02CE 02A5+  dFreqPSG:dc.w $0356,$0326,$02F9,$02CE,$02A5,$0280,$025C,$023A,$021A,$01FB,$01DF,$01C4; Octave 3 - (81 - 8C)
0000FC26 01AB 0193 017D 0167 0153+  	dc.w  $01AB,$0193,$017D,$0167,$0153,$0140,$012E,$011D,$010D,$00FE,$00EF,$00E2; Octave 4 - (8D - 98)
0000FC3E 00D6 00C9 00BE 00B4 00A9+  	dc.w  $00D6,$00C9,$00BE,$00B4,$00A9,$00A0,$0097,$008F,$0087,$007F,$0078,$0071; Octave 5 - (99 - A4)
0000FC56 006B 0065 005F 005A 0055+  	dc.w  $006B,$0065,$005F,$005A,$0055,$0050,$004B,$0047,$0043,$0040,$003C,$0039; Octave 6 - (A5 - B0)
0000FC6E 0036 0033 0030 002D 002B+  	dc.w  $0036,$0033,$0030,$002D,$002B,$0028,$0026,$0024,$0022,$0020,$001F,$001D; Octave 7 - (B1 - BC)
0000FC86 001B 001A 0018 0017 0016+  	dc.w  $001B,$001A,$0018,$0017,$0016,$0015,$0013,$0012,$0011		     ; Notes (BD - C5)
0000FC98 0000                       	dc.w  $0000								     ; Note (C6)
0000FC9A                            dFreqPSG_:
0000FC9A =00000146                  .x = $100|((dFreqPSG_-dFreqPSG)/2)		; to check if we played an invalid note
0000FC9A                            		rept $80-((dFreqPSG_-dFreqPSG)/2); and if so, tell us which note it was
0000FC9A                            			dc.w .x
0000FC9A                            .x =			.x+$101
0000FC9A                            		endr
0000FC9A 0146                     M 	dc.w	.x
0000FC9C =00000247                M .x	=	.x+$101
0000FC9C 0247                     M 	dc.w	.x
0000FC9E =00000348                M .x	=	.x+$101
0000FC9E 0348                     M 	dc.w	.x
0000FCA0 =00000449                M .x	=	.x+$101
0000FCA0 0449                     M 	dc.w	.x
0000FCA2 =0000054A                M .x	=	.x+$101
0000FCA2 054A                     M 	dc.w	.x
0000FCA4 =0000064B                M .x	=	.x+$101
0000FCA4 064B                     M 	dc.w	.x
0000FCA6 =0000074C                M .x	=	.x+$101
0000FCA6 074C                     M 	dc.w	.x
0000FCA8 =0000084D                M .x	=	.x+$101
0000FCA8 084D                     M 	dc.w	.x
0000FCAA =0000094E                M .x	=	.x+$101
0000FCAA 094E                     M 	dc.w	.x
0000FCAC =00000A4F                M .x	=	.x+$101
0000FCAC 0A4F                     M 	dc.w	.x
0000FCAE =00000B50                M .x	=	.x+$101
0000FCAE 0B50                     M 	dc.w	.x
0000FCB0 =00000C51                M .x	=	.x+$101
0000FCB0 0C51                     M 	dc.w	.x
0000FCB2 =00000D52                M .x	=	.x+$101
0000FCB2 0D52                     M 	dc.w	.x
0000FCB4 =00000E53                M .x	=	.x+$101
0000FCB4 0E53                     M 	dc.w	.x
0000FCB6 =00000F54                M .x	=	.x+$101
0000FCB6 0F54                     M 	dc.w	.x
0000FCB8 =00001055                M .x	=	.x+$101
0000FCB8 1055                     M 	dc.w	.x
0000FCBA =00001156                M .x	=	.x+$101
0000FCBA 1156                     M 	dc.w	.x
0000FCBC =00001257                M .x	=	.x+$101
0000FCBC 1257                     M 	dc.w	.x
0000FCBE =00001358                M .x	=	.x+$101
0000FCBE 1358                     M 	dc.w	.x
0000FCC0 =00001459                M .x	=	.x+$101
0000FCC0 1459                     M 	dc.w	.x
0000FCC2 =0000155A                M .x	=	.x+$101
0000FCC2 155A                     M 	dc.w	.x
0000FCC4 =0000165B                M .x	=	.x+$101
0000FCC4 165B                     M 	dc.w	.x
0000FCC6 =0000175C                M .x	=	.x+$101
0000FCC6 175C                     M 	dc.w	.x
0000FCC8 =0000185D                M .x	=	.x+$101
0000FCC8 185D                     M 	dc.w	.x
0000FCCA =0000195E                M .x	=	.x+$101
0000FCCA 195E                     M 	dc.w	.x
0000FCCC =00001A5F                M .x	=	.x+$101
0000FCCC 1A5F                     M 	dc.w	.x
0000FCCE =00001B60                M .x	=	.x+$101
0000FCCE 1B60                     M 	dc.w	.x
0000FCD0 =00001C61                M .x	=	.x+$101
0000FCD0 1C61                     M 	dc.w	.x
0000FCD2 =00001D62                M .x	=	.x+$101
0000FCD2 1D62                     M 	dc.w	.x
0000FCD4 =00001E63                M .x	=	.x+$101
0000FCD4 1E63                     M 	dc.w	.x
0000FCD6 =00001F64                M .x	=	.x+$101
0000FCD6 1F64                     M 	dc.w	.x
0000FCD8 =00002065                M .x	=	.x+$101
0000FCD8 2065                     M 	dc.w	.x
0000FCDA =00002166                M .x	=	.x+$101
0000FCDA 2166                     M 	dc.w	.x
0000FCDC =00002267                M .x	=	.x+$101
0000FCDC 2267                     M 	dc.w	.x
0000FCDE =00002368                M .x	=	.x+$101
0000FCDE 2368                     M 	dc.w	.x
0000FCE0 =00002469                M .x	=	.x+$101
0000FCE0 2469                     M 	dc.w	.x
0000FCE2 =0000256A                M .x	=	.x+$101
0000FCE2 256A                     M 	dc.w	.x
0000FCE4 =0000266B                M .x	=	.x+$101
0000FCE4 266B                     M 	dc.w	.x
0000FCE6 =0000276C                M .x	=	.x+$101
0000FCE6 276C                     M 	dc.w	.x
0000FCE8 =0000286D                M .x	=	.x+$101
0000FCE8 286D                     M 	dc.w	.x
0000FCEA =0000296E                M .x	=	.x+$101
0000FCEA 296E                     M 	dc.w	.x
0000FCEC =00002A6F                M .x	=	.x+$101
0000FCEC 2A6F                     M 	dc.w	.x
0000FCEE =00002B70                M .x	=	.x+$101
0000FCEE 2B70                     M 	dc.w	.x
0000FCF0 =00002C71                M .x	=	.x+$101
0000FCF0 2C71                     M 	dc.w	.x
0000FCF2 =00002D72                M .x	=	.x+$101
0000FCF2 2D72                     M 	dc.w	.x
0000FCF4 =00002E73                M .x	=	.x+$101
0000FCF4 2E73                     M 	dc.w	.x
0000FCF6 =00002F74                M .x	=	.x+$101
0000FCF6 2F74                     M 	dc.w	.x
0000FCF8 =00003075                M .x	=	.x+$101
0000FCF8 3075                     M 	dc.w	.x
0000FCFA =00003176                M .x	=	.x+$101
0000FCFA 3176                     M 	dc.w	.x
0000FCFC =00003277                M .x	=	.x+$101
0000FCFC 3277                     M 	dc.w	.x
0000FCFE =00003378                M .x	=	.x+$101
0000FCFE 3378                     M 	dc.w	.x
0000FD00 =00003479                M .x	=	.x+$101
0000FD00 3479                     M 	dc.w	.x
0000FD02 =0000357A                M .x	=	.x+$101
0000FD02 357A                     M 	dc.w	.x
0000FD04 =0000367B                M .x	=	.x+$101
0000FD04 367B                     M 	dc.w	.x
0000FD06 =0000377C                M .x	=	.x+$101
0000FD06 377C                     M 	dc.w	.x
0000FD08 =0000387D                M .x	=	.x+$101
0000FD08 387D                     M 	dc.w	.x
0000FD0A =0000397E                M .x	=	.x+$101
0000FD0A 397E                     M 	dc.w	.x
0000FD0C =00003A7F                M .x	=	.x+$101
0000FD0C 3A7F                     M 	dc.w	.x
0000FD0E =00003B80                M .x	=	.x+$101
0000FD0E                            ; ===========================================================================
0000FD0E                            ; ---------------------------------------------------------------------------
0000FD0E                            ; Process SFX PSG channels
0000FD0E                            ; ---------------------------------------------------------------------------
0000FD0E                            
0000FD0E                            dAMPSdoPSGSFX:
0000FD0E 7E02                       		moveq	#SFX_PSG-1,d7		; get total number of SFX PSG channels to d7
0000FD10 4DFA FEFC                  		lea	dFreqPSG(pc),a6		; load PSG frequency table for quick access to a6
0000FD14                            
0000FD14                            dAMPSnextPSGSFX:
0000FD14 DAFC 001C                  		add.w	#cSizeSFX,a5		; go to the next channel
0000FD18 4A15                       		tst.b	(a5)			; check if channel is running a tracker
0000FD1A 6A00                       		bpl.s	.next			; if not, branch
0000FD1C 532D 000C                  		subq.b	#1,cDuration(a5)	; decrease note duration
0000FD20 6700 0000                  		beq.w	.update			; if timed out, update channel
0000FD24                            
0000FD24                            	dCalcFreq				; calculate channel base frequency
0000FD24 1C2D 0007                M 	move.b	cdetune(a5),d6
0000FD28 4886                     M 	ext.w	d6
0000FD2A DC6D 000E                M 	add.w	cfreq(a5),d6
0000FD2E                            	dModulate				; run modulation code
0000FD2E 0815 0003                M 	btst	#cfbmod,(a5)
0000FD32 6700                     M 	beq.s	.noret
0000FD34 4A2D 0010                M 	tst.b	cmoddelay(a5)
0000FD38 6700                     M 	beq.s	.started
0000FD3A 532D 0010                M 	subq.b	#1,cmoddelay(a5)
0000FD3E                          M .noret
0000FD3E 6000                     M 	bra.s	.endm
0000FD40                          M .started
0000FD40 532D 0016                M 	subq.b	#1,cmodspeed(a5)
0000FD44 66F8                     M 	bne.s	.noret
0000FD46 226D 0010                M 	movea.l	cmod(a5),a1
0000FD4A 1B69 0001 0016           M 	move.b	1(a1),cmodspeed(a5)
0000FD50 4A2D 0018                M 	tst.b	cmodcount(a5)
0000FD54 6600                     M 	bne.s	.norev
0000FD56 1B69 0003 0018           M 	move.b	3(a1),cmodcount(a5)
0000FD5C 442D 0017                M 	neg.b	cmodstep(a5)
0000FD60                          M .norev
0000FD60 532D 0018                M 	subq.b	#1,cmodcount(a5)
0000FD64 1A2D 0017                M 	move.b	cmodstep(a5),d5
0000FD68 4885                     M 	ext.w	d5
0000FD6A DA6D 0014                M 	add.w	cmodfreq(a5),d5
0000FD6E 3B45 0014                M 	move.w	d5,cmodfreq(a5)
0000FD72 DC45                     M 	add.w	d5,d6
0000FD74 6100 0000                  		bsr.w	dUpdateFreqPSG3		; if frequency needs changing, do it
0000FD78                            
0000FD78                            .endm
0000FD78 6100 0000                  		bsr.w	dEnvelopePSG		; run envelope program
0000FD7C                            .next
0000FD7C 51CF FF96                  		dbf	d7,dAMPSnextPSGSFX	; make sure to run all the channels
0000FD80 4EFA 0000                  		jmp	dCheckTracker(pc)	; after that, check tracker and end loop
0000FD84                            
0000FD84                            .update
0000FD84 0215 00FA                  		and.b	#$FF-(1<<cfbHold)-(1<<cfbRest),(a5); clear hold and rest flags
0000FD88                            	dDoTracker				; process tracker
0000FD88 286D 0002                M 	movea.l	cdata(a5),a4
0000FD8C                          M 	amps_debug_trackupd
0000FD8C 220C                     M 	move.l	a4,d1
0000FD8E 0281 00FF FFFF           M 	and.l	#$ffffff,d1
0000FD94 0C81 0000 0000           M 	cmp.l	#sfxaddr,d1
0000FD9A 6500                     M 	blo.s	.fail2
0000FD9C 0C81 0000 0000           M 	cmp.l	#dacaddr,d1
0000FDA2 6500                     M 	blo.s	.data
0000FDA4                          M .fail2
0000FDA4                          M 	raiseerror	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_channel
0000FDA4 487A FFFE                M 	pea	*(pc)
0000FDA8                          M 	raiseerror2	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_channel
0000FDA8 40E7                     M 	move.w	sr,-(sp)
0000FDAA                          M 	__fstring_generateargumentscode	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FDAA =0000001A                M 	__pos:	set instr("Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000FDAA =00000000                M 	__stack:set	0
0000FDAA =00000000                M 	__sp:	set 0
0000FDAA                          M 	while	(__pos)
0000FDAA =00000021                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000FDAA =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000FDAA =00000021                M 	__midpos:	= __endpos
0000FDAA                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FDAA                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FDAA                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FDAA                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FDAA                          M 	pushp	"move.l a4,-(sp)"
0000FDAA =00000001                M 	__stack:	= __stack+1
0000FDAA =00000004                M 	__sp:	= __sp+4
0000FDAA =00000022                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000FDAA =00000029                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000FDAA =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000FDAA =00000029                M 	__midpos:	= __endpos
0000FDAA                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FDAA                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FDAA =0000002A                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000FDAA =00000035                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000FDAA =00000031                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000FDAA                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FDAA                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FDAA                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FDAA                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FDAA                          M 	pushp	"move.l a4,-(sp)"
0000FDAA =00000002                M 	__stack:	= __stack+1
0000FDAA =00000008                M 	__sp:	= __sp+4
0000FDAA =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000FDAA                          M 	rept	__stack
0000FDAA                          M 	popp	__command
0000FDAA 2F0C                     M 	move.l	a4,-(sp)
0000FDAC                          M 	popp	__command
0000FDAC 2F0C                     M 	move.l	a4,-(sp)
0000FDAE 4EB9 0000 0000           M 	jsr	errorhandler
0000FDB4                          M 	__fstring_generatedecodedstring	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FDB4 =00000001                M 	__lpos:	set 1
0000FDB4 =0000001A                M 	__pos:	set instr("Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000FDB4                          M 	while	(__pos)
0000FDB4                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FDB4 496E 7661 6C69 6420 7472+M 	dc.b	"Invalid tracker address: "
0000FDCD =00000021                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000FDCD =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000FDCD =00000021                M 	__midpos:	= __endpos
0000FDCD                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FDCD                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FDCD                          M 	__param:	substr ,,"hex"
0000FDCD 83                       M 	dc.b	hex|3
0000FDCE =00000022                M 	__lpos:	set __endpos+1
0000FDCE =00000022                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000FDCE                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FDCE                          M 	dc.b	""
0000FDCE =00000029                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000FDCE =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000FDCE =00000029                M 	__midpos:	= __endpos
0000FDCE                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FDCE                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FDCE E0                       M 	dc.b	fendl
0000FDCF =0000002A                M 	__lpos:	set __endpos+1
0000FDCF =0000002A                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000FDCF                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FDCF                          M 	dc.b	""
0000FDCF =00000035                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000FDCF =00000031                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000FDCF                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FDCF                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FDCF B3                       M 	dc.b	sym|3
0000FDD0 =00000036                M 	__lpos:	set __endpos+1
0000FDD0 =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000FDD0                          M 	__substr:	substr __lpos,,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FDD0                          M 	dc.b	""
0000FDD0 00                       M 	dc.b	0
0000FDD1 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000FDD2                          M 	even
0000FDD2 4EFA D4A8                M 	jmp	amps_debug_console_channel
0000FDD6                          M 	even
0000FDD6                          M .data
0000FDD6 7A00                     M 	moveq	#0,d5
0000FDD8 1A1C                     M 	move.b	(a4)+,d5
0000FDDA 0C05 00E0                M 	cmpi.b	#$e0,d5
0000FDDE 6500                     M 	blo.s	.notcomm
0000FDE0 4EBA 0000                M 	jsr	dcommands(pc)
0000FDE4 60F0                     M 	bra.s	.data
0000FDE6 6094                     M 	bra.s	.next
0000FDE8                          M .notcomm
0000FDE8 4A05                       		tst.b	d5			; check if note is being played
0000FDEA 6A00                       		bpl.s	.timer			; if not, it must be a timer. Branch
0000FDEC                            
0000FDEC                            	dGetFreqPSG				; get PSG frequency
0000FDEC 0405 0081                M 	subi.b	#$81,d5
0000FDF0 6400                     M 	bhs.s	.norest
0000FDF2 08D5 0000                M 	bset	#cfbrest,(a5)
0000FDF6 3B7C FFFF 000E           M 	move.w	#-1,cfreq(a5)
0000FDFC 4EBA 0000                M 	jsr	dmutepsgmus(pc)
0000FE00 6000                     M 	bra.s	.freqgot
0000FE02                          M .norest
0000FE02 DA2D 0008                M 	add.b	cpitch(a5),d5
0000FE06 0245 007F                M 	andi.w	#$7f,d5
0000FE0A DA45                     M 	add.w	d5,d5
0000FE0C 3B76 5000 000E           M 	move.w	(a6,d5.w),cfreq(a5)
0000FE12                          M 	amps_debug_notepsg
0000FE12 0C05 008C                M 	cmp.b	#dfreqpsg_-dfreqpsg,d5
0000FE16 6500                     M 	blo.s	.ok
0000FE18                          M .fail
0000FE18 4EBA E0CA                M 	jsr	amps_debugr_notepsg
0000FE1C                          M .ok
0000FE1C                          M .freqgot
0000FE1C 1A1C                       		move.b	(a4)+,d5		; check if next note is a timer
0000FE1E 6A00                       		bpl.s	.timer			; if yes, handle timer
0000FE20 534C                       		subq.w	#1,a4			; else, undo the increment
0000FE22 6000                       		bra.s	.pcnote			; do not calculate duration
0000FE24                            
0000FE24                            .timer
0000FE24 4EBA EB1A                  		jsr	dCalcDuration(pc)	; calculate duration
0000FE28                            .pcnote
0000FE28                            	dProcNote 1, 1				; reset necessary channel memory
0000FE28 2B4C 0002                M 	move.l	a4,cdata(a5)
0000FE2C 1B6D 000D 000C           M 	move.b	clastdur(a5),cduration(a5)
0000FE32 0815 0002                M 	btst	#cfbhold,(a5)
0000FE36 6600                     M 	bne.s	.endpn
0000FE38 422D 0006                M 	clr.b	cenvpos(a5)
0000FE3C 0815 0003                M 	btst	#cfbmod,(a5)
0000FE40 6700                     M 	beq.s	.endpn
0000FE42 226D 0010                M 	movea.l	cmod(a5),a1
0000FE46 1B59 0010                M 	move.b	(a1)+,cmoddelay(a5)
0000FE4A 1B59 0016                M 	move.b	(a1)+,cmodspeed(a5)
0000FE4E 1B59 0017                M 	move.b	(a1)+,cmodstep(a5)
0000FE52 1011                     M 	move.b	(a1),d0
0000FE54 E208                     M 	lsr.b	#1,d0
0000FE56 1B40 0018                M 	move.b	d0,cmodcount(a5)
0000FE5A 426D 0014                M 	clr.w	cmodfreq(a5)
0000FE5E                          M .endpn
0000FE5E                            
0000FE5E 6100 0000                  		bsr.w	dUpdateFreqPSG		; update hardware frequency
0000FE62 6100 0000                  		bsr.w	dEnvProgPSG		; run envelope program
0000FE66 51CF FEAC                  		dbf	d7,dAMPSnextPSGSFX	; make sure to run all the channels
0000FE6A                            	; continue to check tracker and end loop
0000FE6A                            ; ===========================================================================
0000FE6A                            ; ---------------------------------------------------------------------------
0000FE6A                            ; End channel loop and check if tracker debugger should be opened
0000FE6A                            ; ---------------------------------------------------------------------------
0000FE6A                            
0000FE6A                            dCheckTracker:
0000FE6A 4A38 C740                  		tst.b	msChktracker.w		; check if tracker debugger flag was set
0000FE6E 6700                       		beq.s	.rts			; if not, skip
0000FE70 4238 C740                  		clr.b	msChktracker.w		; clear that flag
0000FE74                            		AMPS_Debug_ChkTracker		; run debugger
0000FE74                          M .fail
0000FE74 4EBA E1E0                M 	jsr	amps_debugr_chktracker
0000FE78                            .rts
0000FE78 4E75                       		rts
0000FE7A                            ; ===========================================================================
0000FE7A                            ; ---------------------------------------------------------------------------
0000FE7A                            ; Music PSG channel loop
0000FE7A                            ; ---------------------------------------------------------------------------
0000FE7A                            
0000FE7A                            dAMPSdoPSG:
0000FE7A 7E02                       		moveq	#Mus_PSG-1,d7		; get total number of music PSG channels to d7
0000FE7C 4DFA FD90                  		lea	dFreqPSG(pc),a6		; load PSG frequency table for quick access to a6
0000FE80                            
0000FE80                            dAMPSnextPSG:
0000FE80 DAFC 002C                  		add.w	#cSize,a5		; go to the next channe
0000FE84 4A15                       		tst.b	(a5)			; check if channel is running a tracker
0000FE86 6A00 0000                  		bpl.w	.next			; if not, branch
0000FE8A 532D 000C                  		subq.b	#1,cDuration(a5)	; decrease note duration
0000FE8E 6700 0000                  		beq.w	.update			; if timed out, update channel
0000FE92                            
0000FE92                            	dNoteToutPSG				; handle PSG-specific note timeout behavior
0000FE92                          M 	dnotetouthandler
0000FE92 4A2D 001C                M 	tst.b	cnotetimecur(a5)
0000FE96 6700                     M 	beq.s	.endt
0000FE98 532D 001C                M 	subq.b	#1,cnotetimecur(a5)
0000FE9C 6600                     M 	bne.s	.endt
0000FE9E 08D5 0000                M 	bset	#cfbrest,(a5)
0000FEA2 6100 0000                M 	bsr.w	dmutepsgmus
0000FEA6 6000                     M 	bra.s	.next
0000FEA8                          M .endt
0000FEA8                            	dCalcFreq				; calculate channel base frequency
0000FEA8 1C2D 0007                M 	move.b	cdetune(a5),d6
0000FEAC 4886                     M 	ext.w	d6
0000FEAE DC6D 000E                M 	add.w	cfreq(a5),d6
0000FEB2                            	dModulate				; run modulation code
0000FEB2 0815 0003                M 	btst	#cfbmod,(a5)
0000FEB6 6700                     M 	beq.s	.noret
0000FEB8 4A2D 0010                M 	tst.b	cmoddelay(a5)
0000FEBC 6700                     M 	beq.s	.started
0000FEBE 532D 0010                M 	subq.b	#1,cmoddelay(a5)
0000FEC2                          M .noret
0000FEC2 6000                     M 	bra.s	.endm
0000FEC4                          M .started
0000FEC4 532D 0016                M 	subq.b	#1,cmodspeed(a5)
0000FEC8 66F8                     M 	bne.s	.noret
0000FECA 226D 0010                M 	movea.l	cmod(a5),a1
0000FECE 1B69 0001 0016           M 	move.b	1(a1),cmodspeed(a5)
0000FED4 4A2D 0018                M 	tst.b	cmodcount(a5)
0000FED8 6600                     M 	bne.s	.norev
0000FEDA 1B69 0003 0018           M 	move.b	3(a1),cmodcount(a5)
0000FEE0 442D 0017                M 	neg.b	cmodstep(a5)
0000FEE4                          M .norev
0000FEE4 532D 0018                M 	subq.b	#1,cmodcount(a5)
0000FEE8 1A2D 0017                M 	move.b	cmodstep(a5),d5
0000FEEC 4885                     M 	ext.w	d5
0000FEEE DA6D 0014                M 	add.w	cmodfreq(a5),d5
0000FEF2 3B45 0014                M 	move.w	d5,cmodfreq(a5)
0000FEF6 DC45                     M 	add.w	d5,d6
0000FEF8 6100 0000                  		bsr.w	dUpdateFreqPSG2		; if frequency needs changing, do it
0000FEFC                            
0000FEFC                            .endm
0000FEFC 6100 0000                  		bsr.w	dEnvelopePSG		; run envelope program
0000FF00                            .next
0000FF00 51CF FF7E                  		dbf	d7,dAMPSnextPSG		; make sure to run all the channels
0000FF04 4EFA EA52                  		jmp	dAMPSdoDACSFX(pc)	; after that, process SFX DAC channels
0000FF08                            
0000FF08                            .update
0000FF08 0215 00FA                  		and.b	#$FF-(1<<cfbHold)-(1<<cfbRest),(a5); clear hold and rest flags
0000FF0C                            	dDoTracker				; process tracker
0000FF0C 286D 0002                M 	movea.l	cdata(a5),a4
0000FF10                          M 	amps_debug_trackupd
0000FF10 220C                     M 	move.l	a4,d1
0000FF12 0281 00FF FFFF           M 	and.l	#$ffffff,d1
0000FF18 0C81 0000 0000           M 	cmp.l	#sfxaddr,d1
0000FF1E 6500                     M 	blo.s	.fail2
0000FF20 0C81 0000 0000           M 	cmp.l	#dacaddr,d1
0000FF26 6500                     M 	blo.s	.data
0000FF28                          M .fail2
0000FF28                          M 	raiseerror	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_channel
0000FF28 487A FFFE                M 	pea	*(pc)
0000FF2C                          M 	raiseerror2	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",amps_debug_console_channel
0000FF2C 40E7                     M 	move.w	sr,-(sp)
0000FF2E                          M 	__fstring_generateargumentscode	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FF2E =0000001A                M 	__pos:	set instr("Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000FF2E =00000000                M 	__stack:set	0
0000FF2E =00000000                M 	__sp:	set 0
0000FF2E                          M 	while	(__pos)
0000FF2E =00000021                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000FF2E =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000FF2E =00000021                M 	__midpos:	= __endpos
0000FF2E                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FF2E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FF2E                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FF2E                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FF2E                          M 	pushp	"move.l a4,-(sp)"
0000FF2E =00000001                M 	__stack:	= __stack+1
0000FF2E =00000004                M 	__sp:	= __sp+4
0000FF2E =00000022                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000FF2E =00000029                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000FF2E =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000FF2E =00000029                M 	__midpos:	= __endpos
0000FF2E                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FF2E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FF2E =0000002A                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000FF2E =00000035                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000FF2E =00000031                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000FF2E                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FF2E                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FF2E                          M 	__operand:	substr __pos+1+1,__midpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FF2E                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FF2E                          M 	pushp	"move.l a4,-(sp)"
0000FF2E =00000002                M 	__stack:	= __stack+1
0000FF2E =00000008                M 	__sp:	= __sp+4
0000FF2E =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000FF2E                          M 	rept	__stack
0000FF2E                          M 	popp	__command
0000FF2E 2F0C                     M 	move.l	a4,-(sp)
0000FF30                          M 	popp	__command
0000FF30 2F0C                     M 	move.l	a4,-(sp)
0000FF32 4EB9 0000 0000           M 	jsr	errorhandler
0000FF38                          M 	__fstring_generatedecodedstring	"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FF38 =00000001                M 	__lpos:	set 1
0000FF38 =0000001A                M 	__pos:	set instr("Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000FF38                          M 	while	(__pos)
0000FF38                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FF38 496E 7661 6C69 6420 7472+M 	dc.b	"Invalid tracker address: "
0000FF51 =00000021                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000FF51 =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000FF51 =00000021                M 	__midpos:	= __endpos
0000FF51                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FF51                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FF51                          M 	__param:	substr ,,"hex"
0000FF51 83                       M 	dc.b	hex|3
0000FF52 =00000022                M 	__lpos:	set __endpos+1
0000FF52 =00000022                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000FF52                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FF52                          M 	dc.b	""
0000FF52 =00000029                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000FF52 =0000002E                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000FF52 =00000029                M 	__midpos:	= __endpos
0000FF52                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FF52                          M 	__substr:	substr __pos+1+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FF52 E0                       M 	dc.b	fendl
0000FF53 =0000002A                M 	__lpos:	set __endpos+1
0000FF53 =0000002A                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000FF53                          M 	__substr:	substr __lpos,__pos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FF53                          M 	dc.b	""
0000FF53 =00000035                M 	__endpos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'>')
0000FF53 =00000031                M 	__midpos:	set instr(__pos+5,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",' ')
0000FF53                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FF53                          M 	__param:	substr __midpos+1,__endpos-1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FF53 B3                       M 	dc.b	sym|3
0000FF54 =00000036                M 	__lpos:	set __endpos+1
0000FF54 =00000000                M 	__pos:	set instr(__pos+1,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>",'%<')
0000FF54                          M 	__substr:	substr __lpos,,"Invalid tracker address: %<.l a4>%<fendl>%<.l a4 sym>"
0000FF54                          M 	dc.b	""
0000FF54 00                       M 	dc.b	0
0000FF55 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0000FF56                          M 	even
0000FF56 4EFA D324                M 	jmp	amps_debug_console_channel
0000FF5A                          M 	even
0000FF5A                          M .data
0000FF5A 7A00                     M 	moveq	#0,d5
0000FF5C 1A1C                     M 	move.b	(a4)+,d5
0000FF5E 0C05 00E0                M 	cmpi.b	#$e0,d5
0000FF62 6500                     M 	blo.s	.notcomm
0000FF64 4EBA 0000                M 	jsr	dcommands(pc)
0000FF68 60F0                     M 	bra.s	.data
0000FF6A 6094                     M 	bra.s	.next
0000FF6C                          M .notcomm
0000FF6C 4A05                       		tst.b	d5			; check if note is being played
0000FF6E 6A00                       		bpl.s	.timer			; if not, it must be a timer. branch
0000FF70                            
0000FF70                            	dGetFreqPSG				; get PSG frequency
0000FF70 0405 0081                M 	subi.b	#$81,d5
0000FF74 6400                     M 	bhs.s	.norest
0000FF76 08D5 0000                M 	bset	#cfbrest,(a5)
0000FF7A 3B7C FFFF 000E           M 	move.w	#-1,cfreq(a5)
0000FF80 4EBA 0000                M 	jsr	dmutepsgmus(pc)
0000FF84 6000                     M 	bra.s	.freqgot
0000FF86                          M .norest
0000FF86 DA2D 0008                M 	add.b	cpitch(a5),d5
0000FF8A 0245 007F                M 	andi.w	#$7f,d5
0000FF8E DA45                     M 	add.w	d5,d5
0000FF90 3B76 5000 000E           M 	move.w	(a6,d5.w),cfreq(a5)
0000FF96                          M 	amps_debug_notepsg
0000FF96 0C05 008C                M 	cmp.b	#dfreqpsg_-dfreqpsg,d5
0000FF9A 6500                     M 	blo.s	.ok
0000FF9C                          M .fail
0000FF9C 4EBA DF46                M 	jsr	amps_debugr_notepsg
0000FFA0                          M .ok
0000FFA0                          M .freqgot
0000FFA0 1A1C                       		move.b	(a4)+,d5		; check if next note is a timer
0000FFA2 6A00                       		bpl.s	.timer			; if yes, handle timer
0000FFA4 534C                       		subq.w	#1,a4			; else, undo the increment
0000FFA6 6000                       		bra.s	.pcnote			; do not calculate duration
0000FFA8                            
0000FFA8                            .timer
0000FFA8 4EBA E996                  		jsr	dCalcDuration(pc)	; calculate duration
0000FFAC                            .pcnote
0000FFAC                            	dProcNote 0, 1				; reset necessary channel memory
0000FFAC 2B4C 0002                M 	move.l	a4,cdata(a5)
0000FFB0 1B6D 000D 000C           M 	move.b	clastdur(a5),cduration(a5)
0000FFB6 0815 0002                M 	btst	#cfbhold,(a5)
0000FFBA 6600                     M 	bne.s	.endpn
0000FFBC 1B6D 001D 001C           M 	move.b	cnotetimemain(a5),cnotetimecur(a5)
0000FFC2 422D 0006                M 	clr.b	cenvpos(a5)
0000FFC6 0815 0003                M 	btst	#cfbmod,(a5)
0000FFCA 6700                     M 	beq.s	.endpn
0000FFCC 226D 0010                M 	movea.l	cmod(a5),a1
0000FFD0 1B59 0010                M 	move.b	(a1)+,cmoddelay(a5)
0000FFD4 1B59 0016                M 	move.b	(a1)+,cmodspeed(a5)
0000FFD8 1B59 0017                M 	move.b	(a1)+,cmodstep(a5)
0000FFDC 1011                     M 	move.b	(a1),d0
0000FFDE E208                     M 	lsr.b	#1,d0
0000FFE0 1B40 0018                M 	move.b	d0,cmodcount(a5)
0000FFE4 426D 0014                M 	clr.w	cmodfreq(a5)
0000FFE8                          M .endpn
0000FFE8                            
0000FFE8 6100                       		bsr.s	dUpdateFreqPSG		; update hardware frequency
0000FFEA 6100 0000                  		bsr.w	dEnvProgPSG		; run envelope program
0000FFEE 51CF FE90                  		dbf	d7,dAMPSnextPSG		; make sure to run all the channels
0000FFF2 4EFA E964                  		jmp	dAMPSdoDACSFX(pc)	; after that, process SFX DAC channels
0000FFF6                            ; ===========================================================================
0000FFF6                            ; ---------------------------------------------------------------------------
0000FFF6                            ; Write PSG frequency to hardware
0000FFF6                            ; ---------------------------------------------------------------------------
0000FFF6                            
0000FFF6                            dUpdateFreqPSG:
0000FFF6 3C2D 000E                  		move.w	cFreq(a5),d6		; get channel base frequency to d6
0000FFFA 6A00                       		bpl.s	.detune			; if it was not rest frequency, branch
0000FFFC 08D5 0000                  		bset	#cfbRest,(a5)		; set channel resting flag
00010000 4E75                       		rts
00010002                            
00010002                            .detune
00010002 102D 0007                  		move.b	cDetune(a5),d0		; load detune value to d0
00010006 4880                       		ext.w	d0			; extend to word
00010008 DC40                       		add.w	d0,d6			; add to channel base frequency to d6
0001000A                            
0001000A 0815 0003                  		btst	#cfbMod,(a5)		; check if channel is modulating
0001000E 6700                       		beq.s	dUpdateFreqPSG2		; if not, branch
00010010 DC6D 0014                  		add.w	cModFreq(a5),d6		; add modulation frequency offset to d6
00010014                            
00010014                            dUpdateFreqPSG2:
00010014 0815 0001                  		btst	#cfbInt,(a5)		; is channel interrupted by sfx?
00010018 6600                       		bne.s	locret_dUpdateFreqPSG	; if so, skip
0001001A                            
0001001A                            dUpdateFreqPSG3:
0001001A 0815 0000                  		btst	#cfbRest,(a5)		; is this channel resting
0001001E 6600                       		bne.s	locret_dUpdateFreqPSG	; if so, skip
00010020                            
00010020 102D 0001                  		move.b	cType(a5),d0		; load channel type value to d0
00010024 0C00 00E0                  		cmpi.b	#ctPSG4,d0		; check if this channel is in PSG4 mode
00010028 6600                       		bne.s	.notPSG4		; if not, branch
0001002A 70C0                       		moveq	#$FFFFFF00|ctPSG3,d0	; load PSG3 type value instead
0001002C                            
0001002C                            .notPSG4
0001002C 3206                       		move.w	d6,d1			; copy frequency to d1
0001002E 0201 000F                  		andi.b	#$F,d1			; get the low nibble of it
00010032 8001                       		or.b	d1,d0			; combine with channel type
00010034                            ; ---------------------------------------------------------------------------
00010034                            ; Note about the and instruction below: If this instruction is
00010034                            ; not commented out, the instashield SFX will not sound correct.
00010034                            ; This instruction was removed in Sonic 3K because of this, but
00010034                            ; this can cause issues when values overflow the valid range of
00010034                            ; PSG frequency. This may cause erroneous behavior if not anded,
00010034                            ; but will also make the instashield SFX not sound correctly.
00010034                            ; Comment out the instruction with caution, if you are planning
00010034                            ; to port said sound effect to this driver. This has not caused
00010034                            ; any issues for me, and if you are careful you can avoid any
00010034                            ; such case, but beware of this issue!
00010034                            ; ---------------------------------------------------------------------------
00010034                            
00010034 E84E                       		lsr.w	#4,d6			; get the 2 higher nibbles of frequency
00010036 0206 003F                  		andi.b	#$3F,d6			; clear any extra bits that aren't valid
0001003A 13C0 00C0 0011             		move.b	d0,dPSG			; write frequency low nibble and latch channel
00010040 13C6 00C0 0011             		move.b	d6,dPSG			; write frequency high nibbles to PSG
00010046                            
00010046                            locret_dUpdateFreqPSG:
00010046 4E75                       		rts
00010048                            ; ===========================================================================
00010048                            ; ---------------------------------------------------------------------------
00010048                            ; Routine for running envelope programs
00010048                            ; ---------------------------------------------------------------------------
00010048                            
00010048                            dEnvProgPSG:
00010048 1A2D 0009                  		move.b	cVolume(a5),d5		; load channel volume to d5
0001004C DA38 C4BF                  		add.b	mMasterVolPSG.w,d5	; add PSG master volume to d5
00010050                            
00010050 7800                       		moveq	#0,d4
00010052 182D 000B                  		move.b	cVolEnv(a5),d4		; load volume envelope ID to d4
00010056 6700                       		beq.s	dUpdateVolPSG2		; if 0, update volume only
00010058 6000                       		bra.s	dEnvProgPSG2		; continue to run code below
0001005A                            
0001005A                            dEnvelopePSG:
0001005A 7800                       		moveq	#0,d4
0001005C 182D 000B                  		move.b	cVolEnv(a5),d4		; load volume envelope ID to d4
00010060 6700                       		beq.s	locret_UpdVolPSG	; if 0, return
00010062                            
00010062 1A2D 0009                  		move.b	cVolume(a5),d5		; load channel volume to d5
00010066 DA38 C4BF                  		add.b	mMasterVolPSG.w,d5	; add PSG master volume to d5
0001006A                            
0001006A                            dEnvProgPSG2:
0001006A                            		AMPS_Debug_VolEnvID		; check if volume envelope ID is valid
0001006A 0C04 0000                M 	cmp.b	#(volenvs_end-volenvs)/4,d4
0001006E 6300                     M 	bls.s	.ok
00010070 4EBA DE3C                M 	jsr	amps_debugr_volenvid
00010074                          M .ok
00010074                            
00010074 43FA 0000                  		lea	VolEnvs-4(pc),a1	; load volume envelope data array
00010078 D844                       		add.w	d4,d4			; quadruple volume envelope ID
0001007A D844                       		add.w	d4,d4			; (each entry is 4 bytes in size)
0001007C 2271 4000                  		move.l	(a1,d4.w),a1		; get pointer to volume envelope data
00010080                            
00010080 7200                       		moveq	#0,d1
00010082 7000                       		moveq	#0,d0
00010084                            
00010084                            dEnvProgPSG3:
00010084 122D 0006                  		move.b	cEnvPos(a5),d1		; get envelope position to d1
00010088 1031 1000                  		move.b	(a1,d1.w),d0		; get the date in that position
0001008C 6B00                       		bmi.s	dEnvCommand		; if it is a command, handle it
0001008E                            
0001008E 522D 0006                  		addq.b	#1,cEnvPos(a5)		; increment envelope position
00010092 DA00                       		add.b	d0,d5			; add envelope volume to d5
00010094                            	; continue to update PSG volume
00010094                            ; ===========================================================================
00010094                            ; ---------------------------------------------------------------------------
00010094                            ; Routine for updating PSG volume to hardware
00010094                            ; ---------------------------------------------------------------------------
00010094                            
00010094                            dUpdateVolPSG2:
00010094 0C05 000F                  		cmpi.b	#$F,d5			; check if volume is out of range
00010098 6300                       		bls.s	dUpdateVolPSG		; if not, branch
0001009A 7A0F                       		moveq	#$F,d5			; cap volume to silent
0001009C                            
0001009C                            dUpdateVolPSG:
0001009C 0815 0000                  		btst	#cfbRest,(a5)		; is this channel resting
000100A0 6600                       		bne.s	locret_UpdVolPSG	; if is, do not update
000100A2 0815 0001                  		btst	#cfbInt,(a5)		; is channel interrupted by sfx?
000100A6 6600                       		bne.s	locret_UpdVolPSG	; if is, do not update
000100A8                            
000100A8 0815 0002                  		btst	#cfbHold,(a5)		; check if note is held
000100AC 6700                       		beq.s	dUpdVolPSGset		; if not, update volume
000100AE BAFC C67C                  		cmp.w	#mSFXDAC1,a5		; check if this is a SFX channel
000100B2 6400                       		bhs.s	dUpdVolPSGset		; if so, update volume
000100B4                            
000100B4 4A2D 001D                  		tst.b	cNoteTimeMain(a5)	; check if note timeout is active
000100B8 6700                       		beq.s	dUpdVolPSGset		; if not, update volume
000100BA 4A2D 001C                  		tst.b	cNoteTimeCur(a5)	; is note stopped already?
000100BE 6700                       		beq.s	locret_UpdVolPSG	; if is, do not update
000100C0                            
000100C0                            dUpdVolPSGset:
000100C0 8A2D 0001                  		or.b	cType(a5),d5		; combine channel type value with volume
000100C4 0605 0010                  		addi.b	#$10,d5			; set volume update bit
000100C8 13C5 00C0 0011             		move.b	d5,dPSG			; write volume command to PSG port
000100CE                            
000100CE                            locret_UpdVolPSG:
000100CE 4E75                       		rts
000100D0                            ; ===========================================================================
000100D0                            ; ---------------------------------------------------------------------------
000100D0                            ; Subroutine for handling volume envelope commands
000100D0                            ; ---------------------------------------------------------------------------
000100D0                            
000100D0                            dEnvCommand:
000100D0                            		AMPS_Debug_VolEnvCmd		; check if command is valid
000100D0 0C00 0088                M 	cmp.b	#elast,d0
000100D4 6400                     M 	bhs.s	.fail
000100D6 0C00 0080                M 	cmp.b	#$80,d0
000100DA 6500                     M 	blo.s	.fail
000100DC 0800 0000                M 	btst	#0,d0
000100E0 6700                     M 	beq.s	.ok
000100E2                          M .fail
000100E2                          M 	raiseerror2	"Volume envelope command invalid: %<.b d0>",amps_debug_console_channel
000100E2 40E7                     M 	move.w	sr,-(sp)
000100E4                          M 	__fstring_generateargumentscode	"Volume envelope command invalid: %<.b d0>"
000100E4 =00000022                M 	__pos:	set instr("Volume envelope command invalid: %<.b d0>",'%<')
000100E4 =00000000                M 	__stack:set	0
000100E4 =00000000                M 	__sp:	set 0
000100E4                          M 	while	(__pos)
000100E4 =00000029                M 	__endpos:	set instr(__pos+1,"Volume envelope command invalid: %<.b d0>",'>')
000100E4 =00000000                M 	__midpos:	set instr(__pos+5,"Volume envelope command invalid: %<.b d0>",' ')
000100E4 =00000029                M 	__midpos:	= __endpos
000100E4                          M 	__substr:	substr __pos+1+1,__endpos-1,"Volume envelope command invalid: %<.b d0>"
000100E4                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Volume envelope command invalid: %<.b d0>"
000100E4                          M 	__operand:	substr __pos+1+1,__midpos-1,"Volume envelope command invalid: %<.b d0>"
000100E4                          M 	__param:	substr __midpos+1,__endpos-1,"Volume envelope command invalid: %<.b d0>"
000100E4                          M 	pushp	"move.b d0,1(sp)"
000100E4                          M 	pushp	"subq.w	#2, sp"
000100E4 =00000002                M 	__stack:	= __stack+2
000100E4 =00000002                M 	__sp:	= __sp+2
000100E4 =00000000                M 	__pos:	set instr(__pos+1,"Volume envelope command invalid: %<.b d0>",'%<')
000100E4                          M 	rept	__stack
000100E4                          M 	popp	__command
000100E4 554F                     M 	subq.w	#2,sp
000100E6                          M 	popp	__command
000100E6 1F40 0001                M 	move.b	d0,1(sp)
000100EA 4EB9 0000 0000           M 	jsr	errorhandler
000100F0                          M 	__fstring_generatedecodedstring	"Volume envelope command invalid: %<.b d0>"
000100F0 =00000001                M 	__lpos:	set 1
000100F0 =00000022                M 	__pos:	set instr("Volume envelope command invalid: %<.b d0>",'%<')
000100F0                          M 	while	(__pos)
000100F0                          M 	__substr:	substr __lpos,__pos-1,"Volume envelope command invalid: %<.b d0>"
000100F0 566F 6C75 6D65 2065 6E76+M 	dc.b	"Volume envelope command invalid: "
00010111 =00000029                M 	__endpos:	set instr(__pos+1,"Volume envelope command invalid: %<.b d0>",'>')
00010111 =00000000                M 	__midpos:	set instr(__pos+5,"Volume envelope command invalid: %<.b d0>",' ')
00010111 =00000029                M 	__midpos:	= __endpos
00010111                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"Volume envelope command invalid: %<.b d0>"
00010111                          M 	__param:	substr __midpos+1,__endpos-1,"Volume envelope command invalid: %<.b d0>"
00010111                          M 	__param:	substr ,,"hex"
00010111 80                       M 	dc.b	hex
00010112 =0000002A                M 	__lpos:	set __endpos+1
00010112 =00000000                M 	__pos:	set instr(__pos+1,"Volume envelope command invalid: %<.b d0>",'%<')
00010112                          M 	__substr:	substr __lpos,,"Volume envelope command invalid: %<.b d0>"
00010112                          M 	dc.b	""
00010112 00                       M 	dc.b	0
00010113 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
00010114                          M 	even
00010114 4EFA D166                M 	jmp	amps_debug_console_channel
00010118                          M 	even
00010118                          M .ok
00010118                            
00010118 4EFB 0000                  		jmp	.comm-$80(pc,d0.w)	; jump to command handler
0001011C                            
0001011C                            .comm
0001011C 6000                       		bra.s	.reset			; 80 - Loop back to beginning
0001011E 6000                       		bra.s	.hold			; 82 - Hold the envelope at current level
00010120 6000                       		bra.s	.loop			; 84 - Go to position defined by the next byte
00010122                            	;	bra.s	.stop			; 86 - Stop current note and envelope
00010122                            ; ---------------------------------------------------------------------------
00010122                            
00010122                            .stop
00010122 08D5 0000                  		bset	#cfbRest,(a5)		; set channel resting bit
00010126 6000                       		bra.s	dMutePSGmus		; nute the channel
00010128                            ; ---------------------------------------------------------------------------
00010128                            
00010128                            .hold
00010128 532D 0006                  		subq.b	#1,cEnvPos(a5)		; decrease envelope position
0001012C 4EFA FF56                  		jmp	dEnvProgPSG3(pc)	; run the program again (make sure volume fades work)
00010130                            ; ---------------------------------------------------------------------------
00010130                            
00010130                            .reset
00010130 422D 0006                  		clr.b	cEnvPos(a5)		; set envelope position to 0
00010134 4EFA FF4E                  		jmp	dEnvProgPSG3(pc)	; run the program again
00010138                            ; ---------------------------------------------------------------------------
00010138                            
00010138                            .loop
00010138 1B71 1001 0006             		move.b	1(a1,d1.w),cEnvPos(a5)	; set envelope position to the next byte
0001013E 4EFA FF44                  		jmp	dEnvProgPSG3(pc)	; run the program again
00010142                            ; ===========================================================================
00010142                            ; ---------------------------------------------------------------------------
00010142                            ; Routine for hardware muting a PSG channel
00010142                            ; ---------------------------------------------------------------------------
00010142                            
00010142                            dMutePSGmus:
00010142 0815 0001                  		btst	#cfbInt,(a5)		; check if this is a SFX channel
00010146 6600                       		bne.s	locret_MutePSG		; if yes, do not update
00010148                            
00010148                            dMutePSGsfx:
00010148 701F                       		moveq	#$1F,d0			; prepare volume update to mute value to d0
0001014A 802D 0001                  		or.b	cType(a5),d0		; combine channel type value with d0
0001014E 13C0 00C0 0011             		move.b	d0,dPSG			; write volume command to PSG port
00010154                            
00010154                            locret_MutePSG:
00010154 4E75                       		rts
00010156                            
00010156 414D 5053 2031 2E30        	dc.b "AMPS 1.0"				; not required, just here to make my life easier
0001015E                            ; ===========================================================================
0001015E                            ; ---------------------------------------------------------------------------
0001015E                            ; Routine to execute tracker commands
0001015E                            ;
0001015E                            ; The reason we use add.b instead of add.w, is to get rid of some bits that
0001015E                            ; would make this kind of arbitary jumping way more complex than it needs to be.
0001015E                            ; What do we win by doing this? Why, 8 cycles per command! Thats... Not a lot,
0001015E                            ; but it may be helpful with speed anyway.
0001015E                            ; ---------------------------------------------------------------------------
0001015E                            
0001015E                            dCommands:
0001015E DA05                       		add.b	d5,d5			; quadruple command ID
00010160 DA05                       		add.b	d5,d5			; since each entry is 4 bytes large
00010162                            
00010162 0815 0004                  		btst	#cfbCond,(a5)		; check if condition state
00010166 6600 0000                  		bne.w	.falsecomm		; branch if false
0001016A 4EFB 5000                  		jmp	.comm-$80(pc,d5.w)	; jump to appropriate handler
0001016E                            ; ===========================================================================
0001016E                            ; ---------------------------------------------------------------------------
0001016E                            ; Command handlers for normal execution
0001016E                            ; ---------------------------------------------------------------------------
0001016E                            
0001016E                            .comm
0001016E 6000 0000                  	bra.w	dcPan		; E0 - Panning, AMS, FMS (PANAFMS - PAFMS_PAN)
00010172 6000 0000                  	bra.w	dcsDetune	; E1 - Set channel frequency displacement to xx (DETUNE_SET)
00010176 6000 0000                  	bra.w	dcaDetune	; E2 - Add xx to channel frequency displacement (DETUNE)
0001017A 6000 0000                  	bra.w	dcsTransp	; E3 - Set channel pitch to xx (TRANSPOSE - TRNSP_SET)
0001017E 6000 0000                  	bra.w	dcaTransp	; E4 - Add xx to channel pitch (TRANSPOSE - TRNSP_ADD)
00010182 6000 0000                  	bra.w	dcsTmulCh	; E5 - Set channel tick multiplier to xx (TICK_MULT - TMULT_CUR)
00010186 6000 0000                  	bra.w	dcsTmul		; E6 - Set global tick multiplier to xx (TICK_MULT - TMULT_ALL)
0001018A 6000 0000                  	bra.w	dcHold		; E7 - Do not allow note on/off for next note (HOLD)
0001018E 6000 0000                  	bra.w	dcVoice		; E8 - Set Voice/voice/sample to xx (INSTRUMENT - INS_C_FM / INS_C_PSG / INS_C_DAC)
00010192 6000 0000                  	bra.w	dcsTempoShoes	; E9 - Set music speed shoes tempo to xx (TEMPO - TEMPO_SET_SPEED)
00010196 6000 0000                  	bra.w	dcsTempo	; EA - Set music tempo to xx (TEMPO - TEMPO_SET)
0001019A 6000 0000                  	bra.w	dcModOn		; EB - Turn on Modulation (MOD_SET - MODS_ON)
0001019E 6000 0000                  	bra.w	dcModOff	; EC - Turn off Modulation (MOD_SET - MODS_OFF)
000101A2 6000 0000                  	bra.w	dcaVolume	; ED - Add xx to channel volume (VOLUME - VOL_CN_FM / VOL_CN_PSG / VOL_CN_DAC)
000101A6 6000 0000                  	bra.w	dcsVolume	; EE - Set channel volume to xx (VOLUME - VOL_CN_ABS)
000101AA 6000 0000                  	bra.w	dcsLFO		; EF - Set LFO (SET_LFO - LFO_AMSEN)
000101AE 6000 0000                  	bra.w	dcMod68K	; F0 - Modulation (MOD_SETUP)
000101B2 6000 0000                  	bra.w	dcSampDAC	; F1 - Use sample DAC mode (DAC_MODE - DACM_SAMP)
000101B6 6000 0000                  	bra.w	dcPitchDAC	; F2 - Use pitch DAC mode (DAC_MODE - DACM_NOTE)
000101BA 6000 0000                  	bra.w	dcNoisePSG	; F3 - PSG4 mode to xx (PSG_NOISE - PNOIS_AMPS)
000101BE 6000 0000                  	bra.w	dcCont		; F4 - Do a continuous SFX loop (CONT_SFX)
000101C2 6000 0000                  	bra.w	dcStop		; F5 - End of channel (TRK_END - TEND_STD)
000101C6 6000 0000                  	bra.w	dcJump		; F6 - Jump to xxxx (GOTO)
000101CA 6000 0000                  	bra.w	dcLoop		; F7 - Loop back to zzzz yy times, xx being the loop index (LOOP)
000101CE 6000 0000                  	bra.w	dcCall		; F8 - Call pattern at xxxx, saving return point (GOSUB)
000101D2 6000 0000                  	bra.w	dcReturn	; F9 - Return (RETURN)
000101D6 6000 0000                  	bra.w	dcsComm		; FA - Set communications byte yy to xx (SET_COMM - SPECIAL)
000101DA 6000 0000                  	bra.w	dcCond		; FB - Get comms byte y, and compare zz using condition x (COMM_CONDITION)
000101DE 6000 0000                  	bra.w	dcResetCond	; FC - Reset condition (COMM_RESET)
000101E2 6000 0000                  	bra.w	dcTimeout	; FD - Stop note after xx frames (NOTE_STOP - NSTOP_NORMAL
000101E6 6000 0000                  	bra.w	dcYM		; FE - YM command (YMCMD)
000101EA                            				; FF - META
000101EA                            ; ===========================================================================
000101EA                            ; ---------------------------------------------------------------------------
000101EA                            ; Routine to execute tracker meta and false condition commands
000101EA                            ; ---------------------------------------------------------------------------
000101EA                            
000101EA                            .metacall
000101EA 1A1C                       		move.b	(a4)+,d5		; get next command byte
000101EC DA45                       		add.w	d5,d5			; quadruple ID
000101EE DA45                       		add.w	d5,d5			; since each entry is again 4 bytes large
000101F0 4EFB 5000                  		jmp	.meta(pc,d5.w)		; jump to appropriate meta handler
000101F4                            
000101F4                            .falsecomm
000101F4 4EFB 5000                  		jmp	.false-$80(pc,d5.w)	; jump to appropriate handler (false command)
000101F8                            ; ===========================================================================
000101F8                            ; ---------------------------------------------------------------------------
000101F8                            ; Command handlers for meta commands
000101F8                            ; ---------------------------------------------------------------------------
000101F8                            
000101F8                            .meta
000101F8 6000 0000                  	bra.w	dcWriteDAC1	; FF 00 - Play sample xx on DAC1 (PLAY_DAC - PLAY_DAC1)
000101FC 6000 0000                  	bra.w	dcWriteDAC2	; FF 01 - Play sample xx on DAC2 (PLAY_DAC - PLAY_DAC2)
00010200 6000 0000                  	bra.w	dcsFreq		; FF 02 - Set channel frequency to xxxx (CHFREQ_SET)
00010204 6000 0000                  	bra.w	dcsFreqNote	; FF 03 - Set channel frequency to note xx (CHFREQ_SET - CHFREQ_NOTE)
00010208 6000 0000                  	bra.w	dcSpRev		; FF 04 - Increment spindash rev counter (SPINDASH_REV - SDREV_INC)
0001020C 6000 0000                  	bra.w	dcSpReset	; FF 05 - Reset spindash rev counter (SPINDASH_REV - SDREV_RESET)
00010210 6000 0000                  	bra.w	dcaTempoShoes	; FF 06 - Add xx to music speed tempo (TEMPO - TEMPO_ADD_SPEED)
00010214 6000 0000                  	bra.w	dcaTempo	; FF 07 - Add xx to music tempo (TEMPO - TEMPO_ADD)
00010218 6000 0000                  	bra.w	dcCondReg	; FF 08 - Get RAM table offset by y, and chk zz with cond x (COMM_CONDITION - COMM_SPEC)
0001021C 6000 0000                  	bra.w	dcSound		; FF 09 - Play another music/sfx (SND_CMD)
00010220 6000 0000                  	bra.w	dcFreqOn	; FF 0A - Enable raw frequency mode (RAW_FREQ)
00010224 6000 0000                  	bra.w	dcFreqOff	; FF 0B - Disable raw frequency mode (RAW_FREQ - RAW_FREQ_OFF)
00010228 6000 0000                  	bra.w	dcSpecFM3	; FF 0C - Enable FM3 special mode (SPC_FM3)
0001022C 6000 0000                  	bra.w	dcFilter	; FF 0D - Set DAC filter bank. (DAC_FILTER)
00010230                            
00010230 6000 0000                  		bra.w	dcFreeze	; FF 0E - Freeze CPU. Debug flag (DEBUG_STOP_CPU)
00010234 6000 0000                  		bra.w	dcTracker	; FF 0F - Bring up tracker debugger at end of frame. Debug flag (DEBUG_PRINT_TRACKER)
00010238                            ; ===========================================================================
00010238                            ; ---------------------------------------------------------------------------
00010238                            ; Command handlers for false condition execution
00010238                            ; ---------------------------------------------------------------------------
00010238                            
00010238                            .false
00010238 524C                       	addq.w	#1,a4
0001023A 4E75                       	rts			; E0 - Panning, AMS, FMS (PANAFMS - PAFMS_PAN)
0001023C 524C                       	addq.w	#1,a4
0001023E 4E75                       	rts			; E1 - Add xx to channel frequency displacement (DETUNE)
00010240 524C                       	addq.w	#1,a4
00010242 4E75                       	rts			; E2 - Add xx to channel frequency displacement (DETUNE)
00010244 524C                       	addq.w	#1,a4
00010246 4E75                       	rts			; E3 - Set channel pitch to xx (TRANSPOSE - TRNSP_SET)
00010248 524C                       	addq.w	#1,a4
0001024A 4E75                       	rts			; E4 - Add xx to channel pitch (TRANSPOSE - TRNSP_ADD)
0001024C 6000 0000                  	bra.w	dcsTmulCh	; E5 - Set channel tick multiplier to xx (TICK_MULT - TMULT_CUR)
00010250 6000 0000                  	bra.w	dcsTmul		; E6 - Set global tick multiplier to xx (TICK_MULT - TMULT_ALL)
00010254 6000 0000                  	bra.w	dcHold		; E7 - Do not allow note on/off for next note (HOLD)
00010258 524C                       	addq.w	#1,a4
0001025A 4E75                       	rts			; E8 - Add xx to music tempo (TEMPO - TEMPO_ADD)
0001025C 524C                       	addq.w	#1,a4
0001025E 4E75                       	rts			; E9 - Set music tempo to xx (TEMPO - TEMPO_SET)
00010260 524C                       	addq.w	#1,a4
00010262 4E75                       	rts			; EA - Set Voice/voice/sample to xx (INSTRUMENT - INS_C_FM / INS_C_PSG / INS_C_DAC)
00010264 4E75                       	rts
00010266 4E75                       	rts			; EB - Turn on Modulation (MOD_SET - MODS_ON)
00010268 4E75                       	rts
0001026A 4E75                       	rts			; EC - Turn off Modulation (MOD_SET - MODS_OFF)
0001026C 524C                       	addq.w	#1,a4
0001026E 4E75                       	rts			; ED - Add xx to channel volume (VOLUME - VOL_CN_FM / VOL_CN_PSG / VOL_CN_DAC)
00010270 524C                       	addq.w	#1,a4
00010272 4E75                       	rts			; EE - Set channel volume to xx (VOLUME - VOL_CN_ABS)
00010274 524C                       	addq.w	#1,a4
00010276 4E75                       	rts			; EF - Set LFO (SET_LFO - LFO_AMSEN)
00010278 584C                       	addq.w	#4,a4
0001027A 4E75                       	rts			; F0 - Modulation (MOD_SETUP)
0001027C 4E75                       	rts
0001027E 4E75                       	rts			; F1 - Use sample DAC mode (DAC_MODE - DACM_SAMP)
00010280 4E75                       	rts
00010282 4E75                       	rts			; F2 - Use pitch DAC mode (DAC_MODE - DACM_NOTE)
00010284 524C                       	addq.w	#1,a4
00010286 4E75                       	rts			; F3 - PSG4 mode to xx (PSG_NOISE - PNOIS_SET)
00010288 544C                       	addq.w	#2,a4
0001028A 4E75                       	rts			; F4 - Do a continuous SFX loop (CONT_SFX)
0001028C 4E75                       	rts
0001028E 4E75                       	rts			; F5 - End of channel (TRK_END - TEND_STD)
00010290 544C                       	addq.w	#2,a4
00010292 4E75                       	rts			; F6 - Jump to xxxx (GOTO)
00010294 584C                       	addq.w	#4,a4
00010296 4E75                       	rts			; F7 - Loop back to zzzz yy times, xx being the loop index (LOOP)
00010298 544C                       	addq.w	#2,a4
0001029A 4E75                       	rts			; F8 - Call pattern at xxxx, saving return point (GOSUB)
0001029C 4E75                       	rts
0001029E 4E75                       	rts			; F9 - Return (RETURN)
000102A0 6000 0000                  	bra.w	dcsComm		; FA - Set communications byte yy to xx (SET_COMM - SPECIAL)
000102A4 6000 0000                  	bra.w	dcCond		; FB - Get comms byte y, and compare zz using condition x (COMM_CONDITION)
000102A8 6000 0000                  	bra.w	dcResetCond	; FC - Reset condition (COND_RESET)
000102AC 524C                       	addq.w	#1,a4
000102AE 4E75                       	rts			; FD - Stop note after xx frames (NOTE_STOP - NSTOP_NORMAL
000102B0 524C                       	addq.w	#1,a4
000102B2 4E75                       	rts			; FE - YM command (YMCMD)
000102B4 6000 FF34                  	bra.w	.metacall	; FF - META
000102B8                            ; ===========================================================================
000102B8                            ; ---------------------------------------------------------------------------
000102B8                            ; Tracker commands for writing direct DAC samples to Dual PCM.
000102B8                            ; Note that this will override any DAC already being played,
000102B8                            ; and in turn trackers may override these DAC samples at any
000102B8                            ; time. Use with caution!
000102B8                            ; ---------------------------------------------------------------------------
000102B8                            
000102B8                            dcWriteDAC1:
000102B8 7000                       		moveq	#0,d0
000102BA 101C                       		move.b	(a4)+,d0		; get note to write
000102BC 4EFA E58C                  		jmp	dNoteWriteDAC1(pc)	; note-on
000102C0                            
000102C0                            dcWriteDAC2:
000102C0 7000                       		moveq	#0,d0
000102C2 101C                       		move.b	(a4)+,d0		; get note to write
000102C4 4EFA E576                  		jmp	dNoteWriteDAC2(pc)	; note-on
000102C8                            ; ===========================================================================
000102C8                            ; ---------------------------------------------------------------------------
000102C8                            ; Tracker commands for handling spindash revving.
000102C8                            ; The way spindash revving works, is it actually just
000102C8                            ; increments a counter each time, and this counter is
000102C8                            ; added into the channel pitch offset.
000102C8                            ; ---------------------------------------------------------------------------
000102C8                            
000102C8                            dcSpRev:
000102C8 1038 C4C1                  		move.b	mSpindash.w,d0		; load spindash rev counter to d0
000102CC 5238 C4C1                  		addq.b	#1,mSpindash.w		; increment spindash rev counter
000102D0 D12D 0008                  		add.b	d0,cPitch(a5)		; add d0 to channel pitch offset
000102D4                            
000102D4 0C00 000B                  		cmp.b	#$C-1,d0		; check if this is the max pitch offset
000102D8 6500                       		blo.s	.rts			; if not, skip
000102DA 5338 C4C1                  		subq.b	#1,mSpindash.w		; cap at pitch offset $C
000102DE                            
000102DE                            .rts
000102DE 4E75                       		rts
000102E0                            
000102E0                            dcSpReset:
000102E0 4238 C4C1                  		clr.b	mSpindash.w		; reset spindash rev counter
000102E4 4E75                       		rts
000102E6                            ; ===========================================================================
000102E6                            ; ---------------------------------------------------------------------------
000102E6                            ; Tracker command for changing channel panning
000102E6                            ; ---------------------------------------------------------------------------
000102E6                            
000102E6                            dcPan:
000102E6                            		AMPS_Debug_dcPan		; check if this channel can pan
000102E6 4A2D 0001                M 	tst.b	ctype(a5)
000102EA 6A00                     M 	bpl.s	.ok
000102EC                          M 	raiseerror	"sPan on a PSG channel!",amps_debug_console_channel
000102EC 487A FFFE                M 	pea	*(pc)
000102F0                          M 	raiseerror2	"sPan on a PSG channel!",amps_debug_console_channel
000102F0 40E7                     M 	move.w	sr,-(sp)
000102F2                          M 	__fstring_generateargumentscode	"sPan on a PSG channel!"
000102F2 =00000000                M 	__pos:	set instr("sPan on a PSG channel!",'%<')
000102F2 =00000000                M 	__stack:set	0
000102F2 =00000000                M 	__sp:	set 0
000102F2                          M 	while	(__pos)
000102F2                          M 	rept	__stack
000102F2 4EB9 0000 0000           M 	jsr	errorhandler
000102F8                          M 	__fstring_generatedecodedstring	"sPan on a PSG channel!"
000102F8 =00000001                M 	__lpos:	set 1
000102F8 =00000000                M 	__pos:	set instr("sPan on a PSG channel!",'%<')
000102F8                          M 	while	(__pos)
000102F8                          M 	__substr:	substr __lpos,,"sPan on a PSG channel!"
000102F8 7350 616E 206F 6E20 6120+M 	dc.b	"sPan on a PSG channel!"
0001030E 00                       M 	dc.b	0
0001030F 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
00010310                          M 	even
00010310 4EFA CF6A                M 	jmp	amps_debug_console_channel
00010314                          M 	even
00010314                          M .ok
00010314                            
00010314 7237                       		moveq	#$37,d1			; prepare bits to keep
00010316 C22D 0006                  		and.b	cPanning(a5),d1		; and with channel LFO settings
0001031A 821C                       		or.b	(a4)+,d1		; or panning value
0001031C 1B41 0006                  		move.b	d1,cPanning(a5)		; save as channel panning
00010320                            
00010320 70B4                       		moveq	#$FFFFFFB4,d0		; YM command: Panning & LFO
00010322 082D 0003 0001             		btst	#ctbDAC,cType(a5)	; check if this is a DAC channel
00010328 6700 F55A                  		beq.w	dWriteYMchnInt		; if not, write channel-specific YM command
0001032C                            ; ---------------------------------------------------------------------------
0001032C                            ; Since the DAC channels have or based panning behavior, we need this
0001032C                            ; piece of code to update its panning
0001032C                            ; ---------------------------------------------------------------------------
0001032C                            
0001032C 1238 C4CA                  		move.b	mDAC1+cPanning.w,d1	; read panning value from music DAC1
00010330 0838 0001 C4C4             		btst	#cfbInt,mDAC1+cFlags.w	; check if music DAC1 is interrupted by SFX
00010336 6700                       		beq.s	.nodacsfx		; if not, use music DAC1 panning
00010338 1238 C682                  		move.b	mSFXDAC1+cPanning.w,d1	; read panning value from SFX DAC1
0001033C                            
0001033C                            .nodacsfx
0001033C 8238 C4F6                  		or.b	mDAC2+cPanning.w,d1	; or the panning value from music DAC2
00010340 70B6                       		moveq	#$FFFFFFB4+2,d0		; YM address: Panning and LFO (FM3/6)
00010342 4EFA F592                  		jmp	WriteYM_Pt2(pc)		; write to part 2 channel
00010346                            ; ===========================================================================
00010346                            ; ---------------------------------------------------------------------------
00010346                            ; Tracker commands for changing detune offset
00010346                            ; ---------------------------------------------------------------------------
00010346                            
00010346                            dcaDetune:
00010346 101C                       		move.b	(a4)+,d0		; load detune offset from tracker
00010348 D12D 0007                  		add.b	d0,cDetune(a5)		; Add to channel detune offset
0001034C 4E75                       		rts
0001034E                            
0001034E                            dcsDetune:
0001034E 1B5C 0007                  		move.b	(a4)+,cDetune(a5)	; load detune offset from tracker to channel
00010352 4E75                       		rts
00010354                            ; ===========================================================================
00010354                            ; ---------------------------------------------------------------------------
00010354                            ; Tracker command for changing channel volume
00010354                            ; ---------------------------------------------------------------------------
00010354                            
00010354                            dcsVolume:
00010354 1B5C 0009                  		move.b	(a4)+,cVolume(a5)	; load volume from tracker to channel
00010358 08D5 0005                  		bset	#cfbVol,(a5)		; set volume update flag
0001035C 4E75                       		rts
0001035E                            
0001035E                            dcaVolume:
0001035E 101C                       		move.b	(a4)+,d0		; load volume from tracker
00010360 D12D 0009                  		add.b	d0,cVolume(a5)		; add to channel volume
00010364 08D5 0005                  		bset	#cfbVol,(a5)		; set volume update flag
00010368 4E75                       		rts
0001036A                            ; ===========================================================================
0001036A                            ; ---------------------------------------------------------------------------
0001036A                            ; Tracker command for setting DAC to sample mode and resetting frequency
0001036A                            ; ---------------------------------------------------------------------------
0001036A                            
0001036A                            dcSampDAC:
0001036A 3B7C 0100 000E             		move.w	#$100,cFreq(a5)		; reset to defualt base frequency
00010370 0895 0000                  		bclr	#cfbMode,(a5)		; enable sample mode
00010374 4E75                       		rts
00010376                            ; ===========================================================================
00010376                            ; ---------------------------------------------------------------------------
00010376                            ; Tracker command for setting DAC to pitch mode
00010376                            ; ---------------------------------------------------------------------------
00010376                            
00010376                            dcPitchDAC:
00010376 08D5 0000                  		bset	#cfbMode,(a5)		; enable pitch mode
0001037A 4E75                       		rts
0001037C                            ; ===========================================================================
0001037C                            ; ---------------------------------------------------------------------------
0001037C                            ; Tracker commands for changing channel tick multiplier
0001037C                            ; ---------------------------------------------------------------------------
0001037C                            
0001037C                            dcsTmulCh:
0001037C 1B5C 000A                  		move.b	(a4)+,cTick(a5)		; load tick multiplier from tracker to channel
00010380 4E75                       		rts
00010382                            
00010382                            dcsTmul:
00010382 101C                       		move.b	(a4)+,d0		; load tick multiplier from tracker to d0
00010384 =FFFFC4C4                  .x =	mDAC1					; start at DAC1
00010384                            	rept Mus_Ch				; do for all music channels
00010384                            		move.b	d0,cTick+.x.w		; set channel tick multiplier
00010384                            .x =		.x+cSize			; go to next channel
00010384                            	endr
00010384 11C0 C4CE                M 	move.b	d0,ctick+.x.w
00010388 =FFFFC4F0                M .x	=	.x+csize
00010388 11C0 C4FA                M 	move.b	d0,ctick+.x.w
0001038C =FFFFC51C                M .x	=	.x+csize
0001038C 11C0 C526                M 	move.b	d0,ctick+.x.w
00010390 =FFFFC548                M .x	=	.x+csize
00010390 11C0 C552                M 	move.b	d0,ctick+.x.w
00010394 =FFFFC574                M .x	=	.x+csize
00010394 11C0 C57E                M 	move.b	d0,ctick+.x.w
00010398 =FFFFC5A0                M .x	=	.x+csize
00010398 11C0 C5AA                M 	move.b	d0,ctick+.x.w
0001039C =FFFFC5CC                M .x	=	.x+csize
0001039C 11C0 C5D6                M 	move.b	d0,ctick+.x.w
000103A0 =FFFFC5F8                M .x	=	.x+csize
000103A0 11C0 C602                M 	move.b	d0,ctick+.x.w
000103A4 =FFFFC624                M .x	=	.x+csize
000103A4 11C0 C62E                M 	move.b	d0,ctick+.x.w
000103A8 =FFFFC650                M .x	=	.x+csize
000103A8 11C0 C65A                M 	move.b	d0,ctick+.x.w
000103AC =FFFFC67C                M .x	=	.x+csize
000103AC 4E75                       		rts
000103AE                            ; ===========================================================================
000103AE                            ; ---------------------------------------------------------------------------
000103AE                            ; Tracker command for enabling or disabling the hold flag
000103AE                            ; ---------------------------------------------------------------------------
000103AE                            
000103AE                            dcHold:
000103AE 0855 0002                  		bchg	#cfbHold,(a5)		; flip the channel hold flag
000103B2 4E75                       		rts
000103B4                            ; ===========================================================================
000103B4                            ; ---------------------------------------------------------------------------
000103B4                            ; Tracker command for enabling or disabling note timeout
000103B4                            ; ---------------------------------------------------------------------------
000103B4                            
000103B4                            dcTimeout:
000103B4                            		AMPS_Debug_dcTimeout		; check if this channel has timeout support
000103B4 BAFC C67C                M 	cmp.w	#msfxdac1,a5
000103B8 6500                     M 	blo.s	.ok
000103BA                          M 	raiseerror	"sNoteTimeOut on a SFX channel!",amps_debug_console_channel
000103BA 487A FFFE                M 	pea	*(pc)
000103BE                          M 	raiseerror2	"sNoteTimeOut on a SFX channel!",amps_debug_console_channel
000103BE 40E7                     M 	move.w	sr,-(sp)
000103C0                          M 	__fstring_generateargumentscode	"sNoteTimeOut on a SFX channel!"
000103C0 =00000000                M 	__pos:	set instr("sNoteTimeOut on a SFX channel!",'%<')
000103C0 =00000000                M 	__stack:set	0
000103C0 =00000000                M 	__sp:	set 0
000103C0                          M 	while	(__pos)
000103C0                          M 	rept	__stack
000103C0 4EB9 0000 0000           M 	jsr	errorhandler
000103C6                          M 	__fstring_generatedecodedstring	"sNoteTimeOut on a SFX channel!"
000103C6 =00000001                M 	__lpos:	set 1
000103C6 =00000000                M 	__pos:	set instr("sNoteTimeOut on a SFX channel!",'%<')
000103C6                          M 	while	(__pos)
000103C6                          M 	__substr:	substr __lpos,,"sNoteTimeOut on a SFX channel!"
000103C6 734E 6F74 6554 696D 654F+M 	dc.b	"sNoteTimeOut on a SFX channel!"
000103E4 00                       M 	dc.b	0
000103E5 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
000103E6                          M 	even
000103E6 4EFA CE94                M 	jmp	amps_debug_console_channel
000103EA                          M 	even
000103EA                          M .ok
000103EA                            
000103EA 1B54 001D                  		move.b	(a4),cNoteTimeMain(a5)	; load note timeout from tracker to channel
000103EE 1B5C 001C                  		move.b	(a4)+,cNoteTimeCur(a5)	; ''
000103F2 4E75                       		rts
000103F4                            ; ===========================================================================
000103F4                            ; ---------------------------------------------------------------------------
000103F4                            ; Tracker commands for changing channel pitch
000103F4                            ; ---------------------------------------------------------------------------
000103F4                            
000103F4                            dcaTransp:
000103F4 101C                       		move.b	(a4)+,d0		; load pitch offset from tracker
000103F6 D12D 0008                  		add.b	d0,cPitch(a5)		; add to channel pitch offset
000103FA 4E75                       		rts
000103FC                            
000103FC                            dcsTransp:
000103FC 1B5C 0008                  		move.b	(a4)+,cPitch(a5)	; load pitch offset from tracker to channel
00010400 4E75                       		rts
00010402                            ; ===========================================================================
00010402                            ; ---------------------------------------------------------------------------
00010402                            ; Tracker commands for tempo control
00010402                            ; ---------------------------------------------------------------------------
00010402                            
00010402                            dcsTempoShoes:
00010402 101C                       		move.b	(a4)+,d0		; load tempo value from tracker
00010404 11C0 C4B9                  		move.b	d0,mTempoSpeed.w	; save as the speed shoes tempo
00010408 0838 0001 C4A6             		btst	#mfbSpeed,mFlags.w	; check if speed shoes mode is active
0001040E 6600                       		bne.s	dcsTempoCur		; if is, load as current tempo too
00010410 4E75                       		rts
00010412                            
00010412                            dcsTempo:
00010412 101C                       		move.b	(a4)+,d0		; load tempo value from tracker
00010414 11C0 C4B8                  		move.b	d0,mTempoMain.w		; save as the main tempo
00010418 0838 0001 C4A6             		btst	#mfbSpeed,mFlags.w	; check if speed shoes mode is active
0001041E 6600                       		bne.s	locret_Tempo		; if not, load as current tempo too
00010420                            
00010420                            dcsTempoCur:
00010420 11C0 C4BA                  		move.b	d0,mTempo.w		; save as current tempo
00010424                            
00010424                            locret_Tempo:
00010424 4E75                       		rts
00010426                            
00010426                            dcaTempoShoes:
00010426 101C                       		move.b	(a4)+,d0		; load tempo value from tracker
00010428 D138 C4B9                  		add.b	d0,mTempoSpeed.w	; add to the speed shoes tempo
0001042C 0838 0001 C4A6             		btst	#mfbSpeed,mFlags.w	; check if speed shoes mode is active
00010432 6600                       		bne.s	dcaTempoCur		; if is, add to current tempo too
00010434 4E75                       		rts
00010436                            
00010436                            dcaTempo:
00010436 101C                       		move.b	(a4)+,d0		; load tempo value from tracker
00010438 D138 C4B8                  		add.b	d0,mTempoMain.w		; add to the main tempo
0001043C 0838 0001 C4A6             		btst	#mfbSpeed,mFlags.w	; check if speed shoes mode is active
00010442 66E0                       		bne.s	locret_Tempo		; if not, add to current tempo too
00010444                            
00010444                            dcaTempoCur:
00010444 D138 C4BA                  		add.b	d0,mTempo.w		; add to current tempo
00010448 4E75                       		rts
0001044A                            ; ===========================================================================
0001044A                            ; ---------------------------------------------------------------------------
0001044A                            ; Tracker command for enabling or disabling PSG4 noise mode
0001044A                            ; ---------------------------------------------------------------------------
0001044A                            
0001044A                            dcNoisePSG:
0001044A 1B54 001B                  		move.b	(a4),cStatPSG4(a5)	; load PSG4 status command from tracker to channel
0001044E 6700                       		beq.s	.psg3			; if disabling PSG4 mode, branch
00010450 1B7C 00E0 0001             		move.b	#ctPSG4,cType(a5)	; make PSG3 act on behalf of PSG4
00010456 13DC 00C0 0011             		move.b	(a4)+,dPSG		; send command to PSG port
0001045C 4E75                       		rts
0001045E                            
0001045E                            .psg3
0001045E 1B7C 00C0 0001             		move.b	#ctPSG3,cType(a5)	; make PSG3 not act on behalf of PSG4
00010464 13FC 00FF 00C0 0011        		move.b	#ctPSG4|$1F,dPSG	; send PSG4 mute command to PSG
0001046C 524C                       		addq.w	#1,a4			; skip param
0001046E 4E75                       		rts
00010470                            ; ===========================================================================
00010470                            ; ---------------------------------------------------------------------------
00010470                            ; Tracker command for playing another music or SFX
00010470                            ; ---------------------------------------------------------------------------
00010470                            
00010470                            dcSound:
00010470 11DC C4BE                  		move.b	(a4)+,mQueue+2.w	; load sound ID from tracker to sound queue
00010474                            
00010474                            Return_dcSound:
00010474 4E75                       		rts
00010476                            ; ===========================================================================
00010476                            ; ---------------------------------------------------------------------------
00010476                            ; Tracker command for setting DAC filter bank
00010476                            ; ---------------------------------------------------------------------------
00010476                            
00010476                            dcFilter:
00010476 7000                       		moveq	#0,d0
00010478 101C                       		move.b	(a4)+,d0		; load filter bank number from tracker
0001047A 4EFA EF40                  		jmp	dSetFilter(pc)		; load filter bank instructions to Z80 RAM
0001047E                            ; ===========================================================================
0001047E                            ; ---------------------------------------------------------------------------
0001047E                            ; Tracker command for writing a YM command to YMCue
0001047E                            ; ---------------------------------------------------------------------------
0001047E                            
0001047E                            dcYM:
0001047E 101C                       		move.b	(a4)+,d0		; load YM address from tracker to d0
00010480 121C                       		move.b	(a4)+,d1		; get command value from tracker to d1
00010482 0815 0001                  		btst	#cfbInt,(a5)		; is this channel overridden by SFX?
00010486 66EC                       		bne.s	Return_dcSound		; if so, skip
00010488                            
00010488 0C00 0030                  		cmp.b	#$30,d0			; is this register 00-2F?
0001048C 6500 F408                  		blo.w	WriteYM_Pt1		; if so, write to part 1 always
00010490                            
00010490 1400                       		move.b	d0,d2			; copy address to d2
00010492 0402 00A8                  		sub.b	#$A8,d2			; align $A8 with 0
00010496 0C02 0008                  		cmp.b	#$08,d2			; is this egister A8-AF?
0001049A 6500 F3FA                  		blo.w	WriteYM_Pt1		; if so, write to part 1 always
0001049E 4EFA F3EA                  		jmp	WriteChYM(pc)		; write to YM according to channel
000104A2                            ; ===========================================================================
000104A2                            ; ---------------------------------------------------------------------------
000104A2                            ; Tracker command for setting channel base frequency
000104A2                            ; ---------------------------------------------------------------------------
000104A2                            
000104A2                            dcsFreq:
000104A2 1B5C 000E                  		move.b	(a4)+,cFreq(a5)		; load base frequency from tracker to channel
000104A6 1B5C 000F                  		move.b	(a4)+,cFreq+1(a5)	; ''
000104AA                            
000104AA 082D 0003 0001             		btst	#ctbDAC,cType(a5)	; check if this is a DAC channel
000104B0 6600                       		bne.s	.rts			; if so, brÃ¡nch
000104B2                            		AMPS_Debug_dcInvalid		; this command should be only used with DAC channels
000104B2                          M 	raiseerror	"Invalid command detected!",amps_debug_console_channel
000104B2 487A FFFE                M 	pea	*(pc)
000104B6                          M 	raiseerror2	"Invalid command detected!",amps_debug_console_channel
000104B6 40E7                     M 	move.w	sr,-(sp)
000104B8                          M 	__fstring_generateargumentscode	"Invalid command detected!"
000104B8 =00000000                M 	__pos:	set instr("Invalid command detected!",'%<')
000104B8 =00000000                M 	__stack:set	0
000104B8 =00000000                M 	__sp:	set 0
000104B8                          M 	while	(__pos)
000104B8                          M 	rept	__stack
000104B8 4EB9 0000 0000           M 	jsr	errorhandler
000104BE                          M 	__fstring_generatedecodedstring	"Invalid command detected!"
000104BE =00000001                M 	__lpos:	set 1
000104BE =00000000                M 	__pos:	set instr("Invalid command detected!",'%<')
000104BE                          M 	while	(__pos)
000104BE                          M 	__substr:	substr __lpos,,"Invalid command detected!"
000104BE 496E 7661 6C69 6420 636F+M 	dc.b	"Invalid command detected!"
000104D7 00                       M 	dc.b	0
000104D8 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
000104DA 00                       M 	even
000104DA 4EFA CDA0                M 	jmp	amps_debug_console_channel
000104DE                          M 	even
000104DE                            .rts
000104DE 4E75                       		rts
000104E0                            ; ===========================================================================
000104E0                            ; ---------------------------------------------------------------------------
000104E0                            ; Tracker command for setting channel base frequency from the note table
000104E0                            ; ---------------------------------------------------------------------------
000104E0                            
000104E0                            dcsFreqNote:
000104E0 7000                       		moveq	#0,d0
000104E2 101C                       		move.b	(a4)+,d0		; load note from tracker to d0
000104E4 D02D 0008                  		add.b	cPitch(a5),d0		; add pitch offset to note
000104E8 D040                       		add.w	d0,d0			; double offset (each entry is a word)
000104EA                            
000104EA 43FA F522                  		lea	dFreqDAC(pc),a1		; load DAC frequency table to a1
000104EE 3B71 0000 000E             		move.w	(a1,d0.w),cFreq(a5)	; load and save the requested frequency
000104F4                            
000104F4 082D 0003 0001             		btst	#ctbDAC,cType(a5)	; check if this is a DAC channel
000104FA 6600                       		bne.s	.rts			; if so, brÃ¡nch
000104FC                            		AMPS_Debug_dcInvalid		; this command should be only used with DAC channels
000104FC                          M 	raiseerror	"Invalid command detected!",amps_debug_console_channel
000104FC 487A FFFE                M 	pea	*(pc)
00010500                          M 	raiseerror2	"Invalid command detected!",amps_debug_console_channel
00010500 40E7                     M 	move.w	sr,-(sp)
00010502                          M 	__fstring_generateargumentscode	"Invalid command detected!"
00010502 =00000000                M 	__pos:	set instr("Invalid command detected!",'%<')
00010502 =00000000                M 	__stack:set	0
00010502 =00000000                M 	__sp:	set 0
00010502                          M 	while	(__pos)
00010502                          M 	rept	__stack
00010502 4EB9 0000 0000           M 	jsr	errorhandler
00010508                          M 	__fstring_generatedecodedstring	"Invalid command detected!"
00010508 =00000001                M 	__lpos:	set 1
00010508 =00000000                M 	__pos:	set instr("Invalid command detected!",'%<')
00010508                          M 	while	(__pos)
00010508                          M 	__substr:	substr __lpos,,"Invalid command detected!"
00010508 496E 7661 6C69 6420 636F+M 	dc.b	"Invalid command detected!"
00010521 00                       M 	dc.b	0
00010522 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
00010524 00                       M 	even
00010524 4EFA CD56                M 	jmp	amps_debug_console_channel
00010528                          M 	even
00010528                            .rts
00010528 4E75                       		rts
0001052A                            ; ===========================================================================
0001052A                            ; ---------------------------------------------------------------------------
0001052A                            ; Tracker command for doing a continous SFX loop
0001052A                            ; ---------------------------------------------------------------------------
0001052A                            
0001052A                            dcCont:
0001052A 5338 C4C2                  		subq.b	#1,mContCtr.w		; decrease continous sfx counter
0001052E 6A00                       		bpl.s	dcJump			; if positive, jump to routine
00010530 4238 C4C3                  		clr.b	mContLast.w		; clear continous SFX ID
00010534 544C                       		addq.w	#2,a4			; skip over jump offset
00010536 4E75                       		rts
00010538                            ; ===========================================================================
00010538                            ; ---------------------------------------------------------------------------
00010538                            ; Tracker command for calling a tracker subroutine
00010538                            ; ---------------------------------------------------------------------------
00010538                            
00010538                            dcCall:
00010538                            		AMPS_Debug_dcCall1		; check if this channel supports the stack
00010538 BAFC C67C                M 	cmp.w	#msfxdac1,a5
0001053C 6500                     M 	blo.s	.ok1
0001053E                          M 	raiseerror	"sCall on a SFX channel!",amps_debug_console_channel
0001053E 487A FFFE                M 	pea	*(pc)
00010542                          M 	raiseerror2	"sCall on a SFX channel!",amps_debug_console_channel
00010542 40E7                     M 	move.w	sr,-(sp)
00010544                          M 	__fstring_generateargumentscode	"sCall on a SFX channel!"
00010544 =00000000                M 	__pos:	set instr("sCall on a SFX channel!",'%<')
00010544 =00000000                M 	__stack:set	0
00010544 =00000000                M 	__sp:	set 0
00010544                          M 	while	(__pos)
00010544                          M 	rept	__stack
00010544 4EB9 0000 0000           M 	jsr	errorhandler
0001054A                          M 	__fstring_generatedecodedstring	"sCall on a SFX channel!"
0001054A =00000001                M 	__lpos:	set 1
0001054A =00000000                M 	__pos:	set instr("sCall on a SFX channel!",'%<')
0001054A                          M 	while	(__pos)
0001054A                          M 	__substr:	substr __lpos,,"sCall on a SFX channel!"
0001054A 7343 616C 6C20 6F6E 2061+M 	dc.b	"sCall on a SFX channel!"
00010561 00                       M 	dc.b	0
00010562 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
00010564 00                       M 	even
00010564 4EFA CD16                M 	jmp	amps_debug_console_channel
00010568                          M 	even
00010568                          M .ok1
00010568                            
00010568 7000                       		moveq	#0,d0
0001056A 102D 001E                  		move.b	cStack(a5),d0		; get channel stack pointer
0001056E 5900                       		subq.b	#4,d0			; allocate space for another routine
00010570                            
00010570                            		AMPS_Debug_dcCall2		; check if we overflowed the space
00010570 0C00 001C                M 	cmp.b	#cnotetimecur,d0
00010574 6200                     M 	bhi.s	.ok2
00010576                          M 	raiseerror	"sCall stack too deep!",amps_debug_console_channel
00010576 487A FFFE                M 	pea	*(pc)
0001057A                          M 	raiseerror2	"sCall stack too deep!",amps_debug_console_channel
0001057A 40E7                     M 	move.w	sr,-(sp)
0001057C                          M 	__fstring_generateargumentscode	"sCall stack too deep!"
0001057C =00000000                M 	__pos:	set instr("sCall stack too deep!",'%<')
0001057C =00000000                M 	__stack:set	0
0001057C =00000000                M 	__sp:	set 0
0001057C                          M 	while	(__pos)
0001057C                          M 	rept	__stack
0001057C 4EB9 0000 0000           M 	jsr	errorhandler
00010582                          M 	__fstring_generatedecodedstring	"sCall stack too deep!"
00010582 =00000001                M 	__lpos:	set 1
00010582 =00000000                M 	__pos:	set instr("sCall stack too deep!",'%<')
00010582                          M 	while	(__pos)
00010582                          M 	__substr:	substr __lpos,,"sCall stack too deep!"
00010582 7343 616C 6C20 7374 6163+M 	dc.b	"sCall stack too deep!"
00010597 00                       M 	dc.b	0
00010598 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0001059A 00                       M 	even
0001059A 4EFA CCE0                M 	jmp	amps_debug_console_channel
0001059E                          M 	even
0001059E                          M .ok2
0001059E 2B8C 0000                  		move.l	a4,(a5,d0.w)		; save current address in stack
000105A2 1B40 001E                  		move.b	d0,cStack(a5)		; save stack pointer
000105A6                            ; ===========================================================================
000105A6                            ; ---------------------------------------------------------------------------
000105A6                            ; Tracker command for jumping to another tracker location
000105A6                            ; ---------------------------------------------------------------------------
000105A6                            
000105A6                            dcJump:
000105A6                            	dREAD_WORD a4, d0			; read a word from tracker to d0
000105A6 1E9C                     M 	move.b	(a4)+,(sp)
000105A8 3017                     M 	move.w	(sp),d0
000105AA 1014                     M 	move.b	(a4),d0
000105AC D8C0                       		adda.w	d0,a4			; offset tracker address by d0
000105AE 4E75                       		rts
000105B0                            ; ===========================================================================
000105B0                            ; ---------------------------------------------------------------------------
000105B0                            ; Tracker command for handling loops
000105B0                            ; ---------------------------------------------------------------------------
000105B0                            
000105B0                            dcLoop:
000105B0 7000                       		moveq	#0,d0
000105B2 101C                       		move.b	(a4)+,d0		; load loop index from tracker to d0
000105B4                            		AMPS_Debug_dcLoop		; check if loop index is valid
000105B4 0C00 0003                M 	cmp.b	#3,d0
000105B8 6200                     M 	bhi.s	.fail
000105BA BAFC C67C                M 	cmp.w	#msfxdac1,a5
000105BE 6500                     M 	blo.s	.nosfx
000105C0 0C00 0001                M 	cmp.b	#1,d0
000105C4 6700                     M 	beq.s	.fail
000105C6                          M .nosfx
000105C6 0C2D 00C0 0001           M 	cmp.b	#$c0,ctype(a5)
000105CC 6500                     M 	blo.s	amps_debug_dcloop_ok
000105CE 0C00 0002                M 	cmp.b	#2,d0
000105D2 6600                     M 	bne.s	amps_debug_dcloop_ok
000105D4                          M .fail
000105D4                          M 	raiseerror	"sLoop ID is invalid!",amps_debug_console_channel
000105D4 487A FFFE                M 	pea	*(pc)
000105D8                          M 	raiseerror2	"sLoop ID is invalid!",amps_debug_console_channel
000105D8 40E7                     M 	move.w	sr,-(sp)
000105DA                          M 	__fstring_generateargumentscode	"sLoop ID is invalid!"
000105DA =00000000                M 	__pos:	set instr("sLoop ID is invalid!",'%<')
000105DA =00000000                M 	__stack:set	0
000105DA =00000000                M 	__sp:	set 0
000105DA                          M 	while	(__pos)
000105DA                          M 	rept	__stack
000105DA 4EB9 0000 0000           M 	jsr	errorhandler
000105E0                          M 	__fstring_generatedecodedstring	"sLoop ID is invalid!"
000105E0 =00000001                M 	__lpos:	set 1
000105E0 =00000000                M 	__pos:	set instr("sLoop ID is invalid!",'%<')
000105E0                          M 	while	(__pos)
000105E0                          M 	__substr:	substr __lpos,,"sLoop ID is invalid!"
000105E0 734C 6F6F 7020 4944 2069+M 	dc.b	"sLoop ID is invalid!"
000105F4 00                       M 	dc.b	0
000105F5 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
000105F6                          M 	even
000105F6 4EFA CC84                M 	jmp	amps_debug_console_channel
000105FA                          M 	even
000105FA                          M amps_debug_dcloop_ok
000105FA                            
000105FA 4A35 0019                  		tst.b	cLoop(a5,d0.w)		; check the loop counter
000105FE 6600                       		bne.s	.loopok			; if nonzero, branch
00010600 1BAC 0002 0019             		move.b	2(a4),cLoop(a5,d0.w)	; reload loop counter
00010606                            
00010606                            .loopok
00010606 5335 0019                  		subq.b	#1,cLoop(a5,d0.w)	; decrease loop counter
0001060A 669A                       		bne.s	dcJump			; if not 0, jump to routine
0001060C 564C                       		addq.w	#3,a4			; skip over jump offset
0001060E 4E75                       		rts
00010610                            ; ===========================================================================
00010610                            ; ---------------------------------------------------------------------------
00010610                            ; Tracker command for initializing modulation
00010610                            ; ---------------------------------------------------------------------------
00010610                            
00010610                            dcMod68K:
00010610 2B4C 0010                  		move.l	a4,cMod(a5)		; set modulation data address
00010614 1B5C 0010                  		move.b	(a4)+,cModDelay(a5)	; load modulation delay from tracker to channel
00010618 1B5C 0016                  		move.b	(a4)+,cModSpeed(a5)	; load modulation speed from tracker to channel
0001061C 1B5C 0017                  		move.b	(a4)+,cModStep(a5)	; load modulation step offset from tracker to channel
00010620                            
00010620 101C                       		move.b	(a4)+,d0		; load modulation step count from tracker to d0
00010622 E208                       		lsr.b	#1,d0			; halve it
00010624 1B40 0018                  		move.b	d0,cModCount(a5)	; save as modulation step count to channel
00010628 426D 0014                  		clr.w	cModFreq(a5)		; reset modulation frequency offset to 0
0001062C                            	; continue to enabling modulation
0001062C                            ; ===========================================================================
0001062C                            ; ---------------------------------------------------------------------------
0001062C                            ; Tracker commands for enabling and disabling modulation
0001062C                            ; ---------------------------------------------------------------------------
0001062C                            
0001062C                            dcModOn:
0001062C 08D5 0003                  		bset	#cfbMod,(a5)		; enable modulation
00010630 4E75                       		rts
00010632                            
00010632                            dcModOff:
00010632 0895 0003                  		bclr	#cfbMod,(a5)		; disable modulation
00010636 4E75                       		rts
00010638                            ; ===========================================================================
00010638                            ; ---------------------------------------------------------------------------
00010638                            ; Tracker command for returning from tracker subroutine
00010638                            ; ---------------------------------------------------------------------------
00010638                            
00010638                            dcReturn:
00010638                            		AMPS_Debug_dcReturn1		; check if this channel supports the stack
00010638 BAFC C67C                M 	cmp.w	#msfxdac1,a5
0001063C 6500                     M 	blo.s	.ok1
0001063E                          M 	raiseerror	"sRet on a SFX channel!",amps_debug_console_channel
0001063E 487A FFFE                M 	pea	*(pc)
00010642                          M 	raiseerror2	"sRet on a SFX channel!",amps_debug_console_channel
00010642 40E7                     M 	move.w	sr,-(sp)
00010644                          M 	__fstring_generateargumentscode	"sRet on a SFX channel!"
00010644 =00000000                M 	__pos:	set instr("sRet on a SFX channel!",'%<')
00010644 =00000000                M 	__stack:set	0
00010644 =00000000                M 	__sp:	set 0
00010644                          M 	while	(__pos)
00010644                          M 	rept	__stack
00010644 4EB9 0000 0000           M 	jsr	errorhandler
0001064A                          M 	__fstring_generatedecodedstring	"sRet on a SFX channel!"
0001064A =00000001                M 	__lpos:	set 1
0001064A =00000000                M 	__pos:	set instr("sRet on a SFX channel!",'%<')
0001064A                          M 	while	(__pos)
0001064A                          M 	__substr:	substr __lpos,,"sRet on a SFX channel!"
0001064A 7352 6574 206F 6E20 6120+M 	dc.b	"sRet on a SFX channel!"
00010660 00                       M 	dc.b	0
00010661 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
00010662                          M 	even
00010662 4EFA CC18                M 	jmp	amps_debug_console_channel
00010666                          M 	even
00010666                          M .ok1
00010666 7000                       		moveq	#0,d0
00010668 102D 001E                  		move.b	cStack(a5),d0		; get channel stack pointer
0001066C 2875 0000                  		movea.l	(a5,d0.w),a4		; load the address to return to
00010670                            
00010670 544C                       		addq.w	#2,a4			; skip the call address parameter
00010672 5800                       		addq.b	#4,d0			; deallocate stack space
00010674 1B40 001E                  		move.b	d0,cStack(a5)		; save stack pointer
00010678                            
00010678                            		AMPS_Debug_dcReturn2		; check if we underflowed the space
00010678 0C00 002C                M 	cmp.b	#csize,d0
0001067C 6300                     M 	bls.s	.ok2
0001067E                          M 	raiseerror	"sRet stack too shallow!",amps_debug_console_channel
0001067E 487A FFFE                M 	pea	*(pc)
00010682                          M 	raiseerror2	"sRet stack too shallow!",amps_debug_console_channel
00010682 40E7                     M 	move.w	sr,-(sp)
00010684                          M 	__fstring_generateargumentscode	"sRet stack too shallow!"
00010684 =00000000                M 	__pos:	set instr("sRet stack too shallow!",'%<')
00010684 =00000000                M 	__stack:set	0
00010684 =00000000                M 	__sp:	set 0
00010684                          M 	while	(__pos)
00010684                          M 	rept	__stack
00010684 4EB9 0000 0000           M 	jsr	errorhandler
0001068A                          M 	__fstring_generatedecodedstring	"sRet stack too shallow!"
0001068A =00000001                M 	__lpos:	set 1
0001068A =00000000                M 	__pos:	set instr("sRet stack too shallow!",'%<')
0001068A                          M 	while	(__pos)
0001068A                          M 	__substr:	substr __lpos,,"sRet stack too shallow!"
0001068A 7352 6574 2073 7461 636B+M 	dc.b	"sRet stack too shallow!"
000106A1 00                       M 	dc.b	0
000106A2 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
000106A4 00                       M 	even
000106A4 4EFA CBD6                M 	jmp	amps_debug_console_channel
000106A8                          M 	even
000106A8                          M .ok2
000106A8 4E75                       		rts
000106AA                            ; ===========================================================================
000106AA                            ; ---------------------------------------------------------------------------
000106AA                            ; Tracker command for initializing special FM3 mode
000106AA                            ; ---------------------------------------------------------------------------
000106AA                            
000106AA                            dcSpecFM3:
000106AA                            		AMPS_Debug_dcInvalid		; this is an invalid command
000106AA                          M 	raiseerror	"Invalid command detected!",amps_debug_console_channel
000106AA 487A FFFE                M 	pea	*(pc)
000106AE                          M 	raiseerror2	"Invalid command detected!",amps_debug_console_channel
000106AE 40E7                     M 	move.w	sr,-(sp)
000106B0                          M 	__fstring_generateargumentscode	"Invalid command detected!"
000106B0 =00000000                M 	__pos:	set instr("Invalid command detected!",'%<')
000106B0 =00000000                M 	__stack:set	0
000106B0 =00000000                M 	__sp:	set 0
000106B0                          M 	while	(__pos)
000106B0                          M 	rept	__stack
000106B0 4EB9 0000 0000           M 	jsr	errorhandler
000106B6                          M 	__fstring_generatedecodedstring	"Invalid command detected!"
000106B6 =00000001                M 	__lpos:	set 1
000106B6 =00000000                M 	__pos:	set instr("Invalid command detected!",'%<')
000106B6                          M 	while	(__pos)
000106B6                          M 	__substr:	substr __lpos,,"Invalid command detected!"
000106B6 496E 7661 6C69 6420 636F+M 	dc.b	"Invalid command detected!"
000106CF 00                       M 	dc.b	0
000106D0 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
000106D2 00                       M 	even
000106D2 4EFA CBA8                M 	jmp	amps_debug_console_channel
000106D6                          M 	even
000106D6 4E75                       		rts
000106D8                            ; ===========================================================================
000106D8                            ; ---------------------------------------------------------------------------
000106D8                            ; Tracker command for enabling raw frequency mode
000106D8                            ; ---------------------------------------------------------------------------
000106D8                            
000106D8                            dcFreqOn:
000106D8                            		AMPS_Debug_dcInvalid		; this is an invalid command
000106D8                          M 	raiseerror	"Invalid command detected!",amps_debug_console_channel
000106D8 487A FFFE                M 	pea	*(pc)
000106DC                          M 	raiseerror2	"Invalid command detected!",amps_debug_console_channel
000106DC 40E7                     M 	move.w	sr,-(sp)
000106DE                          M 	__fstring_generateargumentscode	"Invalid command detected!"
000106DE =00000000                M 	__pos:	set instr("Invalid command detected!",'%<')
000106DE =00000000                M 	__stack:set	0
000106DE =00000000                M 	__sp:	set 0
000106DE                          M 	while	(__pos)
000106DE                          M 	rept	__stack
000106DE 4EB9 0000 0000           M 	jsr	errorhandler
000106E4                          M 	__fstring_generatedecodedstring	"Invalid command detected!"
000106E4 =00000001                M 	__lpos:	set 1
000106E4 =00000000                M 	__pos:	set instr("Invalid command detected!",'%<')
000106E4                          M 	while	(__pos)
000106E4                          M 	__substr:	substr __lpos,,"Invalid command detected!"
000106E4 496E 7661 6C69 6420 636F+M 	dc.b	"Invalid command detected!"
000106FD 00                       M 	dc.b	0
000106FE 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
00010700 00                       M 	even
00010700 4EFA CB7A                M 	jmp	amps_debug_console_channel
00010704                          M 	even
00010704 4E75                       		rts
00010706                            ; ===========================================================================
00010706                            ; ---------------------------------------------------------------------------
00010706                            ; Tracker command for disabling raw frequency mode
00010706                            ; ---------------------------------------------------------------------------
00010706                            
00010706                            dcFreqOff:
00010706                            		AMPS_Debug_dcInvalid		; this is an invalid command
00010706                          M 	raiseerror	"Invalid command detected!",amps_debug_console_channel
00010706 487A FFFE                M 	pea	*(pc)
0001070A                          M 	raiseerror2	"Invalid command detected!",amps_debug_console_channel
0001070A 40E7                     M 	move.w	sr,-(sp)
0001070C                          M 	__fstring_generateargumentscode	"Invalid command detected!"
0001070C =00000000                M 	__pos:	set instr("Invalid command detected!",'%<')
0001070C =00000000                M 	__stack:set	0
0001070C =00000000                M 	__sp:	set 0
0001070C                          M 	while	(__pos)
0001070C                          M 	rept	__stack
0001070C 4EB9 0000 0000           M 	jsr	errorhandler
00010712                          M 	__fstring_generatedecodedstring	"Invalid command detected!"
00010712 =00000001                M 	__lpos:	set 1
00010712 =00000000                M 	__pos:	set instr("Invalid command detected!",'%<')
00010712                          M 	while	(__pos)
00010712                          M 	__substr:	substr __lpos,,"Invalid command detected!"
00010712 496E 7661 6C69 6420 636F+M 	dc.b	"Invalid command detected!"
0001072B 00                       M 	dc.b	0
0001072C 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
0001072E 00                       M 	even
0001072E 4EFA CB4C                M 	jmp	amps_debug_console_channel
00010732                          M 	even
00010732                            
00010732                            locret_FreqOff:
00010732 4E75                       		rts
00010734                            ; ===========================================================================
00010734                            ; ---------------------------------------------------------------------------
00010734                            ; Tracker command for changing voice, volume envelope or sample
00010734                            ; ---------------------------------------------------------------------------
00010734                            
00010734                            dcVoice:
00010734 7000                       		moveq	#0,d0
00010736 101C                       		move.b	(a4)+,d0		; load voice/sample/volume envelope from tracker to d0
00010738 1B40 000B                  		move.b	d0,cVoice(a5)		; save to channel
0001073C                            
0001073C 4A2D 0001                  		tst.b	cType(a5)		; check if this is a PSG channel
00010740 6BF0                       		bmi.s	locret_FreqOff		; if is, skip
00010742 082D 0003 0001             		btst	#ctbDAC,cType(a5)	; check if this is a DAC channel
00010748 66E8                       		bne.s	locret_FreqOff		; if is, skip
0001074A                            
0001074A 0815 0001                  		btst	#cfbInt,(a5)		; check if channel is interrupted by SFX
0001074E 66E2                       		bne.s	locret_FreqOff		; if is, skip
00010750 224E                       		move.l	a6,a1			; load voice table to a1
00010752                            	; continue to send FM voice
00010752                            ; ===========================================================================
00010752                            ; ---------------------------------------------------------------------------
00010752                            ; Subroutine for sending the FM voice to YM2612
00010752                            ; This routine is speed optimized in a way that allows Dual PCM
00010752                            ; to only be stopped for as long as it must be. This will waste
00010752                            ; some cycles for 68000, but it will help improve DAC quality.
00010752                            ; ---------------------------------------------------------------------------
00010752                            
00010752                            dUpdateVoiceFM:
00010752                            	dCALC_VOICE				; get address of the specific voice to a1
00010752 EB48                     M 	lsl.w	#5,d0
00010754 D2C0                     M 	add.w	d0,a1
00010756 9EFC 003C                  		sub.w	#(VoiceRegs+1)*2,sp	; prepapre space in the stack
0001075A 264F                       		move.l	sp,a3			; copy pointer to the free space to a3
0001075C                            
0001075C 1819                       		move.b	(a1)+,d4		; load feedback and algorithm to d4
0001075E 16C4                       		move.b	d4,(a3)+		; save it to free space
00010760 16FC 00B0                  		move.b	#$B0,(a3)+		; YM command: Algorithm & FeedBack
00010764                            
00010764 45FA ED86                  		lea	dOpListYM(pc),a2	; load YM2612 operator list into a2
00010768                            	rept VoiceRegs-5
00010768                            		move.b	(a1)+,(a3)+		; copy each value (except Total Level)
00010768                            		move.b	(a2)+,(a3)+		; copy each command
00010768                            	endr
00010768 16D9                     M 	move.b	(a1)+,(a3)+
0001076A 16DA                     M 	move.b	(a2)+,(a3)+
0001076C 16D9                     M 	move.b	(a1)+,(a3)+
0001076E 16DA                     M 	move.b	(a2)+,(a3)+
00010770 16D9                     M 	move.b	(a1)+,(a3)+
00010772 16DA                     M 	move.b	(a2)+,(a3)+
00010774 16D9                     M 	move.b	(a1)+,(a3)+
00010776 16DA                     M 	move.b	(a2)+,(a3)+
00010778 16D9                     M 	move.b	(a1)+,(a3)+
0001077A 16DA                     M 	move.b	(a2)+,(a3)+
0001077C 16D9                     M 	move.b	(a1)+,(a3)+
0001077E 16DA                     M 	move.b	(a2)+,(a3)+
00010780 16D9                     M 	move.b	(a1)+,(a3)+
00010782 16DA                     M 	move.b	(a2)+,(a3)+
00010784 16D9                     M 	move.b	(a1)+,(a3)+
00010786 16DA                     M 	move.b	(a2)+,(a3)+
00010788 16D9                     M 	move.b	(a1)+,(a3)+
0001078A 16DA                     M 	move.b	(a2)+,(a3)+
0001078C 16D9                     M 	move.b	(a1)+,(a3)+
0001078E 16DA                     M 	move.b	(a2)+,(a3)+
00010790 16D9                     M 	move.b	(a1)+,(a3)+
00010792 16DA                     M 	move.b	(a2)+,(a3)+
00010794 16D9                     M 	move.b	(a1)+,(a3)+
00010796 16DA                     M 	move.b	(a2)+,(a3)+
00010798 16D9                     M 	move.b	(a1)+,(a3)+
0001079A 16DA                     M 	move.b	(a2)+,(a3)+
0001079C 16D9                     M 	move.b	(a1)+,(a3)+
0001079E 16DA                     M 	move.b	(a2)+,(a3)+
000107A0 16D9                     M 	move.b	(a1)+,(a3)+
000107A2 16DA                     M 	move.b	(a2)+,(a3)+
000107A4 16D9                     M 	move.b	(a1)+,(a3)+
000107A6 16DA                     M 	move.b	(a2)+,(a3)+
000107A8 16D9                     M 	move.b	(a1)+,(a3)+
000107AA 16DA                     M 	move.b	(a2)+,(a3)+
000107AC 16D9                     M 	move.b	(a1)+,(a3)+
000107AE 16DA                     M 	move.b	(a2)+,(a3)+
000107B0 16D9                     M 	move.b	(a1)+,(a3)+
000107B2 16DA                     M 	move.b	(a2)+,(a3)+
000107B4 16D9                     M 	move.b	(a1)+,(a3)+
000107B6 16DA                     M 	move.b	(a2)+,(a3)+
000107B8 16D9                     M 	move.b	(a1)+,(a3)+
000107BA 16DA                     M 	move.b	(a2)+,(a3)+
000107BC 16D9                     M 	move.b	(a1)+,(a3)+
000107BE 16DA                     M 	move.b	(a2)+,(a3)+
000107C0 16D9                     M 	move.b	(a1)+,(a3)+
000107C2 16DA                     M 	move.b	(a2)+,(a3)+
000107C4 16D9                     M 	move.b	(a1)+,(a3)+
000107C6 16DA                     M 	move.b	(a2)+,(a3)+
000107C8                            
000107C8 7C00                       		moveq	#0,d6			; reset the modulator offset
000107CA 162D 0009                  		move.b	cVolume(a5),d3		; load FM channel volume to d3
000107CE D638 C4B4                  		add.b	mMasterVolFM.w,d3	; add master FM volume to d3
000107D2 6A00                       		bpl.s	.noover			; if volume did not overflow, skio
000107D4 767F                       		moveq	#$7F,d3			; force FM volume to silence
000107D6                            
000107D6                            .noover
000107D6 0838 0002 C4A6             		btst	#mfbWater,mFlags.w	; check if underwater mode is enabled
000107DC 6700                       		beq.s	.uwdone			; if not, skip
000107DE 1C04                       		move.b	d4,d6			; copy algorithm and feedback to d6
000107E0 0246 0007                  		and.w	#7,d6			; mask out everything but the algorithm
000107E4 D606                       		add.b	d6,d3			; add algorithm to Total Level carrier offset
000107E6 1C04                       		move.b	d4,d6			; set algorithm and feedback to modulator offset
000107E8                            
000107E8                            .uwdone
000107E8 7A03                       		moveq	#4-1,d5			; prepare 4 operators to d5
000107EA                            
000107EA                            .tlloop
000107EA 1219                       		move.b	(a1)+,d1		; get Total Level value from voice to d1
000107EC 6A00                       		bpl.s	.noslot			; if slot operator bit was not set, branch
000107EE                            
000107EE D203                       		add.b	d3,d1			; add carrier offset to loaded value
000107F0 6B00                       		bmi.s	.slot			; if we did not overflow, branch
000107F2 727F                       		moveq	#$7F,d1			; cap to silent volume
000107F4 6000                       		bra.s	.slot
000107F6                            
000107F6                            .noslot
000107F6 D206                       		add.b	d6,d1			; add modulator offset to loaded value
000107F8                            .slot
000107F8 16C1                       		move.b	d1,(a3)+		; save the Total Level value
000107FA 16DA                       		move.b	(a2)+,(a3)+		; copy total level command
000107FC 51CD FFEC                  		dbf	d5,.tlloop		; repeat for each Total Level operator
00010800                            
00010800                            		AMPS_Debug_UpdVoiceFM		; check if the voice was valid
00010800 0C19 004E                M 	cmp.b	#'N',(a1)+
00010804 6600                     M 	bne.s	.fail
00010806 0C59 4154                M 	cmp.w	#'AT',(a1)+
0001080A 6700                     M 	beq.s	.ok
0001080C                          M .fail
0001080C                          M 	raiseerror	"FM voice Update invalid voice: %<.b cVoice(a5)>",amps_debug_console_channel
0001080C 487A FFFE                M 	pea	*(pc)
00010810                          M 	raiseerror2	"FM voice Update invalid voice: %<.b cVoice(a5)>",amps_debug_console_channel
00010810 40E7                     M 	move.w	sr,-(sp)
00010812                          M 	__fstring_generateargumentscode	"FM voice Update invalid voice: %<.b cVoice(a5)>"
00010812 =00000020                M 	__pos:	set instr("FM voice Update invalid voice: %<.b cVoice(a5)>",'%<')
00010812 =00000000                M 	__stack:set	0
00010812 =00000000                M 	__sp:	set 0
00010812                          M 	while	(__pos)
00010812 =0000002F                M 	__endpos:	set instr(__pos+1,"FM voice Update invalid voice: %<.b cVoice(a5)>",'>')
00010812 =00000000                M 	__midpos:	set instr(__pos+5,"FM voice Update invalid voice: %<.b cVoice(a5)>",' ')
00010812 =0000002F                M 	__midpos:	= __endpos
00010812                          M 	__substr:	substr __pos+1+1,__endpos-1,"FM voice Update invalid voice: %<.b cVoice(a5)>"
00010812                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"FM voice Update invalid voice: %<.b cVoice(a5)>"
00010812                          M 	__operand:	substr __pos+1+1,__midpos-1,"FM voice Update invalid voice: %<.b cVoice(a5)>"
00010812                          M 	__param:	substr __midpos+1,__endpos-1,"FM voice Update invalid voice: %<.b cVoice(a5)>"
00010812                          M 	pushp	"move.b cVoice(a5),1(sp)"
00010812                          M 	pushp	"subq.w	#2, sp"
00010812 =00000002                M 	__stack:	= __stack+2
00010812 =00000002                M 	__sp:	= __sp+2
00010812 =00000000                M 	__pos:	set instr(__pos+1,"FM voice Update invalid voice: %<.b cVoice(a5)>",'%<')
00010812                          M 	rept	__stack
00010812                          M 	popp	__command
00010812 554F                     M 	subq.w	#2,sp
00010814                          M 	popp	__command
00010814 1F6D 000B 0001           M 	move.b	cvoice(a5),1(sp)
0001081A 4EB9 0000 0000           M 	jsr	errorhandler
00010820                          M 	__fstring_generatedecodedstring	"FM voice Update invalid voice: %<.b cVoice(a5)>"
00010820 =00000001                M 	__lpos:	set 1
00010820 =00000020                M 	__pos:	set instr("FM voice Update invalid voice: %<.b cVoice(a5)>",'%<')
00010820                          M 	while	(__pos)
00010820                          M 	__substr:	substr __lpos,__pos-1,"FM voice Update invalid voice: %<.b cVoice(a5)>"
00010820 464D 2076 6F69 6365 2055+M 	dc.b	"FM voice Update invalid voice: "
0001083F =0000002F                M 	__endpos:	set instr(__pos+1,"FM voice Update invalid voice: %<.b cVoice(a5)>",'>')
0001083F =00000000                M 	__midpos:	set instr(__pos+5,"FM voice Update invalid voice: %<.b cVoice(a5)>",' ')
0001083F =0000002F                M 	__midpos:	= __endpos
0001083F                          M 	__type:	substr __pos+1+1,__pos+1+1+1,"FM voice Update invalid voice: %<.b cVoice(a5)>"
0001083F                          M 	__param:	substr __midpos+1,__endpos-1,"FM voice Update invalid voice: %<.b cVoice(a5)>"
0001083F                          M 	__param:	substr ,,"hex"
0001083F 80                       M 	dc.b	hex
00010840 =00000030                M 	__lpos:	set __endpos+1
00010840 =00000000                M 	__pos:	set instr(__pos+1,"FM voice Update invalid voice: %<.b cVoice(a5)>",'%<')
00010840                          M 	__substr:	substr __lpos,,"FM voice Update invalid voice: %<.b cVoice(a5)>"
00010840                          M 	dc.b	""
00010840 00                       M 	dc.b	0
00010841 00                       M 	dc.b	+_eh_enter_console|(((*&1)^1)*_eh_align_offset)
00010842                          M 	even
00010842 4EFA CA38                M 	jmp	amps_debug_console_channel
00010846                          M 	even
00010846                          M .ok
00010846                            
00010846 0895 0005                  		bclr	#cfbVol,(a5)		; reset volume update request flag
0001084A 16ED 0006                  		move.b	cPanning(a5),(a3)+	; copy panning value to free space
0001084E 16FC 00B4                  		move.b	#$B4,(a3)+		; YM command: Panning & LFO
00010852                            
00010852 7400                       		moveq	#0,d2			; prepare part 1 value
00010854 162D 0001                  		move.b	cType(a5),d3		; load FM channel type to d3
00010858 0803 0002                  		btst	#ctbPt2,d3		; check if its part 1
0001085C 6700                       		beq.s	.ptok			; if so, branch
0001085E 0203 0003                  		and.b	#3,d3			; get channel offset only
00010862 7402                       		moveq	#2,d2			; prepare part 2 value
00010864                            
00010864                            .ptok
00010864 264F                       		move.l	sp,a3			; copy free space pointer to a3 again
00010866 721D                       		moveq	#VoiceRegs,d1		; prepare loop point
00010868                            		AMPS_Debug_CuePtr 0		; make sure cue is valid
00010868 B1FC 0000 0000           M 	cmp.l	#$a00000+ym_buffer1,a0
0001086E 6500                     M 	blo.s	.fail_752
00010870 B1FC 0000 0000           M 	cmp.l	#$a00000+ym_buffer2+$400,a0
00010876 6500                     M 	blo.s	.ok_752
00010878                          M .fail_752
00010878 4EBA D782                M 	jsr	amps_debug_cueptr0
0001087C                          M .ok_752
0001087C                            	StopZ80					; wait for Z80 to stop
0001087C 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
00010884                          M 	waitz80stop
00010884 0839 0000 00A1 1100      M .wait_754:	btst	#0,z80_bus_req
0001088C 66F6                     M 	bne.s	.wait_754
0001088E                            
0001088E                            .write
0001088E 10C2                       		move.b	d2,(a0)+		; select YM port to access (4000 or 4002)
00010890 10DB                       		move.b	(a3)+,(a0)+		; write command values
00010892                            
00010892 101B                       		move.b	(a3)+,d0		; load YM command
00010894 8003                       		or.b	d3,d0			; add the channel offset to command
00010896 10C0                       		move.b	d0,(a0)+		; save to Z80 cue
00010898 51C9 FFF4                  		dbf	d1,.write		; write all registers
0001089C 50D0                       		st	(a0)			; mark as end of the cue
0001089E                            
0001089E                            	StartZ80				; enable Z80 execution
0001089E 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
000108A6 DEFC 003C                  		add.w	#(VoiceRegs+1)*2,sp	; reset stack pointer
000108AA 4E75                       		rts
000108AC                            ; ===========================================================================
000108AC                            ; ---------------------------------------------------------------------------
000108AC                            ; Tracker command for stopping the current channel
000108AC                            ; ---------------------------------------------------------------------------
000108AC                            
000108AC                            dcStop:
000108AC 0215 007B                  		and.b	#$FF-(1<<cfbHold)-(1<<cfbRun),(a5); clear hold and running tracker flags
000108B0 4A2D 0001                  		tst.b	cType(a5)		; check if this was a PSG channel
000108B4 6B00                       		bmi.s	.mutePSG		; if yes, mute it
000108B6                            
000108B6 082D 0003 0001             		btst	#ctbDAC,cType(a5)	; check if this was a DAC channel
000108BC 6600                       		bne.s	.cont			; if we are, skip
000108BE 4EBA EFB0                  		jsr	dKeyOffFM(pc)		; send key-off command to YM
000108C2 6000                       		bra.s	.cont
000108C4                            ; ---------------------------------------------------------------------------
000108C4                            
000108C4                            .mutePSG
000108C4 4EBA F87C                  		jsr	dMutePSGmus(pc)		; mute PSG channel
000108C8                            
000108C8                            .cont
000108C8 BAFC C698                  		cmpa.w	#mSFXFM3,a5		; check if this is a SFX channel
000108CC 6500                       		blo.s	.exit			; if not, skip all this mess
000108CE 422D 001A                  		clr.b	cPrio(a5)		; clear channel priority
000108D2                            
000108D2 43FA E7F2                  		lea	dSFXoverList(pc),a1	; load quick reference to the SFX override list to a1
000108D6 7600                       		moveq	#0,d3
000108D8 162D 0001                  		move.b	cType(a5),d3		; load channel type to d3
000108DC 6B00                       		bmi.s	.psg			; if this is a PSG channel, branch
000108DE 3F0D                       		move.w	a5,-(sp)		; push channel pointer
000108E0                            
000108E0 0243 0007                  		and.w	#$07,d3			; get only the necessary bits to d3
000108E4 5543                       		subq.w	#2,d3			; since FM 1 and 2 are not used, skip over them
000108E6 D643                       		add.w	d3,d3			; double offset (each entry is 1 word in size)
000108E8 3A71 3000                  		move.w	(a1,d3.w),a5		; get the SFX channel we were overriding
000108EC                            
000108EC                            .dacdone
000108EC 4A15                       		tst.b	(a5)			; check if that channel is running a tracker
000108EE 6A00                       		bpl.s	.fixch			; if not, branch
000108F0                            
000108F0 08D5 0005                  		bset	#cfbVol,(a5)		; set update volume flag (cleared by dUpdateVoiceFM)
000108F4 0895 0001                  		bclr	#cfbInt,(a5)		; reset sfx override flag
000108F8 082D 0003 0001             		btst	#ctbDAC,cType(a5)	; check if the channel is a DAC channel
000108FE 6600                       		bne.s	.fixch			; if yes, skip
00010900                            
00010900 08D5 0000                  		bset	#cfbRest,(a5)		; Set channel resting flag
00010904 43FA 0000                  		lea	VoiceBankMusic(pc),a1	; load music voice table to a1
00010908 102D 000B                  		move.b	cVoice(a5),d0		; load FM voice ID of the channel to d0
0001090C 4EBA FE44                  		jsr	dUpdateVoiceFM(pc)	; send FM voice for this channel
00010910                            
00010910                            .fixch
00010910 3A5F                       		move.w	(sp)+,a5		; pop the current channel
00010912                            .exit
00010912 5497                       		addq.l	#2,(sp)			; go to next channel immediately
00010914 4E75                       		rts
00010916                            ; ---------------------------------------------------------------------------
00010916                            ; There is nothing that would break even if the channel is not
00010916                            ; running a tracker, so we do not bother checking
00010916                            ; ---------------------------------------------------------------------------
00010916                            
00010916                            .psg
00010916 E80B                       		lsr.b	#4,d3			; make it easier to reference the right offset in the table
00010918 3271 3000                  		movea.w	(a1,d3.w),a1		; get the SFX channel we were overriding
0001091C 0891 0001                  		bclr	#cfbInt,(a1)		; channel is not interrupted anymore
00010920 08D1 0000                  		bset	#cfbRest,(a1)		; reset sfx override flag
00010924                            
00010924 0C29 00E0 0001             		cmp.b	#ctPSG4,cType(a1)	; check if this channel is in PSG4 mode
0001092A 66E6                       		bne.s	.exit			; if not, skip
0001092C 13E9 001B 00C0 0011        		move.b	cStatPSG4(a1),dPSG	; update PSG4 status to PSG port
00010934 60DC                       		bra.s	.exit
00010936                            ; ===========================================================================
00010936                            ; ---------------------------------------------------------------------------
00010936                            ; Tracker command for enabling LFO
00010936                            ; ---------------------------------------------------------------------------
00010936                            
00010936                            dcsLFO:
00010936 7000                       		moveq	#0,d0
00010938 102D 000B                  		move.b	cVoice(a5),d0		; load FM voice ID of the channel to d0
0001093C 224E                       		move.l	a6,a1			; load voice table to a1
0001093E                            
0001093E                            	dCALC_VOICE 9				; get address of the specific voice to a1
0001093E EB48                     M 	lsl.w	#5,d0
00010940 0640 0009                M 	add.w	#9,d0
00010944 D2C0                     M 	add.w	d0,a1
00010946 1614                       		move.b	(a4),d3			; load LFO enable operators to d3
00010948 45FA EBAA                  		lea	dAMSEn_Ops(pc),a2	; load Decay 1 Rate address table to a2
0001094C 7C03                       		moveq	#4-1,d6			; prepare 4 operators to d5
0001094E                            
0001094E                            .decayloop
0001094E 1219                       		move.b	(a1)+,d1		; get Decay 1 Level value from voice to d1
00010950 101A                       		move.b	(a2)+,d0		; load YM address to write to d0
00010952                            
00010952 D603                       		add.b	d3,d3			; check if LFO is enabled for this channeÃ¶
00010954 6400                       		bcc.s	.noLFO			; if not, skip
00010956 0001 0080                  		or.b	#$80,d1			; set enable LFO bit
0001095A 4EBA EF2E                  		jsr	WriteChYM(pc)		; write to YM according to channel
0001095E                            
0001095E                            .noLFO
0001095E 51CE FFEE                  		dbf	d6,.decayloop		; repeat for each Decay 1 Level operator
00010962                            
00010962 121C                       		move.b	(a4)+,d1		; load LFO frequency value from tracker
00010964 7022                       		moveq	#$22,d0			; YM command: LFO
00010966 4EBA EF2E                  		jsr	WriteYM_Pt1(pc)		; write to part 1 channel
0001096A                            
0001096A 121C                       		move.b	(a4)+,d1		; load AMS, FMS & Panning from tracker
0001096C 1B41 0006                  		move.b	d1,cPanning(a5)		; save to channel panning
00010970                            
00010970 70B4                       		moveq	#$FFFFFFB4,d0		; YM command: Panning & LFO
00010972 4EFA EF10                  		jmp	dWriteYMchnInt(pc)	; write to YM according to channel
00010976                            ; ===========================================================================
00010976                            ; ---------------------------------------------------------------------------
00010976                            ; Tracker command for resetting condition
00010976                            ; ---------------------------------------------------------------------------
00010976                            
00010976                            dcResetCond:
00010976 0895 0004                  		bclr	#cfbCond,(a5)		; reset condition flag
0001097A 4E75                       		rts
0001097C                            ; ===========================================================================
0001097C                            ; ---------------------------------------------------------------------------
0001097C                            ; Tracker command for writing to communications flags
0001097C                            ; ---------------------------------------------------------------------------
0001097C                            
0001097C                            dcsComm:
0001097C 43F8 C4AC                  		lea	mComm.w,a1		; get communications array to a1
00010980 7000                       		moveq	#0,d0
00010982 101C                       		move.b	(a4)+,d0		; load byte number to write from tracker
00010984 139C 0000                  		move.b	(a4)+,(a1,d0.w)		; load vaue from tracker to communications byte
00010988 4E75                       		rts
0001098A                            ; ===========================================================================
0001098A                            ; ---------------------------------------------------------------------------
0001098A                            ; RAM addresses for special condition code
0001098A                            ; ---------------------------------------------------------------------------
0001098A                            
0001098A                            dcCondRegTable:
0001098A C746 C4A6                  	dc.w hwVersion, mFlags	; 0
0001098E C4B8 C4B9                  	dc.w mTempoMain, mTempoSpeed	; 2
00010992 0000 0000                  	dc.w 0, 0			; 4
00010996 0000 0000                  	dc.w 0, 0			; 6
0001099A 0000 0000                  	dc.w 0, 0			; 8
0001099E 0000 0000                  	dc.w 0, 0			; $A
000109A2 0000 0000                  	dc.w 0, 0			; $C
000109A6 0000 0001                  	dc.w 0, cType			; $E
000109AA                            ; ===========================================================================
000109AA                            ; ---------------------------------------------------------------------------
000109AA                            ; Tracker command for checking special RAM addresses
000109AA                            ; ---------------------------------------------------------------------------
000109AA                            
000109AA                            dcCondReg:
000109AA 101C                       		move.b	(a4)+,d0		; get value from tracker
000109AC 1200                       		move.b	d0,d1			; copy to d1
000109AE                            
000109AE 0240 000F                  		and.w	#$F,d0			; get RAM table offset to d0
000109B2 D040                       		add.w	d0,d0			; double it (each entry is 1 word)
000109B4 303B 00D4                  		move.w	dcCondRegTable(pc,d0.w),d0; get data to read from
000109B8 6B00                       		bmi.s	.gotit			; branch if if was a RAM address
000109BA D04D                       		add.w	a5,d0			; else it was a channel offset
000109BC                            
000109BC                            .gotit
000109BC 3240                       		move.w	d0,a1			; get the desired address from d0 to a1
000109BE 1011                       		move.b	(a1),d0			; read byte from it
000109C0 6000                       		bra.s	dcCondCom
000109C2                            ; ===========================================================================
000109C2                            ; ---------------------------------------------------------------------------
000109C2                            ; Tracker command for checking communications bytes
000109C2                            ; ---------------------------------------------------------------------------
000109C2                            
000109C2                            dcCond:
000109C2 43F8 C4AC                  		lea	mComm.w,a1		; get communications array to a1
000109C6 101C                       		move.b	(a4)+,d0		; load condition and offset from tracker to d0
000109C8 1200                       		move.b	d0,d1			; copy to d1
000109CA 0240 000F                  		and.w	#$F,d0			; get offset only
000109CE 1031 0000                  		move.b	(a1,d0.w),d0		; load value from communcations byte to d0
000109D2                            
000109D2                            dcCondCom:
000109D2 0895 0004                  		bclr	#cfbCond,(a5)		; set condition to true
000109D6 0241 00F0                  		and.w	#$F0,d1			; get condition value only
000109DA E449                       		lsr.w	#2,d1			; shift 2 bits down (each entry is 4 bytes large)
000109DC B01C                       		cmp.b	(a4)+,d0		; check value against tracker byte
000109DE 4EFB 1000                  		jmp	.cond(pc,d1.w)		; handle conditional code
000109E2                            ; ===========================================================================
000109E2                            ; ---------------------------------------------------------------------------
000109E2                            ; Code for setting the condition flag
000109E2                            ; ---------------------------------------------------------------------------
000109E2                            
000109E2                            .c	macro x
000109E2                            	\x	.false
000109E2                            	rts
000109E2                                 endm
000109E2                            
000109E2                            .false
000109E2 08D5 0004                  		bset	#cfbCond,(a5)		; set condition to false
000109E6                            
000109E6 4E75                       .cond	rts		; T
000109E8 4E75                       	rts
000109EA                            	.c bra.s	; F
000109EA 60F6                     M 	bra.s	.false
000109EC 4E75                     M 	rts
000109EE                            	.c bls.s	; HI
000109EE 63F2                     M 	bls.s	.false
000109F0 4E75                     M 	rts
000109F2                            	.c bhi.s	; LS
000109F2 62EE                     M 	bhi.s	.false
000109F4 4E75                     M 	rts
000109F6                            	.c blo.s	; HS/CC
000109F6 65EA                     M 	blo.s	.false
000109F8 4E75                     M 	rts
000109FA                            	.c bhs.s	; LO/CS
000109FA 64E6                     M 	bhs.s	.false
000109FC 4E75                     M 	rts
000109FE                            	.c beq.s	; NE
000109FE 67E2                     M 	beq.s	.false
00010A00 4E75                     M 	rts
00010A02                            	.c bne.s	; EQ
00010A02 66DE                     M 	bne.s	.false
00010A04 4E75                     M 	rts
00010A06                            	.c bvs.s	; VC
00010A06 69DA                     M 	bvs.s	.false
00010A08 4E75                     M 	rts
00010A0A                            	.c bvc.s	; VS
00010A0A 68D6                     M 	bvc.s	.false
00010A0C 4E75                     M 	rts
00010A0E                            	.c bmi.s	; PL
00010A0E 6BD2                     M 	bmi.s	.false
00010A10 4E75                     M 	rts
00010A12                            	.c bpl.s	; MI
00010A12 6ACE                     M 	bpl.s	.false
00010A14 4E75                     M 	rts
00010A16                            	.c blt.s	; GE
00010A16 6DCA                     M 	blt.s	.false
00010A18 4E75                     M 	rts
00010A1A                            	.c bge.s	; LT
00010A1A 6CC6                     M 	bge.s	.false
00010A1C 4E75                     M 	rts
00010A1E                            	.c ble.s	; GT
00010A1E 6FC2                     M 	ble.s	.false
00010A20 4E75                     M 	rts
00010A22                            	.c bgt.s	; LE
00010A22 6EBE                     M 	bgt.s	.false
00010A24 4E75                     M 	rts
00010A26                            ; ===========================================================================
00010A26                            ; ---------------------------------------------------------------------------
00010A26                            ; Tracker command for freezing the CPU. DEBUG FLAG
00010A26                            ; ---------------------------------------------------------------------------
00010A26                            
00010A26                            dcFreeze:
00010A26 6000 FFFE                  		bra.w	*		; Freeze CPU here
00010A2A 4E75                       		rts
00010A2C                            ; ===========================================================================
00010A2C                            ; ---------------------------------------------------------------------------
00010A2C                            ; Tracker command for debugging tracker data. DEBUG FLAG
00010A2C                            ; ---------------------------------------------------------------------------
00010A2C                            
00010A2C                            dcTracker:
00010A2C 50F8 C740                  		st	msChktracker.w	; set debug flag
00010A30 4E75                       		rts
00010A32                            ; ===========================================================================
00010A32                            ; ---------------------------------------------------------------------------
00010A32                            ; Check if a song is playing
00010A32                            ; ---------------------------------------------------------------------------
00010A32                            
00010A32                            dChkSongPlay:
00010A32 43F8 C4C4                  	lea	mDAC1.w,a1		; Music track RAM
00010A36 7209                       	moveq	#Mus_Ch-1,d1
00010A38                            
00010A38                            .ChkTracks:
00010A38 4A11                       	tst.b	cFlags(a1)		; Is this track playing?
00010A3A 6B00                       	bmi.s	.Playing		; If so, branch
00010A3C 43E9 002C                  	lea	cSize(a1),a1		; Next track
00010A40 51C9 FFF6                  	dbf	d1,.ChkTracks		; Loop
00010A44 7200                       	moveq	#0,d1
00010A46 4E75                       	rts
00010A48                            
00010A48                            .Playing:
00010A48 50C1                       	st	d1
00010A4A 4E75                       	rts
00010A4C                            ; ===========================================================================
00010A4C                            ; ---------------------------------------------------------------------------
00010A4C                            ; Define music and SFX
00010A4C                            ; ---------------------------------------------------------------------------
00010A4C                            
00010A4C                            	opt oz-				; disable zero-offset optimization
00010A4C                            
00010A4C =00000082                  __sfx =		SFXoff
00010A4C =0000000A                  __mus =		MusOff
00010A4C                            	include	"Sound/sfx.asm"
00010A4C                            
00010A4C                            
00010A4C                            ; ------------------------------------------------------------------------
00010A4C                            ; AMPS SFX list
00010A4C                            ; -------------------------------------------------------------------------
00010A4C                            
00010A4C                            ; -------------------------------------------------------------------------
00010A4C                            ; SFX index
00010A4C                            ; -------------------------------------------------------------------------
00010A4C                            
00010A4C                            SoundIndex:
00010A4C                            	ptrSFX	$00, Snd_Jump
00010A4C =00000000                M .type	=	$00<<24
00010A4C                          M 	rept	narg-1
00010A4C 0000 0000                M 	dc.l	snd_jump|.type
00010A50 =00000083                M __sfx	=	__sfx+1
00010A50                          M 	shift
00010A50                            	ptrSFX	$00, Snd_Skid
00010A50 =00000000                M .type	=	$00<<24
00010A50                          M 	rept	narg-1
00010A50 0000 0000                M 	dc.l	snd_skid|.type
00010A54 =00000084                M __sfx	=	__sfx+1
00010A54                          M 	shift
00010A54                            	ptrSFX	$00, Snd_Death
00010A54 =00000000                M .type	=	$00<<24
00010A54                          M 	rept	narg-1
00010A54 0000 0000                M 	dc.l	snd_death|.type
00010A58 =00000085                M __sfx	=	__sfx+1
00010A58                          M 	shift
00010A58                            	ptrSFX	$00, Snd_Push
00010A58 =00000000                M .type	=	$00<<24
00010A58                          M 	rept	narg-1
00010A58 0000 0000                M 	dc.l	snd_push|.type
00010A5C =00000086                M __sfx	=	__sfx+1
00010A5C                          M 	shift
00010A5C                            	ptrSFX	$00, Snd_Bubble
00010A5C =00000000                M .type	=	$00<<24
00010A5C                          M 	rept	narg-1
00010A5C 0000 0000                M 	dc.l	snd_bubble|.type
00010A60 =00000087                M __sfx	=	__sfx+1
00010A60                          M 	shift
00010A60                            	ptrSFX	$00, Snd_Drown
00010A60 =00000000                M .type	=	$00<<24
00010A60                          M 	rept	narg-1
00010A60 0000 0000                M 	dc.l	snd_drown|.type
00010A64 =00000088                M __sfx	=	__sfx+1
00010A64                          M 	shift
00010A64                            	ptrSFX	$00, Snd_DrownWarning
00010A64 =00000000                M .type	=	$00<<24
00010A64                          M 	rept	narg-1
00010A64 0000 0000                M 	dc.l	snd_drownwarning|.type
00010A68 =00000089                M __sfx	=	__sfx+1
00010A68                          M 	shift
00010A68                            	ptrSFX	$00, Snd_DrownCountdown
00010A68 =00000000                M .type	=	$00<<24
00010A68                          M 	rept	narg-1
00010A68 0000 0000                M 	dc.l	snd_drowncountdown|.type
00010A6C =0000008A                M __sfx	=	__sfx+1
00010A6C                          M 	shift
00010A6C                            	ptrSFX	$00, Snd_Checkpoint
00010A6C =00000000                M .type	=	$00<<24
00010A6C                          M 	rept	narg-1
00010A6C 0000 0000                M 	dc.l	snd_checkpoint|.type
00010A70 =0000008B                M __sfx	=	__sfx+1
00010A70                          M 	shift
00010A70                            	ptrSFX	$00, Snd_SpikeMove
00010A70 =00000000                M .type	=	$00<<24
00010A70                          M 	rept	narg-1
00010A70 0000 0000                M 	dc.l	snd_spikemove|.type
00010A74 =0000008C                M __sfx	=	__sfx+1
00010A74                          M 	shift
00010A74                            	ptrSFX	$00, Snd_Ring
00010A74 =00000000                M .type	=	$00<<24
00010A74                          M 	rept	narg-1
00010A74 0000 0000                M 	dc.l	snd_ring|.type
00010A78 =0000008D                M __sfx	=	__sfx+1
00010A78                          M 	shift
00010A78                            	ptrSFX	$00, Snd_RingLoss
00010A78 =00000000                M .type	=	$00<<24
00010A78                          M 	rept	narg-1
00010A78 0000 0000                M 	dc.l	snd_ringloss|.type
00010A7C =0000008E                M __sfx	=	__sfx+1
00010A7C                          M 	shift
00010A7C                            	ptrSFX	$00, Snd_Spring
00010A7C =00000000                M .type	=	$00<<24
00010A7C                          M 	rept	narg-1
00010A7C 0000 0000                M 	dc.l	snd_spring|.type
00010A80 =0000008F                M __sfx	=	__sfx+1
00010A80                          M 	shift
00010A80                            	ptrSFX	$00, Snd_Shield
00010A80 =00000000                M .type	=	$00<<24
00010A80                          M 	rept	narg-1
00010A80 0000 0000                M 	dc.l	snd_shield|.type
00010A84 =00000090                M __sfx	=	__sfx+1
00010A84                          M 	shift
00010A84                            	ptrSFX	$00, Snd_Splash
00010A84 =00000000                M .type	=	$00<<24
00010A84                          M 	rept	narg-1
00010A84 0000 0000                M 	dc.l	snd_splash|.type
00010A88 =00000091                M __sfx	=	__sfx+1
00010A88                          M 	shift
00010A88                            	ptrSFX	$00, Snd_Bumper
00010A88 =00000000                M .type	=	$00<<24
00010A88                          M 	rept	narg-1
00010A88 0000 0000                M 	dc.l	snd_bumper|.type
00010A8C =00000092                M __sfx	=	__sfx+1
00010A8C                          M 	shift
00010A8C                            	ptrSFX	$00, Snd_Switch
00010A8C =00000000                M .type	=	$00<<24
00010A8C                          M 	rept	narg-1
00010A8C 0000 0000                M 	dc.l	snd_switch|.type
00010A90 =00000093                M __sfx	=	__sfx+1
00010A90                          M 	shift
00010A90                            	ptrSFX	$00, Snd_Signpost
00010A90 =00000000                M .type	=	$00<<24
00010A90                          M 	rept	narg-1
00010A90 0000 0000                M 	dc.l	snd_signpost|.type
00010A94 =00000094                M __sfx	=	__sfx+1
00010A94                          M 	shift
00010A94                            	ptrSFX	$00, Snd_Collapse
00010A94 =00000000                M .type	=	$00<<24
00010A94                          M 	rept	narg-1
00010A94 0000 0000                M 	dc.l	snd_collapse|.type
00010A98 =00000095                M __sfx	=	__sfx+1
00010A98                          M 	shift
00010A98                            	ptrSFX	$00, Snd_WallSmash
00010A98 =00000000                M .type	=	$00<<24
00010A98                          M 	rept	narg-1
00010A98 0000 0000                M 	dc.l	snd_wallsmash|.type
00010A9C =00000096                M __sfx	=	__sfx+1
00010A9C                          M 	shift
00010A9C                            	ptrSFX	$00, Snd_Rumble
00010A9C =00000000                M .type	=	$00<<24
00010A9C                          M 	rept	narg-1
00010A9C 0000 0000                M 	dc.l	snd_rumble|.type
00010AA0 =00000097                M __sfx	=	__sfx+1
00010AA0                          M 	shift
00010AA0                            	ptrSFX	$00, Snd_Warp
00010AA0 =00000000                M .type	=	$00<<24
00010AA0                          M 	rept	narg-1
00010AA0 0000 0000                M 	dc.l	snd_warp|.type
00010AA4 =00000098                M __sfx	=	__sfx+1
00010AA4                          M 	shift
00010AA4                            	ptrSFX	$00, Snd_BossHit
00010AA4 =00000000                M .type	=	$00<<24
00010AA4                          M 	rept	narg-1
00010AA4 0000 0000                M 	dc.l	snd_bosshit|.type
00010AA8 =00000099                M __sfx	=	__sfx+1
00010AA8                          M 	shift
00010AA8                            	ptrSFX	$00, Snd_Bomb
00010AA8 =00000000                M .type	=	$00<<24
00010AA8                          M 	rept	narg-1
00010AA8 0000 0000                M 	dc.l	snd_bomb|.type
00010AAC =0000009A                M __sfx	=	__sfx+1
00010AAC                          M 	shift
00010AAC                            	ptrSFX	$00, Snd_BreakItem
00010AAC =00000000                M .type	=	$00<<24
00010AAC                          M 	rept	narg-1
00010AAC 0000 0000                M 	dc.l	snd_breakitem|.type
00010AB0 =0000009B                M __sfx	=	__sfx+1
00010AB0                          M 	shift
00010AB0                            	ptrSFX	$00, Snd_FloorBounce
00010AB0 =00000000                M .type	=	$00<<24
00010AB0                          M 	rept	narg-1
00010AB0 0000 0000                M 	dc.l	snd_floorbounce|.type
00010AB4 =0000009C                M __sfx	=	__sfx+1
00010AB4                          M 	shift
00010AB4                            	ptrSFX	$00, Snd_Charge
00010AB4 =00000000                M .type	=	$00<<24
00010AB4                          M 	rept	narg-1
00010AB4 0000 0000                M 	dc.l	snd_charge|.type
00010AB8 =0000009D                M __sfx	=	__sfx+1
00010AB8                          M 	shift
00010AB8                            	ptrSFX	$00, Snd_ChargeStop
00010AB8 =00000000                M .type	=	$00<<24
00010AB8                          M 	rept	narg-1
00010AB8 0000 0000                M 	dc.l	snd_chargestop|.type
00010ABC =0000009E                M __sfx	=	__sfx+1
00010ABC                          M 	shift
00010ABC                            	ptrSFX	$00, Snd_ChargeRelease
00010ABC =00000000                M .type	=	$00<<24
00010ABC                          M 	rept	narg-1
00010ABC 0000 0000                M 	dc.l	snd_chargerelease|.type
00010AC0 =0000009F                M __sfx	=	__sfx+1
00010AC0                          M 	shift
00010AC0                            	ptrSFX	$00, Snd_DiamondBreak
00010AC0 =00000000                M .type	=	$00<<24
00010AC0                          M 	rept	narg-1
00010AC0 0000 0000                M 	dc.l	snd_diamondbreak|.type
00010AC4 =000000A0                M __sfx	=	__sfx+1
00010AC4                          M 	shift
00010AC4                            SoundIndex_End:
00010AC4                            
00010AC4                            ; -------------------------------------------------------------------------
00010AC4                            	include	"Sound/music.asm"
00010AC4                            
00010AC4                            
00010AC4                            ; ------------------------------------------------------------------------
00010AC4                            ; AMPS music list
00010AC4                            ; -------------------------------------------------------------------------
00010AC4                            
00010AC4                            ; -------------------------------------------------------------------------
00010AC4                            ; Music index
00010AC4                            ; -------------------------------------------------------------------------
00010AC4                            
00010AC4                            MusicIndex:
00010AC4                            	ptrMusic	Mus_WWZ,		$00
00010AC4                          M 	rept	narg/2
00010AC4 0000 0000                M 	dc.l	(($00)<<24)|mus_wwz
00010AC8 =0000000B                M __mus	=	__mus+1
00010AC8                          M 	shift
00010AC8                          M 	shift
00010AC8                            	ptrMusic	Mus_WWZ,		$00
00010AC8                          M 	rept	narg/2
00010AC8 0000 0000                M 	dc.l	(($00)<<24)|mus_wwz
00010ACC =0000000C                M __mus	=	__mus+1
00010ACC                          M 	shift
00010ACC                          M 	shift
00010ACC                            	ptrMusic	Mus_Boss,		$00
00010ACC                          M 	rept	narg/2
00010ACC 0000 0000                M 	dc.l	(($00)<<24)|mus_boss
00010AD0 =0000000D                M __mus	=	__mus+1
00010AD0                          M 	shift
00010AD0                          M 	shift
00010AD0                            MusicIndex_End:
00010AD0                            
00010AD0                            ; -------------------------------------------------------------------------
00010AD0                            ; ===========================================================================
00010AD0                            ; ---------------------------------------------------------------------------
00010AD0                            ; Define samples
00010AD0                            ; ---------------------------------------------------------------------------
00010AD0                            
00010AD0 =00000080                  __samp =	$80
00010AD0                            	include	"Sound/dac.asm"
00010AD0                            
00010AD0                            
00010AD0                            ; ------------------------------------------------------------------------
00010AD0                            ; AMPS DAC list
00010AD0                            ; -------------------------------------------------------------------------
00010AD0                            
00010AD0                            ; -------------------------------------------------------------------------
00010AD0                            ; Sample 68k PCM list
00010AD0                            ; -------------------------------------------------------------------------
00010AD0                            
00010AD0                            SampleList:
00010AD0                            	sample	$0000, Stop,		Stop,		Stop		; 80 (THIS IS A REST NOTE, DO NOT EDIT...)
00010AD0 =00000080                M dstop	=	__samp
00010AD0 =00000081                M __samp	=	__samp+1
00010AD0 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
00010AD3 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010AD6 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
00010AD9 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010ADC FF00                     M 	dc.w	$0000-$100
00010ADE 0000                     M 	dc.w	0
00010AE0                            	sample	$0100, Kick,		Stop,		Kick		; 81
00010AE0 =00000081                M dkick	=	__samp
00010AE0 =00000082                M __samp	=	__samp+1
00010AE0 0000 00                  M 	dc.b	swf_kick&$ff,((swf_kick>>$08)&$7f)|$80,(swf_kick>>$0f)&$ff
00010AE3 0000 00                  M 	dc.b	(swfr_kick-1)&$ff,(((swfr_kick-1)>>$08)&$7f)|$80,((swfr_kick-1)>>$0f)&$ff
00010AE6 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
00010AE9 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010AEC 0000                     M 	dc.w	$0100-$100
00010AEE 0000                     M 	dc.w	0
00010AF0                            	sample	$0100, Kick,		Stop,		Kick2		; 82
00010AF0 =00000082                M dkick2	=	__samp
00010AF0 =00000083                M __samp	=	__samp+1
00010AF0 0000 00                  M 	dc.b	swf_kick&$ff,((swf_kick>>$08)&$7f)|$80,(swf_kick>>$0f)&$ff
00010AF3 0000 00                  M 	dc.b	(swfr_kick-1)&$ff,(((swfr_kick-1)>>$08)&$7f)|$80,((swfr_kick-1)>>$0f)&$ff
00010AF6 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
00010AF9 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010AFC 0000                     M 	dc.w	$0100-$100
00010AFE 0000                     M 	dc.w	0
00010B00                            	sample	$0100, Snare,		Stop,		Snare		; 83
00010B00 =00000083                M dsnare	=	__samp
00010B00 =00000084                M __samp	=	__samp+1
00010B00 0000 00                  M 	dc.b	swf_snare&$ff,((swf_snare>>$08)&$7f)|$80,(swf_snare>>$0f)&$ff
00010B03 0000 00                  M 	dc.b	(swfr_snare-1)&$ff,(((swfr_snare-1)>>$08)&$7f)|$80,((swfr_snare-1)>>$0f)&$ff
00010B06 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
00010B09 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010B0C 0000                     M 	dc.w	$0100-$100
00010B0E 0000                     M 	dc.w	0
00010B10                            	sample	$0100, Snare,		Stop,		Snare2		; 84
00010B10 =00000084                M dsnare2	=	__samp
00010B10 =00000085                M __samp	=	__samp+1
00010B10 0000 00                  M 	dc.b	swf_snare&$ff,((swf_snare>>$08)&$7f)|$80,(swf_snare>>$0f)&$ff
00010B13 0000 00                  M 	dc.b	(swfr_snare-1)&$ff,(((swfr_snare-1)>>$08)&$7f)|$80,((swfr_snare-1)>>$0f)&$ff
00010B16 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
00010B19 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010B1C 0000                     M 	dc.w	$0100-$100
00010B1E 0000                     M 	dc.w	0
00010B20                            	sample	$0100, Tom,		Stop,		Tom		; 85
00010B20 =00000085                M dtom	=	__samp
00010B20 =00000086                M __samp	=	__samp+1
00010B20 0000 00                  M 	dc.b	swf_tom&$ff,((swf_tom>>$08)&$7f)|$80,(swf_tom>>$0f)&$ff
00010B23 0000 00                  M 	dc.b	(swfr_tom-1)&$ff,(((swfr_tom-1)>>$08)&$7f)|$80,((swfr_tom-1)>>$0f)&$ff
00010B26 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
00010B29 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010B2C 0000                     M 	dc.w	$0100-$100
00010B2E 0000                     M 	dc.w	0
00010B30                            	sample	$0160, Tom,		Stop,		TomH 		; 86
00010B30 =00000086                M dtomh	=	__samp
00010B30 =00000087                M __samp	=	__samp+1
00010B30 0000 00                  M 	dc.b	swf_tom&$ff,((swf_tom>>$08)&$7f)|$80,(swf_tom>>$0f)&$ff
00010B33 0000 00                  M 	dc.b	(swfr_tom-1)&$ff,(((swfr_tom-1)>>$08)&$7f)|$80,((swfr_tom-1)>>$0f)&$ff
00010B36 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
00010B39 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010B3C 0060                     M 	dc.w	$0160-$100
00010B3E 0000                     M 	dc.w	0
00010B40                            	sample	$0130, Tom,		Stop,		TomMid		; 87
00010B40 =00000087                M dtommid	=	__samp
00010B40 =00000088                M __samp	=	__samp+1
00010B40 0000 00                  M 	dc.b	swf_tom&$ff,((swf_tom>>$08)&$7f)|$80,(swf_tom>>$0f)&$ff
00010B43 0000 00                  M 	dc.b	(swfr_tom-1)&$ff,(((swfr_tom-1)>>$08)&$7f)|$80,((swfr_tom-1)>>$0f)&$ff
00010B46 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
00010B49 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010B4C 0030                     M 	dc.w	$0130-$100
00010B4E 0000                     M 	dc.w	0
00010B50                            	sample	$0100, Tom,		Stop,		TomMidL		; 88
00010B50 =00000088                M dtommidl	=	__samp
00010B50 =00000089                M __samp	=	__samp+1
00010B50 0000 00                  M 	dc.b	swf_tom&$ff,((swf_tom>>$08)&$7f)|$80,(swf_tom>>$0f)&$ff
00010B53 0000 00                  M 	dc.b	(swfr_tom-1)&$ff,(((swfr_tom-1)>>$08)&$7f)|$80,((swfr_tom-1)>>$0f)&$ff
00010B56 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
00010B59 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010B5C 0000                     M 	dc.w	$0100-$100
00010B5E 0000                     M 	dc.w	0
00010B60                            	sample	$00E0, Tom,		Stop,		TomL		; 89
00010B60 =00000089                M dtoml	=	__samp
00010B60 =0000008A                M __samp	=	__samp+1
00010B60 0000 00                  M 	dc.b	swf_tom&$ff,((swf_tom>>$08)&$7f)|$80,(swf_tom>>$0f)&$ff
00010B63 0000 00                  M 	dc.b	(swfr_tom-1)&$ff,(((swfr_tom-1)>>$08)&$7f)|$80,((swfr_tom-1)>>$0f)&$ff
00010B66 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
00010B69 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010B6C FFE0                     M 	dc.w	$00e0-$100
00010B6E 0000                     M 	dc.w	0
00010B70                            	sample	$0100, Stop,		Stop,		Stop2		; 8A
00010B70 =0000008A                M dstop2	=	__samp
00010B70 =0000008B                M __samp	=	__samp+1
00010B70 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
00010B73 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010B76 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
00010B79 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010B7C 0000                     M 	dc.w	$0100-$100
00010B7E 0000                     M 	dc.w	0
00010B80                            	sample	$0100, Stop,		Stop,		Stop3		; 8B
00010B80 =0000008B                M dstop3	=	__samp
00010B80 =0000008C                M __samp	=	__samp+1
00010B80 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
00010B83 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010B86 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
00010B89 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010B8C 0000                     M 	dc.w	$0100-$100
00010B8E 0000                     M 	dc.w	0
00010B90                            	sample	$0104, Title,		Title,		Title		; 8C
00010B90 =0000008C                M dtitle	=	__samp
00010B90 =0000008D                M __samp	=	__samp+1
00010B90 0000 00                  M 	dc.b	swf_title&$ff,((swf_title>>$08)&$7f)|$80,(swf_title>>$0f)&$ff
00010B93 0000 00                  M 	dc.b	(swfr_title-1)&$ff,(((swfr_title-1)>>$08)&$7f)|$80,((swfr_title-1)>>$0f)&$ff
00010B96 0000 00                  M 	dc.b	swf_title&$ff,((swf_title>>$08)&$7f)|$80,(swf_title>>$0f)&$ff
00010B99 0000 00                  M 	dc.b	(swfr_title-1)&$ff,(((swfr_title-1)>>$08)&$7f)|$80,((swfr_title-1)>>$0f)&$ff
00010B9C 0004                     M 	dc.w	$0104-$100
00010B9E 0000                     M 	dc.w	0
00010BA0                            	sample	$0104, Sega,		Stop,		Sega		; 8D
00010BA0 =0000008D                M dsega	=	__samp
00010BA0 =0000008E                M __samp	=	__samp+1
00010BA0 0000 00                  M 	dc.b	swf_sega&$ff,((swf_sega>>$08)&$7f)|$80,(swf_sega>>$0f)&$ff
00010BA3 0000 00                  M 	dc.b	(swfr_sega-1)&$ff,(((swfr_sega-1)>>$08)&$7f)|$80,((swfr_sega-1)>>$0f)&$ff
00010BA6 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
00010BA9 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010BAC 0004                     M 	dc.w	$0104-$100
00010BAE 0000                     M 	dc.w	0
00010BB0                            	sample	$0104, Punch,		Stop,		Punch		; 8E
00010BB0 =0000008E                M dpunch	=	__samp
00010BB0 =0000008F                M __samp	=	__samp+1
00010BB0 0000 00                  M 	dc.b	swf_punch&$ff,((swf_punch>>$08)&$7f)|$80,(swf_punch>>$0f)&$ff
00010BB3 0000 00                  M 	dc.b	(swfr_punch-1)&$ff,(((swfr_punch-1)>>$08)&$7f)|$80,((swfr_punch-1)>>$0f)&$ff
00010BB6 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
00010BB9 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010BBC 0004                     M 	dc.w	$0104-$100
00010BBE 0000                     M 	dc.w	0
00010BC0                            	sample	$0114, EndingSong,	EndingSong,	EndingSong	; 8F
00010BC0 =0000008F                M dendingsong	=	__samp
00010BC0 =00000090                M __samp	=	__samp+1
00010BC0 0000 00                  M 	dc.b	swf_endingsong&$ff,((swf_endingsong>>$08)&$7f)|$80,(swf_endingsong>>$0f)&$ff
00010BC3 0000 00                  M 	dc.b	(swfr_endingsong-1)&$ff,(((swfr_endingsong-1)>>$08)&$7f)|$80,((swfr_endingsong-1)>>$0f)&$ff
00010BC6 0000 00                  M 	dc.b	swf_endingsong&$ff,((swf_endingsong>>$08)&$7f)|$80,(swf_endingsong>>$0f)&$ff
00010BC9 0000 00                  M 	dc.b	(swfr_endingsong-1)&$ff,(((swfr_endingsong-1)>>$08)&$7f)|$80,((swfr_endingsong-1)>>$0f)&$ff
00010BCC 0014                     M 	dc.w	$0114-$100
00010BCE 0000                     M 	dc.w	0
00010BD0                            	sample	$0114, BinBowie,	Stop,		BinBowie	; 90
00010BD0 =00000090                M dbinbowie	=	__samp
00010BD0 =00000091                M __samp	=	__samp+1
00010BD0 0000 00                  M 	dc.b	swf_binbowie&$ff,((swf_binbowie>>$08)&$7f)|$80,(swf_binbowie>>$0f)&$ff
00010BD3 0000 00                  M 	dc.b	(swfr_binbowie-1)&$ff,(((swfr_binbowie-1)>>$08)&$7f)|$80,((swfr_binbowie-1)>>$0f)&$ff
00010BD6 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
00010BD9 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010BDC 0014                     M 	dc.w	$0114-$100
00010BDE 0000                     M 	dc.w	0
00010BE0                            	sample	$0114, Wacky_Base_Loud,	Stop,		WackyBase	; 91
00010BE0 =00000091                M dwackybase	=	__samp
00010BE0 =00000092                M __samp	=	__samp+1
00010BE0 0000 00                  M 	dc.b	swf_wacky_base_loud&$ff,((swf_wacky_base_loud>>$08)&$7f)|$80,(swf_wacky_base_loud>>$0f)&$ff
00010BE3 0000 00                  M 	dc.b	(swfr_wacky_base_loud-1)&$ff,(((swfr_wacky_base_loud-1)>>$08)&$7f)|$80,((swfr_wacky_base_loud-1)>>$0f)&$ff
00010BE6 0000 00                  M 	dc.b	swf_stop&$ff,((swf_stop>>$08)&$7f)|$80,(swf_stop>>$0f)&$ff
00010BE9 0000 00                  M 	dc.b	(swfr_stop-1)&$ff,(((swfr_stop-1)>>$08)&$7f)|$80,((swfr_stop-1)>>$0f)&$ff
00010BEC 0014                     M 	dc.w	$0114-$100
00010BEE 0000                     M 	dc.w	0
00010BF0                            SampleList_End:
00010BF0                            
00010BF0                            ; -------------------------------------------------------------------------
00010BF0                            ; ===========================================================================
00010BF0                            ; ---------------------------------------------------------------------------
00010BF0                            ; Define volume envelopes and their data
00010BF0                            ; ---------------------------------------------------------------------------
00010BF0                            
00010BF0 =00000001                  __venv =	$01
00010BF0                            	include	"Sound/psg.asm"
00010BF0                            
00010BF0                            
00010BF0                            ; ------------------------------------------------------------------------
00010BF0                            ; AMPS PSG envelopes
00010BF0                            ; -------------------------------------------------------------------------
00010BF0                            
00010BF0                            ; -------------------------------------------------------------------------
00010BF0                            ; PSG envelope index
00010BF0                            ; -------------------------------------------------------------------------
00010BF0                            
00010BF0                            VolEnvs:
00010BF0                            	volenv	01
00010BF0                          M 	rept	narg
00010BF0 =00000001                M v01	=	__venv
00010BF0 0000 0000                M 	dc.l	vd01
00010BF4 =00000002                M __venv	=	__venv+1
00010BF4                          M 	shift
00010BF4                            	volenv	02
00010BF4                          M 	rept	narg
00010BF4 =00000002                M v02	=	__venv
00010BF4 0000 0000                M 	dc.l	vd02
00010BF8 =00000003                M __venv	=	__venv+1
00010BF8                          M 	shift
00010BF8                            	volenv	03
00010BF8                          M 	rept	narg
00010BF8 =00000003                M v03	=	__venv
00010BF8 0000 0000                M 	dc.l	vd03
00010BFC =00000004                M __venv	=	__venv+1
00010BFC                          M 	shift
00010BFC                            	volenv	04
00010BFC                          M 	rept	narg
00010BFC =00000004                M v04	=	__venv
00010BFC 0000 0000                M 	dc.l	vd04
00010C00 =00000005                M __venv	=	__venv+1
00010C00                          M 	shift
00010C00                            	volenv	05
00010C00                          M 	rept	narg
00010C00 =00000005                M v05	=	__venv
00010C00 0000 0000                M 	dc.l	vd05
00010C04 =00000006                M __venv	=	__venv+1
00010C04                          M 	shift
00010C04                            	volenv	06
00010C04                          M 	rept	narg
00010C04 =00000006                M v06	=	__venv
00010C04 0000 0000                M 	dc.l	vd06
00010C08 =00000007                M __venv	=	__venv+1
00010C08                          M 	shift
00010C08                            	volenv	07
00010C08                          M 	rept	narg
00010C08 =00000007                M v07	=	__venv
00010C08 0000 0000                M 	dc.l	vd07
00010C0C =00000008                M __venv	=	__venv+1
00010C0C                          M 	shift
00010C0C                            	volenv	08
00010C0C                          M 	rept	narg
00010C0C =00000008                M v08	=	__venv
00010C0C 0000 0000                M 	dc.l	vd08
00010C10 =00000009                M __venv	=	__venv+1
00010C10                          M 	shift
00010C10                            	volenv	09
00010C10                          M 	rept	narg
00010C10 =00000009                M v09	=	__venv
00010C10 0000 0000                M 	dc.l	vd09
00010C14 =0000000A                M __venv	=	__venv+1
00010C14                          M 	shift
00010C14                            	volenv	0A
00010C14                          M 	rept	narg
00010C14 =0000000A                M v0a	=	__venv
00010C14 0000 0000                M 	dc.l	vd0a
00010C18 =0000000B                M __venv	=	__venv+1
00010C18                          M 	shift
00010C18                            	volenv	0B
00010C18                          M 	rept	narg
00010C18 =0000000B                M v0b	=	__venv
00010C18 0000 0000                M 	dc.l	vd0b
00010C1C =0000000C                M __venv	=	__venv+1
00010C1C                          M 	shift
00010C1C                            	volenv	0C
00010C1C                          M 	rept	narg
00010C1C =0000000C                M v0c	=	__venv
00010C1C 0000 0000                M 	dc.l	vd0c
00010C20 =0000000D                M __venv	=	__venv+1
00010C20                          M 	shift
00010C20                            	volenv	0D
00010C20                          M 	rept	narg
00010C20 =0000000D                M v0d	=	__venv
00010C20 0000 0000                M 	dc.l	vd0d
00010C24 =0000000E                M __venv	=	__venv+1
00010C24                          M 	shift
00010C24                            VolEnvs_End:
00010C24                            	opt ae-
00010C24                            
00010C24                            ; -------------------------------------------------------------------------
00010C24                            ; PSG envelope data
00010C24                            ; -------------------------------------------------------------------------
00010C24                            
00010C24 0000 0001 0101 0202        vd01:	dc.b	$00, $00, $00, $01, $01, $01, $02, $02
00010C2C 0203 0303 0404 0405        	dc.b	$02, $03, $03, $03, $04, $04, $04, $05
00010C34 0505 0606 0607 82          	dc.b	$05, $05, $06, $06, $06, $07, eHold
00010C3B                            
00010C3B 0002 0406 0810 82          vd02:	dc.b	$00, $02, $04, $06, $08, $10, eHold
00010C42                            
00010C42 0000 0101 0202 0303        vd03:	dc.b	$00, $00, $01, $01, $02, $02, $03, $03
00010C4A 0404 0505 0606 0707        	dc.b	$04, $04, $05, $05, $06, $06, $07, $07
00010C52 82                         	dc.b	eHold
00010C53                            
00010C53 0000 0203 0404 0505        vd04:	dc.b	$00, $00, $02, $03, $04, $04, $05, $05
00010C5B 0506 82                    	dc.b	$05, $06, eHold
00010C5E                            
00010C5E 0000 0000 0000 0000        vd05:	dc.b	$00, $00, $00, $00, $00, $00, $00, $00
00010C66 0000 0101 0101 0101        	dc.b	$00, $00, $01, $01, $01, $01, $01, $01
00010C6E 0101 0101 0101 0101        	dc.b	$01, $01, $01, $01, $01, $01, $01, $01
00010C76 0202 0202 0202 0202        	dc.b	$02, $02, $02, $02, $02, $02, $02, $02
00010C7E 0303 0303 0303 0303        	dc.b	$03, $03, $03, $03, $03, $03, $03, $03
00010C86 0482                       	dc.b	$04, eHold
00010C88                            
00010C88 0303 0302 0202 0201        vd06:	dc.b	$03, $03, $03, $02, $02, $02, $02, $01
00010C90 0101 0000 0000 82          	dc.b	$01, $01, $00, $00, $00, $00, eHold
00010C97                            
00010C97 0000 0000 0000 0101        vd07:	dc.b	$00, $00, $00, $00, $00, $00, $01, $01
00010C9F 0101 0102 0202 0202        	dc.b	$01, $01, $01, $02, $02, $02, $02, $02
00010CA7 0303 0304 0404 0505        	dc.b	$03, $03, $03, $04, $04, $04, $05, $05
00010CAF 0506 0782                  	dc.b	$05, $06, $07, eHold
00010CB3                            
00010CB3 0000 0000 0001 0101        vd08:	dc.b	$00, $00, $00, $00, $00, $01, $01, $01
00010CBB 0101 0202 0202 0202        	dc.b	$01, $01, $02, $02, $02, $02, $02, $02
00010CC3 0303 0303 0304 0404        	dc.b	$03, $03, $03, $03, $03, $04, $04, $04
00010CCB 0404 0505 0505 0506        	dc.b	$04, $04, $05, $05, $05, $05, $05, $06
00010CD3 0606 0606 0707 0782        	dc.b	$06, $06, $06, $06, $07, $07, $07, eHold
00010CDB                            
00010CDB 0001 0203 0405 0607        vd09:	dc.b	$00, $01, $02, $03, $04, $05, $06, $07
00010CE3 0809 0A0B 0C0D 0E0F        	dc.b	$08, $09, $0A, $0B, $0C, $0D, $0E, $0F
00010CEB 82                         	dc.b	eHold
00010CEC                            	even
00010CEC                            
00010CEC 0000 0000 0000 0000        vd0A:	dc.b	$00, $00, $00, $00, $00, $00, $00, $00
00010CF4 0000 0101 0101 0101        	dc.b	$00, $00, $01, $01, $01, $01, $01, $01
00010CFC 0101 0101 0101 0101        	dc.b	$01, $01, $01, $01, $01, $01, $01, $01
00010D04 0101 0101 0101 0101        	dc.b	$01, $01, $01, $01, $01, $01, $01, $01
00010D0C 0101 0101 0101 0101        	dc.b	$01, $01, $01, $01, $01, $01, $01, $01
00010D14 0202 0202 0202 0202        	dc.b	$02, $02, $02, $02, $02, $02, $02, $02
00010D1C 0202 0303 0303 0303        	dc.b	$02, $02, $03, $03, $03, $03, $03, $03
00010D24 0303 0303 0304 82          	dc.b	$03, $03, $03, $03, $03, $04, eHold
00010D2C 00                         	even
00010D2C                            
00010D2C 0404 0403 0303 0202        vd0B:	dc.b	$04, $04, $04, $03, $03, $03, $02, $02
00010D34 0201 0101 0101 0101        	dc.b	$02, $01, $01, $01, $01, $01, $01, $01
00010D3C 0202 0202 0203 0303        	dc.b	$02, $02, $02, $02, $02, $03, $03, $03
00010D44 0303 0482                  	dc.b	$03, $03, $04, eHold
00010D48                            	even
00010D48                            
00010D48 0404 0303 0202 0101        vd0C:	dc.b	$04, $04, $03, $03, $02, $02, $01, $01
00010D50 0101 0101 0101 0101        	dc.b	$01, $01, $01, $01, $01, $01, $01, $01
00010D58 0101 0101 0101 0101        	dc.b	$01, $01, $01, $01, $01, $01, $01, $01
00010D60 0101 0202 0202 0202        	dc.b	$01, $01, $02, $02, $02, $02, $02, $02
00010D68 0202 0202 0202 0202        	dc.b	$02, $02, $02, $02, $02, $02, $02, $02
00010D70 0202 0202 0202 0303        	dc.b	$02, $02, $02, $02, $02, $02, $03, $03
00010D78 0303 0303 0303 0303        	dc.b	$03, $03, $03, $03, $03, $03, $03, $03
00010D80 0303 0303 0303 0303        	dc.b	$03, $03, $03, $03, $03, $03, $03, $03
00010D88 0303 0404 0404 0404        	dc.b	$03, $03, $04, $04, $04, $04, $04, $04
00010D90 0404 0404 0404 0404        	dc.b	$04, $04, $04, $04, $04, $04, $04, $04
00010D98 0404 0404 0404 0505        	dc.b	$04, $04, $04, $04, $04, $04, $05, $05
00010DA0 0505 0505 0505 0505        	dc.b	$05, $05, $05, $05, $05, $05, $05, $05
00010DA8 0505 0505 0505 0505        	dc.b	$05, $05, $05, $05, $05, $05, $05, $05
00010DB0 0505 0606 0606 0606        	dc.b	$05, $05, $06, $06, $06, $06, $06, $06
00010DB8 0606 0606 0606 0606        	dc.b	$06, $06, $06, $06, $06, $06, $06, $06
00010DC0 0606 0606 0606 0782        	dc.b	$06, $06, $06, $06, $06, $06, $07, eHold
00010DC8                            	even
00010DC8                            
00010DC8 0E0D 0C0B 0A09 0807        vd0D:	dc.b	$0E, $0D, $0C, $0B, $0A, $09, $08, $07
00010DD0 0605 0403 0201 000F        	dc.b	$06, $05, $04, $03, $02, $01, $00, $0F
00010DD8 82                         	dc.b	eHold
00010DDA 00                         	even
00010DDA                            
00010DDA                            ; -------------------------------------------------------------------------
00010DDA                            ; ===========================================================================
00010DDA                            ; ---------------------------------------------------------------------------
00010DDA                            ; Include music, sound effects and voice table
00010DDA                            ; ---------------------------------------------------------------------------
00010DDA                            
00010DDA                            VoiceBankMusic:
00010DDA =00000000                  sPatNum = 0
00010DDA                            	include "Sound/unipatchmus.asm"; include universal Voice banks
00010DDA                            
00010DDA                            
00010DDA                            ; ------------------------------------------------------------------------
00010DDA                            ; AMPS music patch list
00010DDA                            ; -------------------------------------------------------------------------
00010DDA                            
00010DDA                            	; Patch $00
00010DDA                            	; $2A
00010DDA                            	; $02, $32, $03, $01,	$5F, $5F, $9F, $9C
00010DDA                            	; $9F, $1F, $9F, $04,	$00, $00, $00, $07
00010DDA                            	; $15, $15, $15, $F5,	$05, $08, $0C, $1A
00010DDA                            	spAlgorithm	$02
00010DDA =00000001                M spatnum	=	spatnum+1
00010DDA =00000002                M spal	=	val
00010DDA                            	spFeedback	$05
00010DDA =00000005                M spfe	=	val
00010DDA                            	spDetune	$00, $00, $03, $00
00010DDA =00000000                M spde1	=	op1
00010DDA =00000000                M spde2	=	op2
00010DDA =00000003                M spde3	=	op3
00010DDA =00000000                M spde4	=	op4
00010DDA                            	spMultiple	$02, $03, $02, $01
00010DDA =00000002                M spmu1	=	op1
00010DDA =00000003                M spmu2	=	op2
00010DDA =00000002                M spmu3	=	op3
00010DDA =00000001                M spmu4	=	op4
00010DDA                            	spRateScale	$01, $02, $01, $02
00010DDA =00000001                M sprs1	=	op1
00010DDA =00000002                M sprs2	=	op2
00010DDA =00000001                M sprs3	=	op3
00010DDA =00000002                M sprs4	=	op4
00010DDA                            	spAttackRt	$1F, $1F, $1F, $1C
00010DDA =0000001F                M spar1	=	op1
00010DDA =0000001F                M spar2	=	op2
00010DDA =0000001F                M spar3	=	op3
00010DDA =0000001C                M spar4	=	op4
00010DDA                            	spAmpMod	$01, $01, $00, $00
00010DDA =00000001                M spam1	=	op1
00010DDA =00000001                M spam2	=	op2
00010DDA =00000000                M spam3	=	op3
00010DDA =00000000                M spam4	=	op4
00010DDA                            	spSustainRt	$1F, $1F, $1F, $04
00010DDA =0000001F                M spsr1	=	op1
00010DDA =0000001F                M spsr2	=	op2
00010DDA =0000001F                M spsr3	=	op3
00010DDA =00000004                M spsr4	=	op4
00010DDA                            	spDecayRt	$00, $00, $00, $07
00010DDA =00000000                M spdr1	=	op1
00010DDA =00000000                M spdr2	=	op2
00010DDA =00000000                M spdr3	=	op3
00010DDA =00000007                M spdr4	=	op4
00010DDA                            	spSustainLv	$01, $01, $01, $0F
00010DDA =00000001                M spsl1	=	op1
00010DDA =00000001                M spsl2	=	op2
00010DDA =00000001                M spsl3	=	op3
00010DDA =0000000F                M spsl4	=	op4
00010DDA                            	spReleaseRt	$05, $05, $05, $05
00010DDA =00000005                M sprr1	=	op1
00010DDA =00000005                M sprr2	=	op2
00010DDA =00000005                M sprr3	=	op3
00010DDA =00000005                M sprr4	=	op4
00010DDA                            	spSSGEG		$00, $00, $00, $00
00010DDA =00000000                M spss1	=	op1
00010DDA =00000000                M spss2	=	op2
00010DDA =00000000                M spss3	=	op3
00010DDA =00000000                M spss4	=	op4
00010DDA                            	spTotalLv	$05, $0C, $08, $1A
00010DDA =00000005                M sptl1	=	op1
00010DDA =0000000C                M sptl2	=	op2
00010DDA =00000008                M sptl3	=	op3
00010DDA =0000001A                M sptl4	=	op4
00010DDA 2A                       M 	dc.b	(spfe<<3)+spal
00010DDB =00000080                M sptlmask4	set	$80
00010DDB =00000000                M sptlmask2	set	((spal>=5)<<7)
00010DDB =00000000                M sptlmask3	set	((spal>=4)<<7)
00010DDB =00000000                M sptlmask1	set	((spal=7)<<7)
00010DDB 0232 0301                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010DDF 5F5F 9F9C                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010DE3 9F1F 9F04                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010DE7 0000 0007                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010DEB 1515 15F5                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010DEF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010DF3 0508 0C9A                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010DF7 4E41 54                  M 	dc.b	'NAT'
00010DFA                            
00010DFA                            	; Patch $01
00010DFA                            	; $38
00010DFA                            	; $01, $00, $01, $00,	$1F, $1F, $1F, $1F
00010DFA                            	; $00, $00, $00, $0D,	$0E, $00, $00, $1F
00010DFA                            	; $00, $00, $00, $30,	$1C, $11, $28, $04
00010DFA                            	spAlgorithm	$00
00010DFA =00000002                M spatnum	=	spatnum+1
00010DFA =00000000                M spal	=	val
00010DFA                            	spFeedback	$07
00010DFA =00000007                M spfe	=	val
00010DFA                            	spDetune	$00, $00, $00, $00
00010DFA =00000000                M spde1	=	op1
00010DFA =00000000                M spde2	=	op2
00010DFA =00000000                M spde3	=	op3
00010DFA =00000000                M spde4	=	op4
00010DFA                            	spMultiple	$01, $01, $00, $00
00010DFA =00000001                M spmu1	=	op1
00010DFA =00000001                M spmu2	=	op2
00010DFA =00000000                M spmu3	=	op3
00010DFA =00000000                M spmu4	=	op4
00010DFA                            	spRateScale	$00, $00, $00, $00
00010DFA =00000000                M sprs1	=	op1
00010DFA =00000000                M sprs2	=	op2
00010DFA =00000000                M sprs3	=	op3
00010DFA =00000000                M sprs4	=	op4
00010DFA                            	spAttackRt	$1F, $1F, $1F, $1F
00010DFA =0000001F                M spar1	=	op1
00010DFA =0000001F                M spar2	=	op2
00010DFA =0000001F                M spar3	=	op3
00010DFA =0000001F                M spar4	=	op4
00010DFA                            	spAmpMod	$00, $00, $00, $00
00010DFA =00000000                M spam1	=	op1
00010DFA =00000000                M spam2	=	op2
00010DFA =00000000                M spam3	=	op3
00010DFA =00000000                M spam4	=	op4
00010DFA                            	spSustainRt	$00, $00, $00, $0D
00010DFA =00000000                M spsr1	=	op1
00010DFA =00000000                M spsr2	=	op2
00010DFA =00000000                M spsr3	=	op3
00010DFA =0000000D                M spsr4	=	op4
00010DFA                            	spDecayRt	$0E, $00, $00, $1F
00010DFA =0000000E                M spdr1	=	op1
00010DFA =00000000                M spdr2	=	op2
00010DFA =00000000                M spdr3	=	op3
00010DFA =0000001F                M spdr4	=	op4
00010DFA                            	spSustainLv	$00, $00, $00, $03
00010DFA =00000000                M spsl1	=	op1
00010DFA =00000000                M spsl2	=	op2
00010DFA =00000000                M spsl3	=	op3
00010DFA =00000003                M spsl4	=	op4
00010DFA                            	spReleaseRt	$00, $00, $00, $00
00010DFA =00000000                M sprr1	=	op1
00010DFA =00000000                M sprr2	=	op2
00010DFA =00000000                M sprr3	=	op3
00010DFA =00000000                M sprr4	=	op4
00010DFA                            	spSSGEG		$00, $00, $00, $00
00010DFA =00000000                M spss1	=	op1
00010DFA =00000000                M spss2	=	op2
00010DFA =00000000                M spss3	=	op3
00010DFA =00000000                M spss4	=	op4
00010DFA                            	spTotalLv	$1C, $28, $11, $04
00010DFA =0000001C                M sptl1	=	op1
00010DFA =00000028                M sptl2	=	op2
00010DFA =00000011                M sptl3	=	op3
00010DFA =00000004                M sptl4	=	op4
00010DFA 38                       M 	dc.b	(spfe<<3)+spal
00010DFB =00000080                M sptlmask4	set	$80
00010DFB =00000000                M sptlmask2	set	((spal>=5)<<7)
00010DFB =00000000                M sptlmask3	set	((spal>=4)<<7)
00010DFB =00000000                M sptlmask1	set	((spal=7)<<7)
00010DFB 0100 0100                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010DFF 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010E03 0000 000D                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010E07 0E00 001F                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010E0B 0000 0030                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010E0F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010E13 1C11 2884                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010E17 4E41 54                  M 	dc.b	'NAT'
00010E1A                            
00010E1A                            	; Patch $02
00010E1A                            	; $21
00010E1A                            	; $00, $00, $00, $00,	$1F, $1F, $1F, $1F
00010E1A                            	; $0B, $08, $0F, $0B,	$01, $13, $1F, $1F
00010E1A                            	; $14, $B4, $44, $14,	$7F, $7F, $14, $04
00010E1A                            	spAlgorithm	$01
00010E1A =00000003                M spatnum	=	spatnum+1
00010E1A =00000001                M spal	=	val
00010E1A                            	spFeedback	$04
00010E1A =00000004                M spfe	=	val
00010E1A                            	spDetune	$00, $00, $00, $00
00010E1A =00000000                M spde1	=	op1
00010E1A =00000000                M spde2	=	op2
00010E1A =00000000                M spde3	=	op3
00010E1A =00000000                M spde4	=	op4
00010E1A                            	spMultiple	$00, $00, $00, $00
00010E1A =00000000                M spmu1	=	op1
00010E1A =00000000                M spmu2	=	op2
00010E1A =00000000                M spmu3	=	op3
00010E1A =00000000                M spmu4	=	op4
00010E1A                            	spRateScale	$00, $00, $00, $00
00010E1A =00000000                M sprs1	=	op1
00010E1A =00000000                M sprs2	=	op2
00010E1A =00000000                M sprs3	=	op3
00010E1A =00000000                M sprs4	=	op4
00010E1A                            	spAttackRt	$1F, $1F, $1F, $1F
00010E1A =0000001F                M spar1	=	op1
00010E1A =0000001F                M spar2	=	op2
00010E1A =0000001F                M spar3	=	op3
00010E1A =0000001F                M spar4	=	op4
00010E1A                            	spAmpMod	$00, $00, $00, $00
00010E1A =00000000                M spam1	=	op1
00010E1A =00000000                M spam2	=	op2
00010E1A =00000000                M spam3	=	op3
00010E1A =00000000                M spam4	=	op4
00010E1A                            	spSustainRt	$0B, $0F, $08, $0B
00010E1A =0000000B                M spsr1	=	op1
00010E1A =0000000F                M spsr2	=	op2
00010E1A =00000008                M spsr3	=	op3
00010E1A =0000000B                M spsr4	=	op4
00010E1A                            	spDecayRt	$01, $1F, $13, $1F
00010E1A =00000001                M spdr1	=	op1
00010E1A =0000001F                M spdr2	=	op2
00010E1A =00000013                M spdr3	=	op3
00010E1A =0000001F                M spdr4	=	op4
00010E1A                            	spSustainLv	$01, $04, $0B, $01
00010E1A =00000001                M spsl1	=	op1
00010E1A =00000004                M spsl2	=	op2
00010E1A =0000000B                M spsl3	=	op3
00010E1A =00000001                M spsl4	=	op4
00010E1A                            	spReleaseRt	$04, $04, $04, $04
00010E1A =00000004                M sprr1	=	op1
00010E1A =00000004                M sprr2	=	op2
00010E1A =00000004                M sprr3	=	op3
00010E1A =00000004                M sprr4	=	op4
00010E1A                            	spSSGEG		$00, $00, $00, $00
00010E1A =00000000                M spss1	=	op1
00010E1A =00000000                M spss2	=	op2
00010E1A =00000000                M spss3	=	op3
00010E1A =00000000                M spss4	=	op4
00010E1A                            	spTotalLv	$7F, $14, $7F, $04
00010E1A =0000007F                M sptl1	=	op1
00010E1A =00000014                M sptl2	=	op2
00010E1A =0000007F                M sptl3	=	op3
00010E1A =00000004                M sptl4	=	op4
00010E1A 21                       M 	dc.b	(spfe<<3)+spal
00010E1B =00000080                M sptlmask4	set	$80
00010E1B =00000000                M sptlmask2	set	((spal>=5)<<7)
00010E1B =00000000                M sptlmask3	set	((spal>=4)<<7)
00010E1B =00000000                M sptlmask1	set	((spal=7)<<7)
00010E1B 0000 0000                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010E1F 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010E23 0B08 0F0B                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010E27 0113 1F1F                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010E2B 14B4 4414                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010E2F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010E33 7F7F 1484                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010E37 4E41 54                  M 	dc.b	'NAT'
00010E3A                            
00010E3A                            	; Patch $03
00010E3A                            	; $34
00010E3A                            	; $74, $02, $6B, $02,	$1F, $53, $53, $11
00010E3A                            	; $11, $1F, $12, $01,	$00, $00, $00, $00
00010E3A                            	; $2B, $0B, $F9, $69,	$2A, $0C, $13, $04
00010E3A                            	spAlgorithm	$04
00010E3A =00000004                M spatnum	=	spatnum+1
00010E3A =00000004                M spal	=	val
00010E3A                            	spFeedback	$06
00010E3A =00000006                M spfe	=	val
00010E3A                            	spDetune	$07, $06, $00, $00
00010E3A =00000007                M spde1	=	op1
00010E3A =00000006                M spde2	=	op2
00010E3A =00000000                M spde3	=	op3
00010E3A =00000000                M spde4	=	op4
00010E3A                            	spMultiple	$04, $0B, $02, $02
00010E3A =00000004                M spmu1	=	op1
00010E3A =0000000B                M spmu2	=	op2
00010E3A =00000002                M spmu3	=	op3
00010E3A =00000002                M spmu4	=	op4
00010E3A                            	spRateScale	$00, $01, $01, $00
00010E3A =00000000                M sprs1	=	op1
00010E3A =00000001                M sprs2	=	op2
00010E3A =00000001                M sprs3	=	op3
00010E3A =00000000                M sprs4	=	op4
00010E3A                            	spAttackRt	$1F, $13, $13, $11
00010E3A =0000001F                M spar1	=	op1
00010E3A =00000013                M spar2	=	op2
00010E3A =00000013                M spar3	=	op3
00010E3A =00000011                M spar4	=	op4
00010E3A                            	spAmpMod	$00, $00, $00, $00
00010E3A =00000000                M spam1	=	op1
00010E3A =00000000                M spam2	=	op2
00010E3A =00000000                M spam3	=	op3
00010E3A =00000000                M spam4	=	op4
00010E3A                            	spSustainRt	$11, $12, $1F, $01
00010E3A =00000011                M spsr1	=	op1
00010E3A =00000012                M spsr2	=	op2
00010E3A =0000001F                M spsr3	=	op3
00010E3A =00000001                M spsr4	=	op4
00010E3A                            	spDecayRt	$00, $00, $00, $00
00010E3A =00000000                M spdr1	=	op1
00010E3A =00000000                M spdr2	=	op2
00010E3A =00000000                M spdr3	=	op3
00010E3A =00000000                M spdr4	=	op4
00010E3A                            	spSustainLv	$02, $0F, $00, $06
00010E3A =00000002                M spsl1	=	op1
00010E3A =0000000F                M spsl2	=	op2
00010E3A =00000000                M spsl3	=	op3
00010E3A =00000006                M spsl4	=	op4
00010E3A                            	spReleaseRt	$0B, $09, $0B, $09
00010E3A =0000000B                M sprr1	=	op1
00010E3A =00000009                M sprr2	=	op2
00010E3A =0000000B                M sprr3	=	op3
00010E3A =00000009                M sprr4	=	op4
00010E3A                            	spSSGEG		$00, $00, $00, $00
00010E3A =00000000                M spss1	=	op1
00010E3A =00000000                M spss2	=	op2
00010E3A =00000000                M spss3	=	op3
00010E3A =00000000                M spss4	=	op4
00010E3A                            	spTotalLv	$2A, $13, $0C, $04
00010E3A =0000002A                M sptl1	=	op1
00010E3A =00000013                M sptl2	=	op2
00010E3A =0000000C                M sptl3	=	op3
00010E3A =00000004                M sptl4	=	op4
00010E3A 34                       M 	dc.b	(spfe<<3)+spal
00010E3B =00000080                M sptlmask4	set	$80
00010E3B =00000000                M sptlmask2	set	((spal>=5)<<7)
00010E3B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00010E3B =00000000                M sptlmask1	set	((spal=7)<<7)
00010E3B 7402 6B02                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010E3F 1F53 5311                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010E43 111F 1201                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010E47 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010E4B 2B0B F969                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010E4F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010E53 2A8C 1384                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010E57 4E41 54                  M 	dc.b	'NAT'
00010E5A                            
00010E5A                            	; Patch $04
00010E5A                            	; $24
00010E5A                            	; $10, $01, $31, $11,	$9B, $5C, $1B, $5C
00010E5A                            	; $0A, $10, $0A, $10,	$03, $04, $03, $04
00010E5A                            	; $1F, $0C, $8F, $0C,	$06, $05, $04, $05
00010E5A                            	spAlgorithm	$04
00010E5A =00000005                M spatnum	=	spatnum+1
00010E5A =00000004                M spal	=	val
00010E5A                            	spFeedback	$04
00010E5A =00000004                M spfe	=	val
00010E5A                            	spDetune	$01, $03, $00, $01
00010E5A =00000001                M spde1	=	op1
00010E5A =00000003                M spde2	=	op2
00010E5A =00000000                M spde3	=	op3
00010E5A =00000001                M spde4	=	op4
00010E5A                            	spMultiple	$00, $01, $01, $01
00010E5A =00000000                M spmu1	=	op1
00010E5A =00000001                M spmu2	=	op2
00010E5A =00000001                M spmu3	=	op3
00010E5A =00000001                M spmu4	=	op4
00010E5A                            	spRateScale	$02, $00, $01, $01
00010E5A =00000002                M sprs1	=	op1
00010E5A =00000000                M sprs2	=	op2
00010E5A =00000001                M sprs3	=	op3
00010E5A =00000001                M sprs4	=	op4
00010E5A                            	spAttackRt	$1B, $1B, $1C, $1C
00010E5A =0000001B                M spar1	=	op1
00010E5A =0000001B                M spar2	=	op2
00010E5A =0000001C                M spar3	=	op3
00010E5A =0000001C                M spar4	=	op4
00010E5A                            	spAmpMod	$00, $00, $00, $00
00010E5A =00000000                M spam1	=	op1
00010E5A =00000000                M spam2	=	op2
00010E5A =00000000                M spam3	=	op3
00010E5A =00000000                M spam4	=	op4
00010E5A                            	spSustainRt	$0A, $0A, $10, $10
00010E5A =0000000A                M spsr1	=	op1
00010E5A =0000000A                M spsr2	=	op2
00010E5A =00000010                M spsr3	=	op3
00010E5A =00000010                M spsr4	=	op4
00010E5A                            	spDecayRt	$03, $03, $04, $04
00010E5A =00000003                M spdr1	=	op1
00010E5A =00000003                M spdr2	=	op2
00010E5A =00000004                M spdr3	=	op3
00010E5A =00000004                M spdr4	=	op4
00010E5A                            	spSustainLv	$01, $08, $00, $00
00010E5A =00000001                M spsl1	=	op1
00010E5A =00000008                M spsl2	=	op2
00010E5A =00000000                M spsl3	=	op3
00010E5A =00000000                M spsl4	=	op4
00010E5A                            	spReleaseRt	$0F, $0F, $0C, $0C
00010E5A =0000000F                M sprr1	=	op1
00010E5A =0000000F                M sprr2	=	op2
00010E5A =0000000C                M sprr3	=	op3
00010E5A =0000000C                M sprr4	=	op4
00010E5A                            	spSSGEG		$00, $00, $00, $00
00010E5A =00000000                M spss1	=	op1
00010E5A =00000000                M spss2	=	op2
00010E5A =00000000                M spss3	=	op3
00010E5A =00000000                M spss4	=	op4
00010E5A                            	spTotalLv	$06, $04, $05, $05
00010E5A =00000006                M sptl1	=	op1
00010E5A =00000004                M sptl2	=	op2
00010E5A =00000005                M sptl3	=	op3
00010E5A =00000005                M sptl4	=	op4
00010E5A 24                       M 	dc.b	(spfe<<3)+spal
00010E5B =00000080                M sptlmask4	set	$80
00010E5B =00000000                M sptlmask2	set	((spal>=5)<<7)
00010E5B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00010E5B =00000000                M sptlmask1	set	((spal=7)<<7)
00010E5B 1001 3111                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010E5F 9B5C 1B5C                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010E63 0A10 0A10                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010E67 0304 0304                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010E6B 1F0C 8F0C                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010E6F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010E73 0685 0485                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010E77 4E41 54                  M 	dc.b	'NAT'
00010E7A                            
00010E7A                            	; Patch $05
00010E7A                            	; $38
00010E7A                            	; $56, $15, $10, $72,	$1F, $1F, $1F, $1F
00010E7A                            	; $08, $08, $0A, $00,	$07, $07, $07, $06
00010E7A                            	; $F0, $F5, $F6, $F8,	$2C, $28, $12, $05
00010E7A                            	spAlgorithm	$00
00010E7A =00000006                M spatnum	=	spatnum+1
00010E7A =00000000                M spal	=	val
00010E7A                            	spFeedback	$07
00010E7A =00000007                M spfe	=	val
00010E7A                            	spDetune	$05, $01, $01, $07
00010E7A =00000005                M spde1	=	op1
00010E7A =00000001                M spde2	=	op2
00010E7A =00000001                M spde3	=	op3
00010E7A =00000007                M spde4	=	op4
00010E7A                            	spMultiple	$06, $00, $05, $02
00010E7A =00000006                M spmu1	=	op1
00010E7A =00000000                M spmu2	=	op2
00010E7A =00000005                M spmu3	=	op3
00010E7A =00000002                M spmu4	=	op4
00010E7A                            	spRateScale	$00, $00, $00, $00
00010E7A =00000000                M sprs1	=	op1
00010E7A =00000000                M sprs2	=	op2
00010E7A =00000000                M sprs3	=	op3
00010E7A =00000000                M sprs4	=	op4
00010E7A                            	spAttackRt	$1F, $1F, $1F, $1F
00010E7A =0000001F                M spar1	=	op1
00010E7A =0000001F                M spar2	=	op2
00010E7A =0000001F                M spar3	=	op3
00010E7A =0000001F                M spar4	=	op4
00010E7A                            	spAmpMod	$00, $00, $00, $00
00010E7A =00000000                M spam1	=	op1
00010E7A =00000000                M spam2	=	op2
00010E7A =00000000                M spam3	=	op3
00010E7A =00000000                M spam4	=	op4
00010E7A                            	spSustainRt	$08, $0A, $08, $00
00010E7A =00000008                M spsr1	=	op1
00010E7A =0000000A                M spsr2	=	op2
00010E7A =00000008                M spsr3	=	op3
00010E7A =00000000                M spsr4	=	op4
00010E7A                            	spDecayRt	$07, $07, $07, $06
00010E7A =00000007                M spdr1	=	op1
00010E7A =00000007                M spdr2	=	op2
00010E7A =00000007                M spdr3	=	op3
00010E7A =00000006                M spdr4	=	op4
00010E7A                            	spSustainLv	$0F, $0F, $0F, $0F
00010E7A =0000000F                M spsl1	=	op1
00010E7A =0000000F                M spsl2	=	op2
00010E7A =0000000F                M spsl3	=	op3
00010E7A =0000000F                M spsl4	=	op4
00010E7A                            	spReleaseRt	$00, $06, $05, $08
00010E7A =00000000                M sprr1	=	op1
00010E7A =00000006                M sprr2	=	op2
00010E7A =00000005                M sprr3	=	op3
00010E7A =00000008                M sprr4	=	op4
00010E7A                            	spSSGEG		$00, $00, $00, $00
00010E7A =00000000                M spss1	=	op1
00010E7A =00000000                M spss2	=	op2
00010E7A =00000000                M spss3	=	op3
00010E7A =00000000                M spss4	=	op4
00010E7A                            	spTotalLv	$2C, $12, $28, $05
00010E7A =0000002C                M sptl1	=	op1
00010E7A =00000012                M sptl2	=	op2
00010E7A =00000028                M sptl3	=	op3
00010E7A =00000005                M sptl4	=	op4
00010E7A 38                       M 	dc.b	(spfe<<3)+spal
00010E7B =00000080                M sptlmask4	set	$80
00010E7B =00000000                M sptlmask2	set	((spal>=5)<<7)
00010E7B =00000000                M sptlmask3	set	((spal>=4)<<7)
00010E7B =00000000                M sptlmask1	set	((spal=7)<<7)
00010E7B 5615 1072                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010E7F 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010E83 0808 0A00                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010E87 0707 0706                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010E8B F0F5 F6F8                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010E8F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010E93 2C28 1285                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010E97 4E41 54                  M 	dc.b	'NAT'
00010E9A                            
00010E9A                            	; Patch $06
00010E9A                            	; $02
00010E9A                            	; $71, $32, $06, $01,	$5F, $5E, $9F, $9C
00010E9A                            	; $02, $06, $05, $04,	$08, $07, $08, $07
00010E9A                            	; $F8, $F8, $F8, $F8,	$00, $10, $07, $05
00010E9A                            	spAlgorithm	$02
00010E9A =00000007                M spatnum	=	spatnum+1
00010E9A =00000002                M spal	=	val
00010E9A                            	spFeedback	$00
00010E9A =00000000                M spfe	=	val
00010E9A                            	spDetune	$07, $00, $03, $00
00010E9A =00000007                M spde1	=	op1
00010E9A =00000000                M spde2	=	op2
00010E9A =00000003                M spde3	=	op3
00010E9A =00000000                M spde4	=	op4
00010E9A                            	spMultiple	$01, $06, $02, $01
00010E9A =00000001                M spmu1	=	op1
00010E9A =00000006                M spmu2	=	op2
00010E9A =00000002                M spmu3	=	op3
00010E9A =00000001                M spmu4	=	op4
00010E9A                            	spRateScale	$01, $02, $01, $02
00010E9A =00000001                M sprs1	=	op1
00010E9A =00000002                M sprs2	=	op2
00010E9A =00000001                M sprs3	=	op3
00010E9A =00000002                M sprs4	=	op4
00010E9A                            	spAttackRt	$1F, $1F, $1E, $1C
00010E9A =0000001F                M spar1	=	op1
00010E9A =0000001F                M spar2	=	op2
00010E9A =0000001E                M spar3	=	op3
00010E9A =0000001C                M spar4	=	op4
00010E9A                            	spAmpMod	$00, $00, $00, $00
00010E9A =00000000                M spam1	=	op1
00010E9A =00000000                M spam2	=	op2
00010E9A =00000000                M spam3	=	op3
00010E9A =00000000                M spam4	=	op4
00010E9A                            	spSustainRt	$02, $05, $06, $04
00010E9A =00000002                M spsr1	=	op1
00010E9A =00000005                M spsr2	=	op2
00010E9A =00000006                M spsr3	=	op3
00010E9A =00000004                M spsr4	=	op4
00010E9A                            	spDecayRt	$08, $08, $07, $07
00010E9A =00000008                M spdr1	=	op1
00010E9A =00000008                M spdr2	=	op2
00010E9A =00000007                M spdr3	=	op3
00010E9A =00000007                M spdr4	=	op4
00010E9A                            	spSustainLv	$0F, $0F, $0F, $0F
00010E9A =0000000F                M spsl1	=	op1
00010E9A =0000000F                M spsl2	=	op2
00010E9A =0000000F                M spsl3	=	op3
00010E9A =0000000F                M spsl4	=	op4
00010E9A                            	spReleaseRt	$08, $08, $08, $08
00010E9A =00000008                M sprr1	=	op1
00010E9A =00000008                M sprr2	=	op2
00010E9A =00000008                M sprr3	=	op3
00010E9A =00000008                M sprr4	=	op4
00010E9A                            	spSSGEG		$00, $00, $00, $00
00010E9A =00000000                M spss1	=	op1
00010E9A =00000000                M spss2	=	op2
00010E9A =00000000                M spss3	=	op3
00010E9A =00000000                M spss4	=	op4
00010E9A                            	spTotalLv	$00, $07, $10, $05
00010E9A =00000000                M sptl1	=	op1
00010E9A =00000007                M sptl2	=	op2
00010E9A =00000010                M sptl3	=	op3
00010E9A =00000005                M sptl4	=	op4
00010E9A 02                       M 	dc.b	(spfe<<3)+spal
00010E9B =00000080                M sptlmask4	set	$80
00010E9B =00000000                M sptlmask2	set	((spal>=5)<<7)
00010E9B =00000000                M sptlmask3	set	((spal>=4)<<7)
00010E9B =00000000                M sptlmask1	set	((spal=7)<<7)
00010E9B 7132 0601                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010E9F 5F5E 9F9C                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010EA3 0206 0504                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010EA7 0807 0807                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010EAB F8F8 F8F8                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010EAF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010EB3 0010 0785                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010EB7 4E41 54                  M 	dc.b	'NAT'
00010EBA                            
00010EBA                            	; Patch $07
00010EBA                            	; $3D
00010EBA                            	; $01, $01, $01, $01,	$8E, $52, $14, $4C
00010EBA                            	; $08, $08, $0E, $03,	$00, $00, $00, $00
00010EBA                            	; $1F, $1F, $1F, $1F,	$1B, $05, $05, $05
00010EBA                            	spAlgorithm	$05
00010EBA =00000008                M spatnum	=	spatnum+1
00010EBA =00000005                M spal	=	val
00010EBA                            	spFeedback	$07
00010EBA =00000007                M spfe	=	val
00010EBA                            	spDetune	$00, $00, $00, $00
00010EBA =00000000                M spde1	=	op1
00010EBA =00000000                M spde2	=	op2
00010EBA =00000000                M spde3	=	op3
00010EBA =00000000                M spde4	=	op4
00010EBA                            	spMultiple	$01, $01, $01, $01
00010EBA =00000001                M spmu1	=	op1
00010EBA =00000001                M spmu2	=	op2
00010EBA =00000001                M spmu3	=	op3
00010EBA =00000001                M spmu4	=	op4
00010EBA                            	spRateScale	$02, $00, $01, $01
00010EBA =00000002                M sprs1	=	op1
00010EBA =00000000                M sprs2	=	op2
00010EBA =00000001                M sprs3	=	op3
00010EBA =00000001                M sprs4	=	op4
00010EBA                            	spAttackRt	$0E, $14, $12, $0C
00010EBA =0000000E                M spar1	=	op1
00010EBA =00000014                M spar2	=	op2
00010EBA =00000012                M spar3	=	op3
00010EBA =0000000C                M spar4	=	op4
00010EBA                            	spAmpMod	$00, $00, $00, $00
00010EBA =00000000                M spam1	=	op1
00010EBA =00000000                M spam2	=	op2
00010EBA =00000000                M spam3	=	op3
00010EBA =00000000                M spam4	=	op4
00010EBA                            	spSustainRt	$08, $0E, $08, $03
00010EBA =00000008                M spsr1	=	op1
00010EBA =0000000E                M spsr2	=	op2
00010EBA =00000008                M spsr3	=	op3
00010EBA =00000003                M spsr4	=	op4
00010EBA                            	spDecayRt	$00, $00, $00, $00
00010EBA =00000000                M spdr1	=	op1
00010EBA =00000000                M spdr2	=	op2
00010EBA =00000000                M spdr3	=	op3
00010EBA =00000000                M spdr4	=	op4
00010EBA                            	spSustainLv	$01, $01, $01, $01
00010EBA =00000001                M spsl1	=	op1
00010EBA =00000001                M spsl2	=	op2
00010EBA =00000001                M spsl3	=	op3
00010EBA =00000001                M spsl4	=	op4
00010EBA                            	spReleaseRt	$0F, $0F, $0F, $0F
00010EBA =0000000F                M sprr1	=	op1
00010EBA =0000000F                M sprr2	=	op2
00010EBA =0000000F                M sprr3	=	op3
00010EBA =0000000F                M sprr4	=	op4
00010EBA                            	spSSGEG		$00, $00, $00, $00
00010EBA =00000000                M spss1	=	op1
00010EBA =00000000                M spss2	=	op2
00010EBA =00000000                M spss3	=	op3
00010EBA =00000000                M spss4	=	op4
00010EBA                            	spTotalLv	$1B, $05, $05, $05
00010EBA =0000001B                M sptl1	=	op1
00010EBA =00000005                M sptl2	=	op2
00010EBA =00000005                M sptl3	=	op3
00010EBA =00000005                M sptl4	=	op4
00010EBA 3D                       M 	dc.b	(spfe<<3)+spal
00010EBB =00000080                M sptlmask4	set	$80
00010EBB =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
00010EBB =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00010EBB =00000000                M sptlmask1	set	((spal=7)<<7)
00010EBB 0101 0101                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010EBF 8E52 144C                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010EC3 0808 0E03                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010EC7 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010ECB 1F1F 1F1F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010ECF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010ED3 1B85 8585                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010ED7 4E41 54                  M 	dc.b	'NAT'
00010EDA                            
00010EDA                            	; Patch $08
00010EDA                            	; $0D
00010EDA                            	; $77, $65, $05, $15,	$1F, $5F, $5F, $5F
00010EDA                            	; $00, $10, $08, $10,	$00, $03, $05, $04
00010EDA                            	; $0F, $FC, $8C, $CC,	$1F, $05, $05, $05
00010EDA                            	spAlgorithm	$05
00010EDA =00000009                M spatnum	=	spatnum+1
00010EDA =00000005                M spal	=	val
00010EDA                            	spFeedback	$01
00010EDA =00000001                M spfe	=	val
00010EDA                            	spDetune	$07, $00, $06, $01
00010EDA =00000007                M spde1	=	op1
00010EDA =00000000                M spde2	=	op2
00010EDA =00000006                M spde3	=	op3
00010EDA =00000001                M spde4	=	op4
00010EDA                            	spMultiple	$07, $05, $05, $05
00010EDA =00000007                M spmu1	=	op1
00010EDA =00000005                M spmu2	=	op2
00010EDA =00000005                M spmu3	=	op3
00010EDA =00000005                M spmu4	=	op4
00010EDA                            	spRateScale	$00, $01, $01, $01
00010EDA =00000000                M sprs1	=	op1
00010EDA =00000001                M sprs2	=	op2
00010EDA =00000001                M sprs3	=	op3
00010EDA =00000001                M sprs4	=	op4
00010EDA                            	spAttackRt	$1F, $1F, $1F, $1F
00010EDA =0000001F                M spar1	=	op1
00010EDA =0000001F                M spar2	=	op2
00010EDA =0000001F                M spar3	=	op3
00010EDA =0000001F                M spar4	=	op4
00010EDA                            	spAmpMod	$00, $00, $00, $00
00010EDA =00000000                M spam1	=	op1
00010EDA =00000000                M spam2	=	op2
00010EDA =00000000                M spam3	=	op3
00010EDA =00000000                M spam4	=	op4
00010EDA                            	spSustainRt	$00, $08, $10, $10
00010EDA =00000000                M spsr1	=	op1
00010EDA =00000008                M spsr2	=	op2
00010EDA =00000010                M spsr3	=	op3
00010EDA =00000010                M spsr4	=	op4
00010EDA                            	spDecayRt	$00, $05, $03, $04
00010EDA =00000000                M spdr1	=	op1
00010EDA =00000005                M spdr2	=	op2
00010EDA =00000003                M spdr3	=	op3
00010EDA =00000004                M spdr4	=	op4
00010EDA                            	spSustainLv	$00, $08, $0F, $0C
00010EDA =00000000                M spsl1	=	op1
00010EDA =00000008                M spsl2	=	op2
00010EDA =0000000F                M spsl3	=	op3
00010EDA =0000000C                M spsl4	=	op4
00010EDA                            	spReleaseRt	$0F, $0C, $0C, $0C
00010EDA =0000000F                M sprr1	=	op1
00010EDA =0000000C                M sprr2	=	op2
00010EDA =0000000C                M sprr3	=	op3
00010EDA =0000000C                M sprr4	=	op4
00010EDA                            	spSSGEG		$00, $00, $00, $00
00010EDA =00000000                M spss1	=	op1
00010EDA =00000000                M spss2	=	op2
00010EDA =00000000                M spss3	=	op3
00010EDA =00000000                M spss4	=	op4
00010EDA                            	spTotalLv	$1F, $05, $05, $05
00010EDA =0000001F                M sptl1	=	op1
00010EDA =00000005                M sptl2	=	op2
00010EDA =00000005                M sptl3	=	op3
00010EDA =00000005                M sptl4	=	op4
00010EDA 0D                       M 	dc.b	(spfe<<3)+spal
00010EDB =00000080                M sptlmask4	set	$80
00010EDB =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
00010EDB =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00010EDB =00000000                M sptlmask1	set	((spal=7)<<7)
00010EDB 7765 0515                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010EDF 1F5F 5F5F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010EE3 0010 0810                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010EE7 0003 0504                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010EEB 0FFC 8CCC                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010EEF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010EF3 1F85 8585                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010EF7 4E41 54                  M 	dc.b	'NAT'
00010EFA                            
00010EFA                            	; Patch $09
00010EFA                            	; $32
00010EFA                            	; $71, $0D, $33, $01,	$5F, $99, $5F, $94
00010EFA                            	; $05, $05, $05, $07,	$02, $02, $02, $02
00010EFA                            	; $11, $11, $11, $72,	$23, $2D, $26, $05
00010EFA                            	spAlgorithm	$02
00010EFA =0000000A                M spatnum	=	spatnum+1
00010EFA =00000002                M spal	=	val
00010EFA                            	spFeedback	$06
00010EFA =00000006                M spfe	=	val
00010EFA                            	spDetune	$07, $03, $00, $00
00010EFA =00000007                M spde1	=	op1
00010EFA =00000003                M spde2	=	op2
00010EFA =00000000                M spde3	=	op3
00010EFA =00000000                M spde4	=	op4
00010EFA                            	spMultiple	$01, $03, $0D, $01
00010EFA =00000001                M spmu1	=	op1
00010EFA =00000003                M spmu2	=	op2
00010EFA =0000000D                M spmu3	=	op3
00010EFA =00000001                M spmu4	=	op4
00010EFA                            	spRateScale	$01, $01, $02, $02
00010EFA =00000001                M sprs1	=	op1
00010EFA =00000001                M sprs2	=	op2
00010EFA =00000002                M sprs3	=	op3
00010EFA =00000002                M sprs4	=	op4
00010EFA                            	spAttackRt	$1F, $1F, $19, $14
00010EFA =0000001F                M spar1	=	op1
00010EFA =0000001F                M spar2	=	op2
00010EFA =00000019                M spar3	=	op3
00010EFA =00000014                M spar4	=	op4
00010EFA                            	spAmpMod	$00, $00, $00, $00
00010EFA =00000000                M spam1	=	op1
00010EFA =00000000                M spam2	=	op2
00010EFA =00000000                M spam3	=	op3
00010EFA =00000000                M spam4	=	op4
00010EFA                            	spSustainRt	$05, $05, $05, $07
00010EFA =00000005                M spsr1	=	op1
00010EFA =00000005                M spsr2	=	op2
00010EFA =00000005                M spsr3	=	op3
00010EFA =00000007                M spsr4	=	op4
00010EFA                            	spDecayRt	$02, $02, $02, $02
00010EFA =00000002                M spdr1	=	op1
00010EFA =00000002                M spdr2	=	op2
00010EFA =00000002                M spdr3	=	op3
00010EFA =00000002                M spdr4	=	op4
00010EFA                            	spSustainLv	$01, $01, $01, $07
00010EFA =00000001                M spsl1	=	op1
00010EFA =00000001                M spsl2	=	op2
00010EFA =00000001                M spsl3	=	op3
00010EFA =00000007                M spsl4	=	op4
00010EFA                            	spReleaseRt	$01, $01, $01, $02
00010EFA =00000001                M sprr1	=	op1
00010EFA =00000001                M sprr2	=	op2
00010EFA =00000001                M sprr3	=	op3
00010EFA =00000002                M sprr4	=	op4
00010EFA                            	spSSGEG		$00, $00, $00, $00
00010EFA =00000000                M spss1	=	op1
00010EFA =00000000                M spss2	=	op2
00010EFA =00000000                M spss3	=	op3
00010EFA =00000000                M spss4	=	op4
00010EFA                            	spTotalLv	$23, $26, $2D, $05
00010EFA =00000023                M sptl1	=	op1
00010EFA =00000026                M sptl2	=	op2
00010EFA =0000002D                M sptl3	=	op3
00010EFA =00000005                M sptl4	=	op4
00010EFA 32                       M 	dc.b	(spfe<<3)+spal
00010EFB =00000080                M sptlmask4	set	$80
00010EFB =00000000                M sptlmask2	set	((spal>=5)<<7)
00010EFB =00000000                M sptlmask3	set	((spal>=4)<<7)
00010EFB =00000000                M sptlmask1	set	((spal=7)<<7)
00010EFB 710D 3301                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010EFF 5F99 5F94                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010F03 0505 0507                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010F07 0202 0202                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010F0B 1111 1172                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010F0F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010F13 232D 2685                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010F17 4E41 54                  M 	dc.b	'NAT'
00010F1A                            
00010F1A                            	; Patch $0A
00010F1A                            	; $08
00010F1A                            	; $0A, $70, $30, $00,	$1F, $1F, $5F, $5F
00010F1A                            	; $12, $0E, $0A, $0A,	$00, $04, $04, $03
00010F1A                            	; $2F, $2F, $2F, $2F,	$22, $2E, $13, $04
00010F1A                            	spAlgorithm	$00
00010F1A =0000000B                M spatnum	=	spatnum+1
00010F1A =00000000                M spal	=	val
00010F1A                            	spFeedback	$01
00010F1A =00000001                M spfe	=	val
00010F1A                            	spDetune	$00, $03, $07, $00
00010F1A =00000000                M spde1	=	op1
00010F1A =00000003                M spde2	=	op2
00010F1A =00000007                M spde3	=	op3
00010F1A =00000000                M spde4	=	op4
00010F1A                            	spMultiple	$0A, $00, $00, $00
00010F1A =0000000A                M spmu1	=	op1
00010F1A =00000000                M spmu2	=	op2
00010F1A =00000000                M spmu3	=	op3
00010F1A =00000000                M spmu4	=	op4
00010F1A                            	spRateScale	$00, $01, $00, $01
00010F1A =00000000                M sprs1	=	op1
00010F1A =00000001                M sprs2	=	op2
00010F1A =00000000                M sprs3	=	op3
00010F1A =00000001                M sprs4	=	op4
00010F1A                            	spAttackRt	$1F, $1F, $1F, $1F
00010F1A =0000001F                M spar1	=	op1
00010F1A =0000001F                M spar2	=	op2
00010F1A =0000001F                M spar3	=	op3
00010F1A =0000001F                M spar4	=	op4
00010F1A                            	spAmpMod	$00, $00, $00, $00
00010F1A =00000000                M spam1	=	op1
00010F1A =00000000                M spam2	=	op2
00010F1A =00000000                M spam3	=	op3
00010F1A =00000000                M spam4	=	op4
00010F1A                            	spSustainRt	$12, $0A, $0E, $0A
00010F1A =00000012                M spsr1	=	op1
00010F1A =0000000A                M spsr2	=	op2
00010F1A =0000000E                M spsr3	=	op3
00010F1A =0000000A                M spsr4	=	op4
00010F1A                            	spDecayRt	$00, $04, $04, $03
00010F1A =00000000                M spdr1	=	op1
00010F1A =00000004                M spdr2	=	op2
00010F1A =00000004                M spdr3	=	op3
00010F1A =00000003                M spdr4	=	op4
00010F1A                            	spSustainLv	$02, $02, $02, $02
00010F1A =00000002                M spsl1	=	op1
00010F1A =00000002                M spsl2	=	op2
00010F1A =00000002                M spsl3	=	op3
00010F1A =00000002                M spsl4	=	op4
00010F1A                            	spReleaseRt	$0F, $0F, $0F, $0F
00010F1A =0000000F                M sprr1	=	op1
00010F1A =0000000F                M sprr2	=	op2
00010F1A =0000000F                M sprr3	=	op3
00010F1A =0000000F                M sprr4	=	op4
00010F1A                            	spSSGEG		$00, $00, $00, $00
00010F1A =00000000                M spss1	=	op1
00010F1A =00000000                M spss2	=	op2
00010F1A =00000000                M spss3	=	op3
00010F1A =00000000                M spss4	=	op4
00010F1A                            	spTotalLv	$22, $13, $2E, $04
00010F1A =00000022                M sptl1	=	op1
00010F1A =00000013                M sptl2	=	op2
00010F1A =0000002E                M sptl3	=	op3
00010F1A =00000004                M sptl4	=	op4
00010F1A 08                       M 	dc.b	(spfe<<3)+spal
00010F1B =00000080                M sptlmask4	set	$80
00010F1B =00000000                M sptlmask2	set	((spal>=5)<<7)
00010F1B =00000000                M sptlmask3	set	((spal>=4)<<7)
00010F1B =00000000                M sptlmask1	set	((spal=7)<<7)
00010F1B 0A70 3000                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010F1F 1F1F 5F5F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010F23 120E 0A0A                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010F27 0004 0403                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010F2B 2F2F 2F2F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010F2F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010F33 222E 1384                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010F37 4E41 54                  M 	dc.b	'NAT'
00010F3A                            
00010F3A                            	; Patch $0B
00010F3A                            	; $28
00010F3A                            	; $39, $35, $30, $31,	$1F, $1F, $1F, $1F
00010F3A                            	; $0C, $0A, $07, $0A,	$07, $07, $07, $09
00010F3A                            	; $26, $16, $16, $F6,	$17, $32, $14, $05
00010F3A                            	spAlgorithm	$00
00010F3A =0000000C                M spatnum	=	spatnum+1
00010F3A =00000000                M spal	=	val
00010F3A                            	spFeedback	$05
00010F3A =00000005                M spfe	=	val
00010F3A                            	spDetune	$03, $03, $03, $03
00010F3A =00000003                M spde1	=	op1
00010F3A =00000003                M spde2	=	op2
00010F3A =00000003                M spde3	=	op3
00010F3A =00000003                M spde4	=	op4
00010F3A                            	spMultiple	$09, $00, $05, $01
00010F3A =00000009                M spmu1	=	op1
00010F3A =00000000                M spmu2	=	op2
00010F3A =00000005                M spmu3	=	op3
00010F3A =00000001                M spmu4	=	op4
00010F3A                            	spRateScale	$00, $00, $00, $00
00010F3A =00000000                M sprs1	=	op1
00010F3A =00000000                M sprs2	=	op2
00010F3A =00000000                M sprs3	=	op3
00010F3A =00000000                M sprs4	=	op4
00010F3A                            	spAttackRt	$1F, $1F, $1F, $1F
00010F3A =0000001F                M spar1	=	op1
00010F3A =0000001F                M spar2	=	op2
00010F3A =0000001F                M spar3	=	op3
00010F3A =0000001F                M spar4	=	op4
00010F3A                            	spAmpMod	$00, $00, $00, $00
00010F3A =00000000                M spam1	=	op1
00010F3A =00000000                M spam2	=	op2
00010F3A =00000000                M spam3	=	op3
00010F3A =00000000                M spam4	=	op4
00010F3A                            	spSustainRt	$0C, $07, $0A, $0A
00010F3A =0000000C                M spsr1	=	op1
00010F3A =00000007                M spsr2	=	op2
00010F3A =0000000A                M spsr3	=	op3
00010F3A =0000000A                M spsr4	=	op4
00010F3A                            	spDecayRt	$07, $07, $07, $09
00010F3A =00000007                M spdr1	=	op1
00010F3A =00000007                M spdr2	=	op2
00010F3A =00000007                M spdr3	=	op3
00010F3A =00000009                M spdr4	=	op4
00010F3A                            	spSustainLv	$02, $01, $01, $0F
00010F3A =00000002                M spsl1	=	op1
00010F3A =00000001                M spsl2	=	op2
00010F3A =00000001                M spsl3	=	op3
00010F3A =0000000F                M spsl4	=	op4
00010F3A                            	spReleaseRt	$06, $06, $06, $06
00010F3A =00000006                M sprr1	=	op1
00010F3A =00000006                M sprr2	=	op2
00010F3A =00000006                M sprr3	=	op3
00010F3A =00000006                M sprr4	=	op4
00010F3A                            	spSSGEG		$00, $00, $00, $00
00010F3A =00000000                M spss1	=	op1
00010F3A =00000000                M spss2	=	op2
00010F3A =00000000                M spss3	=	op3
00010F3A =00000000                M spss4	=	op4
00010F3A                            	spTotalLv	$17, $14, $32, $05
00010F3A =00000017                M sptl1	=	op1
00010F3A =00000014                M sptl2	=	op2
00010F3A =00000032                M sptl3	=	op3
00010F3A =00000005                M sptl4	=	op4
00010F3A 28                       M 	dc.b	(spfe<<3)+spal
00010F3B =00000080                M sptlmask4	set	$80
00010F3B =00000000                M sptlmask2	set	((spal>=5)<<7)
00010F3B =00000000                M sptlmask3	set	((spal>=4)<<7)
00010F3B =00000000                M sptlmask1	set	((spal=7)<<7)
00010F3B 3935 3031                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010F3F 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010F43 0C0A 070A                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010F47 0707 0709                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010F4B 2616 16F6                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010F4F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010F53 1732 1485                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010F57 4E41 54                  M 	dc.b	'NAT'
00010F5A                            
00010F5A                            	; Patch $0C
00010F5A                            	; $3D
00010F5A                            	; $6F, $22, $62, $22,	$1F, $1F, $1F, $1F
00010F5A                            	; $0F, $0F, $0F, $0F,	$08, $08, $08, $08
00010F5A                            	; $25, $25, $25, $25,	$1E, $36, $05, $09
00010F5A                            	spAlgorithm	$05
00010F5A =0000000D                M spatnum	=	spatnum+1
00010F5A =00000005                M spal	=	val
00010F5A                            	spFeedback	$07
00010F5A =00000007                M spfe	=	val
00010F5A                            	spDetune	$06, $06, $02, $02
00010F5A =00000006                M spde1	=	op1
00010F5A =00000006                M spde2	=	op2
00010F5A =00000002                M spde3	=	op3
00010F5A =00000002                M spde4	=	op4
00010F5A                            	spMultiple	$0F, $02, $02, $02
00010F5A =0000000F                M spmu1	=	op1
00010F5A =00000002                M spmu2	=	op2
00010F5A =00000002                M spmu3	=	op3
00010F5A =00000002                M spmu4	=	op4
00010F5A                            	spRateScale	$00, $00, $00, $00
00010F5A =00000000                M sprs1	=	op1
00010F5A =00000000                M sprs2	=	op2
00010F5A =00000000                M sprs3	=	op3
00010F5A =00000000                M sprs4	=	op4
00010F5A                            	spAttackRt	$1F, $1F, $1F, $1F
00010F5A =0000001F                M spar1	=	op1
00010F5A =0000001F                M spar2	=	op2
00010F5A =0000001F                M spar3	=	op3
00010F5A =0000001F                M spar4	=	op4
00010F5A                            	spAmpMod	$00, $00, $00, $00
00010F5A =00000000                M spam1	=	op1
00010F5A =00000000                M spam2	=	op2
00010F5A =00000000                M spam3	=	op3
00010F5A =00000000                M spam4	=	op4
00010F5A                            	spSustainRt	$0F, $0F, $0F, $0F
00010F5A =0000000F                M spsr1	=	op1
00010F5A =0000000F                M spsr2	=	op2
00010F5A =0000000F                M spsr3	=	op3
00010F5A =0000000F                M spsr4	=	op4
00010F5A                            	spDecayRt	$08, $08, $08, $08
00010F5A =00000008                M spdr1	=	op1
00010F5A =00000008                M spdr2	=	op2
00010F5A =00000008                M spdr3	=	op3
00010F5A =00000008                M spdr4	=	op4
00010F5A                            	spSustainLv	$02, $02, $02, $02
00010F5A =00000002                M spsl1	=	op1
00010F5A =00000002                M spsl2	=	op2
00010F5A =00000002                M spsl3	=	op3
00010F5A =00000002                M spsl4	=	op4
00010F5A                            	spReleaseRt	$05, $05, $05, $05
00010F5A =00000005                M sprr1	=	op1
00010F5A =00000005                M sprr2	=	op2
00010F5A =00000005                M sprr3	=	op3
00010F5A =00000005                M sprr4	=	op4
00010F5A                            	spSSGEG		$00, $00, $00, $00
00010F5A =00000000                M spss1	=	op1
00010F5A =00000000                M spss2	=	op2
00010F5A =00000000                M spss3	=	op3
00010F5A =00000000                M spss4	=	op4
00010F5A                            	spTotalLv	$1E, $05, $36, $09
00010F5A =0000001E                M sptl1	=	op1
00010F5A =00000005                M sptl2	=	op2
00010F5A =00000036                M sptl3	=	op3
00010F5A =00000009                M sptl4	=	op4
00010F5A 3D                       M 	dc.b	(spfe<<3)+spal
00010F5B =00000080                M sptlmask4	set	$80
00010F5B =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
00010F5B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00010F5B =00000000                M sptlmask1	set	((spal=7)<<7)
00010F5B 6F22 6222                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010F5F 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010F63 0F0F 0F0F                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010F67 0808 0808                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010F6B 2525 2525                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010F6F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010F73 1EB6 8589                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010F77 4E41 54                  M 	dc.b	'NAT'
00010F7A                            
00010F7A                            	; Patch $0D
00010F7A                            	; $06
00010F7A                            	; $61, $03, $32, $71,	$1F, $1F, $1F, $1F
00010F7A                            	; $00, $00, $00, $00,	$00, $00, $00, $00
00010F7A                            	; $07, $07, $07, $07,	$1E, $0A, $05, $05
00010F7A                            	spAlgorithm	$06
00010F7A =0000000E                M spatnum	=	spatnum+1
00010F7A =00000006                M spal	=	val
00010F7A                            	spFeedback	$00
00010F7A =00000000                M spfe	=	val
00010F7A                            	spDetune	$06, $03, $00, $07
00010F7A =00000006                M spde1	=	op1
00010F7A =00000003                M spde2	=	op2
00010F7A =00000000                M spde3	=	op3
00010F7A =00000007                M spde4	=	op4
00010F7A                            	spMultiple	$01, $02, $03, $01
00010F7A =00000001                M spmu1	=	op1
00010F7A =00000002                M spmu2	=	op2
00010F7A =00000003                M spmu3	=	op3
00010F7A =00000001                M spmu4	=	op4
00010F7A                            	spRateScale	$00, $00, $00, $00
00010F7A =00000000                M sprs1	=	op1
00010F7A =00000000                M sprs2	=	op2
00010F7A =00000000                M sprs3	=	op3
00010F7A =00000000                M sprs4	=	op4
00010F7A                            	spAttackRt	$1F, $1F, $1F, $1F
00010F7A =0000001F                M spar1	=	op1
00010F7A =0000001F                M spar2	=	op2
00010F7A =0000001F                M spar3	=	op3
00010F7A =0000001F                M spar4	=	op4
00010F7A                            	spAmpMod	$00, $00, $00, $00
00010F7A =00000000                M spam1	=	op1
00010F7A =00000000                M spam2	=	op2
00010F7A =00000000                M spam3	=	op3
00010F7A =00000000                M spam4	=	op4
00010F7A                            	spSustainRt	$00, $00, $00, $00
00010F7A =00000000                M spsr1	=	op1
00010F7A =00000000                M spsr2	=	op2
00010F7A =00000000                M spsr3	=	op3
00010F7A =00000000                M spsr4	=	op4
00010F7A                            	spDecayRt	$00, $00, $00, $00
00010F7A =00000000                M spdr1	=	op1
00010F7A =00000000                M spdr2	=	op2
00010F7A =00000000                M spdr3	=	op3
00010F7A =00000000                M spdr4	=	op4
00010F7A                            	spSustainLv	$00, $00, $00, $00
00010F7A =00000000                M spsl1	=	op1
00010F7A =00000000                M spsl2	=	op2
00010F7A =00000000                M spsl3	=	op3
00010F7A =00000000                M spsl4	=	op4
00010F7A                            	spReleaseRt	$07, $07, $07, $07
00010F7A =00000007                M sprr1	=	op1
00010F7A =00000007                M sprr2	=	op2
00010F7A =00000007                M sprr3	=	op3
00010F7A =00000007                M sprr4	=	op4
00010F7A                            	spSSGEG		$00, $00, $00, $00
00010F7A =00000000                M spss1	=	op1
00010F7A =00000000                M spss2	=	op2
00010F7A =00000000                M spss3	=	op3
00010F7A =00000000                M spss4	=	op4
00010F7A                            	spTotalLv	$1E, $05, $0A, $05
00010F7A =0000001E                M sptl1	=	op1
00010F7A =00000005                M sptl2	=	op2
00010F7A =0000000A                M sptl3	=	op3
00010F7A =00000005                M sptl4	=	op4
00010F7A 06                       M 	dc.b	(spfe<<3)+spal
00010F7B =00000080                M sptlmask4	set	$80
00010F7B =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
00010F7B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00010F7B =00000000                M sptlmask1	set	((spal=7)<<7)
00010F7B 6103 3271                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010F7F 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010F83 0000 0000                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010F87 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010F8B 0707 0707                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010F8F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010F93 1E8A 8585                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010F97 4E41 54                  M 	dc.b	'NAT'
00010F9A                            
00010F9A                            	; Patch $0E
00010F9A                            	; $24
00010F9A                            	; $31, $71, $61, $16,	$11, $55, $14, $55
00010F9A                            	; $1F, $01, $00, $04,	$00, $00, $00, $01
00010F9A                            	; $11, $97, $05, $A7,	$04, $05, $00, $05
00010F9A                            	spAlgorithm	$04
00010F9A =0000000F                M spatnum	=	spatnum+1
00010F9A =00000004                M spal	=	val
00010F9A                            	spFeedback	$04
00010F9A =00000004                M spfe	=	val
00010F9A                            	spDetune	$03, $06, $07, $01
00010F9A =00000003                M spde1	=	op1
00010F9A =00000006                M spde2	=	op2
00010F9A =00000007                M spde3	=	op3
00010F9A =00000001                M spde4	=	op4
00010F9A                            	spMultiple	$01, $01, $01, $06
00010F9A =00000001                M spmu1	=	op1
00010F9A =00000001                M spmu2	=	op2
00010F9A =00000001                M spmu3	=	op3
00010F9A =00000006                M spmu4	=	op4
00010F9A                            	spRateScale	$00, $00, $01, $01
00010F9A =00000000                M sprs1	=	op1
00010F9A =00000000                M sprs2	=	op2
00010F9A =00000001                M sprs3	=	op3
00010F9A =00000001                M sprs4	=	op4
00010F9A                            	spAttackRt	$11, $14, $15, $15
00010F9A =00000011                M spar1	=	op1
00010F9A =00000014                M spar2	=	op2
00010F9A =00000015                M spar3	=	op3
00010F9A =00000015                M spar4	=	op4
00010F9A                            	spAmpMod	$00, $00, $00, $00
00010F9A =00000000                M spam1	=	op1
00010F9A =00000000                M spam2	=	op2
00010F9A =00000000                M spam3	=	op3
00010F9A =00000000                M spam4	=	op4
00010F9A                            	spSustainRt	$1F, $00, $01, $04
00010F9A =0000001F                M spsr1	=	op1
00010F9A =00000000                M spsr2	=	op2
00010F9A =00000001                M spsr3	=	op3
00010F9A =00000004                M spsr4	=	op4
00010F9A                            	spDecayRt	$00, $00, $00, $01
00010F9A =00000000                M spdr1	=	op1
00010F9A =00000000                M spdr2	=	op2
00010F9A =00000000                M spdr3	=	op3
00010F9A =00000001                M spdr4	=	op4
00010F9A                            	spSustainLv	$01, $00, $09, $0A
00010F9A =00000001                M spsl1	=	op1
00010F9A =00000000                M spsl2	=	op2
00010F9A =00000009                M spsl3	=	op3
00010F9A =0000000A                M spsl4	=	op4
00010F9A                            	spReleaseRt	$01, $05, $07, $07
00010F9A =00000001                M sprr1	=	op1
00010F9A =00000005                M sprr2	=	op2
00010F9A =00000007                M sprr3	=	op3
00010F9A =00000007                M sprr4	=	op4
00010F9A                            	spSSGEG		$00, $00, $00, $00
00010F9A =00000000                M spss1	=	op1
00010F9A =00000000                M spss2	=	op2
00010F9A =00000000                M spss3	=	op3
00010F9A =00000000                M spss4	=	op4
00010F9A                            	spTotalLv	$04, $00, $05, $05
00010F9A =00000004                M sptl1	=	op1
00010F9A =00000000                M sptl2	=	op2
00010F9A =00000005                M sptl3	=	op3
00010F9A =00000005                M sptl4	=	op4
00010F9A 24                       M 	dc.b	(spfe<<3)+spal
00010F9B =00000080                M sptlmask4	set	$80
00010F9B =00000000                M sptlmask2	set	((spal>=5)<<7)
00010F9B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00010F9B =00000000                M sptlmask1	set	((spal=7)<<7)
00010F9B 3171 6116                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010F9F 1155 1455                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010FA3 1F01 0004                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010FA7 0000 0001                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010FAB 1197 05A7                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010FAF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010FB3 0485 0085                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010FB7 4E41 54                  M 	dc.b	'NAT'
00010FBA                            
00010FBA                            	; Patch $0F
00010FBA                            	; $36
00010FBA                            	; $72, $02, $01, $01,	$D8, $47, $8D, $87
00010FBA                            	; $01, $04, $01, $05,	$00, $05, $07, $00
00010FBA                            	; $51, $14, $15, $14,	$11, $05, $7F, $7F
00010FBA                            	spAlgorithm	$06
00010FBA =00000010                M spatnum	=	spatnum+1
00010FBA =00000006                M spal	=	val
00010FBA                            	spFeedback	$06
00010FBA =00000006                M spfe	=	val
00010FBA                            	spDetune	$07, $00, $00, $00
00010FBA =00000007                M spde1	=	op1
00010FBA =00000000                M spde2	=	op2
00010FBA =00000000                M spde3	=	op3
00010FBA =00000000                M spde4	=	op4
00010FBA                            	spMultiple	$02, $01, $02, $01
00010FBA =00000002                M spmu1	=	op1
00010FBA =00000001                M spmu2	=	op2
00010FBA =00000002                M spmu3	=	op3
00010FBA =00000001                M spmu4	=	op4
00010FBA                            	spRateScale	$03, $02, $01, $02
00010FBA =00000003                M sprs1	=	op1
00010FBA =00000002                M sprs2	=	op2
00010FBA =00000001                M sprs3	=	op3
00010FBA =00000002                M sprs4	=	op4
00010FBA                            	spAttackRt	$18, $0D, $07, $07
00010FBA =00000018                M spar1	=	op1
00010FBA =0000000D                M spar2	=	op2
00010FBA =00000007                M spar3	=	op3
00010FBA =00000007                M spar4	=	op4
00010FBA                            	spAmpMod	$00, $00, $00, $00
00010FBA =00000000                M spam1	=	op1
00010FBA =00000000                M spam2	=	op2
00010FBA =00000000                M spam3	=	op3
00010FBA =00000000                M spam4	=	op4
00010FBA                            	spSustainRt	$01, $01, $04, $05
00010FBA =00000001                M spsr1	=	op1
00010FBA =00000001                M spsr2	=	op2
00010FBA =00000004                M spsr3	=	op3
00010FBA =00000005                M spsr4	=	op4
00010FBA                            	spDecayRt	$00, $07, $05, $00
00010FBA =00000000                M spdr1	=	op1
00010FBA =00000007                M spdr2	=	op2
00010FBA =00000005                M spdr3	=	op3
00010FBA =00000000                M spdr4	=	op4
00010FBA                            	spSustainLv	$05, $01, $01, $01
00010FBA =00000005                M spsl1	=	op1
00010FBA =00000001                M spsl2	=	op2
00010FBA =00000001                M spsl3	=	op3
00010FBA =00000001                M spsl4	=	op4
00010FBA                            	spReleaseRt	$01, $05, $04, $04
00010FBA =00000001                M sprr1	=	op1
00010FBA =00000005                M sprr2	=	op2
00010FBA =00000004                M sprr3	=	op3
00010FBA =00000004                M sprr4	=	op4
00010FBA                            	spSSGEG		$00, $00, $00, $00
00010FBA =00000000                M spss1	=	op1
00010FBA =00000000                M spss2	=	op2
00010FBA =00000000                M spss3	=	op3
00010FBA =00000000                M spss4	=	op4
00010FBA                            	spTotalLv	$11, $7F, $05, $7F
00010FBA =00000011                M sptl1	=	op1
00010FBA =0000007F                M sptl2	=	op2
00010FBA =00000005                M sptl3	=	op3
00010FBA =0000007F                M sptl4	=	op4
00010FBA 36                       M 	dc.b	(spfe<<3)+spal
00010FBB =00000080                M sptlmask4	set	$80
00010FBB =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
00010FBB =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00010FBB =00000000                M sptlmask1	set	((spal=7)<<7)
00010FBB 7202 0101                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010FBF D847 8D87                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010FC3 0104 0105                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010FC7 0005 0700                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010FCB 5114 1514                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010FCF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010FD3 1185 FFFF                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010FD7 4E41 54                  M 	dc.b	'NAT'
00010FDA                            
00010FDA                            	; Patch $10
00010FDA                            	; $24
00010FDA                            	; $10, $01, $31, $11,	$9B, $5C, $1B, $5C
00010FDA                            	; $0A, $10, $0A, $10,	$03, $04, $03, $04
00010FDA                            	; $1F, $0C, $8F, $0C,	$06, $05, $04, $05
00010FDA                            	spAlgorithm	$04
00010FDA =00000011                M spatnum	=	spatnum+1
00010FDA =00000004                M spal	=	val
00010FDA                            	spFeedback	$04
00010FDA =00000004                M spfe	=	val
00010FDA                            	spDetune	$01, $03, $00, $01
00010FDA =00000001                M spde1	=	op1
00010FDA =00000003                M spde2	=	op2
00010FDA =00000000                M spde3	=	op3
00010FDA =00000001                M spde4	=	op4
00010FDA                            	spMultiple	$00, $01, $01, $01
00010FDA =00000000                M spmu1	=	op1
00010FDA =00000001                M spmu2	=	op2
00010FDA =00000001                M spmu3	=	op3
00010FDA =00000001                M spmu4	=	op4
00010FDA                            	spRateScale	$02, $00, $01, $01
00010FDA =00000002                M sprs1	=	op1
00010FDA =00000000                M sprs2	=	op2
00010FDA =00000001                M sprs3	=	op3
00010FDA =00000001                M sprs4	=	op4
00010FDA                            	spAttackRt	$1B, $1B, $1C, $1C
00010FDA =0000001B                M spar1	=	op1
00010FDA =0000001B                M spar2	=	op2
00010FDA =0000001C                M spar3	=	op3
00010FDA =0000001C                M spar4	=	op4
00010FDA                            	spAmpMod	$00, $00, $00, $00
00010FDA =00000000                M spam1	=	op1
00010FDA =00000000                M spam2	=	op2
00010FDA =00000000                M spam3	=	op3
00010FDA =00000000                M spam4	=	op4
00010FDA                            	spSustainRt	$0A, $0A, $10, $10
00010FDA =0000000A                M spsr1	=	op1
00010FDA =0000000A                M spsr2	=	op2
00010FDA =00000010                M spsr3	=	op3
00010FDA =00000010                M spsr4	=	op4
00010FDA                            	spDecayRt	$03, $03, $04, $04
00010FDA =00000003                M spdr1	=	op1
00010FDA =00000003                M spdr2	=	op2
00010FDA =00000004                M spdr3	=	op3
00010FDA =00000004                M spdr4	=	op4
00010FDA                            	spSustainLv	$01, $08, $00, $00
00010FDA =00000001                M spsl1	=	op1
00010FDA =00000008                M spsl2	=	op2
00010FDA =00000000                M spsl3	=	op3
00010FDA =00000000                M spsl4	=	op4
00010FDA                            	spReleaseRt	$0F, $0F, $0C, $0C
00010FDA =0000000F                M sprr1	=	op1
00010FDA =0000000F                M sprr2	=	op2
00010FDA =0000000C                M sprr3	=	op3
00010FDA =0000000C                M sprr4	=	op4
00010FDA                            	spSSGEG		$00, $00, $00, $00
00010FDA =00000000                M spss1	=	op1
00010FDA =00000000                M spss2	=	op2
00010FDA =00000000                M spss3	=	op3
00010FDA =00000000                M spss4	=	op4
00010FDA                            	spTotalLv	$06, $04, $05, $05
00010FDA =00000006                M sptl1	=	op1
00010FDA =00000004                M sptl2	=	op2
00010FDA =00000005                M sptl3	=	op3
00010FDA =00000005                M sptl4	=	op4
00010FDA 24                       M 	dc.b	(spfe<<3)+spal
00010FDB =00000080                M sptlmask4	set	$80
00010FDB =00000000                M sptlmask2	set	((spal>=5)<<7)
00010FDB =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00010FDB =00000000                M sptlmask1	set	((spal=7)<<7)
00010FDB 1001 3111                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010FDF 9B5C 1B5C                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00010FE3 0A10 0A10                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00010FE7 0304 0304                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00010FEB 1F0C 8F0C                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00010FEF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00010FF3 0685 0485                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00010FF7 4E41 54                  M 	dc.b	'NAT'
00010FFA                            
00010FFA                            	; Patch $11
00010FFA                            	; $23
00010FFA                            	; $30, $75, $30, $70,	$08, $1F, $1D, $5B
00010FFA                            	; $8B, $16, $96, $95,	$01, $00, $00, $00
00010FFA                            	; $8B, $3A, $3A, $3A,	$05, $0D, $0B, $02
00010FFA                            	spAlgorithm	$03
00010FFA =00000012                M spatnum	=	spatnum+1
00010FFA =00000003                M spal	=	val
00010FFA                            	spFeedback	$04
00010FFA =00000004                M spfe	=	val
00010FFA                            	spDetune	$03, $03, $07, $07
00010FFA =00000003                M spde1	=	op1
00010FFA =00000003                M spde2	=	op2
00010FFA =00000007                M spde3	=	op3
00010FFA =00000007                M spde4	=	op4
00010FFA                            	spMultiple	$00, $00, $05, $00
00010FFA =00000000                M spmu1	=	op1
00010FFA =00000000                M spmu2	=	op2
00010FFA =00000005                M spmu3	=	op3
00010FFA =00000000                M spmu4	=	op4
00010FFA                            	spRateScale	$00, $00, $00, $01
00010FFA =00000000                M sprs1	=	op1
00010FFA =00000000                M sprs2	=	op2
00010FFA =00000000                M sprs3	=	op3
00010FFA =00000001                M sprs4	=	op4
00010FFA                            	spAttackRt	$08, $1D, $1F, $1B
00010FFA =00000008                M spar1	=	op1
00010FFA =0000001D                M spar2	=	op2
00010FFA =0000001F                M spar3	=	op3
00010FFA =0000001B                M spar4	=	op4
00010FFA                            	spAmpMod	$01, $01, $00, $01
00010FFA =00000001                M spam1	=	op1
00010FFA =00000001                M spam2	=	op2
00010FFA =00000000                M spam3	=	op3
00010FFA =00000001                M spam4	=	op4
00010FFA                            	spSustainRt	$0B, $16, $16, $15
00010FFA =0000000B                M spsr1	=	op1
00010FFA =00000016                M spsr2	=	op2
00010FFA =00000016                M spsr3	=	op3
00010FFA =00000015                M spsr4	=	op4
00010FFA                            	spDecayRt	$01, $00, $00, $00
00010FFA =00000001                M spdr1	=	op1
00010FFA =00000000                M spdr2	=	op2
00010FFA =00000000                M spdr3	=	op3
00010FFA =00000000                M spdr4	=	op4
00010FFA                            	spSustainLv	$08, $03, $03, $03
00010FFA =00000008                M spsl1	=	op1
00010FFA =00000003                M spsl2	=	op2
00010FFA =00000003                M spsl3	=	op3
00010FFA =00000003                M spsl4	=	op4
00010FFA                            	spReleaseRt	$0B, $0A, $0A, $0A
00010FFA =0000000B                M sprr1	=	op1
00010FFA =0000000A                M sprr2	=	op2
00010FFA =0000000A                M sprr3	=	op3
00010FFA =0000000A                M sprr4	=	op4
00010FFA                            	spSSGEG		$00, $00, $00, $00
00010FFA =00000000                M spss1	=	op1
00010FFA =00000000                M spss2	=	op2
00010FFA =00000000                M spss3	=	op3
00010FFA =00000000                M spss4	=	op4
00010FFA                            	spTotalLv	$05, $0B, $0D, $02
00010FFA =00000005                M sptl1	=	op1
00010FFA =0000000B                M sptl2	=	op2
00010FFA =0000000D                M sptl3	=	op3
00010FFA =00000002                M sptl4	=	op4
00010FFA 23                       M 	dc.b	(spfe<<3)+spal
00010FFB =00000080                M sptlmask4	set	$80
00010FFB =00000000                M sptlmask2	set	((spal>=5)<<7)
00010FFB =00000000                M sptlmask3	set	((spal>=4)<<7)
00010FFB =00000000                M sptlmask1	set	((spal=7)<<7)
00010FFB 3075 3070                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00010FFF 081F 1D5B                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011003 8B16 9695                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011007 0100 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001100B 8B3A 3A3A                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001100F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011013 050D 0B82                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011017 4E41 54                  M 	dc.b	'NAT'
0001101A                            
0001101A                            	; Patch $12
0001101A                            	; $2C
0001101A                            	; $70, $32, $00, $00,	$9F, $1F, $5F, $5E
0001101A                            	; $1A, $15, $0C, $05,	$08, $06, $02, $09
0001101A                            	; $28, $AA, $BA, $8A,	$08, $05, $0B, $05
0001101A                            	spAlgorithm	$04
0001101A =00000013                M spatnum	=	spatnum+1
0001101A =00000004                M spal	=	val
0001101A                            	spFeedback	$05
0001101A =00000005                M spfe	=	val
0001101A                            	spDetune	$07, $00, $03, $00
0001101A =00000007                M spde1	=	op1
0001101A =00000000                M spde2	=	op2
0001101A =00000003                M spde3	=	op3
0001101A =00000000                M spde4	=	op4
0001101A                            	spMultiple	$00, $00, $02, $00
0001101A =00000000                M spmu1	=	op1
0001101A =00000000                M spmu2	=	op2
0001101A =00000002                M spmu3	=	op3
0001101A =00000000                M spmu4	=	op4
0001101A                            	spRateScale	$02, $01, $00, $01
0001101A =00000002                M sprs1	=	op1
0001101A =00000001                M sprs2	=	op2
0001101A =00000000                M sprs3	=	op3
0001101A =00000001                M sprs4	=	op4
0001101A                            	spAttackRt	$1F, $1F, $1F, $1E
0001101A =0000001F                M spar1	=	op1
0001101A =0000001F                M spar2	=	op2
0001101A =0000001F                M spar3	=	op3
0001101A =0000001E                M spar4	=	op4
0001101A                            	spAmpMod	$00, $00, $00, $00
0001101A =00000000                M spam1	=	op1
0001101A =00000000                M spam2	=	op2
0001101A =00000000                M spam3	=	op3
0001101A =00000000                M spam4	=	op4
0001101A                            	spSustainRt	$1A, $0C, $15, $05
0001101A =0000001A                M spsr1	=	op1
0001101A =0000000C                M spsr2	=	op2
0001101A =00000015                M spsr3	=	op3
0001101A =00000005                M spsr4	=	op4
0001101A                            	spDecayRt	$08, $02, $06, $09
0001101A =00000008                M spdr1	=	op1
0001101A =00000002                M spdr2	=	op2
0001101A =00000006                M spdr3	=	op3
0001101A =00000009                M spdr4	=	op4
0001101A                            	spSustainLv	$02, $0B, $0A, $08
0001101A =00000002                M spsl1	=	op1
0001101A =0000000B                M spsl2	=	op2
0001101A =0000000A                M spsl3	=	op3
0001101A =00000008                M spsl4	=	op4
0001101A                            	spReleaseRt	$08, $0A, $0A, $0A
0001101A =00000008                M sprr1	=	op1
0001101A =0000000A                M sprr2	=	op2
0001101A =0000000A                M sprr3	=	op3
0001101A =0000000A                M sprr4	=	op4
0001101A                            	spSSGEG		$00, $00, $00, $00
0001101A =00000000                M spss1	=	op1
0001101A =00000000                M spss2	=	op2
0001101A =00000000                M spss3	=	op3
0001101A =00000000                M spss4	=	op4
0001101A                            	spTotalLv	$08, $0B, $05, $05
0001101A =00000008                M sptl1	=	op1
0001101A =0000000B                M sptl2	=	op2
0001101A =00000005                M sptl3	=	op3
0001101A =00000005                M sptl4	=	op4
0001101A 2C                       M 	dc.b	(spfe<<3)+spal
0001101B =00000080                M sptlmask4	set	$80
0001101B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001101B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
0001101B =00000000                M sptlmask1	set	((spal=7)<<7)
0001101B 7032 0000                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001101F 9F1F 5F5E                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011023 1A15 0C05                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011027 0806 0209                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001102B 28AA BA8A                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001102F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011033 0885 0B85                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011037 4E41 54                  M 	dc.b	'NAT'
0001103A                            
0001103A                            	; Patch $13
0001103A                            	; $35
0001103A                            	; $77, $03, $74, $32,	$1A, $14, $56, $17
0001103A                            	; $97, $9F, $9D, $9F,	$13, $0F, $0F, $0E
0001103A                            	; $7C, $1D, $1D, $1D,	$13, $04, $02, $06
0001103A                            	spAlgorithm	$05
0001103A =00000014                M spatnum	=	spatnum+1
0001103A =00000005                M spal	=	val
0001103A                            	spFeedback	$06
0001103A =00000006                M spfe	=	val
0001103A                            	spDetune	$07, $07, $00, $03
0001103A =00000007                M spde1	=	op1
0001103A =00000007                M spde2	=	op2
0001103A =00000000                M spde3	=	op3
0001103A =00000003                M spde4	=	op4
0001103A                            	spMultiple	$07, $04, $03, $02
0001103A =00000007                M spmu1	=	op1
0001103A =00000004                M spmu2	=	op2
0001103A =00000003                M spmu3	=	op3
0001103A =00000002                M spmu4	=	op4
0001103A                            	spRateScale	$00, $01, $00, $00
0001103A =00000000                M sprs1	=	op1
0001103A =00000001                M sprs2	=	op2
0001103A =00000000                M sprs3	=	op3
0001103A =00000000                M sprs4	=	op4
0001103A                            	spAttackRt	$1A, $16, $14, $17
0001103A =0000001A                M spar1	=	op1
0001103A =00000016                M spar2	=	op2
0001103A =00000014                M spar3	=	op3
0001103A =00000017                M spar4	=	op4
0001103A                            	spAmpMod	$01, $01, $01, $01
0001103A =00000001                M spam1	=	op1
0001103A =00000001                M spam2	=	op2
0001103A =00000001                M spam3	=	op3
0001103A =00000001                M spam4	=	op4
0001103A                            	spSustainRt	$17, $1D, $1F, $1F
0001103A =00000017                M spsr1	=	op1
0001103A =0000001D                M spsr2	=	op2
0001103A =0000001F                M spsr3	=	op3
0001103A =0000001F                M spsr4	=	op4
0001103A                            	spDecayRt	$13, $0F, $0F, $0E
0001103A =00000013                M spdr1	=	op1
0001103A =0000000F                M spdr2	=	op2
0001103A =0000000F                M spdr3	=	op3
0001103A =0000000E                M spdr4	=	op4
0001103A                            	spSustainLv	$07, $01, $01, $01
0001103A =00000007                M spsl1	=	op1
0001103A =00000001                M spsl2	=	op2
0001103A =00000001                M spsl3	=	op3
0001103A =00000001                M spsl4	=	op4
0001103A                            	spReleaseRt	$0C, $0D, $0D, $0D
0001103A =0000000C                M sprr1	=	op1
0001103A =0000000D                M sprr2	=	op2
0001103A =0000000D                M sprr3	=	op3
0001103A =0000000D                M sprr4	=	op4
0001103A                            	spSSGEG		$00, $00, $00, $00
0001103A =00000000                M spss1	=	op1
0001103A =00000000                M spss2	=	op2
0001103A =00000000                M spss3	=	op3
0001103A =00000000                M spss4	=	op4
0001103A                            	spTotalLv	$13, $02, $04, $06
0001103A =00000013                M sptl1	=	op1
0001103A =00000002                M sptl2	=	op2
0001103A =00000004                M sptl3	=	op3
0001103A =00000006                M sptl4	=	op4
0001103A 35                       M 	dc.b	(spfe<<3)+spal
0001103B =00000080                M sptlmask4	set	$80
0001103B =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
0001103B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
0001103B =00000000                M sptlmask1	set	((spal=7)<<7)
0001103B 7703 7432                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001103F 1A14 5617                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011043 979F 9D9F                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011047 130F 0F0E                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001104B 7C1D 1D1D                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001104F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011053 1384 8286                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011057 4E41 54                  M 	dc.b	'NAT'
0001105A                            
0001105A                            	; Patch $14
0001105A                            	; $35
0001105A                            	; $21, $31, $20, $15,	$8E, $9B, $95, $94
0001105A                            	; $00, $05, $00, $80,	$01, $02, $02, $02
0001105A                            	; $47, $37, $19, $07,	$19, $05, $0E, $08
0001105A                            	spAlgorithm	$05
0001105A =00000015                M spatnum	=	spatnum+1
0001105A =00000005                M spal	=	val
0001105A                            	spFeedback	$06
0001105A =00000006                M spfe	=	val
0001105A                            	spDetune	$02, $02, $03, $01
0001105A =00000002                M spde1	=	op1
0001105A =00000002                M spde2	=	op2
0001105A =00000003                M spde3	=	op3
0001105A =00000001                M spde4	=	op4
0001105A                            	spMultiple	$01, $00, $01, $05
0001105A =00000001                M spmu1	=	op1
0001105A =00000000                M spmu2	=	op2
0001105A =00000001                M spmu3	=	op3
0001105A =00000005                M spmu4	=	op4
0001105A                            	spRateScale	$02, $02, $02, $02
0001105A =00000002                M sprs1	=	op1
0001105A =00000002                M sprs2	=	op2
0001105A =00000002                M sprs3	=	op3
0001105A =00000002                M sprs4	=	op4
0001105A                            	spAttackRt	$0E, $15, $1B, $14
0001105A =0000000E                M spar1	=	op1
0001105A =00000015                M spar2	=	op2
0001105A =0000001B                M spar3	=	op3
0001105A =00000014                M spar4	=	op4
0001105A                            	spAmpMod	$00, $00, $00, $01
0001105A =00000000                M spam1	=	op1
0001105A =00000000                M spam2	=	op2
0001105A =00000000                M spam3	=	op3
0001105A =00000001                M spam4	=	op4
0001105A                            	spSustainRt	$00, $00, $05, $00
0001105A =00000000                M spsr1	=	op1
0001105A =00000000                M spsr2	=	op2
0001105A =00000005                M spsr3	=	op3
0001105A =00000000                M spsr4	=	op4
0001105A                            	spDecayRt	$01, $02, $02, $02
0001105A =00000001                M spdr1	=	op1
0001105A =00000002                M spdr2	=	op2
0001105A =00000002                M spdr3	=	op3
0001105A =00000002                M spdr4	=	op4
0001105A                            	spSustainLv	$04, $01, $03, $00
0001105A =00000004                M spsl1	=	op1
0001105A =00000001                M spsl2	=	op2
0001105A =00000003                M spsl3	=	op3
0001105A =00000000                M spsl4	=	op4
0001105A                            	spReleaseRt	$07, $09, $07, $07
0001105A =00000007                M sprr1	=	op1
0001105A =00000009                M sprr2	=	op2
0001105A =00000007                M sprr3	=	op3
0001105A =00000007                M sprr4	=	op4
0001105A                            	spSSGEG		$00, $00, $00, $00
0001105A =00000000                M spss1	=	op1
0001105A =00000000                M spss2	=	op2
0001105A =00000000                M spss3	=	op3
0001105A =00000000                M spss4	=	op4
0001105A                            	spTotalLv	$19, $0E, $05, $08
0001105A =00000019                M sptl1	=	op1
0001105A =0000000E                M sptl2	=	op2
0001105A =00000005                M sptl3	=	op3
0001105A =00000008                M sptl4	=	op4
0001105A 35                       M 	dc.b	(spfe<<3)+spal
0001105B =00000080                M sptlmask4	set	$80
0001105B =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
0001105B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
0001105B =00000000                M sptlmask1	set	((spal=7)<<7)
0001105B 2131 2015                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001105F 8E9B 9594                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011063 0005 0080                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011067 0102 0202                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001106B 4737 1907                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001106F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011073 1985 8E88                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011077 4E41 54                  M 	dc.b	'NAT'
0001107A                            
0001107A                            	; Patch $15
0001107A                            	; $35
0001107A                            	; $22, $32, $21, $34,	$8E, $9B, $8F, $94
0001107A                            	; $00, $05, $00, $80,	$01, $02, $02, $02
0001107A                            	; $07, $36, $17, $08,	$15, $12, $14, $05
0001107A                            	spAlgorithm	$05
0001107A =00000016                M spatnum	=	spatnum+1
0001107A =00000005                M spal	=	val
0001107A                            	spFeedback	$06
0001107A =00000006                M spfe	=	val
0001107A                            	spDetune	$02, $02, $03, $03
0001107A =00000002                M spde1	=	op1
0001107A =00000002                M spde2	=	op2
0001107A =00000003                M spde3	=	op3
0001107A =00000003                M spde4	=	op4
0001107A                            	spMultiple	$02, $01, $02, $04
0001107A =00000002                M spmu1	=	op1
0001107A =00000001                M spmu2	=	op2
0001107A =00000002                M spmu3	=	op3
0001107A =00000004                M spmu4	=	op4
0001107A                            	spRateScale	$02, $02, $02, $02
0001107A =00000002                M sprs1	=	op1
0001107A =00000002                M sprs2	=	op2
0001107A =00000002                M sprs3	=	op3
0001107A =00000002                M sprs4	=	op4
0001107A                            	spAttackRt	$0E, $0F, $1B, $14
0001107A =0000000E                M spar1	=	op1
0001107A =0000000F                M spar2	=	op2
0001107A =0000001B                M spar3	=	op3
0001107A =00000014                M spar4	=	op4
0001107A                            	spAmpMod	$00, $00, $00, $01
0001107A =00000000                M spam1	=	op1
0001107A =00000000                M spam2	=	op2
0001107A =00000000                M spam3	=	op3
0001107A =00000001                M spam4	=	op4
0001107A                            	spSustainRt	$00, $00, $05, $00
0001107A =00000000                M spsr1	=	op1
0001107A =00000000                M spsr2	=	op2
0001107A =00000005                M spsr3	=	op3
0001107A =00000000                M spsr4	=	op4
0001107A                            	spDecayRt	$01, $02, $02, $02
0001107A =00000001                M spdr1	=	op1
0001107A =00000002                M spdr2	=	op2
0001107A =00000002                M spdr3	=	op3
0001107A =00000002                M spdr4	=	op4
0001107A                            	spSustainLv	$00, $01, $03, $00
0001107A =00000000                M spsl1	=	op1
0001107A =00000001                M spsl2	=	op2
0001107A =00000003                M spsl3	=	op3
0001107A =00000000                M spsl4	=	op4
0001107A                            	spReleaseRt	$07, $07, $06, $08
0001107A =00000007                M sprr1	=	op1
0001107A =00000007                M sprr2	=	op2
0001107A =00000006                M sprr3	=	op3
0001107A =00000008                M sprr4	=	op4
0001107A                            	spSSGEG		$00, $00, $00, $00
0001107A =00000000                M spss1	=	op1
0001107A =00000000                M spss2	=	op2
0001107A =00000000                M spss3	=	op3
0001107A =00000000                M spss4	=	op4
0001107A                            	spTotalLv	$15, $14, $12, $05
0001107A =00000015                M sptl1	=	op1
0001107A =00000014                M sptl2	=	op2
0001107A =00000012                M sptl3	=	op3
0001107A =00000005                M sptl4	=	op4
0001107A 35                       M 	dc.b	(spfe<<3)+spal
0001107B =00000080                M sptlmask4	set	$80
0001107B =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
0001107B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
0001107B =00000000                M sptlmask1	set	((spal=7)<<7)
0001107B 2232 2134                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001107F 8E9B 8F94                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011083 0005 0080                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011087 0102 0202                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001108B 0736 1708                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001108F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011093 1592 9485                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011097 4E41 54                  M 	dc.b	'NAT'
0001109A                            
0001109A                            	; Patch $16
0001109A                            	; $2B
0001109A                            	; $31, $32, $35, $31,	$1F, $59, $9E, $5E
0001109A                            	; $06, $80, $80, $85,	$01, $17, $12, $0A
0001109A                            	; $AA, $AF, $F9, $FC,	$0E, $12, $46, $05
0001109A                            	spAlgorithm	$03
0001109A =00000017                M spatnum	=	spatnum+1
0001109A =00000003                M spal	=	val
0001109A                            	spFeedback	$05
0001109A =00000005                M spfe	=	val
0001109A                            	spDetune	$03, $03, $03, $03
0001109A =00000003                M spde1	=	op1
0001109A =00000003                M spde2	=	op2
0001109A =00000003                M spde3	=	op3
0001109A =00000003                M spde4	=	op4
0001109A                            	spMultiple	$01, $05, $02, $01
0001109A =00000001                M spmu1	=	op1
0001109A =00000005                M spmu2	=	op2
0001109A =00000002                M spmu3	=	op3
0001109A =00000001                M spmu4	=	op4
0001109A                            	spRateScale	$00, $02, $01, $01
0001109A =00000000                M sprs1	=	op1
0001109A =00000002                M sprs2	=	op2
0001109A =00000001                M sprs3	=	op3
0001109A =00000001                M sprs4	=	op4
0001109A                            	spAttackRt	$1F, $1E, $19, $1E
0001109A =0000001F                M spar1	=	op1
0001109A =0000001E                M spar2	=	op2
0001109A =00000019                M spar3	=	op3
0001109A =0000001E                M spar4	=	op4
0001109A                            	spAmpMod	$00, $01, $01, $01
0001109A =00000000                M spam1	=	op1
0001109A =00000001                M spam2	=	op2
0001109A =00000001                M spam3	=	op3
0001109A =00000001                M spam4	=	op4
0001109A                            	spSustainRt	$06, $00, $00, $05
0001109A =00000006                M spsr1	=	op1
0001109A =00000000                M spsr2	=	op2
0001109A =00000000                M spsr3	=	op3
0001109A =00000005                M spsr4	=	op4
0001109A                            	spDecayRt	$01, $12, $17, $0A
0001109A =00000001                M spdr1	=	op1
0001109A =00000012                M spdr2	=	op2
0001109A =00000017                M spdr3	=	op3
0001109A =0000000A                M spdr4	=	op4
0001109A                            	spSustainLv	$0A, $0F, $0A, $0F
0001109A =0000000A                M spsl1	=	op1
0001109A =0000000F                M spsl2	=	op2
0001109A =0000000A                M spsl3	=	op3
0001109A =0000000F                M spsl4	=	op4
0001109A                            	spReleaseRt	$0A, $09, $0F, $0C
0001109A =0000000A                M sprr1	=	op1
0001109A =00000009                M sprr2	=	op2
0001109A =0000000F                M sprr3	=	op3
0001109A =0000000C                M sprr4	=	op4
0001109A                            	spSSGEG		$00, $00, $00, $00
0001109A =00000000                M spss1	=	op1
0001109A =00000000                M spss2	=	op2
0001109A =00000000                M spss3	=	op3
0001109A =00000000                M spss4	=	op4
0001109A                            	spTotalLv	$0E, $46, $12, $05
0001109A =0000000E                M sptl1	=	op1
0001109A =00000046                M sptl2	=	op2
0001109A =00000012                M sptl3	=	op3
0001109A =00000005                M sptl4	=	op4
0001109A 2B                       M 	dc.b	(spfe<<3)+spal
0001109B =00000080                M sptlmask4	set	$80
0001109B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001109B =00000000                M sptlmask3	set	((spal>=4)<<7)
0001109B =00000000                M sptlmask1	set	((spal=7)<<7)
0001109B 3132 3531                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001109F 1F59 9E5E                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000110A3 0680 8085                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000110A7 0117 120A                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000110AB AAAF F9FC                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000110AF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000110B3 0E12 4685                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000110B7 4E41 54                  M 	dc.b	'NAT'
000110BA                            
000110BA                            	; Patch $17
000110BA                            	; $04
000110BA                            	; $00, $00, $01, $02,	$9F, $1F, $9F, $1F
000110BA                            	; $8A, $8A, $91, $94,	$0E, $0A, $0E, $0E
000110BA                            	; $F8, $48, $F8, $F8,	$17, $04, $07, $04
000110BA                            	spAlgorithm	$04
000110BA =00000018                M spatnum	=	spatnum+1
000110BA =00000004                M spal	=	val
000110BA                            	spFeedback	$00
000110BA =00000000                M spfe	=	val
000110BA                            	spDetune	$00, $00, $00, $00
000110BA =00000000                M spde1	=	op1
000110BA =00000000                M spde2	=	op2
000110BA =00000000                M spde3	=	op3
000110BA =00000000                M spde4	=	op4
000110BA                            	spMultiple	$00, $01, $00, $02
000110BA =00000000                M spmu1	=	op1
000110BA =00000001                M spmu2	=	op2
000110BA =00000000                M spmu3	=	op3
000110BA =00000002                M spmu4	=	op4
000110BA                            	spRateScale	$02, $02, $00, $00
000110BA =00000002                M sprs1	=	op1
000110BA =00000002                M sprs2	=	op2
000110BA =00000000                M sprs3	=	op3
000110BA =00000000                M sprs4	=	op4
000110BA                            	spAttackRt	$1F, $1F, $1F, $1F
000110BA =0000001F                M spar1	=	op1
000110BA =0000001F                M spar2	=	op2
000110BA =0000001F                M spar3	=	op3
000110BA =0000001F                M spar4	=	op4
000110BA                            	spAmpMod	$01, $01, $01, $01
000110BA =00000001                M spam1	=	op1
000110BA =00000001                M spam2	=	op2
000110BA =00000001                M spam3	=	op3
000110BA =00000001                M spam4	=	op4
000110BA                            	spSustainRt	$0A, $11, $0A, $14
000110BA =0000000A                M spsr1	=	op1
000110BA =00000011                M spsr2	=	op2
000110BA =0000000A                M spsr3	=	op3
000110BA =00000014                M spsr4	=	op4
000110BA                            	spDecayRt	$0E, $0E, $0A, $0E
000110BA =0000000E                M spdr1	=	op1
000110BA =0000000E                M spdr2	=	op2
000110BA =0000000A                M spdr3	=	op3
000110BA =0000000E                M spdr4	=	op4
000110BA                            	spSustainLv	$0F, $0F, $04, $0F
000110BA =0000000F                M spsl1	=	op1
000110BA =0000000F                M spsl2	=	op2
000110BA =00000004                M spsl3	=	op3
000110BA =0000000F                M spsl4	=	op4
000110BA                            	spReleaseRt	$08, $08, $08, $08
000110BA =00000008                M sprr1	=	op1
000110BA =00000008                M sprr2	=	op2
000110BA =00000008                M sprr3	=	op3
000110BA =00000008                M sprr4	=	op4
000110BA                            	spSSGEG		$00, $00, $00, $00
000110BA =00000000                M spss1	=	op1
000110BA =00000000                M spss2	=	op2
000110BA =00000000                M spss3	=	op3
000110BA =00000000                M spss4	=	op4
000110BA                            	spTotalLv	$17, $07, $04, $04
000110BA =00000017                M sptl1	=	op1
000110BA =00000007                M sptl2	=	op2
000110BA =00000004                M sptl3	=	op3
000110BA =00000004                M sptl4	=	op4
000110BA 04                       M 	dc.b	(spfe<<3)+spal
000110BB =00000080                M sptlmask4	set	$80
000110BB =00000000                M sptlmask2	set	((spal>=5)<<7)
000110BB =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
000110BB =00000000                M sptlmask1	set	((spal=7)<<7)
000110BB 0000 0102                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000110BF 9F1F 9F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000110C3 8A8A 9194                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000110C7 0E0A 0E0E                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000110CB F848 F8F8                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000110CF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000110D3 1784 0784                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000110D7 4E41 54                  M 	dc.b	'NAT'
000110DA                            
000110DA                            	; Patch $18
000110DA                            	; $3A
000110DA                            	; $71, $0C, $33, $01,	$5F, $5F, $5F, $5F
000110DA                            	; $84, $89, $84, $8A,	$00, $01, $03, $06
000110DA                            	; $15, $12, $16, $28,	$25, $2F, $25, $03
000110DA                            	spAlgorithm	$02
000110DA =00000019                M spatnum	=	spatnum+1
000110DA =00000002                M spal	=	val
000110DA                            	spFeedback	$07
000110DA =00000007                M spfe	=	val
000110DA                            	spDetune	$07, $03, $00, $00
000110DA =00000007                M spde1	=	op1
000110DA =00000003                M spde2	=	op2
000110DA =00000000                M spde3	=	op3
000110DA =00000000                M spde4	=	op4
000110DA                            	spMultiple	$01, $03, $0C, $01
000110DA =00000001                M spmu1	=	op1
000110DA =00000003                M spmu2	=	op2
000110DA =0000000C                M spmu3	=	op3
000110DA =00000001                M spmu4	=	op4
000110DA                            	spRateScale	$01, $01, $01, $01
000110DA =00000001                M sprs1	=	op1
000110DA =00000001                M sprs2	=	op2
000110DA =00000001                M sprs3	=	op3
000110DA =00000001                M sprs4	=	op4
000110DA                            	spAttackRt	$1F, $1F, $1F, $1F
000110DA =0000001F                M spar1	=	op1
000110DA =0000001F                M spar2	=	op2
000110DA =0000001F                M spar3	=	op3
000110DA =0000001F                M spar4	=	op4
000110DA                            	spAmpMod	$01, $01, $01, $01
000110DA =00000001                M spam1	=	op1
000110DA =00000001                M spam2	=	op2
000110DA =00000001                M spam3	=	op3
000110DA =00000001                M spam4	=	op4
000110DA                            	spSustainRt	$04, $04, $09, $0A
000110DA =00000004                M spsr1	=	op1
000110DA =00000004                M spsr2	=	op2
000110DA =00000009                M spsr3	=	op3
000110DA =0000000A                M spsr4	=	op4
000110DA                            	spDecayRt	$00, $03, $01, $06
000110DA =00000000                M spdr1	=	op1
000110DA =00000003                M spdr2	=	op2
000110DA =00000001                M spdr3	=	op3
000110DA =00000006                M spdr4	=	op4
000110DA                            	spSustainLv	$01, $01, $01, $02
000110DA =00000001                M spsl1	=	op1
000110DA =00000001                M spsl2	=	op2
000110DA =00000001                M spsl3	=	op3
000110DA =00000002                M spsl4	=	op4
000110DA                            	spReleaseRt	$05, $06, $02, $08
000110DA =00000005                M sprr1	=	op1
000110DA =00000006                M sprr2	=	op2
000110DA =00000002                M sprr3	=	op3
000110DA =00000008                M sprr4	=	op4
000110DA                            	spSSGEG		$00, $00, $00, $00
000110DA =00000000                M spss1	=	op1
000110DA =00000000                M spss2	=	op2
000110DA =00000000                M spss3	=	op3
000110DA =00000000                M spss4	=	op4
000110DA                            	spTotalLv	$25, $25, $2F, $03
000110DA =00000025                M sptl1	=	op1
000110DA =00000025                M sptl2	=	op2
000110DA =0000002F                M sptl3	=	op3
000110DA =00000003                M sptl4	=	op4
000110DA 3A                       M 	dc.b	(spfe<<3)+spal
000110DB =00000080                M sptlmask4	set	$80
000110DB =00000000                M sptlmask2	set	((spal>=5)<<7)
000110DB =00000000                M sptlmask3	set	((spal>=4)<<7)
000110DB =00000000                M sptlmask1	set	((spal=7)<<7)
000110DB 710C 3301                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000110DF 5F5F 5F5F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000110E3 8489 848A                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000110E7 0001 0306                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000110EB 1512 1628                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000110EF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000110F3 252F 2583                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000110F7 4E41 54                  M 	dc.b	'NAT'
000110FA                            
000110FA                            	; Patch $19
000110FA                            	; $3A
000110FA                            	; $04, $02, $08, $02,	$1F, $1F, $1F, $1F
000110FA                            	; $00, $00, $00, $11,	$15, $0F, $0B, $1F
000110FA                            	; $00, $00, $00, $50,	$09, $07, $3F, $04
000110FA                            	spAlgorithm	$02
000110FA =0000001A                M spatnum	=	spatnum+1
000110FA =00000002                M spal	=	val
000110FA                            	spFeedback	$07
000110FA =00000007                M spfe	=	val
000110FA                            	spDetune	$00, $00, $00, $00
000110FA =00000000                M spde1	=	op1
000110FA =00000000                M spde2	=	op2
000110FA =00000000                M spde3	=	op3
000110FA =00000000                M spde4	=	op4
000110FA                            	spMultiple	$04, $08, $02, $02
000110FA =00000004                M spmu1	=	op1
000110FA =00000008                M spmu2	=	op2
000110FA =00000002                M spmu3	=	op3
000110FA =00000002                M spmu4	=	op4
000110FA                            	spRateScale	$00, $00, $00, $00
000110FA =00000000                M sprs1	=	op1
000110FA =00000000                M sprs2	=	op2
000110FA =00000000                M sprs3	=	op3
000110FA =00000000                M sprs4	=	op4
000110FA                            	spAttackRt	$1F, $1F, $1F, $1F
000110FA =0000001F                M spar1	=	op1
000110FA =0000001F                M spar2	=	op2
000110FA =0000001F                M spar3	=	op3
000110FA =0000001F                M spar4	=	op4
000110FA                            	spAmpMod	$00, $00, $00, $00
000110FA =00000000                M spam1	=	op1
000110FA =00000000                M spam2	=	op2
000110FA =00000000                M spam3	=	op3
000110FA =00000000                M spam4	=	op4
000110FA                            	spSustainRt	$00, $00, $00, $11
000110FA =00000000                M spsr1	=	op1
000110FA =00000000                M spsr2	=	op2
000110FA =00000000                M spsr3	=	op3
000110FA =00000011                M spsr4	=	op4
000110FA                            	spDecayRt	$15, $0B, $0F, $1F
000110FA =00000015                M spdr1	=	op1
000110FA =0000000B                M spdr2	=	op2
000110FA =0000000F                M spdr3	=	op3
000110FA =0000001F                M spdr4	=	op4
000110FA                            	spSustainLv	$00, $00, $00, $05
000110FA =00000000                M spsl1	=	op1
000110FA =00000000                M spsl2	=	op2
000110FA =00000000                M spsl3	=	op3
000110FA =00000005                M spsl4	=	op4
000110FA                            	spReleaseRt	$00, $00, $00, $00
000110FA =00000000                M sprr1	=	op1
000110FA =00000000                M sprr2	=	op2
000110FA =00000000                M sprr3	=	op3
000110FA =00000000                M sprr4	=	op4
000110FA                            	spSSGEG		$00, $00, $00, $00
000110FA =00000000                M spss1	=	op1
000110FA =00000000                M spss2	=	op2
000110FA =00000000                M spss3	=	op3
000110FA =00000000                M spss4	=	op4
000110FA                            	spTotalLv	$09, $3F, $07, $04
000110FA =00000009                M sptl1	=	op1
000110FA =0000003F                M sptl2	=	op2
000110FA =00000007                M sptl3	=	op3
000110FA =00000004                M sptl4	=	op4
000110FA 3A                       M 	dc.b	(spfe<<3)+spal
000110FB =00000080                M sptlmask4	set	$80
000110FB =00000000                M sptlmask2	set	((spal>=5)<<7)
000110FB =00000000                M sptlmask3	set	((spal>=4)<<7)
000110FB =00000000                M sptlmask1	set	((spal=7)<<7)
000110FB 0402 0802                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000110FF 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011103 0000 0011                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011107 150F 0B1F                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001110B 0000 0050                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001110F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011113 0907 3F84                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011117 4E41 54                  M 	dc.b	'NAT'
0001111A                            
0001111A                            	; Patch $1A
0001111A                            	; $39
0001111A                            	; $11, $0C, $00, $00,	$1F, $5F, $D4, $D3
0001111A                            	; $07, $15, $0B, $0A,	$00, $10, $06, $01
0001111A                            	; $17, $8D, $06, $06,	$27, $24, $0C, $05
0001111A                            	spAlgorithm	$01
0001111A =0000001B                M spatnum	=	spatnum+1
0001111A =00000001                M spal	=	val
0001111A                            	spFeedback	$07
0001111A =00000007                M spfe	=	val
0001111A                            	spDetune	$01, $00, $00, $00
0001111A =00000001                M spde1	=	op1
0001111A =00000000                M spde2	=	op2
0001111A =00000000                M spde3	=	op3
0001111A =00000000                M spde4	=	op4
0001111A                            	spMultiple	$01, $00, $0C, $00
0001111A =00000001                M spmu1	=	op1
0001111A =00000000                M spmu2	=	op2
0001111A =0000000C                M spmu3	=	op3
0001111A =00000000                M spmu4	=	op4
0001111A                            	spRateScale	$00, $03, $01, $03
0001111A =00000000                M sprs1	=	op1
0001111A =00000003                M sprs2	=	op2
0001111A =00000001                M sprs3	=	op3
0001111A =00000003                M sprs4	=	op4
0001111A                            	spAttackRt	$1F, $14, $1F, $13
0001111A =0000001F                M spar1	=	op1
0001111A =00000014                M spar2	=	op2
0001111A =0000001F                M spar3	=	op3
0001111A =00000013                M spar4	=	op4
0001111A                            	spAmpMod	$00, $00, $00, $00
0001111A =00000000                M spam1	=	op1
0001111A =00000000                M spam2	=	op2
0001111A =00000000                M spam3	=	op3
0001111A =00000000                M spam4	=	op4
0001111A                            	spSustainRt	$07, $0B, $15, $0A
0001111A =00000007                M spsr1	=	op1
0001111A =0000000B                M spsr2	=	op2
0001111A =00000015                M spsr3	=	op3
0001111A =0000000A                M spsr4	=	op4
0001111A                            	spDecayRt	$00, $06, $10, $01
0001111A =00000000                M spdr1	=	op1
0001111A =00000006                M spdr2	=	op2
0001111A =00000010                M spdr3	=	op3
0001111A =00000001                M spdr4	=	op4
0001111A                            	spSustainLv	$01, $00, $08, $00
0001111A =00000001                M spsl1	=	op1
0001111A =00000000                M spsl2	=	op2
0001111A =00000008                M spsl3	=	op3
0001111A =00000000                M spsl4	=	op4
0001111A                            	spReleaseRt	$07, $06, $0D, $06
0001111A =00000007                M sprr1	=	op1
0001111A =00000006                M sprr2	=	op2
0001111A =0000000D                M sprr3	=	op3
0001111A =00000006                M sprr4	=	op4
0001111A                            	spSSGEG		$00, $00, $00, $00
0001111A =00000000                M spss1	=	op1
0001111A =00000000                M spss2	=	op2
0001111A =00000000                M spss3	=	op3
0001111A =00000000                M spss4	=	op4
0001111A                            	spTotalLv	$27, $0C, $24, $05
0001111A =00000027                M sptl1	=	op1
0001111A =0000000C                M sptl2	=	op2
0001111A =00000024                M sptl3	=	op3
0001111A =00000005                M sptl4	=	op4
0001111A 39                       M 	dc.b	(spfe<<3)+spal
0001111B =00000080                M sptlmask4	set	$80
0001111B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001111B =00000000                M sptlmask3	set	((spal>=4)<<7)
0001111B =00000000                M sptlmask1	set	((spal=7)<<7)
0001111B 110C 0000                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001111F 1F5F D4D3                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011123 0715 0B0A                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011127 0010 0601                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001112B 178D 0606                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001112F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011133 2724 0C85                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011137 4E41 54                  M 	dc.b	'NAT'
0001113A                            
0001113A                            	; Patch $1B
0001113A                            	; $3A
0001113A                            	; $60, $70, $21, $13,	$1F, $1F, $1F, $1F
0001113A                            	; $08, $09, $09, $09,	$00, $00, $00, $00
0001113A                            	; $FF, $FF, $FF, $FF,	$2C, $3C, $16, $05
0001113A                            	spAlgorithm	$02
0001113A =0000001C                M spatnum	=	spatnum+1
0001113A =00000002                M spal	=	val
0001113A                            	spFeedback	$07
0001113A =00000007                M spfe	=	val
0001113A                            	spDetune	$06, $02, $07, $01
0001113A =00000006                M spde1	=	op1
0001113A =00000002                M spde2	=	op2
0001113A =00000007                M spde3	=	op3
0001113A =00000001                M spde4	=	op4
0001113A                            	spMultiple	$00, $01, $00, $03
0001113A =00000000                M spmu1	=	op1
0001113A =00000001                M spmu2	=	op2
0001113A =00000000                M spmu3	=	op3
0001113A =00000003                M spmu4	=	op4
0001113A                            	spRateScale	$00, $00, $00, $00
0001113A =00000000                M sprs1	=	op1
0001113A =00000000                M sprs2	=	op2
0001113A =00000000                M sprs3	=	op3
0001113A =00000000                M sprs4	=	op4
0001113A                            	spAttackRt	$1F, $1F, $1F, $1F
0001113A =0000001F                M spar1	=	op1
0001113A =0000001F                M spar2	=	op2
0001113A =0000001F                M spar3	=	op3
0001113A =0000001F                M spar4	=	op4
0001113A                            	spAmpMod	$00, $00, $00, $00
0001113A =00000000                M spam1	=	op1
0001113A =00000000                M spam2	=	op2
0001113A =00000000                M spam3	=	op3
0001113A =00000000                M spam4	=	op4
0001113A                            	spSustainRt	$08, $09, $09, $09
0001113A =00000008                M spsr1	=	op1
0001113A =00000009                M spsr2	=	op2
0001113A =00000009                M spsr3	=	op3
0001113A =00000009                M spsr4	=	op4
0001113A                            	spDecayRt	$00, $00, $00, $00
0001113A =00000000                M spdr1	=	op1
0001113A =00000000                M spdr2	=	op2
0001113A =00000000                M spdr3	=	op3
0001113A =00000000                M spdr4	=	op4
0001113A                            	spSustainLv	$0F, $0F, $0F, $0F
0001113A =0000000F                M spsl1	=	op1
0001113A =0000000F                M spsl2	=	op2
0001113A =0000000F                M spsl3	=	op3
0001113A =0000000F                M spsl4	=	op4
0001113A                            	spReleaseRt	$0F, $0F, $0F, $0F
0001113A =0000000F                M sprr1	=	op1
0001113A =0000000F                M sprr2	=	op2
0001113A =0000000F                M sprr3	=	op3
0001113A =0000000F                M sprr4	=	op4
0001113A                            	spSSGEG		$00, $00, $00, $00
0001113A =00000000                M spss1	=	op1
0001113A =00000000                M spss2	=	op2
0001113A =00000000                M spss3	=	op3
0001113A =00000000                M spss4	=	op4
0001113A                            	spTotalLv	$2C, $16, $3C, $05
0001113A =0000002C                M sptl1	=	op1
0001113A =00000016                M sptl2	=	op2
0001113A =0000003C                M sptl3	=	op3
0001113A =00000005                M sptl4	=	op4
0001113A 3A                       M 	dc.b	(spfe<<3)+spal
0001113B =00000080                M sptlmask4	set	$80
0001113B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001113B =00000000                M sptlmask3	set	((spal>=4)<<7)
0001113B =00000000                M sptlmask1	set	((spal=7)<<7)
0001113B 6070 2113                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001113F 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011143 0809 0909                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011147 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001114B FFFF FFFF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001114F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011153 2C3C 1685                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011157 4E41 54                  M 	dc.b	'NAT'
0001115A                            
0001115A                            	; Patch $1C
0001115A                            	; $3A
0001115A                            	; $62, $62, $20, $13,	$1F, $1F, $1F, $1F
0001115A                            	; $05, $10, $05, $08,	$1F, $1F, $1F, $1F
0001115A                            	; $FF, $FF, $FF, $FF,	$2C, $3C, $16, $05
0001115A                            	spAlgorithm	$02
0001115A =0000001D                M spatnum	=	spatnum+1
0001115A =00000002                M spal	=	val
0001115A                            	spFeedback	$07
0001115A =00000007                M spfe	=	val
0001115A                            	spDetune	$06, $02, $06, $01
0001115A =00000006                M spde1	=	op1
0001115A =00000002                M spde2	=	op2
0001115A =00000006                M spde3	=	op3
0001115A =00000001                M spde4	=	op4
0001115A                            	spMultiple	$02, $00, $02, $03
0001115A =00000002                M spmu1	=	op1
0001115A =00000000                M spmu2	=	op2
0001115A =00000002                M spmu3	=	op3
0001115A =00000003                M spmu4	=	op4
0001115A                            	spRateScale	$00, $00, $00, $00
0001115A =00000000                M sprs1	=	op1
0001115A =00000000                M sprs2	=	op2
0001115A =00000000                M sprs3	=	op3
0001115A =00000000                M sprs4	=	op4
0001115A                            	spAttackRt	$1F, $1F, $1F, $1F
0001115A =0000001F                M spar1	=	op1
0001115A =0000001F                M spar2	=	op2
0001115A =0000001F                M spar3	=	op3
0001115A =0000001F                M spar4	=	op4
0001115A                            	spAmpMod	$00, $00, $00, $00
0001115A =00000000                M spam1	=	op1
0001115A =00000000                M spam2	=	op2
0001115A =00000000                M spam3	=	op3
0001115A =00000000                M spam4	=	op4
0001115A                            	spSustainRt	$05, $05, $10, $08
0001115A =00000005                M spsr1	=	op1
0001115A =00000005                M spsr2	=	op2
0001115A =00000010                M spsr3	=	op3
0001115A =00000008                M spsr4	=	op4
0001115A                            	spDecayRt	$1F, $1F, $1F, $1F
0001115A =0000001F                M spdr1	=	op1
0001115A =0000001F                M spdr2	=	op2
0001115A =0000001F                M spdr3	=	op3
0001115A =0000001F                M spdr4	=	op4
0001115A                            	spSustainLv	$0F, $0F, $0F, $0F
0001115A =0000000F                M spsl1	=	op1
0001115A =0000000F                M spsl2	=	op2
0001115A =0000000F                M spsl3	=	op3
0001115A =0000000F                M spsl4	=	op4
0001115A                            	spReleaseRt	$0F, $0F, $0F, $0F
0001115A =0000000F                M sprr1	=	op1
0001115A =0000000F                M sprr2	=	op2
0001115A =0000000F                M sprr3	=	op3
0001115A =0000000F                M sprr4	=	op4
0001115A                            	spSSGEG		$00, $00, $00, $00
0001115A =00000000                M spss1	=	op1
0001115A =00000000                M spss2	=	op2
0001115A =00000000                M spss3	=	op3
0001115A =00000000                M spss4	=	op4
0001115A                            	spTotalLv	$2C, $16, $3C, $05
0001115A =0000002C                M sptl1	=	op1
0001115A =00000016                M sptl2	=	op2
0001115A =0000003C                M sptl3	=	op3
0001115A =00000005                M sptl4	=	op4
0001115A 3A                       M 	dc.b	(spfe<<3)+spal
0001115B =00000080                M sptlmask4	set	$80
0001115B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001115B =00000000                M sptlmask3	set	((spal>=4)<<7)
0001115B =00000000                M sptlmask1	set	((spal=7)<<7)
0001115B 6262 2013                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001115F 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011163 0510 0508                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011167 1F1F 1F1F                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001116B FFFF FFFF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001116F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011173 2C3C 1685                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011177 4E41 54                  M 	dc.b	'NAT'
0001117A                            
0001117A                            	; Patch $1D
0001117A                            	; $17
0001117A                            	; $08, $70, $70, $30,	$1F, $19, $1C, $5F
0001117A                            	; $93, $8F, $93, $95,	$00, $09, $06, $09
0001117A                            	; $2F, $3F, $0C, $1A,	$05, $13, $20, $0B
0001117A                            	spAlgorithm	$07
0001117A =0000001E                M spatnum	=	spatnum+1
0001117A =00000007                M spal	=	val
0001117A                            	spFeedback	$02
0001117A =00000002                M spfe	=	val
0001117A                            	spDetune	$00, $07, $07, $03
0001117A =00000000                M spde1	=	op1
0001117A =00000007                M spde2	=	op2
0001117A =00000007                M spde3	=	op3
0001117A =00000003                M spde4	=	op4
0001117A                            	spMultiple	$08, $00, $00, $00
0001117A =00000008                M spmu1	=	op1
0001117A =00000000                M spmu2	=	op2
0001117A =00000000                M spmu3	=	op3
0001117A =00000000                M spmu4	=	op4
0001117A                            	spRateScale	$00, $00, $00, $01
0001117A =00000000                M sprs1	=	op1
0001117A =00000000                M sprs2	=	op2
0001117A =00000000                M sprs3	=	op3
0001117A =00000001                M sprs4	=	op4
0001117A                            	spAttackRt	$1F, $1C, $19, $1F
0001117A =0000001F                M spar1	=	op1
0001117A =0000001C                M spar2	=	op2
0001117A =00000019                M spar3	=	op3
0001117A =0000001F                M spar4	=	op4
0001117A                            	spAmpMod	$01, $01, $01, $01
0001117A =00000001                M spam1	=	op1
0001117A =00000001                M spam2	=	op2
0001117A =00000001                M spam3	=	op3
0001117A =00000001                M spam4	=	op4
0001117A                            	spSustainRt	$13, $13, $0F, $15
0001117A =00000013                M spsr1	=	op1
0001117A =00000013                M spsr2	=	op2
0001117A =0000000F                M spsr3	=	op3
0001117A =00000015                M spsr4	=	op4
0001117A                            	spDecayRt	$00, $06, $09, $09
0001117A =00000000                M spdr1	=	op1
0001117A =00000006                M spdr2	=	op2
0001117A =00000009                M spdr3	=	op3
0001117A =00000009                M spdr4	=	op4
0001117A                            	spSustainLv	$02, $00, $03, $01
0001117A =00000002                M spsl1	=	op1
0001117A =00000000                M spsl2	=	op2
0001117A =00000003                M spsl3	=	op3
0001117A =00000001                M spsl4	=	op4
0001117A                            	spReleaseRt	$0F, $0C, $0F, $0A
0001117A =0000000F                M sprr1	=	op1
0001117A =0000000C                M sprr2	=	op2
0001117A =0000000F                M sprr3	=	op3
0001117A =0000000A                M sprr4	=	op4
0001117A                            	spSSGEG		$00, $00, $00, $00
0001117A =00000000                M spss1	=	op1
0001117A =00000000                M spss2	=	op2
0001117A =00000000                M spss3	=	op3
0001117A =00000000                M spss4	=	op4
0001117A                            	spTotalLv	$05, $20, $13, $0B
0001117A =00000005                M sptl1	=	op1
0001117A =00000020                M sptl2	=	op2
0001117A =00000013                M sptl3	=	op3
0001117A =0000000B                M sptl4	=	op4
0001117A 17                       M 	dc.b	(spfe<<3)+spal
0001117B =00000080                M sptlmask4	set	$80
0001117B =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
0001117B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
0001117B =FFFFFF80                M sptlmask1	set	((spal=7)<<7)
0001117B 0870 7030                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001117F 1F19 1C5F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011183 938F 9395                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011187 0009 0609                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001118B 2F3F 0C1A                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001118F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011193 8593 A08B                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011197 4E41 54                  M 	dc.b	'NAT'
0001119A                            
0001119A                            	; Patch $1E
0001119A                            	; $33
0001119A                            	; $52, $60, $1B, $31,	$9A, $1F, $9C, $9F
0001119A                            	; $08, $1F, $09, $19,	$00, $00, $00, $02
0001119A                            	; $05, $16, $07, $08,	$23, $04, $19, $05
0001119A                            	spAlgorithm	$03
0001119A =0000001F                M spatnum	=	spatnum+1
0001119A =00000003                M spal	=	val
0001119A                            	spFeedback	$06
0001119A =00000006                M spfe	=	val
0001119A                            	spDetune	$05, $01, $06, $03
0001119A =00000005                M spde1	=	op1
0001119A =00000001                M spde2	=	op2
0001119A =00000006                M spde3	=	op3
0001119A =00000003                M spde4	=	op4
0001119A                            	spMultiple	$02, $0B, $00, $01
0001119A =00000002                M spmu1	=	op1
0001119A =0000000B                M spmu2	=	op2
0001119A =00000000                M spmu3	=	op3
0001119A =00000001                M spmu4	=	op4
0001119A                            	spRateScale	$02, $02, $00, $02
0001119A =00000002                M sprs1	=	op1
0001119A =00000002                M sprs2	=	op2
0001119A =00000000                M sprs3	=	op3
0001119A =00000002                M sprs4	=	op4
0001119A                            	spAttackRt	$1A, $1C, $1F, $1F
0001119A =0000001A                M spar1	=	op1
0001119A =0000001C                M spar2	=	op2
0001119A =0000001F                M spar3	=	op3
0001119A =0000001F                M spar4	=	op4
0001119A                            	spAmpMod	$00, $00, $00, $00
0001119A =00000000                M spam1	=	op1
0001119A =00000000                M spam2	=	op2
0001119A =00000000                M spam3	=	op3
0001119A =00000000                M spam4	=	op4
0001119A                            	spSustainRt	$08, $09, $1F, $19
0001119A =00000008                M spsr1	=	op1
0001119A =00000009                M spsr2	=	op2
0001119A =0000001F                M spsr3	=	op3
0001119A =00000019                M spsr4	=	op4
0001119A                            	spDecayRt	$00, $00, $00, $02
0001119A =00000000                M spdr1	=	op1
0001119A =00000000                M spdr2	=	op2
0001119A =00000000                M spdr3	=	op3
0001119A =00000002                M spdr4	=	op4
0001119A                            	spSustainLv	$00, $00, $01, $00
0001119A =00000000                M spsl1	=	op1
0001119A =00000000                M spsl2	=	op2
0001119A =00000001                M spsl3	=	op3
0001119A =00000000                M spsl4	=	op4
0001119A                            	spReleaseRt	$05, $07, $06, $08
0001119A =00000005                M sprr1	=	op1
0001119A =00000007                M sprr2	=	op2
0001119A =00000006                M sprr3	=	op3
0001119A =00000008                M sprr4	=	op4
0001119A                            	spSSGEG		$00, $00, $00, $00
0001119A =00000000                M spss1	=	op1
0001119A =00000000                M spss2	=	op2
0001119A =00000000                M spss3	=	op3
0001119A =00000000                M spss4	=	op4
0001119A                            	spTotalLv	$23, $19, $04, $05
0001119A =00000023                M sptl1	=	op1
0001119A =00000019                M sptl2	=	op2
0001119A =00000004                M sptl3	=	op3
0001119A =00000005                M sptl4	=	op4
0001119A 33                       M 	dc.b	(spfe<<3)+spal
0001119B =00000080                M sptlmask4	set	$80
0001119B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001119B =00000000                M sptlmask3	set	((spal>=4)<<7)
0001119B =00000000                M sptlmask1	set	((spal=7)<<7)
0001119B 5260 1B31                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001119F 9A1F 9C9F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000111A3 081F 0919                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000111A7 0000 0002                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000111AB 0516 0708                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000111AF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000111B3 2304 1985                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000111B7 4E41 54                  M 	dc.b	'NAT'
000111BA                            
000111BA                            	; Patch $1F
000111BA                            	; $1B
000111BA                            	; $31, $13, $71, $52,	$18, $10, $16, $13
000111BA                            	; $17, $9F, $1F, $1F,	$00, $00, $00, $00
000111BA                            	; $06, $01, $07, $0C,	$0C, $10, $0E, $05
000111BA                            	spAlgorithm	$03
000111BA =00000020                M spatnum	=	spatnum+1
000111BA =00000003                M spal	=	val
000111BA                            	spFeedback	$03
000111BA =00000003                M spfe	=	val
000111BA                            	spDetune	$03, $07, $01, $05
000111BA =00000003                M spde1	=	op1
000111BA =00000007                M spde2	=	op2
000111BA =00000001                M spde3	=	op3
000111BA =00000005                M spde4	=	op4
000111BA                            	spMultiple	$01, $01, $03, $02
000111BA =00000001                M spmu1	=	op1
000111BA =00000001                M spmu2	=	op2
000111BA =00000003                M spmu3	=	op3
000111BA =00000002                M spmu4	=	op4
000111BA                            	spRateScale	$00, $00, $00, $00
000111BA =00000000                M sprs1	=	op1
000111BA =00000000                M sprs2	=	op2
000111BA =00000000                M sprs3	=	op3
000111BA =00000000                M sprs4	=	op4
000111BA                            	spAttackRt	$18, $16, $10, $13
000111BA =00000018                M spar1	=	op1
000111BA =00000016                M spar2	=	op2
000111BA =00000010                M spar3	=	op3
000111BA =00000013                M spar4	=	op4
000111BA                            	spAmpMod	$00, $00, $01, $00
000111BA =00000000                M spam1	=	op1
000111BA =00000000                M spam2	=	op2
000111BA =00000001                M spam3	=	op3
000111BA =00000000                M spam4	=	op4
000111BA                            	spSustainRt	$17, $1F, $1F, $1F
000111BA =00000017                M spsr1	=	op1
000111BA =0000001F                M spsr2	=	op2
000111BA =0000001F                M spsr3	=	op3
000111BA =0000001F                M spsr4	=	op4
000111BA                            	spDecayRt	$00, $00, $00, $00
000111BA =00000000                M spdr1	=	op1
000111BA =00000000                M spdr2	=	op2
000111BA =00000000                M spdr3	=	op3
000111BA =00000000                M spdr4	=	op4
000111BA                            	spSustainLv	$00, $00, $00, $00
000111BA =00000000                M spsl1	=	op1
000111BA =00000000                M spsl2	=	op2
000111BA =00000000                M spsl3	=	op3
000111BA =00000000                M spsl4	=	op4
000111BA                            	spReleaseRt	$06, $07, $01, $0C
000111BA =00000006                M sprr1	=	op1
000111BA =00000007                M sprr2	=	op2
000111BA =00000001                M sprr3	=	op3
000111BA =0000000C                M sprr4	=	op4
000111BA                            	spSSGEG		$00, $00, $00, $00
000111BA =00000000                M spss1	=	op1
000111BA =00000000                M spss2	=	op2
000111BA =00000000                M spss3	=	op3
000111BA =00000000                M spss4	=	op4
000111BA                            	spTotalLv	$0C, $0E, $10, $05
000111BA =0000000C                M sptl1	=	op1
000111BA =0000000E                M sptl2	=	op2
000111BA =00000010                M sptl3	=	op3
000111BA =00000005                M sptl4	=	op4
000111BA 1B                       M 	dc.b	(spfe<<3)+spal
000111BB =00000080                M sptlmask4	set	$80
000111BB =00000000                M sptlmask2	set	((spal>=5)<<7)
000111BB =00000000                M sptlmask3	set	((spal>=4)<<7)
000111BB =00000000                M sptlmask1	set	((spal=7)<<7)
000111BB 3113 7152                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000111BF 1810 1613                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000111C3 179F 1F1F                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000111C7 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000111CB 0601 070C                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000111CF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000111D3 0C10 0E85                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000111D7 4E41 54                  M 	dc.b	'NAT'
000111DA                            
000111DA                            	; Patch $20
000111DA                            	; $11
000111DA                            	; $01, $75, $64, $31,	$1F, $9F, $5F, $9F
000111DA                            	; $04, $88, $06, $01,	$02, $02, $02, $02
000111DA                            	; $81, $31, $51, $6A,	$08, $12, $16, $05
000111DA                            	spAlgorithm	$01
000111DA =00000021                M spatnum	=	spatnum+1
000111DA =00000001                M spal	=	val
000111DA                            	spFeedback	$02
000111DA =00000002                M spfe	=	val
000111DA                            	spDetune	$00, $06, $07, $03
000111DA =00000000                M spde1	=	op1
000111DA =00000006                M spde2	=	op2
000111DA =00000007                M spde3	=	op3
000111DA =00000003                M spde4	=	op4
000111DA                            	spMultiple	$01, $04, $05, $01
000111DA =00000001                M spmu1	=	op1
000111DA =00000004                M spmu2	=	op2
000111DA =00000005                M spmu3	=	op3
000111DA =00000001                M spmu4	=	op4
000111DA                            	spRateScale	$00, $01, $02, $02
000111DA =00000000                M sprs1	=	op1
000111DA =00000001                M sprs2	=	op2
000111DA =00000002                M sprs3	=	op3
000111DA =00000002                M sprs4	=	op4
000111DA                            	spAttackRt	$1F, $1F, $1F, $1F
000111DA =0000001F                M spar1	=	op1
000111DA =0000001F                M spar2	=	op2
000111DA =0000001F                M spar3	=	op3
000111DA =0000001F                M spar4	=	op4
000111DA                            	spAmpMod	$00, $00, $01, $00
000111DA =00000000                M spam1	=	op1
000111DA =00000000                M spam2	=	op2
000111DA =00000001                M spam3	=	op3
000111DA =00000000                M spam4	=	op4
000111DA                            	spSustainRt	$04, $06, $08, $01
000111DA =00000004                M spsr1	=	op1
000111DA =00000006                M spsr2	=	op2
000111DA =00000008                M spsr3	=	op3
000111DA =00000001                M spsr4	=	op4
000111DA                            	spDecayRt	$02, $02, $02, $02
000111DA =00000002                M spdr1	=	op1
000111DA =00000002                M spdr2	=	op2
000111DA =00000002                M spdr3	=	op3
000111DA =00000002                M spdr4	=	op4
000111DA                            	spSustainLv	$08, $05, $03, $06
000111DA =00000008                M spsl1	=	op1
000111DA =00000005                M spsl2	=	op2
000111DA =00000003                M spsl3	=	op3
000111DA =00000006                M spsl4	=	op4
000111DA                            	spReleaseRt	$01, $01, $01, $0A
000111DA =00000001                M sprr1	=	op1
000111DA =00000001                M sprr2	=	op2
000111DA =00000001                M sprr3	=	op3
000111DA =0000000A                M sprr4	=	op4
000111DA                            	spSSGEG		$00, $00, $00, $00
000111DA =00000000                M spss1	=	op1
000111DA =00000000                M spss2	=	op2
000111DA =00000000                M spss3	=	op3
000111DA =00000000                M spss4	=	op4
000111DA                            	spTotalLv	$08, $16, $12, $05
000111DA =00000008                M sptl1	=	op1
000111DA =00000016                M sptl2	=	op2
000111DA =00000012                M sptl3	=	op3
000111DA =00000005                M sptl4	=	op4
000111DA 11                       M 	dc.b	(spfe<<3)+spal
000111DB =00000080                M sptlmask4	set	$80
000111DB =00000000                M sptlmask2	set	((spal>=5)<<7)
000111DB =00000000                M sptlmask3	set	((spal>=4)<<7)
000111DB =00000000                M sptlmask1	set	((spal=7)<<7)
000111DB 0175 6431                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000111DF 1F9F 5F9F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000111E3 0488 0601                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000111E7 0202 0202                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000111EB 8131 516A                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000111EF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000111F3 0812 1685                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000111F7 4E41 54                  M 	dc.b	'NAT'
000111FA                            
000111FA                            	; Patch $21
000111FA                            	; $22
000111FA                            	; $50, $05, $10, $00,	$D8, $DD, $DD, $9F
000111FA                            	; $04, $05, $08, $0B,	$00, $00, $00, $06
000111FA                            	; $FC, $FF, $FC, $FF,	$14, $16, $2B, $02
000111FA                            	spAlgorithm	$02
000111FA =00000022                M spatnum	=	spatnum+1
000111FA =00000002                M spal	=	val
000111FA                            	spFeedback	$04
000111FA =00000004                M spfe	=	val
000111FA                            	spDetune	$05, $01, $00, $00
000111FA =00000005                M spde1	=	op1
000111FA =00000001                M spde2	=	op2
000111FA =00000000                M spde3	=	op3
000111FA =00000000                M spde4	=	op4
000111FA                            	spMultiple	$00, $00, $05, $00
000111FA =00000000                M spmu1	=	op1
000111FA =00000000                M spmu2	=	op2
000111FA =00000005                M spmu3	=	op3
000111FA =00000000                M spmu4	=	op4
000111FA                            	spRateScale	$03, $03, $03, $02
000111FA =00000003                M sprs1	=	op1
000111FA =00000003                M sprs2	=	op2
000111FA =00000003                M sprs3	=	op3
000111FA =00000002                M sprs4	=	op4
000111FA                            	spAttackRt	$18, $1D, $1D, $1F
000111FA =00000018                M spar1	=	op1
000111FA =0000001D                M spar2	=	op2
000111FA =0000001D                M spar3	=	op3
000111FA =0000001F                M spar4	=	op4
000111FA                            	spAmpMod	$00, $00, $00, $00
000111FA =00000000                M spam1	=	op1
000111FA =00000000                M spam2	=	op2
000111FA =00000000                M spam3	=	op3
000111FA =00000000                M spam4	=	op4
000111FA                            	spSustainRt	$04, $08, $05, $0B
000111FA =00000004                M spsr1	=	op1
000111FA =00000008                M spsr2	=	op2
000111FA =00000005                M spsr3	=	op3
000111FA =0000000B                M spsr4	=	op4
000111FA                            	spDecayRt	$00, $00, $00, $06
000111FA =00000000                M spdr1	=	op1
000111FA =00000000                M spdr2	=	op2
000111FA =00000000                M spdr3	=	op3
000111FA =00000006                M spdr4	=	op4
000111FA                            	spSustainLv	$0F, $0F, $0F, $0F
000111FA =0000000F                M spsl1	=	op1
000111FA =0000000F                M spsl2	=	op2
000111FA =0000000F                M spsl3	=	op3
000111FA =0000000F                M spsl4	=	op4
000111FA                            	spReleaseRt	$0C, $0C, $0F, $0F
000111FA =0000000C                M sprr1	=	op1
000111FA =0000000C                M sprr2	=	op2
000111FA =0000000F                M sprr3	=	op3
000111FA =0000000F                M sprr4	=	op4
000111FA                            	spSSGEG		$00, $00, $00, $00
000111FA =00000000                M spss1	=	op1
000111FA =00000000                M spss2	=	op2
000111FA =00000000                M spss3	=	op3
000111FA =00000000                M spss4	=	op4
000111FA                            	spTotalLv	$14, $2B, $16, $02
000111FA =00000014                M sptl1	=	op1
000111FA =0000002B                M sptl2	=	op2
000111FA =00000016                M sptl3	=	op3
000111FA =00000002                M sptl4	=	op4
000111FA 22                       M 	dc.b	(spfe<<3)+spal
000111FB =00000080                M sptlmask4	set	$80
000111FB =00000000                M sptlmask2	set	((spal>=5)<<7)
000111FB =00000000                M sptlmask3	set	((spal>=4)<<7)
000111FB =00000000                M sptlmask1	set	((spal=7)<<7)
000111FB 5005 1000                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000111FF D8DD DD9F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011203 0405 080B                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011207 0000 0006                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001120B FCFF FCFF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001120F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011213 1416 2B82                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011217 4E41 54                  M 	dc.b	'NAT'
0001121A                            
0001121A                            	; Patch $22
0001121A                            	; $35
0001121A                            	; $01, $00, $72, $31,	$9F, $14, $52, $52
0001121A                            	; $0A, $8A, $8A, $0A,	$09, $0E, $0F, $10
0001121A                            	; $11, $26, $26, $26,	$0F, $08, $05, $05
0001121A                            	spAlgorithm	$05
0001121A =00000023                M spatnum	=	spatnum+1
0001121A =00000005                M spal	=	val
0001121A                            	spFeedback	$06
0001121A =00000006                M spfe	=	val
0001121A                            	spDetune	$00, $07, $00, $03
0001121A =00000000                M spde1	=	op1
0001121A =00000007                M spde2	=	op2
0001121A =00000000                M spde3	=	op3
0001121A =00000003                M spde4	=	op4
0001121A                            	spMultiple	$01, $02, $00, $01
0001121A =00000001                M spmu1	=	op1
0001121A =00000002                M spmu2	=	op2
0001121A =00000000                M spmu3	=	op3
0001121A =00000001                M spmu4	=	op4
0001121A                            	spRateScale	$02, $01, $00, $01
0001121A =00000002                M sprs1	=	op1
0001121A =00000001                M sprs2	=	op2
0001121A =00000000                M sprs3	=	op3
0001121A =00000001                M sprs4	=	op4
0001121A                            	spAttackRt	$1F, $12, $14, $12
0001121A =0000001F                M spar1	=	op1
0001121A =00000012                M spar2	=	op2
0001121A =00000014                M spar3	=	op3
0001121A =00000012                M spar4	=	op4
0001121A                            	spAmpMod	$00, $01, $01, $00
0001121A =00000000                M spam1	=	op1
0001121A =00000001                M spam2	=	op2
0001121A =00000001                M spam3	=	op3
0001121A =00000000                M spam4	=	op4
0001121A                            	spSustainRt	$0A, $0A, $0A, $0A
0001121A =0000000A                M spsr1	=	op1
0001121A =0000000A                M spsr2	=	op2
0001121A =0000000A                M spsr3	=	op3
0001121A =0000000A                M spsr4	=	op4
0001121A                            	spDecayRt	$09, $0F, $0E, $10
0001121A =00000009                M spdr1	=	op1
0001121A =0000000F                M spdr2	=	op2
0001121A =0000000E                M spdr3	=	op3
0001121A =00000010                M spdr4	=	op4
0001121A                            	spSustainLv	$01, $02, $02, $02
0001121A =00000001                M spsl1	=	op1
0001121A =00000002                M spsl2	=	op2
0001121A =00000002                M spsl3	=	op3
0001121A =00000002                M spsl4	=	op4
0001121A                            	spReleaseRt	$01, $06, $06, $06
0001121A =00000001                M sprr1	=	op1
0001121A =00000006                M sprr2	=	op2
0001121A =00000006                M sprr3	=	op3
0001121A =00000006                M sprr4	=	op4
0001121A                            	spSSGEG		$00, $00, $00, $00
0001121A =00000000                M spss1	=	op1
0001121A =00000000                M spss2	=	op2
0001121A =00000000                M spss3	=	op3
0001121A =00000000                M spss4	=	op4
0001121A                            	spTotalLv	$0F, $05, $08, $05
0001121A =0000000F                M sptl1	=	op1
0001121A =00000005                M sptl2	=	op2
0001121A =00000008                M sptl3	=	op3
0001121A =00000005                M sptl4	=	op4
0001121A 35                       M 	dc.b	(spfe<<3)+spal
0001121B =00000080                M sptlmask4	set	$80
0001121B =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
0001121B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
0001121B =00000000                M sptlmask1	set	((spal=7)<<7)
0001121B 0100 7231                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001121F 9F14 5252                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011223 0A8A 8A0A                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011227 090E 0F10                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001122B 1126 2626                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001122F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011233 0F88 8585                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011237 4E41 54                  M 	dc.b	'NAT'
0001123A                            
0001123A                            	; Patch $23
0001123A                            	; $0D
0001123A                            	; $50, $02, $14, $00,	$9D, $5E, $9D, $5C
0001123A                            	; $8C, $09, $8B, $02,	$00, $00, $09, $00
0001123A                            	; $FF, $FF, $FF, $FF,	$0C, $10, $0B, $05
0001123A                            	spAlgorithm	$05
0001123A =00000024                M spatnum	=	spatnum+1
0001123A =00000005                M spal	=	val
0001123A                            	spFeedback	$01
0001123A =00000001                M spfe	=	val
0001123A                            	spDetune	$05, $01, $00, $00
0001123A =00000005                M spde1	=	op1
0001123A =00000001                M spde2	=	op2
0001123A =00000000                M spde3	=	op3
0001123A =00000000                M spde4	=	op4
0001123A                            	spMultiple	$00, $04, $02, $00
0001123A =00000000                M spmu1	=	op1
0001123A =00000004                M spmu2	=	op2
0001123A =00000002                M spmu3	=	op3
0001123A =00000000                M spmu4	=	op4
0001123A                            	spRateScale	$02, $02, $01, $01
0001123A =00000002                M sprs1	=	op1
0001123A =00000002                M sprs2	=	op2
0001123A =00000001                M sprs3	=	op3
0001123A =00000001                M sprs4	=	op4
0001123A                            	spAttackRt	$1D, $1D, $1E, $1C
0001123A =0000001D                M spar1	=	op1
0001123A =0000001D                M spar2	=	op2
0001123A =0000001E                M spar3	=	op3
0001123A =0000001C                M spar4	=	op4
0001123A                            	spAmpMod	$01, $01, $00, $00
0001123A =00000001                M spam1	=	op1
0001123A =00000001                M spam2	=	op2
0001123A =00000000                M spam3	=	op3
0001123A =00000000                M spam4	=	op4
0001123A                            	spSustainRt	$0C, $0B, $09, $02
0001123A =0000000C                M spsr1	=	op1
0001123A =0000000B                M spsr2	=	op2
0001123A =00000009                M spsr3	=	op3
0001123A =00000002                M spsr4	=	op4
0001123A                            	spDecayRt	$00, $09, $00, $00
0001123A =00000000                M spdr1	=	op1
0001123A =00000009                M spdr2	=	op2
0001123A =00000000                M spdr3	=	op3
0001123A =00000000                M spdr4	=	op4
0001123A                            	spSustainLv	$0F, $0F, $0F, $0F
0001123A =0000000F                M spsl1	=	op1
0001123A =0000000F                M spsl2	=	op2
0001123A =0000000F                M spsl3	=	op3
0001123A =0000000F                M spsl4	=	op4
0001123A                            	spReleaseRt	$0F, $0F, $0F, $0F
0001123A =0000000F                M sprr1	=	op1
0001123A =0000000F                M sprr2	=	op2
0001123A =0000000F                M sprr3	=	op3
0001123A =0000000F                M sprr4	=	op4
0001123A                            	spSSGEG		$00, $00, $00, $00
0001123A =00000000                M spss1	=	op1
0001123A =00000000                M spss2	=	op2
0001123A =00000000                M spss3	=	op3
0001123A =00000000                M spss4	=	op4
0001123A                            	spTotalLv	$0C, $0B, $10, $05
0001123A =0000000C                M sptl1	=	op1
0001123A =0000000B                M sptl2	=	op2
0001123A =00000010                M sptl3	=	op3
0001123A =00000005                M sptl4	=	op4
0001123A 0D                       M 	dc.b	(spfe<<3)+spal
0001123B =00000080                M sptlmask4	set	$80
0001123B =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
0001123B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
0001123B =00000000                M sptlmask1	set	((spal=7)<<7)
0001123B 5002 1400                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001123F 9D5E 9D5C                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011243 8C09 8B02                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011247 0000 0900                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001124B FFFF FFFF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001124F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011253 0C90 8B85                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011257 4E41 54                  M 	dc.b	'NAT'
0001125A                            
0001125A                            	; Patch $24
0001125A                            	; $35
0001125A                            	; $30, $01, $70, $30,	$5F, $57, $56, $5F
0001125A                            	; $19, $0A, $0A, $0A,	$0F, $0F, $0F, $0F
0001125A                            	; $05, $35, $35, $35,	$13, $05, $05, $05
0001125A                            	spAlgorithm	$05
0001125A =00000025                M spatnum	=	spatnum+1
0001125A =00000005                M spal	=	val
0001125A                            	spFeedback	$06
0001125A =00000006                M spfe	=	val
0001125A                            	spDetune	$03, $07, $00, $03
0001125A =00000003                M spde1	=	op1
0001125A =00000007                M spde2	=	op2
0001125A =00000000                M spde3	=	op3
0001125A =00000003                M spde4	=	op4
0001125A                            	spMultiple	$00, $00, $01, $00
0001125A =00000000                M spmu1	=	op1
0001125A =00000000                M spmu2	=	op2
0001125A =00000001                M spmu3	=	op3
0001125A =00000000                M spmu4	=	op4
0001125A                            	spRateScale	$01, $01, $01, $01
0001125A =00000001                M sprs1	=	op1
0001125A =00000001                M sprs2	=	op2
0001125A =00000001                M sprs3	=	op3
0001125A =00000001                M sprs4	=	op4
0001125A                            	spAttackRt	$1F, $16, $17, $1F
0001125A =0000001F                M spar1	=	op1
0001125A =00000016                M spar2	=	op2
0001125A =00000017                M spar3	=	op3
0001125A =0000001F                M spar4	=	op4
0001125A                            	spAmpMod	$00, $00, $00, $00
0001125A =00000000                M spam1	=	op1
0001125A =00000000                M spam2	=	op2
0001125A =00000000                M spam3	=	op3
0001125A =00000000                M spam4	=	op4
0001125A                            	spSustainRt	$19, $0A, $0A, $0A
0001125A =00000019                M spsr1	=	op1
0001125A =0000000A                M spsr2	=	op2
0001125A =0000000A                M spsr3	=	op3
0001125A =0000000A                M spsr4	=	op4
0001125A                            	spDecayRt	$0F, $0F, $0F, $0F
0001125A =0000000F                M spdr1	=	op1
0001125A =0000000F                M spdr2	=	op2
0001125A =0000000F                M spdr3	=	op3
0001125A =0000000F                M spdr4	=	op4
0001125A                            	spSustainLv	$00, $03, $03, $03
0001125A =00000000                M spsl1	=	op1
0001125A =00000003                M spsl2	=	op2
0001125A =00000003                M spsl3	=	op3
0001125A =00000003                M spsl4	=	op4
0001125A                            	spReleaseRt	$05, $05, $05, $05
0001125A =00000005                M sprr1	=	op1
0001125A =00000005                M sprr2	=	op2
0001125A =00000005                M sprr3	=	op3
0001125A =00000005                M sprr4	=	op4
0001125A                            	spSSGEG		$00, $00, $00, $00
0001125A =00000000                M spss1	=	op1
0001125A =00000000                M spss2	=	op2
0001125A =00000000                M spss3	=	op3
0001125A =00000000                M spss4	=	op4
0001125A                            	spTotalLv	$13, $05, $05, $05
0001125A =00000013                M sptl1	=	op1
0001125A =00000005                M sptl2	=	op2
0001125A =00000005                M sptl3	=	op3
0001125A =00000005                M sptl4	=	op4
0001125A 35                       M 	dc.b	(spfe<<3)+spal
0001125B =00000080                M sptlmask4	set	$80
0001125B =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
0001125B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
0001125B =00000000                M sptlmask1	set	((spal=7)<<7)
0001125B 3001 7030                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001125F 5F57 565F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011263 190A 0A0A                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011267 0F0F 0F0F                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001126B 0535 3535                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001126F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011273 1385 8585                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011277 4E41 54                  M 	dc.b	'NAT'
0001127A                            
0001127A                            	; Patch $25
0001127A                            	; $3B
0001127A                            	; $00, $01, $00, $03,	$1F, $1F, $16, $14
0001127A                            	; $03, $02, $02, $00,	$02, $02, $02, $1F
0001127A                            	; $22, $14, $13, $15,	$0E, $04, $23, $04
0001127A                            	spAlgorithm	$03
0001127A =00000026                M spatnum	=	spatnum+1
0001127A =00000003                M spal	=	val
0001127A                            	spFeedback	$07
0001127A =00000007                M spfe	=	val
0001127A                            	spDetune	$00, $00, $00, $00
0001127A =00000000                M spde1	=	op1
0001127A =00000000                M spde2	=	op2
0001127A =00000000                M spde3	=	op3
0001127A =00000000                M spde4	=	op4
0001127A                            	spMultiple	$00, $00, $01, $03
0001127A =00000000                M spmu1	=	op1
0001127A =00000000                M spmu2	=	op2
0001127A =00000001                M spmu3	=	op3
0001127A =00000003                M spmu4	=	op4
0001127A                            	spRateScale	$00, $00, $00, $00
0001127A =00000000                M sprs1	=	op1
0001127A =00000000                M sprs2	=	op2
0001127A =00000000                M sprs3	=	op3
0001127A =00000000                M sprs4	=	op4
0001127A                            	spAttackRt	$1F, $16, $1F, $14
0001127A =0000001F                M spar1	=	op1
0001127A =00000016                M spar2	=	op2
0001127A =0000001F                M spar3	=	op3
0001127A =00000014                M spar4	=	op4
0001127A                            	spAmpMod	$00, $00, $00, $00
0001127A =00000000                M spam1	=	op1
0001127A =00000000                M spam2	=	op2
0001127A =00000000                M spam3	=	op3
0001127A =00000000                M spam4	=	op4
0001127A                            	spSustainRt	$03, $02, $02, $00
0001127A =00000003                M spsr1	=	op1
0001127A =00000002                M spsr2	=	op2
0001127A =00000002                M spsr3	=	op3
0001127A =00000000                M spsr4	=	op4
0001127A                            	spDecayRt	$02, $02, $02, $1F
0001127A =00000002                M spdr1	=	op1
0001127A =00000002                M spdr2	=	op2
0001127A =00000002                M spdr3	=	op3
0001127A =0000001F                M spdr4	=	op4
0001127A                            	spSustainLv	$02, $01, $01, $01
0001127A =00000002                M spsl1	=	op1
0001127A =00000001                M spsl2	=	op2
0001127A =00000001                M spsl3	=	op3
0001127A =00000001                M spsl4	=	op4
0001127A                            	spReleaseRt	$02, $03, $04, $05
0001127A =00000002                M sprr1	=	op1
0001127A =00000003                M sprr2	=	op2
0001127A =00000004                M sprr3	=	op3
0001127A =00000005                M sprr4	=	op4
0001127A                            	spSSGEG		$00, $00, $00, $00
0001127A =00000000                M spss1	=	op1
0001127A =00000000                M spss2	=	op2
0001127A =00000000                M spss3	=	op3
0001127A =00000000                M spss4	=	op4
0001127A                            	spTotalLv	$0E, $23, $04, $04
0001127A =0000000E                M sptl1	=	op1
0001127A =00000023                M sptl2	=	op2
0001127A =00000004                M sptl3	=	op3
0001127A =00000004                M sptl4	=	op4
0001127A 3B                       M 	dc.b	(spfe<<3)+spal
0001127B =00000080                M sptlmask4	set	$80
0001127B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001127B =00000000                M sptlmask3	set	((spal>=4)<<7)
0001127B =00000000                M sptlmask1	set	((spal=7)<<7)
0001127B 0001 0003                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001127F 1F1F 1614                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011283 0302 0200                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011287 0202 021F                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001128B 2214 1315                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001128F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011293 0E04 2384                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011297 4E41 54                  M 	dc.b	'NAT'
0001129A                            
0001129A                            	; Patch $26
0001129A                            	; $3B
0001129A                            	; $30, $50, $33, $10,	$59, $55, $19, $1A
0001129A                            	; $00, $00, $00, $00,	$1F, $1F, $1F, $03
0001129A                            	; $7E, $17, $27, $17,	$0F, $00, $0D, $05
0001129A                            	spAlgorithm	$03
0001129A =00000027                M spatnum	=	spatnum+1
0001129A =00000003                M spal	=	val
0001129A                            	spFeedback	$07
0001129A =00000007                M spfe	=	val
0001129A                            	spDetune	$03, $03, $05, $01
0001129A =00000003                M spde1	=	op1
0001129A =00000003                M spde2	=	op2
0001129A =00000005                M spde3	=	op3
0001129A =00000001                M spde4	=	op4
0001129A                            	spMultiple	$00, $03, $00, $00
0001129A =00000000                M spmu1	=	op1
0001129A =00000003                M spmu2	=	op2
0001129A =00000000                M spmu3	=	op3
0001129A =00000000                M spmu4	=	op4
0001129A                            	spRateScale	$01, $00, $01, $00
0001129A =00000001                M sprs1	=	op1
0001129A =00000000                M sprs2	=	op2
0001129A =00000001                M sprs3	=	op3
0001129A =00000000                M sprs4	=	op4
0001129A                            	spAttackRt	$19, $19, $15, $1A
0001129A =00000019                M spar1	=	op1
0001129A =00000019                M spar2	=	op2
0001129A =00000015                M spar3	=	op3
0001129A =0000001A                M spar4	=	op4
0001129A                            	spAmpMod	$00, $00, $00, $00
0001129A =00000000                M spam1	=	op1
0001129A =00000000                M spam2	=	op2
0001129A =00000000                M spam3	=	op3
0001129A =00000000                M spam4	=	op4
0001129A                            	spSustainRt	$00, $00, $00, $00
0001129A =00000000                M spsr1	=	op1
0001129A =00000000                M spsr2	=	op2
0001129A =00000000                M spsr3	=	op3
0001129A =00000000                M spsr4	=	op4
0001129A                            	spDecayRt	$1F, $1F, $1F, $03
0001129A =0000001F                M spdr1	=	op1
0001129A =0000001F                M spdr2	=	op2
0001129A =0000001F                M spdr3	=	op3
0001129A =00000003                M spdr4	=	op4
0001129A                            	spSustainLv	$07, $02, $01, $01
0001129A =00000007                M spsl1	=	op1
0001129A =00000002                M spsl2	=	op2
0001129A =00000001                M spsl3	=	op3
0001129A =00000001                M spsl4	=	op4
0001129A                            	spReleaseRt	$0E, $07, $07, $07
0001129A =0000000E                M sprr1	=	op1
0001129A =00000007                M sprr2	=	op2
0001129A =00000007                M sprr3	=	op3
0001129A =00000007                M sprr4	=	op4
0001129A                            	spSSGEG		$00, $00, $00, $00
0001129A =00000000                M spss1	=	op1
0001129A =00000000                M spss2	=	op2
0001129A =00000000                M spss3	=	op3
0001129A =00000000                M spss4	=	op4
0001129A                            	spTotalLv	$0F, $0D, $00, $05
0001129A =0000000F                M sptl1	=	op1
0001129A =0000000D                M sptl2	=	op2
0001129A =00000000                M sptl3	=	op3
0001129A =00000005                M sptl4	=	op4
0001129A 3B                       M 	dc.b	(spfe<<3)+spal
0001129B =00000080                M sptlmask4	set	$80
0001129B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001129B =00000000                M sptlmask3	set	((spal>=4)<<7)
0001129B =00000000                M sptlmask1	set	((spal=7)<<7)
0001129B 3050 3310                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001129F 5955 191A                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000112A3 0000 0000                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000112A7 1F1F 1F03                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000112AB 7E17 2717                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000112AF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000112B3 0F00 0D85                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000112B7 4E41 54                  M 	dc.b	'NAT'
000112BA                            
000112BA                            	; Patch $27
000112BA                            	; $35
000112BA                            	; $21, $31, $20, $14,	$8E, $9B, $95, $94
000112BA                            	; $00, $05, $00, $80,	$01, $02, $02, $02
000112BA                            	; $4F, $3F, $1F, $0F,	$16, $06, $08, $05
000112BA                            	spAlgorithm	$05
000112BA =00000028                M spatnum	=	spatnum+1
000112BA =00000005                M spal	=	val
000112BA                            	spFeedback	$06
000112BA =00000006                M spfe	=	val
000112BA                            	spDetune	$02, $02, $03, $01
000112BA =00000002                M spde1	=	op1
000112BA =00000002                M spde2	=	op2
000112BA =00000003                M spde3	=	op3
000112BA =00000001                M spde4	=	op4
000112BA                            	spMultiple	$01, $00, $01, $04
000112BA =00000001                M spmu1	=	op1
000112BA =00000000                M spmu2	=	op2
000112BA =00000001                M spmu3	=	op3
000112BA =00000004                M spmu4	=	op4
000112BA                            	spRateScale	$02, $02, $02, $02
000112BA =00000002                M sprs1	=	op1
000112BA =00000002                M sprs2	=	op2
000112BA =00000002                M sprs3	=	op3
000112BA =00000002                M sprs4	=	op4
000112BA                            	spAttackRt	$0E, $15, $1B, $14
000112BA =0000000E                M spar1	=	op1
000112BA =00000015                M spar2	=	op2
000112BA =0000001B                M spar3	=	op3
000112BA =00000014                M spar4	=	op4
000112BA                            	spAmpMod	$00, $00, $00, $01
000112BA =00000000                M spam1	=	op1
000112BA =00000000                M spam2	=	op2
000112BA =00000000                M spam3	=	op3
000112BA =00000001                M spam4	=	op4
000112BA                            	spSustainRt	$00, $00, $05, $00
000112BA =00000000                M spsr1	=	op1
000112BA =00000000                M spsr2	=	op2
000112BA =00000005                M spsr3	=	op3
000112BA =00000000                M spsr4	=	op4
000112BA                            	spDecayRt	$01, $02, $02, $02
000112BA =00000001                M spdr1	=	op1
000112BA =00000002                M spdr2	=	op2
000112BA =00000002                M spdr3	=	op3
000112BA =00000002                M spdr4	=	op4
000112BA                            	spSustainLv	$04, $01, $03, $00
000112BA =00000004                M spsl1	=	op1
000112BA =00000001                M spsl2	=	op2
000112BA =00000003                M spsl3	=	op3
000112BA =00000000                M spsl4	=	op4
000112BA                            	spReleaseRt	$0F, $0F, $0F, $0F
000112BA =0000000F                M sprr1	=	op1
000112BA =0000000F                M sprr2	=	op2
000112BA =0000000F                M sprr3	=	op3
000112BA =0000000F                M sprr4	=	op4
000112BA                            	spSSGEG		$00, $00, $00, $00
000112BA =00000000                M spss1	=	op1
000112BA =00000000                M spss2	=	op2
000112BA =00000000                M spss3	=	op3
000112BA =00000000                M spss4	=	op4
000112BA                            	spTotalLv	$16, $08, $06, $05
000112BA =00000016                M sptl1	=	op1
000112BA =00000008                M sptl2	=	op2
000112BA =00000006                M sptl3	=	op3
000112BA =00000005                M sptl4	=	op4
000112BA 35                       M 	dc.b	(spfe<<3)+spal
000112BB =00000080                M sptlmask4	set	$80
000112BB =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
000112BB =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
000112BB =00000000                M sptlmask1	set	((spal=7)<<7)
000112BB 2131 2014                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000112BF 8E9B 9594                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000112C3 0005 0080                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000112C7 0102 0202                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000112CB 4F3F 1F0F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000112CF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000112D3 1686 8885                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000112D7 4E41 54                  M 	dc.b	'NAT'
000112DA                            
000112DA                            	; Patch $28
000112DA                            	; $24
000112DA                            	; $01, $33, $00, $00,	$12, $0A, $0D, $0C
000112DA                            	; $00, $8F, $03, $0F,	$00, $00, $00, $00
000112DA                            	; $4F, $1F, $1F, $1F,	$03, $05, $10, $05
000112DA                            	spAlgorithm	$04
000112DA =00000029                M spatnum	=	spatnum+1
000112DA =00000004                M spal	=	val
000112DA                            	spFeedback	$04
000112DA =00000004                M spfe	=	val
000112DA                            	spDetune	$00, $00, $03, $00
000112DA =00000000                M spde1	=	op1
000112DA =00000000                M spde2	=	op2
000112DA =00000003                M spde3	=	op3
000112DA =00000000                M spde4	=	op4
000112DA                            	spMultiple	$01, $00, $03, $00
000112DA =00000001                M spmu1	=	op1
000112DA =00000000                M spmu2	=	op2
000112DA =00000003                M spmu3	=	op3
000112DA =00000000                M spmu4	=	op4
000112DA                            	spRateScale	$00, $00, $00, $00
000112DA =00000000                M sprs1	=	op1
000112DA =00000000                M sprs2	=	op2
000112DA =00000000                M sprs3	=	op3
000112DA =00000000                M sprs4	=	op4
000112DA                            	spAttackRt	$12, $0D, $0A, $0C
000112DA =00000012                M spar1	=	op1
000112DA =0000000D                M spar2	=	op2
000112DA =0000000A                M spar3	=	op3
000112DA =0000000C                M spar4	=	op4
000112DA                            	spAmpMod	$00, $00, $01, $00
000112DA =00000000                M spam1	=	op1
000112DA =00000000                M spam2	=	op2
000112DA =00000001                M spam3	=	op3
000112DA =00000000                M spam4	=	op4
000112DA                            	spSustainRt	$00, $03, $0F, $0F
000112DA =00000000                M spsr1	=	op1
000112DA =00000003                M spsr2	=	op2
000112DA =0000000F                M spsr3	=	op3
000112DA =0000000F                M spsr4	=	op4
000112DA                            	spDecayRt	$00, $00, $00, $00
000112DA =00000000                M spdr1	=	op1
000112DA =00000000                M spdr2	=	op2
000112DA =00000000                M spdr3	=	op3
000112DA =00000000                M spdr4	=	op4
000112DA                            	spSustainLv	$04, $01, $01, $01
000112DA =00000004                M spsl1	=	op1
000112DA =00000001                M spsl2	=	op2
000112DA =00000001                M spsl3	=	op3
000112DA =00000001                M spsl4	=	op4
000112DA                            	spReleaseRt	$0F, $0F, $0F, $0F
000112DA =0000000F                M sprr1	=	op1
000112DA =0000000F                M sprr2	=	op2
000112DA =0000000F                M sprr3	=	op3
000112DA =0000000F                M sprr4	=	op4
000112DA                            	spSSGEG		$00, $00, $00, $00
000112DA =00000000                M spss1	=	op1
000112DA =00000000                M spss2	=	op2
000112DA =00000000                M spss3	=	op3
000112DA =00000000                M spss4	=	op4
000112DA                            	spTotalLv	$03, $10, $05, $05
000112DA =00000003                M sptl1	=	op1
000112DA =00000010                M sptl2	=	op2
000112DA =00000005                M sptl3	=	op3
000112DA =00000005                M sptl4	=	op4
000112DA 24                       M 	dc.b	(spfe<<3)+spal
000112DB =00000080                M sptlmask4	set	$80
000112DB =00000000                M sptlmask2	set	((spal>=5)<<7)
000112DB =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
000112DB =00000000                M sptlmask1	set	((spal=7)<<7)
000112DB 0133 0000                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000112DF 120A 0D0C                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000112E3 008F 030F                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000112E7 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000112EB 4F1F 1F1F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000112EF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000112F3 0385 1085                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000112F7 4E41 54                  M 	dc.b	'NAT'
000112FA                            
000112FA                            	; Patch $29
000112FA                            	; $29
000112FA                            	; $33, $50, $02, $25,	$9D, $56, $13, $5E
000112FA                            	; $01, $01, $00, $01,	$15, $0F, $0C, $0F
000112FA                            	; $4F, $3F, $3F, $3F,	$13, $10, $1B, $05
000112FA                            	spAlgorithm	$01
000112FA =0000002A                M spatnum	=	spatnum+1
000112FA =00000001                M spal	=	val
000112FA                            	spFeedback	$05
000112FA =00000005                M spfe	=	val
000112FA                            	spDetune	$03, $00, $05, $02
000112FA =00000003                M spde1	=	op1
000112FA =00000000                M spde2	=	op2
000112FA =00000005                M spde3	=	op3
000112FA =00000002                M spde4	=	op4
000112FA                            	spMultiple	$03, $02, $00, $05
000112FA =00000003                M spmu1	=	op1
000112FA =00000002                M spmu2	=	op2
000112FA =00000000                M spmu3	=	op3
000112FA =00000005                M spmu4	=	op4
000112FA                            	spRateScale	$02, $00, $01, $01
000112FA =00000002                M sprs1	=	op1
000112FA =00000000                M sprs2	=	op2
000112FA =00000001                M sprs3	=	op3
000112FA =00000001                M sprs4	=	op4
000112FA                            	spAttackRt	$1D, $13, $16, $1E
000112FA =0000001D                M spar1	=	op1
000112FA =00000013                M spar2	=	op2
000112FA =00000016                M spar3	=	op3
000112FA =0000001E                M spar4	=	op4
000112FA                            	spAmpMod	$00, $00, $00, $00
000112FA =00000000                M spam1	=	op1
000112FA =00000000                M spam2	=	op2
000112FA =00000000                M spam3	=	op3
000112FA =00000000                M spam4	=	op4
000112FA                            	spSustainRt	$01, $00, $01, $01
000112FA =00000001                M spsr1	=	op1
000112FA =00000000                M spsr2	=	op2
000112FA =00000001                M spsr3	=	op3
000112FA =00000001                M spsr4	=	op4
000112FA                            	spDecayRt	$15, $0C, $0F, $0F
000112FA =00000015                M spdr1	=	op1
000112FA =0000000C                M spdr2	=	op2
000112FA =0000000F                M spdr3	=	op3
000112FA =0000000F                M spdr4	=	op4
000112FA                            	spSustainLv	$04, $03, $03, $03
000112FA =00000004                M spsl1	=	op1
000112FA =00000003                M spsl2	=	op2
000112FA =00000003                M spsl3	=	op3
000112FA =00000003                M spsl4	=	op4
000112FA                            	spReleaseRt	$0F, $0F, $0F, $0F
000112FA =0000000F                M sprr1	=	op1
000112FA =0000000F                M sprr2	=	op2
000112FA =0000000F                M sprr3	=	op3
000112FA =0000000F                M sprr4	=	op4
000112FA                            	spSSGEG		$00, $00, $00, $00
000112FA =00000000                M spss1	=	op1
000112FA =00000000                M spss2	=	op2
000112FA =00000000                M spss3	=	op3
000112FA =00000000                M spss4	=	op4
000112FA                            	spTotalLv	$13, $1B, $10, $05
000112FA =00000013                M sptl1	=	op1
000112FA =0000001B                M sptl2	=	op2
000112FA =00000010                M sptl3	=	op3
000112FA =00000005                M sptl4	=	op4
000112FA 29                       M 	dc.b	(spfe<<3)+spal
000112FB =00000080                M sptlmask4	set	$80
000112FB =00000000                M sptlmask2	set	((spal>=5)<<7)
000112FB =00000000                M sptlmask3	set	((spal>=4)<<7)
000112FB =00000000                M sptlmask1	set	((spal=7)<<7)
000112FB 3350 0225                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000112FF 9D56 135E                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011303 0101 0001                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011307 150F 0C0F                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001130B 4F3F 3F3F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001130F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011313 1310 1B85                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011317 4E41 54                  M 	dc.b	'NAT'
0001131A                            
0001131A                            	; Patch $2A
0001131A                            	; $2B
0001131A                            	; $31, $32, $35, $31,	$1F, $59, $9E, $5E
0001131A                            	; $80, $80, $80, $85,	$01, $17, $12, $0A
0001131A                            	; $AA, $AF, $F9, $FC,	$0F, $12, $46, $05
0001131A                            	spAlgorithm	$03
0001131A =0000002B                M spatnum	=	spatnum+1
0001131A =00000003                M spal	=	val
0001131A                            	spFeedback	$05
0001131A =00000005                M spfe	=	val
0001131A                            	spDetune	$03, $03, $03, $03
0001131A =00000003                M spde1	=	op1
0001131A =00000003                M spde2	=	op2
0001131A =00000003                M spde3	=	op3
0001131A =00000003                M spde4	=	op4
0001131A                            	spMultiple	$01, $05, $02, $01
0001131A =00000001                M spmu1	=	op1
0001131A =00000005                M spmu2	=	op2
0001131A =00000002                M spmu3	=	op3
0001131A =00000001                M spmu4	=	op4
0001131A                            	spRateScale	$00, $02, $01, $01
0001131A =00000000                M sprs1	=	op1
0001131A =00000002                M sprs2	=	op2
0001131A =00000001                M sprs3	=	op3
0001131A =00000001                M sprs4	=	op4
0001131A                            	spAttackRt	$1F, $1E, $19, $1E
0001131A =0000001F                M spar1	=	op1
0001131A =0000001E                M spar2	=	op2
0001131A =00000019                M spar3	=	op3
0001131A =0000001E                M spar4	=	op4
0001131A                            	spAmpMod	$01, $01, $01, $01
0001131A =00000001                M spam1	=	op1
0001131A =00000001                M spam2	=	op2
0001131A =00000001                M spam3	=	op3
0001131A =00000001                M spam4	=	op4
0001131A                            	spSustainRt	$00, $00, $00, $05
0001131A =00000000                M spsr1	=	op1
0001131A =00000000                M spsr2	=	op2
0001131A =00000000                M spsr3	=	op3
0001131A =00000005                M spsr4	=	op4
0001131A                            	spDecayRt	$01, $12, $17, $0A
0001131A =00000001                M spdr1	=	op1
0001131A =00000012                M spdr2	=	op2
0001131A =00000017                M spdr3	=	op3
0001131A =0000000A                M spdr4	=	op4
0001131A                            	spSustainLv	$0A, $0F, $0A, $0F
0001131A =0000000A                M spsl1	=	op1
0001131A =0000000F                M spsl2	=	op2
0001131A =0000000A                M spsl3	=	op3
0001131A =0000000F                M spsl4	=	op4
0001131A                            	spReleaseRt	$0A, $09, $0F, $0C
0001131A =0000000A                M sprr1	=	op1
0001131A =00000009                M sprr2	=	op2
0001131A =0000000F                M sprr3	=	op3
0001131A =0000000C                M sprr4	=	op4
0001131A                            	spSSGEG		$00, $00, $00, $00
0001131A =00000000                M spss1	=	op1
0001131A =00000000                M spss2	=	op2
0001131A =00000000                M spss3	=	op3
0001131A =00000000                M spss4	=	op4
0001131A                            	spTotalLv	$0F, $46, $12, $05
0001131A =0000000F                M sptl1	=	op1
0001131A =00000046                M sptl2	=	op2
0001131A =00000012                M sptl3	=	op3
0001131A =00000005                M sptl4	=	op4
0001131A 2B                       M 	dc.b	(spfe<<3)+spal
0001131B =00000080                M sptlmask4	set	$80
0001131B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001131B =00000000                M sptlmask3	set	((spal>=4)<<7)
0001131B =00000000                M sptlmask1	set	((spal=7)<<7)
0001131B 3132 3531                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001131F 1F59 9E5E                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011323 8080 8085                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011327 0117 120A                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001132B AAAF F9FC                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001132F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011333 0F12 4685                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011337 4E41 54                  M 	dc.b	'NAT'
0001133A                            
0001133A                            	; Patch $2B
0001133A                            	; $04
0001133A                            	; $70, $70, $30, $31,	$9F, $1F, $9F, $1F
0001133A                            	; $80, $80, $9F, $8E,	$00, $00, $12, $00
0001133A                            	; $09, $09, $09, $09,	$33, $05, $08, $05
0001133A                            	spAlgorithm	$04
0001133A =0000002C                M spatnum	=	spatnum+1
0001133A =00000004                M spal	=	val
0001133A                            	spFeedback	$00
0001133A =00000000                M spfe	=	val
0001133A                            	spDetune	$07, $03, $07, $03
0001133A =00000007                M spde1	=	op1
0001133A =00000003                M spde2	=	op2
0001133A =00000007                M spde3	=	op3
0001133A =00000003                M spde4	=	op4
0001133A                            	spMultiple	$00, $00, $00, $01
0001133A =00000000                M spmu1	=	op1
0001133A =00000000                M spmu2	=	op2
0001133A =00000000                M spmu3	=	op3
0001133A =00000001                M spmu4	=	op4
0001133A                            	spRateScale	$02, $02, $00, $00
0001133A =00000002                M sprs1	=	op1
0001133A =00000002                M sprs2	=	op2
0001133A =00000000                M sprs3	=	op3
0001133A =00000000                M sprs4	=	op4
0001133A                            	spAttackRt	$1F, $1F, $1F, $1F
0001133A =0000001F                M spar1	=	op1
0001133A =0000001F                M spar2	=	op2
0001133A =0000001F                M spar3	=	op3
0001133A =0000001F                M spar4	=	op4
0001133A                            	spAmpMod	$01, $01, $01, $01
0001133A =00000001                M spam1	=	op1
0001133A =00000001                M spam2	=	op2
0001133A =00000001                M spam3	=	op3
0001133A =00000001                M spam4	=	op4
0001133A                            	spSustainRt	$00, $1F, $00, $0E
0001133A =00000000                M spsr1	=	op1
0001133A =0000001F                M spsr2	=	op2
0001133A =00000000                M spsr3	=	op3
0001133A =0000000E                M spsr4	=	op4
0001133A                            	spDecayRt	$00, $12, $00, $00
0001133A =00000000                M spdr1	=	op1
0001133A =00000012                M spdr2	=	op2
0001133A =00000000                M spdr3	=	op3
0001133A =00000000                M spdr4	=	op4
0001133A                            	spSustainLv	$00, $00, $00, $00
0001133A =00000000                M spsl1	=	op1
0001133A =00000000                M spsl2	=	op2
0001133A =00000000                M spsl3	=	op3
0001133A =00000000                M spsl4	=	op4
0001133A                            	spReleaseRt	$09, $09, $09, $09
0001133A =00000009                M sprr1	=	op1
0001133A =00000009                M sprr2	=	op2
0001133A =00000009                M sprr3	=	op3
0001133A =00000009                M sprr4	=	op4
0001133A                            	spSSGEG		$00, $00, $00, $00
0001133A =00000000                M spss1	=	op1
0001133A =00000000                M spss2	=	op2
0001133A =00000000                M spss3	=	op3
0001133A =00000000                M spss4	=	op4
0001133A                            	spTotalLv	$33, $08, $05, $05
0001133A =00000033                M sptl1	=	op1
0001133A =00000008                M sptl2	=	op2
0001133A =00000005                M sptl3	=	op3
0001133A =00000005                M sptl4	=	op4
0001133A 04                       M 	dc.b	(spfe<<3)+spal
0001133B =00000080                M sptlmask4	set	$80
0001133B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001133B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
0001133B =00000000                M sptlmask1	set	((spal=7)<<7)
0001133B 7070 3031                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001133F 9F1F 9F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011343 8080 9F8E                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011347 0000 1200                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001134B 0909 0909                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001134F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011353 3385 0885                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011357 4E41 54                  M 	dc.b	'NAT'
0001135A                            
0001135A                            	; Patch $2C
0001135A                            	; $1F
0001135A                            	; $16, $61, $03, $52,	$1C, $9F, $1F, $1F
0001135A                            	; $92, $8F, $8F, $8F,	$00, $00, $00, $00
0001135A                            	; $FF, $0F, $0F, $0F,	$05, $05, $05, $05
0001135A                            	spAlgorithm	$07
0001135A =0000002D                M spatnum	=	spatnum+1
0001135A =00000007                M spal	=	val
0001135A                            	spFeedback	$03
0001135A =00000003                M spfe	=	val
0001135A                            	spDetune	$01, $00, $06, $05
0001135A =00000001                M spde1	=	op1
0001135A =00000000                M spde2	=	op2
0001135A =00000006                M spde3	=	op3
0001135A =00000005                M spde4	=	op4
0001135A                            	spMultiple	$06, $03, $01, $02
0001135A =00000006                M spmu1	=	op1
0001135A =00000003                M spmu2	=	op2
0001135A =00000001                M spmu3	=	op3
0001135A =00000002                M spmu4	=	op4
0001135A                            	spRateScale	$00, $00, $02, $00
0001135A =00000000                M sprs1	=	op1
0001135A =00000000                M sprs2	=	op2
0001135A =00000002                M sprs3	=	op3
0001135A =00000000                M sprs4	=	op4
0001135A                            	spAttackRt	$1C, $1F, $1F, $1F
0001135A =0000001C                M spar1	=	op1
0001135A =0000001F                M spar2	=	op2
0001135A =0000001F                M spar3	=	op3
0001135A =0000001F                M spar4	=	op4
0001135A                            	spAmpMod	$01, $01, $01, $01
0001135A =00000001                M spam1	=	op1
0001135A =00000001                M spam2	=	op2
0001135A =00000001                M spam3	=	op3
0001135A =00000001                M spam4	=	op4
0001135A                            	spSustainRt	$12, $0F, $0F, $0F
0001135A =00000012                M spsr1	=	op1
0001135A =0000000F                M spsr2	=	op2
0001135A =0000000F                M spsr3	=	op3
0001135A =0000000F                M spsr4	=	op4
0001135A                            	spDecayRt	$00, $00, $00, $00
0001135A =00000000                M spdr1	=	op1
0001135A =00000000                M spdr2	=	op2
0001135A =00000000                M spdr3	=	op3
0001135A =00000000                M spdr4	=	op4
0001135A                            	spSustainLv	$0F, $00, $00, $00
0001135A =0000000F                M spsl1	=	op1
0001135A =00000000                M spsl2	=	op2
0001135A =00000000                M spsl3	=	op3
0001135A =00000000                M spsl4	=	op4
0001135A                            	spReleaseRt	$0F, $0F, $0F, $0F
0001135A =0000000F                M sprr1	=	op1
0001135A =0000000F                M sprr2	=	op2
0001135A =0000000F                M sprr3	=	op3
0001135A =0000000F                M sprr4	=	op4
0001135A                            	spSSGEG		$00, $00, $00, $00
0001135A =00000000                M spss1	=	op1
0001135A =00000000                M spss2	=	op2
0001135A =00000000                M spss3	=	op3
0001135A =00000000                M spss4	=	op4
0001135A                            	spTotalLv	$05, $05, $05, $05
0001135A =00000005                M sptl1	=	op1
0001135A =00000005                M sptl2	=	op2
0001135A =00000005                M sptl3	=	op3
0001135A =00000005                M sptl4	=	op4
0001135A 1F                       M 	dc.b	(spfe<<3)+spal
0001135B =00000080                M sptlmask4	set	$80
0001135B =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
0001135B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
0001135B =FFFFFF80                M sptlmask1	set	((spal=7)<<7)
0001135B 1661 0352                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001135F 1C9F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011363 928F 8F8F                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011367 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001136B FF0F 0F0F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001136F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011373 8585 8585                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011377 4E41 54                  M 	dc.b	'NAT'
0001137A                            
0001137A                            	; Patch $2D
0001137A                            	; $2C
0001137A                            	; $74, $74, $34, $34,	$12, $12, $12, $12
0001137A                            	; $80, $80, $80, $80,	$00, $01, $00, $01
0001137A                            	; $07, $37, $07, $37,	$16, $05, $17, $05
0001137A                            	spAlgorithm	$04
0001137A =0000002E                M spatnum	=	spatnum+1
0001137A =00000004                M spal	=	val
0001137A                            	spFeedback	$05
0001137A =00000005                M spfe	=	val
0001137A                            	spDetune	$07, $03, $07, $03
0001137A =00000007                M spde1	=	op1
0001137A =00000003                M spde2	=	op2
0001137A =00000007                M spde3	=	op3
0001137A =00000003                M spde4	=	op4
0001137A                            	spMultiple	$04, $04, $04, $04
0001137A =00000004                M spmu1	=	op1
0001137A =00000004                M spmu2	=	op2
0001137A =00000004                M spmu3	=	op3
0001137A =00000004                M spmu4	=	op4
0001137A                            	spRateScale	$00, $00, $00, $00
0001137A =00000000                M sprs1	=	op1
0001137A =00000000                M sprs2	=	op2
0001137A =00000000                M sprs3	=	op3
0001137A =00000000                M sprs4	=	op4
0001137A                            	spAttackRt	$12, $12, $12, $12
0001137A =00000012                M spar1	=	op1
0001137A =00000012                M spar2	=	op2
0001137A =00000012                M spar3	=	op3
0001137A =00000012                M spar4	=	op4
0001137A                            	spAmpMod	$01, $01, $01, $01
0001137A =00000001                M spam1	=	op1
0001137A =00000001                M spam2	=	op2
0001137A =00000001                M spam3	=	op3
0001137A =00000001                M spam4	=	op4
0001137A                            	spSustainRt	$00, $00, $00, $00
0001137A =00000000                M spsr1	=	op1
0001137A =00000000                M spsr2	=	op2
0001137A =00000000                M spsr3	=	op3
0001137A =00000000                M spsr4	=	op4
0001137A                            	spDecayRt	$00, $00, $01, $01
0001137A =00000000                M spdr1	=	op1
0001137A =00000000                M spdr2	=	op2
0001137A =00000001                M spdr3	=	op3
0001137A =00000001                M spdr4	=	op4
0001137A                            	spSustainLv	$00, $00, $03, $03
0001137A =00000000                M spsl1	=	op1
0001137A =00000000                M spsl2	=	op2
0001137A =00000003                M spsl3	=	op3
0001137A =00000003                M spsl4	=	op4
0001137A                            	spReleaseRt	$07, $07, $07, $07
0001137A =00000007                M sprr1	=	op1
0001137A =00000007                M sprr2	=	op2
0001137A =00000007                M sprr3	=	op3
0001137A =00000007                M sprr4	=	op4
0001137A                            	spSSGEG		$00, $00, $00, $00
0001137A =00000000                M spss1	=	op1
0001137A =00000000                M spss2	=	op2
0001137A =00000000                M spss3	=	op3
0001137A =00000000                M spss4	=	op4
0001137A                            	spTotalLv	$16, $17, $05, $05
0001137A =00000016                M sptl1	=	op1
0001137A =00000017                M sptl2	=	op2
0001137A =00000005                M sptl3	=	op3
0001137A =00000005                M sptl4	=	op4
0001137A 2C                       M 	dc.b	(spfe<<3)+spal
0001137B =00000080                M sptlmask4	set	$80
0001137B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001137B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
0001137B =00000000                M sptlmask1	set	((spal=7)<<7)
0001137B 7474 3434                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001137F 1212 1212                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011383 8080 8080                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011387 0001 0001                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001138B 0737 0737                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001138F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011393 1685 1785                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011397 4E41 54                  M 	dc.b	'NAT'
0001139A                            
0001139A                            	; Patch $2E
0001139A                            	; $07
0001139A                            	; $34, $74, $32, $70,	$1F, $1F, $1F, $1F
0001139A                            	; $0A, $0A, $05, $03,	$00, $00, $00, $00
0001139A                            	; $3F, $3F, $2F, $2F,	$05, $05, $05, $05
0001139A                            	spAlgorithm	$07
0001139A =0000002F                M spatnum	=	spatnum+1
0001139A =00000007                M spal	=	val
0001139A                            	spFeedback	$00
0001139A =00000000                M spfe	=	val
0001139A                            	spDetune	$03, $03, $07, $07
0001139A =00000003                M spde1	=	op1
0001139A =00000003                M spde2	=	op2
0001139A =00000007                M spde3	=	op3
0001139A =00000007                M spde4	=	op4
0001139A                            	spMultiple	$04, $02, $04, $00
0001139A =00000004                M spmu1	=	op1
0001139A =00000002                M spmu2	=	op2
0001139A =00000004                M spmu3	=	op3
0001139A =00000000                M spmu4	=	op4
0001139A                            	spRateScale	$00, $00, $00, $00
0001139A =00000000                M sprs1	=	op1
0001139A =00000000                M sprs2	=	op2
0001139A =00000000                M sprs3	=	op3
0001139A =00000000                M sprs4	=	op4
0001139A                            	spAttackRt	$1F, $1F, $1F, $1F
0001139A =0000001F                M spar1	=	op1
0001139A =0000001F                M spar2	=	op2
0001139A =0000001F                M spar3	=	op3
0001139A =0000001F                M spar4	=	op4
0001139A                            	spAmpMod	$00, $00, $00, $00
0001139A =00000000                M spam1	=	op1
0001139A =00000000                M spam2	=	op2
0001139A =00000000                M spam3	=	op3
0001139A =00000000                M spam4	=	op4
0001139A                            	spSustainRt	$0A, $05, $0A, $03
0001139A =0000000A                M spsr1	=	op1
0001139A =00000005                M spsr2	=	op2
0001139A =0000000A                M spsr3	=	op3
0001139A =00000003                M spsr4	=	op4
0001139A                            	spDecayRt	$00, $00, $00, $00
0001139A =00000000                M spdr1	=	op1
0001139A =00000000                M spdr2	=	op2
0001139A =00000000                M spdr3	=	op3
0001139A =00000000                M spdr4	=	op4
0001139A                            	spSustainLv	$03, $02, $03, $02
0001139A =00000003                M spsl1	=	op1
0001139A =00000002                M spsl2	=	op2
0001139A =00000003                M spsl3	=	op3
0001139A =00000002                M spsl4	=	op4
0001139A                            	spReleaseRt	$0F, $0F, $0F, $0F
0001139A =0000000F                M sprr1	=	op1
0001139A =0000000F                M sprr2	=	op2
0001139A =0000000F                M sprr3	=	op3
0001139A =0000000F                M sprr4	=	op4
0001139A                            	spSSGEG		$00, $00, $00, $00
0001139A =00000000                M spss1	=	op1
0001139A =00000000                M spss2	=	op2
0001139A =00000000                M spss3	=	op3
0001139A =00000000                M spss4	=	op4
0001139A                            	spTotalLv	$05, $05, $05, $05
0001139A =00000005                M sptl1	=	op1
0001139A =00000005                M sptl2	=	op2
0001139A =00000005                M sptl3	=	op3
0001139A =00000005                M sptl4	=	op4
0001139A 07                       M 	dc.b	(spfe<<3)+spal
0001139B =00000080                M sptlmask4	set	$80
0001139B =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
0001139B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
0001139B =FFFFFF80                M sptlmask1	set	((spal=7)<<7)
0001139B 3474 3270                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001139F 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000113A3 0A0A 0503                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000113A7 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000113AB 3F3F 2F2F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000113AF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000113B3 8585 8585                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000113B7 4E41 54                  M 	dc.b	'NAT'
000113BA                            
000113BA                            	; Patch $2F
000113BA                            	; $3A
000113BA                            	; $70, $76, $30, $71,	$1F, $95, $1F, $1F
000113BA                            	; $0E, $0F, $05, $0C,	$07, $06, $06, $07
000113BA                            	; $2F, $4F, $1F, $5F,	$18, $0E, $0F, $02
000113BA                            	spAlgorithm	$02
000113BA =00000030                M spatnum	=	spatnum+1
000113BA =00000002                M spal	=	val
000113BA                            	spFeedback	$07
000113BA =00000007                M spfe	=	val
000113BA                            	spDetune	$07, $03, $07, $07
000113BA =00000007                M spde1	=	op1
000113BA =00000003                M spde2	=	op2
000113BA =00000007                M spde3	=	op3
000113BA =00000007                M spde4	=	op4
000113BA                            	spMultiple	$00, $00, $06, $01
000113BA =00000000                M spmu1	=	op1
000113BA =00000000                M spmu2	=	op2
000113BA =00000006                M spmu3	=	op3
000113BA =00000001                M spmu4	=	op4
000113BA                            	spRateScale	$00, $00, $02, $00
000113BA =00000000                M sprs1	=	op1
000113BA =00000000                M sprs2	=	op2
000113BA =00000002                M sprs3	=	op3
000113BA =00000000                M sprs4	=	op4
000113BA                            	spAttackRt	$1F, $1F, $15, $1F
000113BA =0000001F                M spar1	=	op1
000113BA =0000001F                M spar2	=	op2
000113BA =00000015                M spar3	=	op3
000113BA =0000001F                M spar4	=	op4
000113BA                            	spAmpMod	$00, $00, $00, $00
000113BA =00000000                M spam1	=	op1
000113BA =00000000                M spam2	=	op2
000113BA =00000000                M spam3	=	op3
000113BA =00000000                M spam4	=	op4
000113BA                            	spSustainRt	$0E, $05, $0F, $0C
000113BA =0000000E                M spsr1	=	op1
000113BA =00000005                M spsr2	=	op2
000113BA =0000000F                M spsr3	=	op3
000113BA =0000000C                M spsr4	=	op4
000113BA                            	spDecayRt	$07, $06, $06, $07
000113BA =00000007                M spdr1	=	op1
000113BA =00000006                M spdr2	=	op2
000113BA =00000006                M spdr3	=	op3
000113BA =00000007                M spdr4	=	op4
000113BA                            	spSustainLv	$02, $01, $04, $05
000113BA =00000002                M spsl1	=	op1
000113BA =00000001                M spsl2	=	op2
000113BA =00000004                M spsl3	=	op3
000113BA =00000005                M spsl4	=	op4
000113BA                            	spReleaseRt	$0F, $0F, $0F, $0F
000113BA =0000000F                M sprr1	=	op1
000113BA =0000000F                M sprr2	=	op2
000113BA =0000000F                M sprr3	=	op3
000113BA =0000000F                M sprr4	=	op4
000113BA                            	spSSGEG		$00, $00, $00, $00
000113BA =00000000                M spss1	=	op1
000113BA =00000000                M spss2	=	op2
000113BA =00000000                M spss3	=	op3
000113BA =00000000                M spss4	=	op4
000113BA                            	spTotalLv	$18, $0F, $0E, $02
000113BA =00000018                M sptl1	=	op1
000113BA =0000000F                M sptl2	=	op2
000113BA =0000000E                M sptl3	=	op3
000113BA =00000002                M sptl4	=	op4
000113BA 3A                       M 	dc.b	(spfe<<3)+spal
000113BB =00000080                M sptlmask4	set	$80
000113BB =00000000                M sptlmask2	set	((spal>=5)<<7)
000113BB =00000000                M sptlmask3	set	((spal>=4)<<7)
000113BB =00000000                M sptlmask1	set	((spal=7)<<7)
000113BB 7076 3071                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000113BF 1F95 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000113C3 0E0F 050C                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000113C7 0706 0607                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000113CB 2F4F 1F5F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000113CF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000113D3 180E 0F82                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000113D7 4E41 54                  M 	dc.b	'NAT'
000113DA                            
000113DA                            	; Patch $30
000113DA                            	; $20
000113DA                            	; $34, $38, $30, $31,	$DF, $DF, $9F, $9F
000113DA                            	; $07, $08, $08, $0A,	$07, $0E, $0A, $11
000113DA                            	; $20, $1F, $1F, $1F,	$22, $37, $14, $00
000113DA                            	spAlgorithm	$00
000113DA =00000031                M spatnum	=	spatnum+1
000113DA =00000000                M spal	=	val
000113DA                            	spFeedback	$04
000113DA =00000004                M spfe	=	val
000113DA                            	spDetune	$03, $03, $03, $03
000113DA =00000003                M spde1	=	op1
000113DA =00000003                M spde2	=	op2
000113DA =00000003                M spde3	=	op3
000113DA =00000003                M spde4	=	op4
000113DA                            	spMultiple	$04, $00, $08, $01
000113DA =00000004                M spmu1	=	op1
000113DA =00000000                M spmu2	=	op2
000113DA =00000008                M spmu3	=	op3
000113DA =00000001                M spmu4	=	op4
000113DA                            	spRateScale	$03, $02, $03, $02
000113DA =00000003                M sprs1	=	op1
000113DA =00000002                M sprs2	=	op2
000113DA =00000003                M sprs3	=	op3
000113DA =00000002                M sprs4	=	op4
000113DA                            	spAttackRt	$1F, $1F, $1F, $1F
000113DA =0000001F                M spar1	=	op1
000113DA =0000001F                M spar2	=	op2
000113DA =0000001F                M spar3	=	op3
000113DA =0000001F                M spar4	=	op4
000113DA                            	spAmpMod	$00, $00, $00, $00
000113DA =00000000                M spam1	=	op1
000113DA =00000000                M spam2	=	op2
000113DA =00000000                M spam3	=	op3
000113DA =00000000                M spam4	=	op4
000113DA                            	spSustainRt	$07, $08, $08, $0A
000113DA =00000007                M spsr1	=	op1
000113DA =00000008                M spsr2	=	op2
000113DA =00000008                M spsr3	=	op3
000113DA =0000000A                M spsr4	=	op4
000113DA                            	spDecayRt	$07, $0A, $0E, $11
000113DA =00000007                M spdr1	=	op1
000113DA =0000000A                M spdr2	=	op2
000113DA =0000000E                M spdr3	=	op3
000113DA =00000011                M spdr4	=	op4
000113DA                            	spSustainLv	$02, $01, $01, $01
000113DA =00000002                M spsl1	=	op1
000113DA =00000001                M spsl2	=	op2
000113DA =00000001                M spsl3	=	op3
000113DA =00000001                M spsl4	=	op4
000113DA                            	spReleaseRt	$00, $0F, $0F, $0F
000113DA =00000000                M sprr1	=	op1
000113DA =0000000F                M sprr2	=	op2
000113DA =0000000F                M sprr3	=	op3
000113DA =0000000F                M sprr4	=	op4
000113DA                            	spSSGEG		$00, $00, $00, $00
000113DA =00000000                M spss1	=	op1
000113DA =00000000                M spss2	=	op2
000113DA =00000000                M spss3	=	op3
000113DA =00000000                M spss4	=	op4
000113DA                            	spTotalLv	$22, $14, $37, $00
000113DA =00000022                M sptl1	=	op1
000113DA =00000014                M sptl2	=	op2
000113DA =00000037                M sptl3	=	op3
000113DA =00000000                M sptl4	=	op4
000113DA 20                       M 	dc.b	(spfe<<3)+spal
000113DB =00000080                M sptlmask4	set	$80
000113DB =00000000                M sptlmask2	set	((spal>=5)<<7)
000113DB =00000000                M sptlmask3	set	((spal>=4)<<7)
000113DB =00000000                M sptlmask1	set	((spal=7)<<7)
000113DB 3438 3031                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000113DF DFDF 9F9F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000113E3 0708 080A                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000113E7 070E 0A11                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000113EB 201F 1F1F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000113EF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000113F3 2237 1480                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000113F7 4E41 54                  M 	dc.b	'NAT'
000113FA                            
000113FA                            	; Patch $31
000113FA                            	; $3A
000113FA                            	; $31, $7F, $61, $0A,	$9C, $DB, $9C, $9A
000113FA                            	; $04, $08, $03, $09,	$03, $01, $00, $00
000113FA                            	; $1F, $0F, $FF, $FF,	$23, $25, $1B, $06
000113FA                            	spAlgorithm	$02
000113FA =00000032                M spatnum	=	spatnum+1
000113FA =00000002                M spal	=	val
000113FA                            	spFeedback	$07
000113FA =00000007                M spfe	=	val
000113FA                            	spDetune	$03, $06, $07, $00
000113FA =00000003                M spde1	=	op1
000113FA =00000006                M spde2	=	op2
000113FA =00000007                M spde3	=	op3
000113FA =00000000                M spde4	=	op4
000113FA                            	spMultiple	$01, $01, $0F, $0A
000113FA =00000001                M spmu1	=	op1
000113FA =00000001                M spmu2	=	op2
000113FA =0000000F                M spmu3	=	op3
000113FA =0000000A                M spmu4	=	op4
000113FA                            	spRateScale	$02, $02, $03, $02
000113FA =00000002                M sprs1	=	op1
000113FA =00000002                M sprs2	=	op2
000113FA =00000003                M sprs3	=	op3
000113FA =00000002                M sprs4	=	op4
000113FA                            	spAttackRt	$1C, $1C, $1B, $1A
000113FA =0000001C                M spar1	=	op1
000113FA =0000001C                M spar2	=	op2
000113FA =0000001B                M spar3	=	op3
000113FA =0000001A                M spar4	=	op4
000113FA                            	spAmpMod	$00, $00, $00, $00
000113FA =00000000                M spam1	=	op1
000113FA =00000000                M spam2	=	op2
000113FA =00000000                M spam3	=	op3
000113FA =00000000                M spam4	=	op4
000113FA                            	spSustainRt	$04, $03, $08, $09
000113FA =00000004                M spsr1	=	op1
000113FA =00000003                M spsr2	=	op2
000113FA =00000008                M spsr3	=	op3
000113FA =00000009                M spsr4	=	op4
000113FA                            	spDecayRt	$03, $00, $01, $00
000113FA =00000003                M spdr1	=	op1
000113FA =00000000                M spdr2	=	op2
000113FA =00000001                M spdr3	=	op3
000113FA =00000000                M spdr4	=	op4
000113FA                            	spSustainLv	$01, $0F, $00, $0F
000113FA =00000001                M spsl1	=	op1
000113FA =0000000F                M spsl2	=	op2
000113FA =00000000                M spsl3	=	op3
000113FA =0000000F                M spsl4	=	op4
000113FA                            	spReleaseRt	$0F, $0F, $0F, $0F
000113FA =0000000F                M sprr1	=	op1
000113FA =0000000F                M sprr2	=	op2
000113FA =0000000F                M sprr3	=	op3
000113FA =0000000F                M sprr4	=	op4
000113FA                            	spSSGEG		$00, $00, $00, $00
000113FA =00000000                M spss1	=	op1
000113FA =00000000                M spss2	=	op2
000113FA =00000000                M spss3	=	op3
000113FA =00000000                M spss4	=	op4
000113FA                            	spTotalLv	$23, $1B, $25, $06
000113FA =00000023                M sptl1	=	op1
000113FA =0000001B                M sptl2	=	op2
000113FA =00000025                M sptl3	=	op3
000113FA =00000006                M sptl4	=	op4
000113FA 3A                       M 	dc.b	(spfe<<3)+spal
000113FB =00000080                M sptlmask4	set	$80
000113FB =00000000                M sptlmask2	set	((spal>=5)<<7)
000113FB =00000000                M sptlmask3	set	((spal>=4)<<7)
000113FB =00000000                M sptlmask1	set	((spal=7)<<7)
000113FB 317F 610A                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000113FF 9CDB 9C9A                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011403 0408 0309                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011407 0301 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001140B 1F0F FFFF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001140F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011413 2325 1B86                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011417 4E41 54                  M 	dc.b	'NAT'
0001141A                            
0001141A                            	; Patch $32
0001141A                            	; $04
0001141A                            	; $02, $02, $03, $03,	$13, $10, $13, $10
0001141A                            	; $06, $0C, $06, $0C,	$00, $00, $00, $00
0001141A                            	; $4F, $2F, $4F, $2F,	$18, $06, $18, $06
0001141A                            	spAlgorithm	$04
0001141A =00000033                M spatnum	=	spatnum+1
0001141A =00000004                M spal	=	val
0001141A                            	spFeedback	$00
0001141A =00000000                M spfe	=	val
0001141A                            	spDetune	$00, $00, $00, $00
0001141A =00000000                M spde1	=	op1
0001141A =00000000                M spde2	=	op2
0001141A =00000000                M spde3	=	op3
0001141A =00000000                M spde4	=	op4
0001141A                            	spMultiple	$02, $03, $02, $03
0001141A =00000002                M spmu1	=	op1
0001141A =00000003                M spmu2	=	op2
0001141A =00000002                M spmu3	=	op3
0001141A =00000003                M spmu4	=	op4
0001141A                            	spRateScale	$00, $00, $00, $00
0001141A =00000000                M sprs1	=	op1
0001141A =00000000                M sprs2	=	op2
0001141A =00000000                M sprs3	=	op3
0001141A =00000000                M sprs4	=	op4
0001141A                            	spAttackRt	$13, $13, $10, $10
0001141A =00000013                M spar1	=	op1
0001141A =00000013                M spar2	=	op2
0001141A =00000010                M spar3	=	op3
0001141A =00000010                M spar4	=	op4
0001141A                            	spAmpMod	$00, $00, $00, $00
0001141A =00000000                M spam1	=	op1
0001141A =00000000                M spam2	=	op2
0001141A =00000000                M spam3	=	op3
0001141A =00000000                M spam4	=	op4
0001141A                            	spSustainRt	$06, $06, $0C, $0C
0001141A =00000006                M spsr1	=	op1
0001141A =00000006                M spsr2	=	op2
0001141A =0000000C                M spsr3	=	op3
0001141A =0000000C                M spsr4	=	op4
0001141A                            	spDecayRt	$00, $00, $00, $00
0001141A =00000000                M spdr1	=	op1
0001141A =00000000                M spdr2	=	op2
0001141A =00000000                M spdr3	=	op3
0001141A =00000000                M spdr4	=	op4
0001141A                            	spSustainLv	$04, $04, $02, $02
0001141A =00000004                M spsl1	=	op1
0001141A =00000004                M spsl2	=	op2
0001141A =00000002                M spsl3	=	op3
0001141A =00000002                M spsl4	=	op4
0001141A                            	spReleaseRt	$0F, $0F, $0F, $0F
0001141A =0000000F                M sprr1	=	op1
0001141A =0000000F                M sprr2	=	op2
0001141A =0000000F                M sprr3	=	op3
0001141A =0000000F                M sprr4	=	op4
0001141A                            	spSSGEG		$00, $00, $00, $00
0001141A =00000000                M spss1	=	op1
0001141A =00000000                M spss2	=	op2
0001141A =00000000                M spss3	=	op3
0001141A =00000000                M spss4	=	op4
0001141A                            	spTotalLv	$18, $18, $06, $06
0001141A =00000018                M sptl1	=	op1
0001141A =00000018                M sptl2	=	op2
0001141A =00000006                M sptl3	=	op3
0001141A =00000006                M sptl4	=	op4
0001141A 04                       M 	dc.b	(spfe<<3)+spal
0001141B =00000080                M sptlmask4	set	$80
0001141B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001141B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
0001141B =00000000                M sptlmask1	set	((spal=7)<<7)
0001141B 0202 0303                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001141F 1310 1310                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011423 060C 060C                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011427 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001142B 4F2F 4F2F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001142F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011433 1886 1886                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011437 4E41 54                  M 	dc.b	'NAT'
0001143A                            
0001143A                            	; Patch $33
0001143A                            	; $38
0001143A                            	; $75, $13, $71, $11,	$DF, $5F, $1F, $1F
0001143A                            	; $0C, $0D, $01, $01,	$00, $00, $00, $00
0001143A                            	; $FF, $FF, $FF, $FF,	$1E, $1E, $1E, $03
0001143A                            	spAlgorithm	$00
0001143A =00000034                M spatnum	=	spatnum+1
0001143A =00000000                M spal	=	val
0001143A                            	spFeedback	$07
0001143A =00000007                M spfe	=	val
0001143A                            	spDetune	$07, $07, $01, $01
0001143A =00000007                M spde1	=	op1
0001143A =00000007                M spde2	=	op2
0001143A =00000001                M spde3	=	op3
0001143A =00000001                M spde4	=	op4
0001143A                            	spMultiple	$05, $01, $03, $01
0001143A =00000005                M spmu1	=	op1
0001143A =00000001                M spmu2	=	op2
0001143A =00000003                M spmu3	=	op3
0001143A =00000001                M spmu4	=	op4
0001143A                            	spRateScale	$03, $00, $01, $00
0001143A =00000003                M sprs1	=	op1
0001143A =00000000                M sprs2	=	op2
0001143A =00000001                M sprs3	=	op3
0001143A =00000000                M sprs4	=	op4
0001143A                            	spAttackRt	$1F, $1F, $1F, $1F
0001143A =0000001F                M spar1	=	op1
0001143A =0000001F                M spar2	=	op2
0001143A =0000001F                M spar3	=	op3
0001143A =0000001F                M spar4	=	op4
0001143A                            	spAmpMod	$00, $00, $00, $00
0001143A =00000000                M spam1	=	op1
0001143A =00000000                M spam2	=	op2
0001143A =00000000                M spam3	=	op3
0001143A =00000000                M spam4	=	op4
0001143A                            	spSustainRt	$0C, $01, $0D, $01
0001143A =0000000C                M spsr1	=	op1
0001143A =00000001                M spsr2	=	op2
0001143A =0000000D                M spsr3	=	op3
0001143A =00000001                M spsr4	=	op4
0001143A                            	spDecayRt	$00, $00, $00, $00
0001143A =00000000                M spdr1	=	op1
0001143A =00000000                M spdr2	=	op2
0001143A =00000000                M spdr3	=	op3
0001143A =00000000                M spdr4	=	op4
0001143A                            	spSustainLv	$0F, $0F, $0F, $0F
0001143A =0000000F                M spsl1	=	op1
0001143A =0000000F                M spsl2	=	op2
0001143A =0000000F                M spsl3	=	op3
0001143A =0000000F                M spsl4	=	op4
0001143A                            	spReleaseRt	$0F, $0F, $0F, $0F
0001143A =0000000F                M sprr1	=	op1
0001143A =0000000F                M sprr2	=	op2
0001143A =0000000F                M sprr3	=	op3
0001143A =0000000F                M sprr4	=	op4
0001143A                            	spSSGEG		$00, $00, $00, $00
0001143A =00000000                M spss1	=	op1
0001143A =00000000                M spss2	=	op2
0001143A =00000000                M spss3	=	op3
0001143A =00000000                M spss4	=	op4
0001143A                            	spTotalLv	$1E, $1E, $1E, $03
0001143A =0000001E                M sptl1	=	op1
0001143A =0000001E                M sptl2	=	op2
0001143A =0000001E                M sptl3	=	op3
0001143A =00000003                M sptl4	=	op4
0001143A 38                       M 	dc.b	(spfe<<3)+spal
0001143B =00000080                M sptlmask4	set	$80
0001143B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001143B =00000000                M sptlmask3	set	((spal>=4)<<7)
0001143B =00000000                M sptlmask1	set	((spal=7)<<7)
0001143B 7513 7111                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001143F DF5F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011443 0C0D 0101                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011447 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001144B FFFF FFFF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001144F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011453 1E1E 1E83                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011457 4E41 54                  M 	dc.b	'NAT'
0001145A                            
0001145A                            	; Patch $34
0001145A                            	; $34
0001145A                            	; $74, $21, $16, $71,	$11, $1F, $1F, $1F
0001145A                            	; $08, $05, $08, $09,	$00, $00, $00, $00
0001145A                            	; $FF, $FF, $FF, $FF,	$17, $05, $10, $05
0001145A                            	spAlgorithm	$04
0001145A =00000035                M spatnum	=	spatnum+1
0001145A =00000004                M spal	=	val
0001145A                            	spFeedback	$06
0001145A =00000006                M spfe	=	val
0001145A                            	spDetune	$07, $01, $02, $07
0001145A =00000007                M spde1	=	op1
0001145A =00000001                M spde2	=	op2
0001145A =00000002                M spde3	=	op3
0001145A =00000007                M spde4	=	op4
0001145A                            	spMultiple	$04, $06, $01, $01
0001145A =00000004                M spmu1	=	op1
0001145A =00000006                M spmu2	=	op2
0001145A =00000001                M spmu3	=	op3
0001145A =00000001                M spmu4	=	op4
0001145A                            	spRateScale	$00, $00, $00, $00
0001145A =00000000                M sprs1	=	op1
0001145A =00000000                M sprs2	=	op2
0001145A =00000000                M sprs3	=	op3
0001145A =00000000                M sprs4	=	op4
0001145A                            	spAttackRt	$11, $1F, $1F, $1F
0001145A =00000011                M spar1	=	op1
0001145A =0000001F                M spar2	=	op2
0001145A =0000001F                M spar3	=	op3
0001145A =0000001F                M spar4	=	op4
0001145A                            	spAmpMod	$00, $00, $00, $00
0001145A =00000000                M spam1	=	op1
0001145A =00000000                M spam2	=	op2
0001145A =00000000                M spam3	=	op3
0001145A =00000000                M spam4	=	op4
0001145A                            	spSustainRt	$08, $08, $05, $09
0001145A =00000008                M spsr1	=	op1
0001145A =00000008                M spsr2	=	op2
0001145A =00000005                M spsr3	=	op3
0001145A =00000009                M spsr4	=	op4
0001145A                            	spDecayRt	$00, $00, $00, $00
0001145A =00000000                M spdr1	=	op1
0001145A =00000000                M spdr2	=	op2
0001145A =00000000                M spdr3	=	op3
0001145A =00000000                M spdr4	=	op4
0001145A                            	spSustainLv	$0F, $0F, $0F, $0F
0001145A =0000000F                M spsl1	=	op1
0001145A =0000000F                M spsl2	=	op2
0001145A =0000000F                M spsl3	=	op3
0001145A =0000000F                M spsl4	=	op4
0001145A                            	spReleaseRt	$0F, $0F, $0F, $0F
0001145A =0000000F                M sprr1	=	op1
0001145A =0000000F                M sprr2	=	op2
0001145A =0000000F                M sprr3	=	op3
0001145A =0000000F                M sprr4	=	op4
0001145A                            	spSSGEG		$00, $00, $00, $00
0001145A =00000000                M spss1	=	op1
0001145A =00000000                M spss2	=	op2
0001145A =00000000                M spss3	=	op3
0001145A =00000000                M spss4	=	op4
0001145A                            	spTotalLv	$17, $10, $05, $05
0001145A =00000017                M sptl1	=	op1
0001145A =00000010                M sptl2	=	op2
0001145A =00000005                M sptl3	=	op3
0001145A =00000005                M sptl4	=	op4
0001145A 34                       M 	dc.b	(spfe<<3)+spal
0001145B =00000080                M sptlmask4	set	$80
0001145B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001145B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
0001145B =00000000                M sptlmask1	set	((spal=7)<<7)
0001145B 7421 1671                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001145F 111F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011463 0805 0809                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011467 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001146B FFFF FFFF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001146F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011473 1785 1085                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011477 4E41 54                  M 	dc.b	'NAT'
0001147A                            
0001147A                            	; Patch $35
0001147A                            	; $38
0001147A                            	; $41, $11, $71, $41,	$16, $13, $0F, $17
0001147A                            	; $02, $0C, $05, $01,	$00, $0F, $00, $00
0001147A                            	; $1F, $3F, $5F, $1F,	$2A, $12, $24, $04
0001147A                            	spAlgorithm	$00
0001147A =00000036                M spatnum	=	spatnum+1
0001147A =00000000                M spal	=	val
0001147A                            	spFeedback	$07
0001147A =00000007                M spfe	=	val
0001147A                            	spDetune	$04, $07, $01, $04
0001147A =00000004                M spde1	=	op1
0001147A =00000007                M spde2	=	op2
0001147A =00000001                M spde3	=	op3
0001147A =00000004                M spde4	=	op4
0001147A                            	spMultiple	$01, $01, $01, $01
0001147A =00000001                M spmu1	=	op1
0001147A =00000001                M spmu2	=	op2
0001147A =00000001                M spmu3	=	op3
0001147A =00000001                M spmu4	=	op4
0001147A                            	spRateScale	$00, $00, $00, $00
0001147A =00000000                M sprs1	=	op1
0001147A =00000000                M sprs2	=	op2
0001147A =00000000                M sprs3	=	op3
0001147A =00000000                M sprs4	=	op4
0001147A                            	spAttackRt	$16, $0F, $13, $17
0001147A =00000016                M spar1	=	op1
0001147A =0000000F                M spar2	=	op2
0001147A =00000013                M spar3	=	op3
0001147A =00000017                M spar4	=	op4
0001147A                            	spAmpMod	$00, $00, $00, $00
0001147A =00000000                M spam1	=	op1
0001147A =00000000                M spam2	=	op2
0001147A =00000000                M spam3	=	op3
0001147A =00000000                M spam4	=	op4
0001147A                            	spSustainRt	$02, $05, $0C, $01
0001147A =00000002                M spsr1	=	op1
0001147A =00000005                M spsr2	=	op2
0001147A =0000000C                M spsr3	=	op3
0001147A =00000001                M spsr4	=	op4
0001147A                            	spDecayRt	$00, $00, $0F, $00
0001147A =00000000                M spdr1	=	op1
0001147A =00000000                M spdr2	=	op2
0001147A =0000000F                M spdr3	=	op3
0001147A =00000000                M spdr4	=	op4
0001147A                            	spSustainLv	$01, $05, $03, $01
0001147A =00000001                M spsl1	=	op1
0001147A =00000005                M spsl2	=	op2
0001147A =00000003                M spsl3	=	op3
0001147A =00000001                M spsl4	=	op4
0001147A                            	spReleaseRt	$0F, $0F, $0F, $0F
0001147A =0000000F                M sprr1	=	op1
0001147A =0000000F                M sprr2	=	op2
0001147A =0000000F                M sprr3	=	op3
0001147A =0000000F                M sprr4	=	op4
0001147A                            	spSSGEG		$00, $00, $00, $00
0001147A =00000000                M spss1	=	op1
0001147A =00000000                M spss2	=	op2
0001147A =00000000                M spss3	=	op3
0001147A =00000000                M spss4	=	op4
0001147A                            	spTotalLv	$2A, $24, $12, $04
0001147A =0000002A                M sptl1	=	op1
0001147A =00000024                M sptl2	=	op2
0001147A =00000012                M sptl3	=	op3
0001147A =00000004                M sptl4	=	op4
0001147A 38                       M 	dc.b	(spfe<<3)+spal
0001147B =00000080                M sptlmask4	set	$80
0001147B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001147B =00000000                M sptlmask3	set	((spal>=4)<<7)
0001147B =00000000                M sptlmask1	set	((spal=7)<<7)
0001147B 4111 7141                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001147F 1613 0F17                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011483 020C 0501                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011487 000F 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001148B 1F3F 5F1F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001148F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011493 2A12 2484                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011497 4E41 54                  M 	dc.b	'NAT'
0001149A                            
0001149A                            	; Patch $36
0001149A                            	; $3D
0001149A                            	; $01, $01, $01, $01,	$94, $19, $19, $19
0001149A                            	; $0F, $0D, $0D, $0D,	$07, $04, $04, $04
0001149A                            	; $25, $1A, $1A, $1A,	$15, $05, $05, $05
0001149A                            	spAlgorithm	$05
0001149A =00000037                M spatnum	=	spatnum+1
0001149A =00000005                M spal	=	val
0001149A                            	spFeedback	$07
0001149A =00000007                M spfe	=	val
0001149A                            	spDetune	$00, $00, $00, $00
0001149A =00000000                M spde1	=	op1
0001149A =00000000                M spde2	=	op2
0001149A =00000000                M spde3	=	op3
0001149A =00000000                M spde4	=	op4
0001149A                            	spMultiple	$01, $01, $01, $01
0001149A =00000001                M spmu1	=	op1
0001149A =00000001                M spmu2	=	op2
0001149A =00000001                M spmu3	=	op3
0001149A =00000001                M spmu4	=	op4
0001149A                            	spRateScale	$02, $00, $00, $00
0001149A =00000002                M sprs1	=	op1
0001149A =00000000                M sprs2	=	op2
0001149A =00000000                M sprs3	=	op3
0001149A =00000000                M sprs4	=	op4
0001149A                            	spAttackRt	$14, $19, $19, $19
0001149A =00000014                M spar1	=	op1
0001149A =00000019                M spar2	=	op2
0001149A =00000019                M spar3	=	op3
0001149A =00000019                M spar4	=	op4
0001149A                            	spAmpMod	$00, $00, $00, $00
0001149A =00000000                M spam1	=	op1
0001149A =00000000                M spam2	=	op2
0001149A =00000000                M spam3	=	op3
0001149A =00000000                M spam4	=	op4
0001149A                            	spSustainRt	$0F, $0D, $0D, $0D
0001149A =0000000F                M spsr1	=	op1
0001149A =0000000D                M spsr2	=	op2
0001149A =0000000D                M spsr3	=	op3
0001149A =0000000D                M spsr4	=	op4
0001149A                            	spDecayRt	$07, $04, $04, $04
0001149A =00000007                M spdr1	=	op1
0001149A =00000004                M spdr2	=	op2
0001149A =00000004                M spdr3	=	op3
0001149A =00000004                M spdr4	=	op4
0001149A                            	spSustainLv	$02, $01, $01, $01
0001149A =00000002                M spsl1	=	op1
0001149A =00000001                M spsl2	=	op2
0001149A =00000001                M spsl3	=	op3
0001149A =00000001                M spsl4	=	op4
0001149A                            	spReleaseRt	$05, $0A, $0A, $0A
0001149A =00000005                M sprr1	=	op1
0001149A =0000000A                M sprr2	=	op2
0001149A =0000000A                M sprr3	=	op3
0001149A =0000000A                M sprr4	=	op4
0001149A                            	spSSGEG		$00, $00, $00, $00
0001149A =00000000                M spss1	=	op1
0001149A =00000000                M spss2	=	op2
0001149A =00000000                M spss3	=	op3
0001149A =00000000                M spss4	=	op4
0001149A                            	spTotalLv	$15, $05, $05, $05
0001149A =00000015                M sptl1	=	op1
0001149A =00000005                M sptl2	=	op2
0001149A =00000005                M sptl3	=	op3
0001149A =00000005                M sptl4	=	op4
0001149A 3D                       M 	dc.b	(spfe<<3)+spal
0001149B =00000080                M sptlmask4	set	$80
0001149B =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
0001149B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
0001149B =00000000                M sptlmask1	set	((spal=7)<<7)
0001149B 0101 0101                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001149F 9419 1919                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000114A3 0F0D 0D0D                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000114A7 0704 0404                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000114AB 251A 1A1A                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000114AF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000114B3 1585 8585                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000114B7 4E41 54                  M 	dc.b	'NAT'
000114BA                            
000114BA                            	; Patch $37
000114BA                            	; $3A
000114BA                            	; $31, $77, $32, $02,	$1C, $13, $0E, $4E
000114BA                            	; $04, $10, $09, $0A,	$0C, $00, $03, $00
000114BA                            	; $16, $2B, $24, $18,	$1D, $13, $2A, $04
000114BA                            	spAlgorithm	$02
000114BA =00000038                M spatnum	=	spatnum+1
000114BA =00000002                M spal	=	val
000114BA                            	spFeedback	$07
000114BA =00000007                M spfe	=	val
000114BA                            	spDetune	$03, $03, $07, $00
000114BA =00000003                M spde1	=	op1
000114BA =00000003                M spde2	=	op2
000114BA =00000007                M spde3	=	op3
000114BA =00000000                M spde4	=	op4
000114BA                            	spMultiple	$01, $02, $07, $02
000114BA =00000001                M spmu1	=	op1
000114BA =00000002                M spmu2	=	op2
000114BA =00000007                M spmu3	=	op3
000114BA =00000002                M spmu4	=	op4
000114BA                            	spRateScale	$00, $00, $00, $01
000114BA =00000000                M sprs1	=	op1
000114BA =00000000                M sprs2	=	op2
000114BA =00000000                M sprs3	=	op3
000114BA =00000001                M sprs4	=	op4
000114BA                            	spAttackRt	$1C, $0E, $13, $0E
000114BA =0000001C                M spar1	=	op1
000114BA =0000000E                M spar2	=	op2
000114BA =00000013                M spar3	=	op3
000114BA =0000000E                M spar4	=	op4
000114BA                            	spAmpMod	$00, $00, $00, $00
000114BA =00000000                M spam1	=	op1
000114BA =00000000                M spam2	=	op2
000114BA =00000000                M spam3	=	op3
000114BA =00000000                M spam4	=	op4
000114BA                            	spSustainRt	$04, $09, $10, $0A
000114BA =00000004                M spsr1	=	op1
000114BA =00000009                M spsr2	=	op2
000114BA =00000010                M spsr3	=	op3
000114BA =0000000A                M spsr4	=	op4
000114BA                            	spDecayRt	$0C, $03, $00, $00
000114BA =0000000C                M spdr1	=	op1
000114BA =00000003                M spdr2	=	op2
000114BA =00000000                M spdr3	=	op3
000114BA =00000000                M spdr4	=	op4
000114BA                            	spSustainLv	$01, $02, $02, $01
000114BA =00000001                M spsl1	=	op1
000114BA =00000002                M spsl2	=	op2
000114BA =00000002                M spsl3	=	op3
000114BA =00000001                M spsl4	=	op4
000114BA                            	spReleaseRt	$06, $04, $0B, $08
000114BA =00000006                M sprr1	=	op1
000114BA =00000004                M sprr2	=	op2
000114BA =0000000B                M sprr3	=	op3
000114BA =00000008                M sprr4	=	op4
000114BA                            	spSSGEG		$00, $00, $00, $00
000114BA =00000000                M spss1	=	op1
000114BA =00000000                M spss2	=	op2
000114BA =00000000                M spss3	=	op3
000114BA =00000000                M spss4	=	op4
000114BA                            	spTotalLv	$1D, $2A, $13, $04
000114BA =0000001D                M sptl1	=	op1
000114BA =0000002A                M sptl2	=	op2
000114BA =00000013                M sptl3	=	op3
000114BA =00000004                M sptl4	=	op4
000114BA 3A                       M 	dc.b	(spfe<<3)+spal
000114BB =00000080                M sptlmask4	set	$80
000114BB =00000000                M sptlmask2	set	((spal>=5)<<7)
000114BB =00000000                M sptlmask3	set	((spal>=4)<<7)
000114BB =00000000                M sptlmask1	set	((spal=7)<<7)
000114BB 3177 3202                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000114BF 1C13 0E4E                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000114C3 0410 090A                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000114C7 0C00 0300                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000114CB 162B 2418                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000114CF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000114D3 1D13 2A84                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000114D7 4E41 54                  M 	dc.b	'NAT'
000114DA                            
000114DA                            	; Patch $38
000114DA                            	; $03
000114DA                            	; $01, $78, $39, $3A,	$1F, $1F, $1F, $1F
000114DA                            	; $06, $00, $08, $0A,	$00, $00, $00, $00
000114DA                            	; $F4, $02, $56, $F5,	$33, $1B, $43, $04
000114DA                            	spAlgorithm	$03
000114DA =00000039                M spatnum	=	spatnum+1
000114DA =00000003                M spal	=	val
000114DA                            	spFeedback	$00
000114DA =00000000                M spfe	=	val
000114DA                            	spDetune	$00, $03, $07, $03
000114DA =00000000                M spde1	=	op1
000114DA =00000003                M spde2	=	op2
000114DA =00000007                M spde3	=	op3
000114DA =00000003                M spde4	=	op4
000114DA                            	spMultiple	$01, $09, $08, $0A
000114DA =00000001                M spmu1	=	op1
000114DA =00000009                M spmu2	=	op2
000114DA =00000008                M spmu3	=	op3
000114DA =0000000A                M spmu4	=	op4
000114DA                            	spRateScale	$00, $00, $00, $00
000114DA =00000000                M sprs1	=	op1
000114DA =00000000                M sprs2	=	op2
000114DA =00000000                M sprs3	=	op3
000114DA =00000000                M sprs4	=	op4
000114DA                            	spAttackRt	$1F, $1F, $1F, $1F
000114DA =0000001F                M spar1	=	op1
000114DA =0000001F                M spar2	=	op2
000114DA =0000001F                M spar3	=	op3
000114DA =0000001F                M spar4	=	op4
000114DA                            	spAmpMod	$00, $00, $00, $00
000114DA =00000000                M spam1	=	op1
000114DA =00000000                M spam2	=	op2
000114DA =00000000                M spam3	=	op3
000114DA =00000000                M spam4	=	op4
000114DA                            	spSustainRt	$06, $08, $00, $0A
000114DA =00000006                M spsr1	=	op1
000114DA =00000008                M spsr2	=	op2
000114DA =00000000                M spsr3	=	op3
000114DA =0000000A                M spsr4	=	op4
000114DA                            	spDecayRt	$00, $00, $00, $00
000114DA =00000000                M spdr1	=	op1
000114DA =00000000                M spdr2	=	op2
000114DA =00000000                M spdr3	=	op3
000114DA =00000000                M spdr4	=	op4
000114DA                            	spSustainLv	$0F, $05, $00, $0F
000114DA =0000000F                M spsl1	=	op1
000114DA =00000005                M spsl2	=	op2
000114DA =00000000                M spsl3	=	op3
000114DA =0000000F                M spsl4	=	op4
000114DA                            	spReleaseRt	$04, $06, $02, $05
000114DA =00000004                M sprr1	=	op1
000114DA =00000006                M sprr2	=	op2
000114DA =00000002                M sprr3	=	op3
000114DA =00000005                M sprr4	=	op4
000114DA                            	spSSGEG		$00, $00, $00, $00
000114DA =00000000                M spss1	=	op1
000114DA =00000000                M spss2	=	op2
000114DA =00000000                M spss3	=	op3
000114DA =00000000                M spss4	=	op4
000114DA                            	spTotalLv	$33, $43, $1B, $04
000114DA =00000033                M sptl1	=	op1
000114DA =00000043                M sptl2	=	op2
000114DA =0000001B                M sptl3	=	op3
000114DA =00000004                M sptl4	=	op4
000114DA 03                       M 	dc.b	(spfe<<3)+spal
000114DB =00000080                M sptlmask4	set	$80
000114DB =00000000                M sptlmask2	set	((spal>=5)<<7)
000114DB =00000000                M sptlmask3	set	((spal>=4)<<7)
000114DB =00000000                M sptlmask1	set	((spal=7)<<7)
000114DB 0178 393A                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000114DF 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000114E3 0600 080A                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000114E7 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000114EB F402 56F5                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000114EF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000114F3 331B 4384                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000114F7 4E41 54                  M 	dc.b	'NAT'
000114FA                            
000114FA                            	; Patch $39
000114FA                            	; $3A
000114FA                            	; $01, $07, $01, $01,	$8E, $8E, $8D, $53
000114FA                            	; $0E, $0E, $0E, $03,	$00, $00, $00, $00
000114FA                            	; $13, $FA, $13, $0A,	$18, $1E, $27, $04
000114FA                            	spAlgorithm	$02
000114FA =0000003A                M spatnum	=	spatnum+1
000114FA =00000002                M spal	=	val
000114FA                            	spFeedback	$07
000114FA =00000007                M spfe	=	val
000114FA                            	spDetune	$00, $00, $00, $00
000114FA =00000000                M spde1	=	op1
000114FA =00000000                M spde2	=	op2
000114FA =00000000                M spde3	=	op3
000114FA =00000000                M spde4	=	op4
000114FA                            	spMultiple	$01, $01, $07, $01
000114FA =00000001                M spmu1	=	op1
000114FA =00000001                M spmu2	=	op2
000114FA =00000007                M spmu3	=	op3
000114FA =00000001                M spmu4	=	op4
000114FA                            	spRateScale	$02, $02, $02, $01
000114FA =00000002                M sprs1	=	op1
000114FA =00000002                M sprs2	=	op2
000114FA =00000002                M sprs3	=	op3
000114FA =00000001                M sprs4	=	op4
000114FA                            	spAttackRt	$0E, $0D, $0E, $13
000114FA =0000000E                M spar1	=	op1
000114FA =0000000D                M spar2	=	op2
000114FA =0000000E                M spar3	=	op3
000114FA =00000013                M spar4	=	op4
000114FA                            	spAmpMod	$00, $00, $00, $00
000114FA =00000000                M spam1	=	op1
000114FA =00000000                M spam2	=	op2
000114FA =00000000                M spam3	=	op3
000114FA =00000000                M spam4	=	op4
000114FA                            	spSustainRt	$0E, $0E, $0E, $03
000114FA =0000000E                M spsr1	=	op1
000114FA =0000000E                M spsr2	=	op2
000114FA =0000000E                M spsr3	=	op3
000114FA =00000003                M spsr4	=	op4
000114FA                            	spDecayRt	$00, $00, $00, $00
000114FA =00000000                M spdr1	=	op1
000114FA =00000000                M spdr2	=	op2
000114FA =00000000                M spdr3	=	op3
000114FA =00000000                M spdr4	=	op4
000114FA                            	spSustainLv	$01, $01, $0F, $00
000114FA =00000001                M spsl1	=	op1
000114FA =00000001                M spsl2	=	op2
000114FA =0000000F                M spsl3	=	op3
000114FA =00000000                M spsl4	=	op4
000114FA                            	spReleaseRt	$03, $03, $0A, $0A
000114FA =00000003                M sprr1	=	op1
000114FA =00000003                M sprr2	=	op2
000114FA =0000000A                M sprr3	=	op3
000114FA =0000000A                M sprr4	=	op4
000114FA                            	spSSGEG		$00, $00, $00, $00
000114FA =00000000                M spss1	=	op1
000114FA =00000000                M spss2	=	op2
000114FA =00000000                M spss3	=	op3
000114FA =00000000                M spss4	=	op4
000114FA                            	spTotalLv	$18, $27, $1E, $04
000114FA =00000018                M sptl1	=	op1
000114FA =00000027                M sptl2	=	op2
000114FA =0000001E                M sptl3	=	op3
000114FA =00000004                M sptl4	=	op4
000114FA 3A                       M 	dc.b	(spfe<<3)+spal
000114FB =00000080                M sptlmask4	set	$80
000114FB =00000000                M sptlmask2	set	((spal>=5)<<7)
000114FB =00000000                M sptlmask3	set	((spal>=4)<<7)
000114FB =00000000                M sptlmask1	set	((spal=7)<<7)
000114FB 0107 0101                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000114FF 8E8E 8D53                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011503 0E0E 0E03                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011507 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001150B 13FA 130A                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001150F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011513 181E 2784                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011517 4E41 54                  M 	dc.b	'NAT'
0001151A                            
0001151A                            	; Patch $3A
0001151A                            	; $24
0001151A                            	; $7D, $35, $3D, $75,	$1F, $1F, $1F, $1F
0001151A                            	; $01, $0D, $01, $0D,	$10, $12, $10, $12
0001151A                            	; $F5, $38, $F5, $38,	$00, $04, $00, $04
0001151A                            	spAlgorithm	$04
0001151A =0000003B                M spatnum	=	spatnum+1
0001151A =00000004                M spal	=	val
0001151A                            	spFeedback	$04
0001151A =00000004                M spfe	=	val
0001151A                            	spDetune	$07, $03, $03, $07
0001151A =00000007                M spde1	=	op1
0001151A =00000003                M spde2	=	op2
0001151A =00000003                M spde3	=	op3
0001151A =00000007                M spde4	=	op4
0001151A                            	spMultiple	$0D, $0D, $05, $05
0001151A =0000000D                M spmu1	=	op1
0001151A =0000000D                M spmu2	=	op2
0001151A =00000005                M spmu3	=	op3
0001151A =00000005                M spmu4	=	op4
0001151A                            	spRateScale	$00, $00, $00, $00
0001151A =00000000                M sprs1	=	op1
0001151A =00000000                M sprs2	=	op2
0001151A =00000000                M sprs3	=	op3
0001151A =00000000                M sprs4	=	op4
0001151A                            	spAttackRt	$1F, $1F, $1F, $1F
0001151A =0000001F                M spar1	=	op1
0001151A =0000001F                M spar2	=	op2
0001151A =0000001F                M spar3	=	op3
0001151A =0000001F                M spar4	=	op4
0001151A                            	spAmpMod	$00, $00, $00, $00
0001151A =00000000                M spam1	=	op1
0001151A =00000000                M spam2	=	op2
0001151A =00000000                M spam3	=	op3
0001151A =00000000                M spam4	=	op4
0001151A                            	spSustainRt	$01, $01, $0D, $0D
0001151A =00000001                M spsr1	=	op1
0001151A =00000001                M spsr2	=	op2
0001151A =0000000D                M spsr3	=	op3
0001151A =0000000D                M spsr4	=	op4
0001151A                            	spDecayRt	$10, $10, $12, $12
0001151A =00000010                M spdr1	=	op1
0001151A =00000010                M spdr2	=	op2
0001151A =00000012                M spdr3	=	op3
0001151A =00000012                M spdr4	=	op4
0001151A                            	spSustainLv	$0F, $0F, $03, $03
0001151A =0000000F                M spsl1	=	op1
0001151A =0000000F                M spsl2	=	op2
0001151A =00000003                M spsl3	=	op3
0001151A =00000003                M spsl4	=	op4
0001151A                            	spReleaseRt	$05, $05, $08, $08
0001151A =00000005                M sprr1	=	op1
0001151A =00000005                M sprr2	=	op2
0001151A =00000008                M sprr3	=	op3
0001151A =00000008                M sprr4	=	op4
0001151A                            	spSSGEG		$00, $00, $00, $00
0001151A =00000000                M spss1	=	op1
0001151A =00000000                M spss2	=	op2
0001151A =00000000                M spss3	=	op3
0001151A =00000000                M spss4	=	op4
0001151A                            	spTotalLv	$00, $00, $04, $04
0001151A =00000000                M sptl1	=	op1
0001151A =00000000                M sptl2	=	op2
0001151A =00000004                M sptl3	=	op3
0001151A =00000004                M sptl4	=	op4
0001151A 24                       M 	dc.b	(spfe<<3)+spal
0001151B =00000080                M sptlmask4	set	$80
0001151B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001151B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
0001151B =00000000                M sptlmask1	set	((spal=7)<<7)
0001151B 7D35 3D75                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001151F 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011523 010D 010D                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011527 1012 1012                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001152B F538 F538                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001152F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011533 0084 0084                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011537 4E41 54                  M 	dc.b	'NAT'
0001153A                            
0001153A                            	; Patch $3B
0001153A                            	; $32
0001153A                            	; $2A, $61, $65, $23,	$94, $10, $54, $19
0001153A                            	; $85, $0B, $0E, $05,	$06, $04, $03, $03
0001153A                            	; $12, $14, $24, $27,	$2E, $0A, $1B, $05
0001153A                            	spAlgorithm	$02
0001153A =0000003C                M spatnum	=	spatnum+1
0001153A =00000002                M spal	=	val
0001153A                            	spFeedback	$06
0001153A =00000006                M spfe	=	val
0001153A                            	spDetune	$02, $06, $06, $02
0001153A =00000002                M spde1	=	op1
0001153A =00000006                M spde2	=	op2
0001153A =00000006                M spde3	=	op3
0001153A =00000002                M spde4	=	op4
0001153A                            	spMultiple	$0A, $05, $01, $03
0001153A =0000000A                M spmu1	=	op1
0001153A =00000005                M spmu2	=	op2
0001153A =00000001                M spmu3	=	op3
0001153A =00000003                M spmu4	=	op4
0001153A                            	spRateScale	$02, $01, $00, $00
0001153A =00000002                M sprs1	=	op1
0001153A =00000001                M sprs2	=	op2
0001153A =00000000                M sprs3	=	op3
0001153A =00000000                M sprs4	=	op4
0001153A                            	spAttackRt	$14, $14, $10, $19
0001153A =00000014                M spar1	=	op1
0001153A =00000014                M spar2	=	op2
0001153A =00000010                M spar3	=	op3
0001153A =00000019                M spar4	=	op4
0001153A                            	spAmpMod	$01, $00, $00, $00
0001153A =00000001                M spam1	=	op1
0001153A =00000000                M spam2	=	op2
0001153A =00000000                M spam3	=	op3
0001153A =00000000                M spam4	=	op4
0001153A                            	spSustainRt	$05, $0E, $0B, $05
0001153A =00000005                M spsr1	=	op1
0001153A =0000000E                M spsr2	=	op2
0001153A =0000000B                M spsr3	=	op3
0001153A =00000005                M spsr4	=	op4
0001153A                            	spDecayRt	$06, $03, $04, $03
0001153A =00000006                M spdr1	=	op1
0001153A =00000003                M spdr2	=	op2
0001153A =00000004                M spdr3	=	op3
0001153A =00000003                M spdr4	=	op4
0001153A                            	spSustainLv	$01, $02, $01, $02
0001153A =00000001                M spsl1	=	op1
0001153A =00000002                M spsl2	=	op2
0001153A =00000001                M spsl3	=	op3
0001153A =00000002                M spsl4	=	op4
0001153A                            	spReleaseRt	$02, $04, $04, $07
0001153A =00000002                M sprr1	=	op1
0001153A =00000004                M sprr2	=	op2
0001153A =00000004                M sprr3	=	op3
0001153A =00000007                M sprr4	=	op4
0001153A                            	spSSGEG		$00, $00, $00, $00
0001153A =00000000                M spss1	=	op1
0001153A =00000000                M spss2	=	op2
0001153A =00000000                M spss3	=	op3
0001153A =00000000                M spss4	=	op4
0001153A                            	spTotalLv	$2E, $1B, $0A, $05
0001153A =0000002E                M sptl1	=	op1
0001153A =0000001B                M sptl2	=	op2
0001153A =0000000A                M sptl3	=	op3
0001153A =00000005                M sptl4	=	op4
0001153A 32                       M 	dc.b	(spfe<<3)+spal
0001153B =00000080                M sptlmask4	set	$80
0001153B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001153B =00000000                M sptlmask3	set	((spal>=4)<<7)
0001153B =00000000                M sptlmask1	set	((spal=7)<<7)
0001153B 2A61 6523                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001153F 9410 5419                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011543 850B 0E05                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011547 0604 0303                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001154B 1214 2427                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001154F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011553 2E0A 1B85                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011557 4E41 54                  M 	dc.b	'NAT'
0001155A                            
0001155A                            	; Patch $3C
0001155A                            	; $38
0001155A                            	; $71, $31, $71, $41,	$5F, $1F, $1F, $1F
0001155A                            	; $07, $06, $09, $1F,	$00, $00, $00, $00
0001155A                            	; $98, $9A, $09, $0C,	$1C, $1B, $1A, $04
0001155A                            	spAlgorithm	$00
0001155A =0000003D                M spatnum	=	spatnum+1
0001155A =00000000                M spal	=	val
0001155A                            	spFeedback	$07
0001155A =00000007                M spfe	=	val
0001155A                            	spDetune	$07, $07, $03, $04
0001155A =00000007                M spde1	=	op1
0001155A =00000007                M spde2	=	op2
0001155A =00000003                M spde3	=	op3
0001155A =00000004                M spde4	=	op4
0001155A                            	spMultiple	$01, $01, $01, $01
0001155A =00000001                M spmu1	=	op1
0001155A =00000001                M spmu2	=	op2
0001155A =00000001                M spmu3	=	op3
0001155A =00000001                M spmu4	=	op4
0001155A                            	spRateScale	$01, $00, $00, $00
0001155A =00000001                M sprs1	=	op1
0001155A =00000000                M sprs2	=	op2
0001155A =00000000                M sprs3	=	op3
0001155A =00000000                M sprs4	=	op4
0001155A                            	spAttackRt	$1F, $1F, $1F, $1F
0001155A =0000001F                M spar1	=	op1
0001155A =0000001F                M spar2	=	op2
0001155A =0000001F                M spar3	=	op3
0001155A =0000001F                M spar4	=	op4
0001155A                            	spAmpMod	$00, $00, $00, $00
0001155A =00000000                M spam1	=	op1
0001155A =00000000                M spam2	=	op2
0001155A =00000000                M spam3	=	op3
0001155A =00000000                M spam4	=	op4
0001155A                            	spSustainRt	$07, $09, $06, $1F
0001155A =00000007                M spsr1	=	op1
0001155A =00000009                M spsr2	=	op2
0001155A =00000006                M spsr3	=	op3
0001155A =0000001F                M spsr4	=	op4
0001155A                            	spDecayRt	$00, $00, $00, $00
0001155A =00000000                M spdr1	=	op1
0001155A =00000000                M spdr2	=	op2
0001155A =00000000                M spdr3	=	op3
0001155A =00000000                M spdr4	=	op4
0001155A                            	spSustainLv	$09, $00, $09, $00
0001155A =00000009                M spsl1	=	op1
0001155A =00000000                M spsl2	=	op2
0001155A =00000009                M spsl3	=	op3
0001155A =00000000                M spsl4	=	op4
0001155A                            	spReleaseRt	$08, $09, $0A, $0C
0001155A =00000008                M sprr1	=	op1
0001155A =00000009                M sprr2	=	op2
0001155A =0000000A                M sprr3	=	op3
0001155A =0000000C                M sprr4	=	op4
0001155A                            	spSSGEG		$00, $00, $00, $00
0001155A =00000000                M spss1	=	op1
0001155A =00000000                M spss2	=	op2
0001155A =00000000                M spss3	=	op3
0001155A =00000000                M spss4	=	op4
0001155A                            	spTotalLv	$1C, $1A, $1B, $04
0001155A =0000001C                M sptl1	=	op1
0001155A =0000001A                M sptl2	=	op2
0001155A =0000001B                M sptl3	=	op3
0001155A =00000004                M sptl4	=	op4
0001155A 38                       M 	dc.b	(spfe<<3)+spal
0001155B =00000080                M sptlmask4	set	$80
0001155B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001155B =00000000                M sptlmask3	set	((spal>=4)<<7)
0001155B =00000000                M sptlmask1	set	((spal=7)<<7)
0001155B 7131 7141                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001155F 5F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011563 0706 091F                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011567 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001156B 989A 090C                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001156F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011573 1C1B 1A84                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011577 4E41 54                  M 	dc.b	'NAT'
0001157A                            
0001157A                            	; Patch $3D
0001157A                            	; $02
0001157A                            	; $61, $7C, $04, $31,	$14, $D0, $8F, $54
0001157A                            	; $01, $05, $05, $08,	$02, $02, $05, $1F
0001157A                            	; $01, $11, $31, $88,	$1C, $2D, $27, $05
0001157A                            	spAlgorithm	$02
0001157A =0000003E                M spatnum	=	spatnum+1
0001157A =00000002                M spal	=	val
0001157A                            	spFeedback	$00
0001157A =00000000                M spfe	=	val
0001157A                            	spDetune	$06, $00, $07, $03
0001157A =00000006                M spde1	=	op1
0001157A =00000000                M spde2	=	op2
0001157A =00000007                M spde3	=	op3
0001157A =00000003                M spde4	=	op4
0001157A                            	spMultiple	$01, $04, $0C, $01
0001157A =00000001                M spmu1	=	op1
0001157A =00000004                M spmu2	=	op2
0001157A =0000000C                M spmu3	=	op3
0001157A =00000001                M spmu4	=	op4
0001157A                            	spRateScale	$00, $02, $03, $01
0001157A =00000000                M sprs1	=	op1
0001157A =00000002                M sprs2	=	op2
0001157A =00000003                M sprs3	=	op3
0001157A =00000001                M sprs4	=	op4
0001157A                            	spAttackRt	$14, $0F, $10, $14
0001157A =00000014                M spar1	=	op1
0001157A =0000000F                M spar2	=	op2
0001157A =00000010                M spar3	=	op3
0001157A =00000014                M spar4	=	op4
0001157A                            	spAmpMod	$00, $00, $00, $00
0001157A =00000000                M spam1	=	op1
0001157A =00000000                M spam2	=	op2
0001157A =00000000                M spam3	=	op3
0001157A =00000000                M spam4	=	op4
0001157A                            	spSustainRt	$01, $05, $05, $08
0001157A =00000001                M spsr1	=	op1
0001157A =00000005                M spsr2	=	op2
0001157A =00000005                M spsr3	=	op3
0001157A =00000008                M spsr4	=	op4
0001157A                            	spDecayRt	$02, $05, $02, $1F
0001157A =00000002                M spdr1	=	op1
0001157A =00000005                M spdr2	=	op2
0001157A =00000002                M spdr3	=	op3
0001157A =0000001F                M spdr4	=	op4
0001157A                            	spSustainLv	$00, $03, $01, $08
0001157A =00000000                M spsl1	=	op1
0001157A =00000003                M spsl2	=	op2
0001157A =00000001                M spsl3	=	op3
0001157A =00000008                M spsl4	=	op4
0001157A                            	spReleaseRt	$01, $01, $01, $08
0001157A =00000001                M sprr1	=	op1
0001157A =00000001                M sprr2	=	op2
0001157A =00000001                M sprr3	=	op3
0001157A =00000008                M sprr4	=	op4
0001157A                            	spSSGEG		$00, $00, $00, $00
0001157A =00000000                M spss1	=	op1
0001157A =00000000                M spss2	=	op2
0001157A =00000000                M spss3	=	op3
0001157A =00000000                M spss4	=	op4
0001157A                            	spTotalLv	$1C, $27, $2D, $05
0001157A =0000001C                M sptl1	=	op1
0001157A =00000027                M sptl2	=	op2
0001157A =0000002D                M sptl3	=	op3
0001157A =00000005                M sptl4	=	op4
0001157A 02                       M 	dc.b	(spfe<<3)+spal
0001157B =00000080                M sptlmask4	set	$80
0001157B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001157B =00000000                M sptlmask3	set	((spal>=4)<<7)
0001157B =00000000                M sptlmask1	set	((spal=7)<<7)
0001157B 617C 0431                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001157F 14D0 8F54                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011583 0105 0508                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011587 0202 051F                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001158B 0111 3188                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001158F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011593 1C2D 2785                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011597 4E41 54                  M 	dc.b	'NAT'
0001159A                            
0001159A                            	; Patch $3E
0001159A                            	; $13
0001159A                            	; $01, $04, $00, $01,	$1C, $9D, $DE, $DF
0001159A                            	; $11, $0D, $02, $01,	$1F, $18, $0B, $01
0001159A                            	; $6F, $63, $FF, $3F,	$1E, $1C, $19, $05
0001159A                            	spAlgorithm	$03
0001159A =0000003F                M spatnum	=	spatnum+1
0001159A =00000003                M spal	=	val
0001159A                            	spFeedback	$02
0001159A =00000002                M spfe	=	val
0001159A                            	spDetune	$00, $00, $00, $00
0001159A =00000000                M spde1	=	op1
0001159A =00000000                M spde2	=	op2
0001159A =00000000                M spde3	=	op3
0001159A =00000000                M spde4	=	op4
0001159A                            	spMultiple	$01, $00, $04, $01
0001159A =00000001                M spmu1	=	op1
0001159A =00000000                M spmu2	=	op2
0001159A =00000004                M spmu3	=	op3
0001159A =00000001                M spmu4	=	op4
0001159A                            	spRateScale	$00, $03, $02, $03
0001159A =00000000                M sprs1	=	op1
0001159A =00000003                M sprs2	=	op2
0001159A =00000002                M sprs3	=	op3
0001159A =00000003                M sprs4	=	op4
0001159A                            	spAttackRt	$1C, $1E, $1D, $1F
0001159A =0000001C                M spar1	=	op1
0001159A =0000001E                M spar2	=	op2
0001159A =0000001D                M spar3	=	op3
0001159A =0000001F                M spar4	=	op4
0001159A                            	spAmpMod	$00, $00, $00, $00
0001159A =00000000                M spam1	=	op1
0001159A =00000000                M spam2	=	op2
0001159A =00000000                M spam3	=	op3
0001159A =00000000                M spam4	=	op4
0001159A                            	spSustainRt	$11, $02, $0D, $01
0001159A =00000011                M spsr1	=	op1
0001159A =00000002                M spsr2	=	op2
0001159A =0000000D                M spsr3	=	op3
0001159A =00000001                M spsr4	=	op4
0001159A                            	spDecayRt	$1F, $0B, $18, $01
0001159A =0000001F                M spdr1	=	op1
0001159A =0000000B                M spdr2	=	op2
0001159A =00000018                M spdr3	=	op3
0001159A =00000001                M spdr4	=	op4
0001159A                            	spSustainLv	$06, $0F, $06, $03
0001159A =00000006                M spsl1	=	op1
0001159A =0000000F                M spsl2	=	op2
0001159A =00000006                M spsl3	=	op3
0001159A =00000003                M spsl4	=	op4
0001159A                            	spReleaseRt	$0F, $0F, $03, $0F
0001159A =0000000F                M sprr1	=	op1
0001159A =0000000F                M sprr2	=	op2
0001159A =00000003                M sprr3	=	op3
0001159A =0000000F                M sprr4	=	op4
0001159A                            	spSSGEG		$00, $00, $00, $00
0001159A =00000000                M spss1	=	op1
0001159A =00000000                M spss2	=	op2
0001159A =00000000                M spss3	=	op3
0001159A =00000000                M spss4	=	op4
0001159A                            	spTotalLv	$1E, $19, $1C, $05
0001159A =0000001E                M sptl1	=	op1
0001159A =00000019                M sptl2	=	op2
0001159A =0000001C                M sptl3	=	op3
0001159A =00000005                M sptl4	=	op4
0001159A 13                       M 	dc.b	(spfe<<3)+spal
0001159B =00000080                M sptlmask4	set	$80
0001159B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001159B =00000000                M sptlmask3	set	((spal>=4)<<7)
0001159B =00000000                M sptlmask1	set	((spal=7)<<7)
0001159B 0104 0001                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001159F 1C9D DEDF                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000115A3 110D 0201                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000115A7 1F18 0B01                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000115AB 6F63 FF3F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000115AF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000115B3 1E1C 1985                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000115B7 4E41 54                  M 	dc.b	'NAT'
000115BA                            
000115BA                            	; Patch $3F
000115BA                            	; $17
000115BA                            	; $32, $72, $32, $12,	$C8, $88, $8C, $C8
000115BA                            	; $00, $13, $8C, $8D,	$01, $01, $01, $00
000115BA                            	; $08, $58, $A8, $78,	$04, $08, $09, $07
000115BA                            	spAlgorithm	$07
000115BA =00000040                M spatnum	=	spatnum+1
000115BA =00000007                M spal	=	val
000115BA                            	spFeedback	$02
000115BA =00000002                M spfe	=	val
000115BA                            	spDetune	$03, $03, $07, $01
000115BA =00000003                M spde1	=	op1
000115BA =00000003                M spde2	=	op2
000115BA =00000007                M spde3	=	op3
000115BA =00000001                M spde4	=	op4
000115BA                            	spMultiple	$02, $02, $02, $02
000115BA =00000002                M spmu1	=	op1
000115BA =00000002                M spmu2	=	op2
000115BA =00000002                M spmu3	=	op3
000115BA =00000002                M spmu4	=	op4
000115BA                            	spRateScale	$03, $02, $02, $03
000115BA =00000003                M sprs1	=	op1
000115BA =00000002                M sprs2	=	op2
000115BA =00000002                M sprs3	=	op3
000115BA =00000003                M sprs4	=	op4
000115BA                            	spAttackRt	$08, $0C, $08, $08
000115BA =00000008                M spar1	=	op1
000115BA =0000000C                M spar2	=	op2
000115BA =00000008                M spar3	=	op3
000115BA =00000008                M spar4	=	op4
000115BA                            	spAmpMod	$00, $01, $00, $01
000115BA =00000000                M spam1	=	op1
000115BA =00000001                M spam2	=	op2
000115BA =00000000                M spam3	=	op3
000115BA =00000001                M spam4	=	op4
000115BA                            	spSustainRt	$00, $0C, $13, $0D
000115BA =00000000                M spsr1	=	op1
000115BA =0000000C                M spsr2	=	op2
000115BA =00000013                M spsr3	=	op3
000115BA =0000000D                M spsr4	=	op4
000115BA                            	spDecayRt	$01, $01, $01, $00
000115BA =00000001                M spdr1	=	op1
000115BA =00000001                M spdr2	=	op2
000115BA =00000001                M spdr3	=	op3
000115BA =00000000                M spdr4	=	op4
000115BA                            	spSustainLv	$00, $0A, $05, $07
000115BA =00000000                M spsl1	=	op1
000115BA =0000000A                M spsl2	=	op2
000115BA =00000005                M spsl3	=	op3
000115BA =00000007                M spsl4	=	op4
000115BA                            	spReleaseRt	$08, $08, $08, $08
000115BA =00000008                M sprr1	=	op1
000115BA =00000008                M sprr2	=	op2
000115BA =00000008                M sprr3	=	op3
000115BA =00000008                M sprr4	=	op4
000115BA                            	spSSGEG		$00, $00, $00, $00
000115BA =00000000                M spss1	=	op1
000115BA =00000000                M spss2	=	op2
000115BA =00000000                M spss3	=	op3
000115BA =00000000                M spss4	=	op4
000115BA                            	spTotalLv	$04, $09, $08, $07
000115BA =00000004                M sptl1	=	op1
000115BA =00000009                M sptl2	=	op2
000115BA =00000008                M sptl3	=	op3
000115BA =00000007                M sptl4	=	op4
000115BA 17                       M 	dc.b	(spfe<<3)+spal
000115BB =00000080                M sptlmask4	set	$80
000115BB =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
000115BB =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
000115BB =FFFFFF80                M sptlmask1	set	((spal=7)<<7)
000115BB 3272 3212                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000115BF C888 8CC8                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000115C3 0013 8C8D                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000115C7 0101 0100                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000115CB 0858 A878                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000115CF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000115D3 8488 8987                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000115D7 4E41 54                  M 	dc.b	'NAT'
000115DA                            
000115DA                            	; Patch $40
000115DA                            	; $3D
000115DA                            	; $01, $01, $01, $01,	$10, $50, $50, $50
000115DA                            	; $07, $08, $08, $08,	$01, $00, $00, $00
000115DA                            	; $20, $1A, $1A, $1A,	$19, $05, $05, $05
000115DA                            	spAlgorithm	$05
000115DA =00000041                M spatnum	=	spatnum+1
000115DA =00000005                M spal	=	val
000115DA                            	spFeedback	$07
000115DA =00000007                M spfe	=	val
000115DA                            	spDetune	$00, $00, $00, $00
000115DA =00000000                M spde1	=	op1
000115DA =00000000                M spde2	=	op2
000115DA =00000000                M spde3	=	op3
000115DA =00000000                M spde4	=	op4
000115DA                            	spMultiple	$01, $01, $01, $01
000115DA =00000001                M spmu1	=	op1
000115DA =00000001                M spmu2	=	op2
000115DA =00000001                M spmu3	=	op3
000115DA =00000001                M spmu4	=	op4
000115DA                            	spRateScale	$00, $01, $01, $01
000115DA =00000000                M sprs1	=	op1
000115DA =00000001                M sprs2	=	op2
000115DA =00000001                M sprs3	=	op3
000115DA =00000001                M sprs4	=	op4
000115DA                            	spAttackRt	$10, $10, $10, $10
000115DA =00000010                M spar1	=	op1
000115DA =00000010                M spar2	=	op2
000115DA =00000010                M spar3	=	op3
000115DA =00000010                M spar4	=	op4
000115DA                            	spAmpMod	$00, $00, $00, $00
000115DA =00000000                M spam1	=	op1
000115DA =00000000                M spam2	=	op2
000115DA =00000000                M spam3	=	op3
000115DA =00000000                M spam4	=	op4
000115DA                            	spSustainRt	$07, $08, $08, $08
000115DA =00000007                M spsr1	=	op1
000115DA =00000008                M spsr2	=	op2
000115DA =00000008                M spsr3	=	op3
000115DA =00000008                M spsr4	=	op4
000115DA                            	spDecayRt	$01, $00, $00, $00
000115DA =00000001                M spdr1	=	op1
000115DA =00000000                M spdr2	=	op2
000115DA =00000000                M spdr3	=	op3
000115DA =00000000                M spdr4	=	op4
000115DA                            	spSustainLv	$02, $01, $01, $01
000115DA =00000002                M spsl1	=	op1
000115DA =00000001                M spsl2	=	op2
000115DA =00000001                M spsl3	=	op3
000115DA =00000001                M spsl4	=	op4
000115DA                            	spReleaseRt	$00, $0A, $0A, $0A
000115DA =00000000                M sprr1	=	op1
000115DA =0000000A                M sprr2	=	op2
000115DA =0000000A                M sprr3	=	op3
000115DA =0000000A                M sprr4	=	op4
000115DA                            	spSSGEG		$00, $00, $00, $00
000115DA =00000000                M spss1	=	op1
000115DA =00000000                M spss2	=	op2
000115DA =00000000                M spss3	=	op3
000115DA =00000000                M spss4	=	op4
000115DA                            	spTotalLv	$19, $05, $05, $05
000115DA =00000019                M sptl1	=	op1
000115DA =00000005                M sptl2	=	op2
000115DA =00000005                M sptl3	=	op3
000115DA =00000005                M sptl4	=	op4
000115DA 3D                       M 	dc.b	(spfe<<3)+spal
000115DB =00000080                M sptlmask4	set	$80
000115DB =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
000115DB =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
000115DB =00000000                M sptlmask1	set	((spal=7)<<7)
000115DB 0101 0101                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000115DF 1050 5050                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000115E3 0708 0808                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000115E7 0100 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000115EB 201A 1A1A                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000115EF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000115F3 1985 8585                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000115F7 4E41 54                  M 	dc.b	'NAT'
000115FA                            
000115FA                            	; Patch $41
000115FA                            	; $3A
000115FA                            	; $03, $08, $03, $01,	$8E, $8E, $8D, $53
000115FA                            	; $0E, $0E, $0E, $03,	$00, $00, $00, $00
000115FA                            	; $1F, $FF, $1F, $0F,	$17, $28, $20, $05
000115FA                            	spAlgorithm	$02
000115FA =00000042                M spatnum	=	spatnum+1
000115FA =00000002                M spal	=	val
000115FA                            	spFeedback	$07
000115FA =00000007                M spfe	=	val
000115FA                            	spDetune	$00, $00, $00, $00
000115FA =00000000                M spde1	=	op1
000115FA =00000000                M spde2	=	op2
000115FA =00000000                M spde3	=	op3
000115FA =00000000                M spde4	=	op4
000115FA                            	spMultiple	$03, $03, $08, $01
000115FA =00000003                M spmu1	=	op1
000115FA =00000003                M spmu2	=	op2
000115FA =00000008                M spmu3	=	op3
000115FA =00000001                M spmu4	=	op4
000115FA                            	spRateScale	$02, $02, $02, $01
000115FA =00000002                M sprs1	=	op1
000115FA =00000002                M sprs2	=	op2
000115FA =00000002                M sprs3	=	op3
000115FA =00000001                M sprs4	=	op4
000115FA                            	spAttackRt	$0E, $0D, $0E, $13
000115FA =0000000E                M spar1	=	op1
000115FA =0000000D                M spar2	=	op2
000115FA =0000000E                M spar3	=	op3
000115FA =00000013                M spar4	=	op4
000115FA                            	spAmpMod	$00, $00, $00, $00
000115FA =00000000                M spam1	=	op1
000115FA =00000000                M spam2	=	op2
000115FA =00000000                M spam3	=	op3
000115FA =00000000                M spam4	=	op4
000115FA                            	spSustainRt	$0E, $0E, $0E, $03
000115FA =0000000E                M spsr1	=	op1
000115FA =0000000E                M spsr2	=	op2
000115FA =0000000E                M spsr3	=	op3
000115FA =00000003                M spsr4	=	op4
000115FA                            	spDecayRt	$00, $00, $00, $00
000115FA =00000000                M spdr1	=	op1
000115FA =00000000                M spdr2	=	op2
000115FA =00000000                M spdr3	=	op3
000115FA =00000000                M spdr4	=	op4
000115FA                            	spSustainLv	$01, $01, $0F, $00
000115FA =00000001                M spsl1	=	op1
000115FA =00000001                M spsl2	=	op2
000115FA =0000000F                M spsl3	=	op3
000115FA =00000000                M spsl4	=	op4
000115FA                            	spReleaseRt	$0F, $0F, $0F, $0F
000115FA =0000000F                M sprr1	=	op1
000115FA =0000000F                M sprr2	=	op2
000115FA =0000000F                M sprr3	=	op3
000115FA =0000000F                M sprr4	=	op4
000115FA                            	spSSGEG		$00, $00, $00, $00
000115FA =00000000                M spss1	=	op1
000115FA =00000000                M spss2	=	op2
000115FA =00000000                M spss3	=	op3
000115FA =00000000                M spss4	=	op4
000115FA                            	spTotalLv	$17, $20, $28, $05
000115FA =00000017                M sptl1	=	op1
000115FA =00000020                M sptl2	=	op2
000115FA =00000028                M sptl3	=	op3
000115FA =00000005                M sptl4	=	op4
000115FA 3A                       M 	dc.b	(spfe<<3)+spal
000115FB =00000080                M sptlmask4	set	$80
000115FB =00000000                M sptlmask2	set	((spal>=5)<<7)
000115FB =00000000                M sptlmask3	set	((spal>=4)<<7)
000115FB =00000000                M sptlmask1	set	((spal=7)<<7)
000115FB 0308 0301                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000115FF 8E8E 8D53                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011603 0E0E 0E03                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011607 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001160B 1FFF 1F0F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001160F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011613 1728 2085                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011617 4E41 54                  M 	dc.b	'NAT'
0001161A                            
0001161A                            	; Patch $42
0001161A                            	; $07
0001161A                            	; $06, $7C, $75, $0A,	$1F, $1F, $1F, $1F
0001161A                            	; $00, $00, $00, $00,	$00, $00, $00, $00
0001161A                            	; $0F, $0F, $0F, $0F,	$07, $07, $07, $07
0001161A                            	spAlgorithm	$07
0001161A =00000043                M spatnum	=	spatnum+1
0001161A =00000007                M spal	=	val
0001161A                            	spFeedback	$00
0001161A =00000000                M spfe	=	val
0001161A                            	spDetune	$00, $07, $07, $00
0001161A =00000000                M spde1	=	op1
0001161A =00000007                M spde2	=	op2
0001161A =00000007                M spde3	=	op3
0001161A =00000000                M spde4	=	op4
0001161A                            	spMultiple	$06, $05, $0C, $0A
0001161A =00000006                M spmu1	=	op1
0001161A =00000005                M spmu2	=	op2
0001161A =0000000C                M spmu3	=	op3
0001161A =0000000A                M spmu4	=	op4
0001161A                            	spRateScale	$00, $00, $00, $00
0001161A =00000000                M sprs1	=	op1
0001161A =00000000                M sprs2	=	op2
0001161A =00000000                M sprs3	=	op3
0001161A =00000000                M sprs4	=	op4
0001161A                            	spAttackRt	$1F, $1F, $1F, $1F
0001161A =0000001F                M spar1	=	op1
0001161A =0000001F                M spar2	=	op2
0001161A =0000001F                M spar3	=	op3
0001161A =0000001F                M spar4	=	op4
0001161A                            	spAmpMod	$00, $00, $00, $00
0001161A =00000000                M spam1	=	op1
0001161A =00000000                M spam2	=	op2
0001161A =00000000                M spam3	=	op3
0001161A =00000000                M spam4	=	op4
0001161A                            	spSustainRt	$00, $00, $00, $00
0001161A =00000000                M spsr1	=	op1
0001161A =00000000                M spsr2	=	op2
0001161A =00000000                M spsr3	=	op3
0001161A =00000000                M spsr4	=	op4
0001161A                            	spDecayRt	$00, $00, $00, $00
0001161A =00000000                M spdr1	=	op1
0001161A =00000000                M spdr2	=	op2
0001161A =00000000                M spdr3	=	op3
0001161A =00000000                M spdr4	=	op4
0001161A                            	spSustainLv	$00, $00, $00, $00
0001161A =00000000                M spsl1	=	op1
0001161A =00000000                M spsl2	=	op2
0001161A =00000000                M spsl3	=	op3
0001161A =00000000                M spsl4	=	op4
0001161A                            	spReleaseRt	$0F, $0F, $0F, $0F
0001161A =0000000F                M sprr1	=	op1
0001161A =0000000F                M sprr2	=	op2
0001161A =0000000F                M sprr3	=	op3
0001161A =0000000F                M sprr4	=	op4
0001161A                            	spSSGEG		$00, $00, $00, $00
0001161A =00000000                M spss1	=	op1
0001161A =00000000                M spss2	=	op2
0001161A =00000000                M spss3	=	op3
0001161A =00000000                M spss4	=	op4
0001161A                            	spTotalLv	$07, $07, $07, $07
0001161A =00000007                M sptl1	=	op1
0001161A =00000007                M sptl2	=	op2
0001161A =00000007                M sptl3	=	op3
0001161A =00000007                M sptl4	=	op4
0001161A 07                       M 	dc.b	(spfe<<3)+spal
0001161B =00000080                M sptlmask4	set	$80
0001161B =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
0001161B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
0001161B =FFFFFF80                M sptlmask1	set	((spal=7)<<7)
0001161B 067C 750A                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001161F 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011623 0000 0000                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011627 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001162B 0F0F 0F0F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001162F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011633 8787 8787                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011637 4E41 54                  M 	dc.b	'NAT'
0001163A                            
0001163A                            	; Patch $43
0001163A                            	; $3A
0001163A                            	; $01, $40, $01, $31,	$1F, $1F, $1F, $1F
0001163A                            	; $0B, $04, $04, $04,	$02, $04, $03, $02
0001163A                            	; $5F, $1F, $5F, $2F,	$18, $05, $11, $05
0001163A                            	spAlgorithm	$02
0001163A =00000044                M spatnum	=	spatnum+1
0001163A =00000002                M spal	=	val
0001163A                            	spFeedback	$07
0001163A =00000007                M spfe	=	val
0001163A                            	spDetune	$00, $00, $04, $03
0001163A =00000000                M spde1	=	op1
0001163A =00000000                M spde2	=	op2
0001163A =00000004                M spde3	=	op3
0001163A =00000003                M spde4	=	op4
0001163A                            	spMultiple	$01, $01, $00, $01
0001163A =00000001                M spmu1	=	op1
0001163A =00000001                M spmu2	=	op2
0001163A =00000000                M spmu3	=	op3
0001163A =00000001                M spmu4	=	op4
0001163A                            	spRateScale	$00, $00, $00, $00
0001163A =00000000                M sprs1	=	op1
0001163A =00000000                M sprs2	=	op2
0001163A =00000000                M sprs3	=	op3
0001163A =00000000                M sprs4	=	op4
0001163A                            	spAttackRt	$1F, $1F, $1F, $1F
0001163A =0000001F                M spar1	=	op1
0001163A =0000001F                M spar2	=	op2
0001163A =0000001F                M spar3	=	op3
0001163A =0000001F                M spar4	=	op4
0001163A                            	spAmpMod	$00, $00, $00, $00
0001163A =00000000                M spam1	=	op1
0001163A =00000000                M spam2	=	op2
0001163A =00000000                M spam3	=	op3
0001163A =00000000                M spam4	=	op4
0001163A                            	spSustainRt	$0B, $04, $04, $04
0001163A =0000000B                M spsr1	=	op1
0001163A =00000004                M spsr2	=	op2
0001163A =00000004                M spsr3	=	op3
0001163A =00000004                M spsr4	=	op4
0001163A                            	spDecayRt	$02, $03, $04, $02
0001163A =00000002                M spdr1	=	op1
0001163A =00000003                M spdr2	=	op2
0001163A =00000004                M spdr3	=	op3
0001163A =00000002                M spdr4	=	op4
0001163A                            	spSustainLv	$05, $05, $01, $02
0001163A =00000005                M spsl1	=	op1
0001163A =00000005                M spsl2	=	op2
0001163A =00000001                M spsl3	=	op3
0001163A =00000002                M spsl4	=	op4
0001163A                            	spReleaseRt	$0F, $0F, $0F, $0F
0001163A =0000000F                M sprr1	=	op1
0001163A =0000000F                M sprr2	=	op2
0001163A =0000000F                M sprr3	=	op3
0001163A =0000000F                M sprr4	=	op4
0001163A                            	spSSGEG		$00, $00, $00, $00
0001163A =00000000                M spss1	=	op1
0001163A =00000000                M spss2	=	op2
0001163A =00000000                M spss3	=	op3
0001163A =00000000                M spss4	=	op4
0001163A                            	spTotalLv	$18, $11, $05, $05
0001163A =00000018                M sptl1	=	op1
0001163A =00000011                M sptl2	=	op2
0001163A =00000005                M sptl3	=	op3
0001163A =00000005                M sptl4	=	op4
0001163A 3A                       M 	dc.b	(spfe<<3)+spal
0001163B =00000080                M sptlmask4	set	$80
0001163B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001163B =00000000                M sptlmask3	set	((spal>=4)<<7)
0001163B =00000000                M sptlmask1	set	((spal=7)<<7)
0001163B 0140 0131                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001163F 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011643 0B04 0404                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011647 0204 0302                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001164B 5F1F 5F2F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001164F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011653 1805 1185                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011657 4E41 54                  M 	dc.b	'NAT'
0001165A                            
0001165A                            	; Patch $44
0001165A                            	; $3C
0001165A                            	; $01, $01, $0E, $04,	$8D, $52, $9F, $1F
0001165A                            	; $09, $00, $00, $0D,	$00, $00, $00, $00
0001165A                            	; $23, $08, $02, $6F,	$15, $02, $10, $05
0001165A                            	spAlgorithm	$04
0001165A =00000045                M spatnum	=	spatnum+1
0001165A =00000004                M spal	=	val
0001165A                            	spFeedback	$07
0001165A =00000007                M spfe	=	val
0001165A                            	spDetune	$00, $00, $00, $00
0001165A =00000000                M spde1	=	op1
0001165A =00000000                M spde2	=	op2
0001165A =00000000                M spde3	=	op3
0001165A =00000000                M spde4	=	op4
0001165A                            	spMultiple	$01, $0E, $01, $04
0001165A =00000001                M spmu1	=	op1
0001165A =0000000E                M spmu2	=	op2
0001165A =00000001                M spmu3	=	op3
0001165A =00000004                M spmu4	=	op4
0001165A                            	spRateScale	$02, $02, $01, $00
0001165A =00000002                M sprs1	=	op1
0001165A =00000002                M sprs2	=	op2
0001165A =00000001                M sprs3	=	op3
0001165A =00000000                M sprs4	=	op4
0001165A                            	spAttackRt	$0D, $1F, $12, $1F
0001165A =0000000D                M spar1	=	op1
0001165A =0000001F                M spar2	=	op2
0001165A =00000012                M spar3	=	op3
0001165A =0000001F                M spar4	=	op4
0001165A                            	spAmpMod	$00, $00, $00, $00
0001165A =00000000                M spam1	=	op1
0001165A =00000000                M spam2	=	op2
0001165A =00000000                M spam3	=	op3
0001165A =00000000                M spam4	=	op4
0001165A                            	spSustainRt	$09, $00, $00, $0D
0001165A =00000009                M spsr1	=	op1
0001165A =00000000                M spsr2	=	op2
0001165A =00000000                M spsr3	=	op3
0001165A =0000000D                M spsr4	=	op4
0001165A                            	spDecayRt	$00, $00, $00, $00
0001165A =00000000                M spdr1	=	op1
0001165A =00000000                M spdr2	=	op2
0001165A =00000000                M spdr3	=	op3
0001165A =00000000                M spdr4	=	op4
0001165A                            	spSustainLv	$02, $00, $00, $06
0001165A =00000002                M spsl1	=	op1
0001165A =00000000                M spsl2	=	op2
0001165A =00000000                M spsl3	=	op3
0001165A =00000006                M spsl4	=	op4
0001165A                            	spReleaseRt	$03, $02, $08, $0F
0001165A =00000003                M sprr1	=	op1
0001165A =00000002                M sprr2	=	op2
0001165A =00000008                M sprr3	=	op3
0001165A =0000000F                M sprr4	=	op4
0001165A                            	spSSGEG		$00, $00, $00, $00
0001165A =00000000                M spss1	=	op1
0001165A =00000000                M spss2	=	op2
0001165A =00000000                M spss3	=	op3
0001165A =00000000                M spss4	=	op4
0001165A                            	spTotalLv	$15, $10, $02, $05
0001165A =00000015                M sptl1	=	op1
0001165A =00000010                M sptl2	=	op2
0001165A =00000002                M sptl3	=	op3
0001165A =00000005                M sptl4	=	op4
0001165A 3C                       M 	dc.b	(spfe<<3)+spal
0001165B =00000080                M sptlmask4	set	$80
0001165B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001165B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
0001165B =00000000                M sptlmask1	set	((spal=7)<<7)
0001165B 0101 0E04                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001165F 8D52 9F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011663 0900 000D                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011667 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001166B 2308 026F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001166F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011673 1582 1085                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011677 4E41 54                  M 	dc.b	'NAT'
0001167A                            
0001167A                            	; Patch $45
0001167A                            	; $04
0001167A                            	; $37, $72, $77, $49,	$1F, $1F, $1F, $1F
0001167A                            	; $07, $0A, $07, $0D,	$00, $0B, $00, $0B
0001167A                            	; $1F, $0F, $1F, $0F,	$23, $00, $23, $00
0001167A                            	spAlgorithm	$04
0001167A =00000046                M spatnum	=	spatnum+1
0001167A =00000004                M spal	=	val
0001167A                            	spFeedback	$00
0001167A =00000000                M spfe	=	val
0001167A                            	spDetune	$03, $07, $07, $04
0001167A =00000003                M spde1	=	op1
0001167A =00000007                M spde2	=	op2
0001167A =00000007                M spde3	=	op3
0001167A =00000004                M spde4	=	op4
0001167A                            	spMultiple	$07, $07, $02, $09
0001167A =00000007                M spmu1	=	op1
0001167A =00000007                M spmu2	=	op2
0001167A =00000002                M spmu3	=	op3
0001167A =00000009                M spmu4	=	op4
0001167A                            	spRateScale	$00, $00, $00, $00
0001167A =00000000                M sprs1	=	op1
0001167A =00000000                M sprs2	=	op2
0001167A =00000000                M sprs3	=	op3
0001167A =00000000                M sprs4	=	op4
0001167A                            	spAttackRt	$1F, $1F, $1F, $1F
0001167A =0000001F                M spar1	=	op1
0001167A =0000001F                M spar2	=	op2
0001167A =0000001F                M spar3	=	op3
0001167A =0000001F                M spar4	=	op4
0001167A                            	spAmpMod	$00, $00, $00, $00
0001167A =00000000                M spam1	=	op1
0001167A =00000000                M spam2	=	op2
0001167A =00000000                M spam3	=	op3
0001167A =00000000                M spam4	=	op4
0001167A                            	spSustainRt	$07, $07, $0A, $0D
0001167A =00000007                M spsr1	=	op1
0001167A =00000007                M spsr2	=	op2
0001167A =0000000A                M spsr3	=	op3
0001167A =0000000D                M spsr4	=	op4
0001167A                            	spDecayRt	$00, $00, $0B, $0B
0001167A =00000000                M spdr1	=	op1
0001167A =00000000                M spdr2	=	op2
0001167A =0000000B                M spdr3	=	op3
0001167A =0000000B                M spdr4	=	op4
0001167A                            	spSustainLv	$01, $01, $00, $00
0001167A =00000001                M spsl1	=	op1
0001167A =00000001                M spsl2	=	op2
0001167A =00000000                M spsl3	=	op3
0001167A =00000000                M spsl4	=	op4
0001167A                            	spReleaseRt	$0F, $0F, $0F, $0F
0001167A =0000000F                M sprr1	=	op1
0001167A =0000000F                M sprr2	=	op2
0001167A =0000000F                M sprr3	=	op3
0001167A =0000000F                M sprr4	=	op4
0001167A                            	spSSGEG		$00, $00, $00, $00
0001167A =00000000                M spss1	=	op1
0001167A =00000000                M spss2	=	op2
0001167A =00000000                M spss3	=	op3
0001167A =00000000                M spss4	=	op4
0001167A                            	spTotalLv	$23, $23, $00, $00
0001167A =00000023                M sptl1	=	op1
0001167A =00000023                M sptl2	=	op2
0001167A =00000000                M sptl3	=	op3
0001167A =00000000                M sptl4	=	op4
0001167A 04                       M 	dc.b	(spfe<<3)+spal
0001167B =00000080                M sptlmask4	set	$80
0001167B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001167B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
0001167B =00000000                M sptlmask1	set	((spal=7)<<7)
0001167B 3772 7749                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001167F 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011683 070A 070D                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011687 000B 000B                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001168B 1F0F 1F0F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001168F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011693 2380 2380                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011697 4E41 54                  M 	dc.b	'NAT'
0001169A                            
0001169A                            	; Patch $46
0001169A                            	; $3C
0001169A                            	; $31, $73, $71, $31,	$10, $8C, $0A, $13
0001169A                            	; $00, $00, $00, $00,	$00, $0C, $00, $03
0001169A                            	; $0F, $0F, $0F, $0F,	$20, $00, $20, $00
0001169A                            	spAlgorithm	$04
0001169A =00000047                M spatnum	=	spatnum+1
0001169A =00000004                M spal	=	val
0001169A                            	spFeedback	$07
0001169A =00000007                M spfe	=	val
0001169A                            	spDetune	$03, $07, $07, $03
0001169A =00000003                M spde1	=	op1
0001169A =00000007                M spde2	=	op2
0001169A =00000007                M spde3	=	op3
0001169A =00000003                M spde4	=	op4
0001169A                            	spMultiple	$01, $01, $03, $01
0001169A =00000001                M spmu1	=	op1
0001169A =00000001                M spmu2	=	op2
0001169A =00000003                M spmu3	=	op3
0001169A =00000001                M spmu4	=	op4
0001169A                            	spRateScale	$00, $00, $02, $00
0001169A =00000000                M sprs1	=	op1
0001169A =00000000                M sprs2	=	op2
0001169A =00000002                M sprs3	=	op3
0001169A =00000000                M sprs4	=	op4
0001169A                            	spAttackRt	$10, $0A, $0C, $13
0001169A =00000010                M spar1	=	op1
0001169A =0000000A                M spar2	=	op2
0001169A =0000000C                M spar3	=	op3
0001169A =00000013                M spar4	=	op4
0001169A                            	spAmpMod	$00, $00, $00, $00
0001169A =00000000                M spam1	=	op1
0001169A =00000000                M spam2	=	op2
0001169A =00000000                M spam3	=	op3
0001169A =00000000                M spam4	=	op4
0001169A                            	spSustainRt	$00, $00, $00, $00
0001169A =00000000                M spsr1	=	op1
0001169A =00000000                M spsr2	=	op2
0001169A =00000000                M spsr3	=	op3
0001169A =00000000                M spsr4	=	op4
0001169A                            	spDecayRt	$00, $00, $0C, $03
0001169A =00000000                M spdr1	=	op1
0001169A =00000000                M spdr2	=	op2
0001169A =0000000C                M spdr3	=	op3
0001169A =00000003                M spdr4	=	op4
0001169A                            	spSustainLv	$00, $00, $00, $00
0001169A =00000000                M spsl1	=	op1
0001169A =00000000                M spsl2	=	op2
0001169A =00000000                M spsl3	=	op3
0001169A =00000000                M spsl4	=	op4
0001169A                            	spReleaseRt	$0F, $0F, $0F, $0F
0001169A =0000000F                M sprr1	=	op1
0001169A =0000000F                M sprr2	=	op2
0001169A =0000000F                M sprr3	=	op3
0001169A =0000000F                M sprr4	=	op4
0001169A                            	spSSGEG		$00, $00, $00, $00
0001169A =00000000                M spss1	=	op1
0001169A =00000000                M spss2	=	op2
0001169A =00000000                M spss3	=	op3
0001169A =00000000                M spss4	=	op4
0001169A                            	spTotalLv	$20, $20, $00, $00
0001169A =00000020                M sptl1	=	op1
0001169A =00000020                M sptl2	=	op2
0001169A =00000000                M sptl3	=	op3
0001169A =00000000                M sptl4	=	op4
0001169A 3C                       M 	dc.b	(spfe<<3)+spal
0001169B =00000080                M sptlmask4	set	$80
0001169B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001169B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
0001169B =00000000                M sptlmask1	set	((spal=7)<<7)
0001169B 3173 7131                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001169F 108C 0A13                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000116A3 0000 0000                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000116A7 000C 0003                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000116AB 0F0F 0F0F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000116AF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000116B3 2080 2080                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000116B7 4E41 54                  M 	dc.b	'NAT'
000116BA                            
000116BA                            	; Patch $47
000116BA                            	; $24
000116BA                            	; $00, $04, $01, $04,	$10, $19, $10, $0D
000116BA                            	; $00, $03, $00, $00,	$02, $00, $01, $00
000116BA                            	; $0A, $0C, $0D, $0C,	$08, $04, $0B, $05
000116BA                            	spAlgorithm	$04
000116BA =00000048                M spatnum	=	spatnum+1
000116BA =00000004                M spal	=	val
000116BA                            	spFeedback	$04
000116BA =00000004                M spfe	=	val
000116BA                            	spDetune	$00, $00, $00, $00
000116BA =00000000                M spde1	=	op1
000116BA =00000000                M spde2	=	op2
000116BA =00000000                M spde3	=	op3
000116BA =00000000                M spde4	=	op4
000116BA                            	spMultiple	$00, $01, $04, $04
000116BA =00000000                M spmu1	=	op1
000116BA =00000001                M spmu2	=	op2
000116BA =00000004                M spmu3	=	op3
000116BA =00000004                M spmu4	=	op4
000116BA                            	spRateScale	$00, $00, $00, $00
000116BA =00000000                M sprs1	=	op1
000116BA =00000000                M sprs2	=	op2
000116BA =00000000                M sprs3	=	op3
000116BA =00000000                M sprs4	=	op4
000116BA                            	spAttackRt	$10, $10, $19, $0D
000116BA =00000010                M spar1	=	op1
000116BA =00000010                M spar2	=	op2
000116BA =00000019                M spar3	=	op3
000116BA =0000000D                M spar4	=	op4
000116BA                            	spAmpMod	$00, $00, $00, $00
000116BA =00000000                M spam1	=	op1
000116BA =00000000                M spam2	=	op2
000116BA =00000000                M spam3	=	op3
000116BA =00000000                M spam4	=	op4
000116BA                            	spSustainRt	$00, $00, $03, $00
000116BA =00000000                M spsr1	=	op1
000116BA =00000000                M spsr2	=	op2
000116BA =00000003                M spsr3	=	op3
000116BA =00000000                M spsr4	=	op4
000116BA                            	spDecayRt	$02, $01, $00, $00
000116BA =00000002                M spdr1	=	op1
000116BA =00000001                M spdr2	=	op2
000116BA =00000000                M spdr3	=	op3
000116BA =00000000                M spdr4	=	op4
000116BA                            	spSustainLv	$00, $00, $00, $00
000116BA =00000000                M spsl1	=	op1
000116BA =00000000                M spsl2	=	op2
000116BA =00000000                M spsl3	=	op3
000116BA =00000000                M spsl4	=	op4
000116BA                            	spReleaseRt	$0A, $0D, $0C, $0C
000116BA =0000000A                M sprr1	=	op1
000116BA =0000000D                M sprr2	=	op2
000116BA =0000000C                M sprr3	=	op3
000116BA =0000000C                M sprr4	=	op4
000116BA                            	spSSGEG		$00, $00, $00, $00
000116BA =00000000                M spss1	=	op1
000116BA =00000000                M spss2	=	op2
000116BA =00000000                M spss3	=	op3
000116BA =00000000                M spss4	=	op4
000116BA                            	spTotalLv	$08, $0B, $04, $05
000116BA =00000008                M sptl1	=	op1
000116BA =0000000B                M sptl2	=	op2
000116BA =00000004                M sptl3	=	op3
000116BA =00000005                M sptl4	=	op4
000116BA 24                       M 	dc.b	(spfe<<3)+spal
000116BB =00000080                M sptlmask4	set	$80
000116BB =00000000                M sptlmask2	set	((spal>=5)<<7)
000116BB =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
000116BB =00000000                M sptlmask1	set	((spal=7)<<7)
000116BB 0004 0104                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000116BF 1019 100D                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000116C3 0003 0000                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000116C7 0200 0100                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000116CB 0A0C 0D0C                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000116CF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000116D3 0884 0B85                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000116D7 4E41 54                  M 	dc.b	'NAT'
000116DA                            
000116DA                            	; Patch $48
000116DA                            	; $22
000116DA                            	; $61, $7C, $04, $31,	$14, $D0, $8F, $54
000116DA                            	; $01, $05, $05, $08,	$02, $02, $05, $1F
000116DA                            	; $01, $11, $31, $88,	$19, $28, $24, $00
000116DA                            	spAlgorithm	$02
000116DA =00000049                M spatnum	=	spatnum+1
000116DA =00000002                M spal	=	val
000116DA                            	spFeedback	$04
000116DA =00000004                M spfe	=	val
000116DA                            	spDetune	$06, $00, $07, $03
000116DA =00000006                M spde1	=	op1
000116DA =00000000                M spde2	=	op2
000116DA =00000007                M spde3	=	op3
000116DA =00000003                M spde4	=	op4
000116DA                            	spMultiple	$01, $04, $0C, $01
000116DA =00000001                M spmu1	=	op1
000116DA =00000004                M spmu2	=	op2
000116DA =0000000C                M spmu3	=	op3
000116DA =00000001                M spmu4	=	op4
000116DA                            	spRateScale	$00, $02, $03, $01
000116DA =00000000                M sprs1	=	op1
000116DA =00000002                M sprs2	=	op2
000116DA =00000003                M sprs3	=	op3
000116DA =00000001                M sprs4	=	op4
000116DA                            	spAttackRt	$14, $0F, $10, $14
000116DA =00000014                M spar1	=	op1
000116DA =0000000F                M spar2	=	op2
000116DA =00000010                M spar3	=	op3
000116DA =00000014                M spar4	=	op4
000116DA                            	spAmpMod	$00, $00, $00, $00
000116DA =00000000                M spam1	=	op1
000116DA =00000000                M spam2	=	op2
000116DA =00000000                M spam3	=	op3
000116DA =00000000                M spam4	=	op4
000116DA                            	spSustainRt	$01, $05, $05, $08
000116DA =00000001                M spsr1	=	op1
000116DA =00000005                M spsr2	=	op2
000116DA =00000005                M spsr3	=	op3
000116DA =00000008                M spsr4	=	op4
000116DA                            	spDecayRt	$02, $05, $02, $1F
000116DA =00000002                M spdr1	=	op1
000116DA =00000005                M spdr2	=	op2
000116DA =00000002                M spdr3	=	op3
000116DA =0000001F                M spdr4	=	op4
000116DA                            	spSustainLv	$00, $03, $01, $08
000116DA =00000000                M spsl1	=	op1
000116DA =00000003                M spsl2	=	op2
000116DA =00000001                M spsl3	=	op3
000116DA =00000008                M spsl4	=	op4
000116DA                            	spReleaseRt	$01, $01, $01, $08
000116DA =00000001                M sprr1	=	op1
000116DA =00000001                M sprr2	=	op2
000116DA =00000001                M sprr3	=	op3
000116DA =00000008                M sprr4	=	op4
000116DA                            	spSSGEG		$00, $00, $00, $00
000116DA =00000000                M spss1	=	op1
000116DA =00000000                M spss2	=	op2
000116DA =00000000                M spss3	=	op3
000116DA =00000000                M spss4	=	op4
000116DA                            	spTotalLv	$19, $24, $28, $00
000116DA =00000019                M sptl1	=	op1
000116DA =00000024                M sptl2	=	op2
000116DA =00000028                M sptl3	=	op3
000116DA =00000000                M sptl4	=	op4
000116DA 22                       M 	dc.b	(spfe<<3)+spal
000116DB =00000080                M sptlmask4	set	$80
000116DB =00000000                M sptlmask2	set	((spal>=5)<<7)
000116DB =00000000                M sptlmask3	set	((spal>=4)<<7)
000116DB =00000000                M sptlmask1	set	((spal=7)<<7)
000116DB 617C 0431                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000116DF 14D0 8F54                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000116E3 0105 0508                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000116E7 0202 051F                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000116EB 0111 3188                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000116EF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000116F3 1928 2480                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000116F7 4E41 54                  M 	dc.b	'NAT'
000116FA                            
000116FA                            	; Patch $49
000116FA                            	; $3B
000116FA                            	; $51, $71, $61, $41,	$51, $16, $18, $1A
000116FA                            	; $05, $01, $01, $00,	$09, $01, $01, $01
000116FA                            	; $17, $97, $27, $87,	$1C, $22, $15, $00
000116FA                            	spAlgorithm	$03
000116FA =0000004A                M spatnum	=	spatnum+1
000116FA =00000003                M spal	=	val
000116FA                            	spFeedback	$07
000116FA =00000007                M spfe	=	val
000116FA                            	spDetune	$05, $06, $07, $04
000116FA =00000005                M spde1	=	op1
000116FA =00000006                M spde2	=	op2
000116FA =00000007                M spde3	=	op3
000116FA =00000004                M spde4	=	op4
000116FA                            	spMultiple	$01, $01, $01, $01
000116FA =00000001                M spmu1	=	op1
000116FA =00000001                M spmu2	=	op2
000116FA =00000001                M spmu3	=	op3
000116FA =00000001                M spmu4	=	op4
000116FA                            	spRateScale	$01, $00, $00, $00
000116FA =00000001                M sprs1	=	op1
000116FA =00000000                M sprs2	=	op2
000116FA =00000000                M sprs3	=	op3
000116FA =00000000                M sprs4	=	op4
000116FA                            	spAttackRt	$11, $18, $16, $1A
000116FA =00000011                M spar1	=	op1
000116FA =00000018                M spar2	=	op2
000116FA =00000016                M spar3	=	op3
000116FA =0000001A                M spar4	=	op4
000116FA                            	spAmpMod	$00, $00, $00, $00
000116FA =00000000                M spam1	=	op1
000116FA =00000000                M spam2	=	op2
000116FA =00000000                M spam3	=	op3
000116FA =00000000                M spam4	=	op4
000116FA                            	spSustainRt	$05, $01, $01, $00
000116FA =00000005                M spsr1	=	op1
000116FA =00000001                M spsr2	=	op2
000116FA =00000001                M spsr3	=	op3
000116FA =00000000                M spsr4	=	op4
000116FA                            	spDecayRt	$09, $01, $01, $01
000116FA =00000009                M spdr1	=	op1
000116FA =00000001                M spdr2	=	op2
000116FA =00000001                M spdr3	=	op3
000116FA =00000001                M spdr4	=	op4
000116FA                            	spSustainLv	$01, $02, $09, $08
000116FA =00000001                M spsl1	=	op1
000116FA =00000002                M spsl2	=	op2
000116FA =00000009                M spsl3	=	op3
000116FA =00000008                M spsl4	=	op4
000116FA                            	spReleaseRt	$07, $07, $07, $07
000116FA =00000007                M sprr1	=	op1
000116FA =00000007                M sprr2	=	op2
000116FA =00000007                M sprr3	=	op3
000116FA =00000007                M sprr4	=	op4
000116FA                            	spSSGEG		$00, $00, $00, $00
000116FA =00000000                M spss1	=	op1
000116FA =00000000                M spss2	=	op2
000116FA =00000000                M spss3	=	op3
000116FA =00000000                M spss4	=	op4
000116FA                            	spTotalLv	$1C, $15, $22, $00
000116FA =0000001C                M sptl1	=	op1
000116FA =00000015                M sptl2	=	op2
000116FA =00000022                M sptl3	=	op3
000116FA =00000000                M sptl4	=	op4
000116FA 3B                       M 	dc.b	(spfe<<3)+spal
000116FB =00000080                M sptlmask4	set	$80
000116FB =00000000                M sptlmask2	set	((spal>=5)<<7)
000116FB =00000000                M sptlmask3	set	((spal>=4)<<7)
000116FB =00000000                M sptlmask1	set	((spal=7)<<7)
000116FB 5171 6141                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000116FF 5116 181A                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011703 0501 0100                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011707 0901 0101                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001170B 1797 2787                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001170F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011713 1C22 1580                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011717 4E41 54                  M 	dc.b	'NAT'
0001171A                            
0001171A                            	; Patch $4A
0001171A                            	; $32
0001171A                            	; $00, $01, $04, $04,	$1F, $16, $18, $1B
0001171A                            	; $08, $07, $07, $04,	$07, $08, $06, $1F
0001171A                            	; $04, $58, $05, $77,	$06, $05, $15, $00
0001171A                            	spAlgorithm	$02
0001171A =0000004B                M spatnum	=	spatnum+1
0001171A =00000002                M spal	=	val
0001171A                            	spFeedback	$06
0001171A =00000006                M spfe	=	val
0001171A                            	spDetune	$00, $00, $00, $00
0001171A =00000000                M spde1	=	op1
0001171A =00000000                M spde2	=	op2
0001171A =00000000                M spde3	=	op3
0001171A =00000000                M spde4	=	op4
0001171A                            	spMultiple	$00, $04, $01, $04
0001171A =00000000                M spmu1	=	op1
0001171A =00000004                M spmu2	=	op2
0001171A =00000001                M spmu3	=	op3
0001171A =00000004                M spmu4	=	op4
0001171A                            	spRateScale	$00, $00, $00, $00
0001171A =00000000                M sprs1	=	op1
0001171A =00000000                M sprs2	=	op2
0001171A =00000000                M sprs3	=	op3
0001171A =00000000                M sprs4	=	op4
0001171A                            	spAttackRt	$1F, $18, $16, $1B
0001171A =0000001F                M spar1	=	op1
0001171A =00000018                M spar2	=	op2
0001171A =00000016                M spar3	=	op3
0001171A =0000001B                M spar4	=	op4
0001171A                            	spAmpMod	$00, $00, $00, $00
0001171A =00000000                M spam1	=	op1
0001171A =00000000                M spam2	=	op2
0001171A =00000000                M spam3	=	op3
0001171A =00000000                M spam4	=	op4
0001171A                            	spSustainRt	$08, $07, $07, $04
0001171A =00000008                M spsr1	=	op1
0001171A =00000007                M spsr2	=	op2
0001171A =00000007                M spsr3	=	op3
0001171A =00000004                M spsr4	=	op4
0001171A                            	spDecayRt	$07, $06, $08, $1F
0001171A =00000007                M spdr1	=	op1
0001171A =00000006                M spdr2	=	op2
0001171A =00000008                M spdr3	=	op3
0001171A =0000001F                M spdr4	=	op4
0001171A                            	spSustainLv	$00, $00, $05, $07
0001171A =00000000                M spsl1	=	op1
0001171A =00000000                M spsl2	=	op2
0001171A =00000005                M spsl3	=	op3
0001171A =00000007                M spsl4	=	op4
0001171A                            	spReleaseRt	$04, $05, $08, $07
0001171A =00000004                M sprr1	=	op1
0001171A =00000005                M sprr2	=	op2
0001171A =00000008                M sprr3	=	op3
0001171A =00000007                M sprr4	=	op4
0001171A                            	spSSGEG		$00, $00, $00, $00
0001171A =00000000                M spss1	=	op1
0001171A =00000000                M spss2	=	op2
0001171A =00000000                M spss3	=	op3
0001171A =00000000                M spss4	=	op4
0001171A                            	spTotalLv	$06, $15, $05, $00
0001171A =00000006                M sptl1	=	op1
0001171A =00000015                M sptl2	=	op2
0001171A =00000005                M sptl3	=	op3
0001171A =00000000                M sptl4	=	op4
0001171A 32                       M 	dc.b	(spfe<<3)+spal
0001171B =00000080                M sptlmask4	set	$80
0001171B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001171B =00000000                M sptlmask3	set	((spal>=4)<<7)
0001171B =00000000                M sptlmask1	set	((spal=7)<<7)
0001171B 0001 0404                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001171F 1F16 181B                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011723 0807 0704                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011727 0708 061F                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001172B 0458 0577                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001172F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011733 0605 1580                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011737 4E41 54                  M 	dc.b	'NAT'
0001173A                            
0001173A                            	; Patch $4B
0001173A                            	; $39
0001173A                            	; $01, $61, $00, $00,	$1F, $5F, $5F, $5F
0001173A                            	; $10, $11, $09, $09,	$1F, $1F, $1E, $1C
0001173A                            	; $FF, $FF, $FF, $FF,	$1C, $22, $1F, $02
0001173A                            	spAlgorithm	$01
0001173A =0000004C                M spatnum	=	spatnum+1
0001173A =00000001                M spal	=	val
0001173A                            	spFeedback	$07
0001173A =00000007                M spfe	=	val
0001173A                            	spDetune	$00, $00, $06, $00
0001173A =00000000                M spde1	=	op1
0001173A =00000000                M spde2	=	op2
0001173A =00000006                M spde3	=	op3
0001173A =00000000                M spde4	=	op4
0001173A                            	spMultiple	$01, $00, $01, $00
0001173A =00000001                M spmu1	=	op1
0001173A =00000000                M spmu2	=	op2
0001173A =00000001                M spmu3	=	op3
0001173A =00000000                M spmu4	=	op4
0001173A                            	spRateScale	$00, $01, $01, $01
0001173A =00000000                M sprs1	=	op1
0001173A =00000001                M sprs2	=	op2
0001173A =00000001                M sprs3	=	op3
0001173A =00000001                M sprs4	=	op4
0001173A                            	spAttackRt	$1F, $1F, $1F, $1F
0001173A =0000001F                M spar1	=	op1
0001173A =0000001F                M spar2	=	op2
0001173A =0000001F                M spar3	=	op3
0001173A =0000001F                M spar4	=	op4
0001173A                            	spAmpMod	$00, $00, $00, $00
0001173A =00000000                M spam1	=	op1
0001173A =00000000                M spam2	=	op2
0001173A =00000000                M spam3	=	op3
0001173A =00000000                M spam4	=	op4
0001173A                            	spSustainRt	$10, $09, $11, $09
0001173A =00000010                M spsr1	=	op1
0001173A =00000009                M spsr2	=	op2
0001173A =00000011                M spsr3	=	op3
0001173A =00000009                M spsr4	=	op4
0001173A                            	spDecayRt	$1F, $1E, $1F, $1C
0001173A =0000001F                M spdr1	=	op1
0001173A =0000001E                M spdr2	=	op2
0001173A =0000001F                M spdr3	=	op3
0001173A =0000001C                M spdr4	=	op4
0001173A                            	spSustainLv	$0F, $0F, $0F, $0F
0001173A =0000000F                M spsl1	=	op1
0001173A =0000000F                M spsl2	=	op2
0001173A =0000000F                M spsl3	=	op3
0001173A =0000000F                M spsl4	=	op4
0001173A                            	spReleaseRt	$0F, $0F, $0F, $0F
0001173A =0000000F                M sprr1	=	op1
0001173A =0000000F                M sprr2	=	op2
0001173A =0000000F                M sprr3	=	op3
0001173A =0000000F                M sprr4	=	op4
0001173A                            	spSSGEG		$00, $00, $00, $00
0001173A =00000000                M spss1	=	op1
0001173A =00000000                M spss2	=	op2
0001173A =00000000                M spss3	=	op3
0001173A =00000000                M spss4	=	op4
0001173A                            	spTotalLv	$1C, $1F, $22, $02
0001173A =0000001C                M sptl1	=	op1
0001173A =0000001F                M sptl2	=	op2
0001173A =00000022                M sptl3	=	op3
0001173A =00000002                M sptl4	=	op4
0001173A 39                       M 	dc.b	(spfe<<3)+spal
0001173B =00000080                M sptlmask4	set	$80
0001173B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001173B =00000000                M sptlmask3	set	((spal>=4)<<7)
0001173B =00000000                M sptlmask1	set	((spal=7)<<7)
0001173B 0161 0000                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001173F 1F5F 5F5F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011743 1011 0909                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011747 1F1F 1E1C                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001174B FFFF FFFF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001174F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011753 1C22 1F82                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011757 4E41 54                  M 	dc.b	'NAT'
0001175A                            
0001175A                            	; Patch $4C
0001175A                            	; $27
0001175A                            	; $14, $30, $51, $62,	$5C, $5C, $5C, $5C
0001175A                            	; $00, $00, $00, $00,	$04, $1B, $04, $04
0001175A                            	; $FA, $F8, $F8, $FA,	$08, $08, $08, $08
0001175A                            	spAlgorithm	$07
0001175A =0000004D                M spatnum	=	spatnum+1
0001175A =00000007                M spal	=	val
0001175A                            	spFeedback	$04
0001175A =00000004                M spfe	=	val
0001175A                            	spDetune	$01, $05, $03, $06
0001175A =00000001                M spde1	=	op1
0001175A =00000005                M spde2	=	op2
0001175A =00000003                M spde3	=	op3
0001175A =00000006                M spde4	=	op4
0001175A                            	spMultiple	$04, $01, $00, $02
0001175A =00000004                M spmu1	=	op1
0001175A =00000001                M spmu2	=	op2
0001175A =00000000                M spmu3	=	op3
0001175A =00000002                M spmu4	=	op4
0001175A                            	spRateScale	$01, $01, $01, $01
0001175A =00000001                M sprs1	=	op1
0001175A =00000001                M sprs2	=	op2
0001175A =00000001                M sprs3	=	op3
0001175A =00000001                M sprs4	=	op4
0001175A                            	spAttackRt	$1C, $1C, $1C, $1C
0001175A =0000001C                M spar1	=	op1
0001175A =0000001C                M spar2	=	op2
0001175A =0000001C                M spar3	=	op3
0001175A =0000001C                M spar4	=	op4
0001175A                            	spAmpMod	$00, $00, $00, $00
0001175A =00000000                M spam1	=	op1
0001175A =00000000                M spam2	=	op2
0001175A =00000000                M spam3	=	op3
0001175A =00000000                M spam4	=	op4
0001175A                            	spSustainRt	$00, $00, $00, $00
0001175A =00000000                M spsr1	=	op1
0001175A =00000000                M spsr2	=	op2
0001175A =00000000                M spsr3	=	op3
0001175A =00000000                M spsr4	=	op4
0001175A                            	spDecayRt	$04, $04, $1B, $04
0001175A =00000004                M spdr1	=	op1
0001175A =00000004                M spdr2	=	op2
0001175A =0000001B                M spdr3	=	op3
0001175A =00000004                M spdr4	=	op4
0001175A                            	spSustainLv	$0F, $0F, $0F, $0F
0001175A =0000000F                M spsl1	=	op1
0001175A =0000000F                M spsl2	=	op2
0001175A =0000000F                M spsl3	=	op3
0001175A =0000000F                M spsl4	=	op4
0001175A                            	spReleaseRt	$0A, $08, $08, $0A
0001175A =0000000A                M sprr1	=	op1
0001175A =00000008                M sprr2	=	op2
0001175A =00000008                M sprr3	=	op3
0001175A =0000000A                M sprr4	=	op4
0001175A                            	spSSGEG		$00, $00, $00, $00
0001175A =00000000                M spss1	=	op1
0001175A =00000000                M spss2	=	op2
0001175A =00000000                M spss3	=	op3
0001175A =00000000                M spss4	=	op4
0001175A                            	spTotalLv	$08, $08, $08, $08
0001175A =00000008                M sptl1	=	op1
0001175A =00000008                M sptl2	=	op2
0001175A =00000008                M sptl3	=	op3
0001175A =00000008                M sptl4	=	op4
0001175A 27                       M 	dc.b	(spfe<<3)+spal
0001175B =00000080                M sptlmask4	set	$80
0001175B =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
0001175B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
0001175B =FFFFFF80                M sptlmask1	set	((spal=7)<<7)
0001175B 1430 5162                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001175F 5C5C 5C5C                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011763 0000 0000                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011767 041B 0404                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001176B FAF8 F8FA                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001176F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011773 8888 8888                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011777 4E41 54                  M 	dc.b	'NAT'
0001177A                            
0001177A                            	; Patch $4D
0001177A                            	; $26
0001177A                            	; $01, $02, $01, $00,	$11, $19, $10, $17
0001177A                            	; $01, $01, $03, $01,	$07, $04, $03, $03
0001177A                            	; $05, $45, $3A, $0A,	$0A, $02, $0E, $00
0001177A                            	spAlgorithm	$06
0001177A =0000004E                M spatnum	=	spatnum+1
0001177A =00000006                M spal	=	val
0001177A                            	spFeedback	$04
0001177A =00000004                M spfe	=	val
0001177A                            	spDetune	$00, $00, $00, $00
0001177A =00000000                M spde1	=	op1
0001177A =00000000                M spde2	=	op2
0001177A =00000000                M spde3	=	op3
0001177A =00000000                M spde4	=	op4
0001177A                            	spMultiple	$01, $01, $02, $00
0001177A =00000001                M spmu1	=	op1
0001177A =00000001                M spmu2	=	op2
0001177A =00000002                M spmu3	=	op3
0001177A =00000000                M spmu4	=	op4
0001177A                            	spRateScale	$00, $00, $00, $00
0001177A =00000000                M sprs1	=	op1
0001177A =00000000                M sprs2	=	op2
0001177A =00000000                M sprs3	=	op3
0001177A =00000000                M sprs4	=	op4
0001177A                            	spAttackRt	$11, $10, $19, $17
0001177A =00000011                M spar1	=	op1
0001177A =00000010                M spar2	=	op2
0001177A =00000019                M spar3	=	op3
0001177A =00000017                M spar4	=	op4
0001177A                            	spAmpMod	$00, $00, $00, $00
0001177A =00000000                M spam1	=	op1
0001177A =00000000                M spam2	=	op2
0001177A =00000000                M spam3	=	op3
0001177A =00000000                M spam4	=	op4
0001177A                            	spSustainRt	$01, $03, $01, $01
0001177A =00000001                M spsr1	=	op1
0001177A =00000003                M spsr2	=	op2
0001177A =00000001                M spsr3	=	op3
0001177A =00000001                M spsr4	=	op4
0001177A                            	spDecayRt	$07, $03, $04, $03
0001177A =00000007                M spdr1	=	op1
0001177A =00000003                M spdr2	=	op2
0001177A =00000004                M spdr3	=	op3
0001177A =00000003                M spdr4	=	op4
0001177A                            	spSustainLv	$00, $03, $04, $00
0001177A =00000000                M spsl1	=	op1
0001177A =00000003                M spsl2	=	op2
0001177A =00000004                M spsl3	=	op3
0001177A =00000000                M spsl4	=	op4
0001177A                            	spReleaseRt	$05, $0A, $05, $0A
0001177A =00000005                M sprr1	=	op1
0001177A =0000000A                M sprr2	=	op2
0001177A =00000005                M sprr3	=	op3
0001177A =0000000A                M sprr4	=	op4
0001177A                            	spSSGEG		$00, $00, $00, $00
0001177A =00000000                M spss1	=	op1
0001177A =00000000                M spss2	=	op2
0001177A =00000000                M spss3	=	op3
0001177A =00000000                M spss4	=	op4
0001177A                            	spTotalLv	$0A, $0E, $02, $00
0001177A =0000000A                M sptl1	=	op1
0001177A =0000000E                M sptl2	=	op2
0001177A =00000002                M sptl3	=	op3
0001177A =00000000                M sptl4	=	op4
0001177A 26                       M 	dc.b	(spfe<<3)+spal
0001177B =00000080                M sptlmask4	set	$80
0001177B =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
0001177B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
0001177B =00000000                M sptlmask1	set	((spal=7)<<7)
0001177B 0102 0100                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001177F 1119 1017                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011783 0101 0301                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011787 0704 0303                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001178B 0545 3A0A                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001178F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011793 0A82 8E80                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011797 4E41 54                  M 	dc.b	'NAT'
0001179A                            
0001179A                            	; Patch $4E
0001179A                            	; $32
0001179A                            	; $30, $51, $72, $72,	$13, $18, $1F, $1F
0001179A                            	; $18, $1E, $1A, $05,	$05, $04, $02, $04
0001179A                            	; $25, $D5, $35, $25,	$15, $04, $1C, $00
0001179A                            	spAlgorithm	$02
0001179A =0000004F                M spatnum	=	spatnum+1
0001179A =00000002                M spal	=	val
0001179A                            	spFeedback	$06
0001179A =00000006                M spfe	=	val
0001179A                            	spDetune	$03, $07, $05, $07
0001179A =00000003                M spde1	=	op1
0001179A =00000007                M spde2	=	op2
0001179A =00000005                M spde3	=	op3
0001179A =00000007                M spde4	=	op4
0001179A                            	spMultiple	$00, $02, $01, $02
0001179A =00000000                M spmu1	=	op1
0001179A =00000002                M spmu2	=	op2
0001179A =00000001                M spmu3	=	op3
0001179A =00000002                M spmu4	=	op4
0001179A                            	spRateScale	$00, $00, $00, $00
0001179A =00000000                M sprs1	=	op1
0001179A =00000000                M sprs2	=	op2
0001179A =00000000                M sprs3	=	op3
0001179A =00000000                M sprs4	=	op4
0001179A                            	spAttackRt	$13, $1F, $18, $1F
0001179A =00000013                M spar1	=	op1
0001179A =0000001F                M spar2	=	op2
0001179A =00000018                M spar3	=	op3
0001179A =0000001F                M spar4	=	op4
0001179A                            	spAmpMod	$00, $00, $00, $00
0001179A =00000000                M spam1	=	op1
0001179A =00000000                M spam2	=	op2
0001179A =00000000                M spam3	=	op3
0001179A =00000000                M spam4	=	op4
0001179A                            	spSustainRt	$18, $1A, $1E, $05
0001179A =00000018                M spsr1	=	op1
0001179A =0000001A                M spsr2	=	op2
0001179A =0000001E                M spsr3	=	op3
0001179A =00000005                M spsr4	=	op4
0001179A                            	spDecayRt	$05, $02, $04, $04
0001179A =00000005                M spdr1	=	op1
0001179A =00000002                M spdr2	=	op2
0001179A =00000004                M spdr3	=	op3
0001179A =00000004                M spdr4	=	op4
0001179A                            	spSustainLv	$02, $03, $0D, $02
0001179A =00000002                M spsl1	=	op1
0001179A =00000003                M spsl2	=	op2
0001179A =0000000D                M spsl3	=	op3
0001179A =00000002                M spsl4	=	op4
0001179A                            	spReleaseRt	$05, $05, $05, $05
0001179A =00000005                M sprr1	=	op1
0001179A =00000005                M sprr2	=	op2
0001179A =00000005                M sprr3	=	op3
0001179A =00000005                M sprr4	=	op4
0001179A                            	spSSGEG		$00, $00, $00, $00
0001179A =00000000                M spss1	=	op1
0001179A =00000000                M spss2	=	op2
0001179A =00000000                M spss3	=	op3
0001179A =00000000                M spss4	=	op4
0001179A                            	spTotalLv	$15, $1C, $04, $00
0001179A =00000015                M sptl1	=	op1
0001179A =0000001C                M sptl2	=	op2
0001179A =00000004                M sptl3	=	op3
0001179A =00000000                M sptl4	=	op4
0001179A 32                       M 	dc.b	(spfe<<3)+spal
0001179B =00000080                M sptlmask4	set	$80
0001179B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001179B =00000000                M sptlmask3	set	((spal>=4)<<7)
0001179B =00000000                M sptlmask1	set	((spal=7)<<7)
0001179B 3051 7272                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001179F 1318 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000117A3 181E 1A05                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000117A7 0504 0204                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000117AB 25D5 3525                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000117AF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000117B3 1504 1C80                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000117B7 4E41 54                  M 	dc.b	'NAT'
000117BA                            
000117BA                            	; Patch $4F
000117BA                            	; $3E
000117BA                            	; $38, $01, $7A, $34,	$59, $D9, $5F, $9C
000117BA                            	; $0F, $04, $0F, $0A,	$02, $02, $05, $05
000117BA                            	; $AF, $AF, $66, $66,	$28, $00, $23, $00
000117BA                            	spAlgorithm	$06
000117BA =00000050                M spatnum	=	spatnum+1
000117BA =00000006                M spal	=	val
000117BA                            	spFeedback	$07
000117BA =00000007                M spfe	=	val
000117BA                            	spDetune	$03, $07, $00, $03
000117BA =00000003                M spde1	=	op1
000117BA =00000007                M spde2	=	op2
000117BA =00000000                M spde3	=	op3
000117BA =00000003                M spde4	=	op4
000117BA                            	spMultiple	$08, $0A, $01, $04
000117BA =00000008                M spmu1	=	op1
000117BA =0000000A                M spmu2	=	op2
000117BA =00000001                M spmu3	=	op3
000117BA =00000004                M spmu4	=	op4
000117BA                            	spRateScale	$01, $01, $03, $02
000117BA =00000001                M sprs1	=	op1
000117BA =00000001                M sprs2	=	op2
000117BA =00000003                M sprs3	=	op3
000117BA =00000002                M sprs4	=	op4
000117BA                            	spAttackRt	$19, $1F, $19, $1C
000117BA =00000019                M spar1	=	op1
000117BA =0000001F                M spar2	=	op2
000117BA =00000019                M spar3	=	op3
000117BA =0000001C                M spar4	=	op4
000117BA                            	spAmpMod	$00, $00, $00, $00
000117BA =00000000                M spam1	=	op1
000117BA =00000000                M spam2	=	op2
000117BA =00000000                M spam3	=	op3
000117BA =00000000                M spam4	=	op4
000117BA                            	spSustainRt	$0F, $0F, $04, $0A
000117BA =0000000F                M spsr1	=	op1
000117BA =0000000F                M spsr2	=	op2
000117BA =00000004                M spsr3	=	op3
000117BA =0000000A                M spsr4	=	op4
000117BA                            	spDecayRt	$02, $05, $02, $05
000117BA =00000002                M spdr1	=	op1
000117BA =00000005                M spdr2	=	op2
000117BA =00000002                M spdr3	=	op3
000117BA =00000005                M spdr4	=	op4
000117BA                            	spSustainLv	$0A, $06, $0A, $06
000117BA =0000000A                M spsl1	=	op1
000117BA =00000006                M spsl2	=	op2
000117BA =0000000A                M spsl3	=	op3
000117BA =00000006                M spsl4	=	op4
000117BA                            	spReleaseRt	$0F, $06, $0F, $06
000117BA =0000000F                M sprr1	=	op1
000117BA =00000006                M sprr2	=	op2
000117BA =0000000F                M sprr3	=	op3
000117BA =00000006                M sprr4	=	op4
000117BA                            	spSSGEG		$00, $00, $00, $00
000117BA =00000000                M spss1	=	op1
000117BA =00000000                M spss2	=	op2
000117BA =00000000                M spss3	=	op3
000117BA =00000000                M spss4	=	op4
000117BA                            	spTotalLv	$28, $23, $00, $00
000117BA =00000028                M sptl1	=	op1
000117BA =00000023                M sptl2	=	op2
000117BA =00000000                M sptl3	=	op3
000117BA =00000000                M sptl4	=	op4
000117BA 3E                       M 	dc.b	(spfe<<3)+spal
000117BB =00000080                M sptlmask4	set	$80
000117BB =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
000117BB =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
000117BB =00000000                M sptlmask1	set	((spal=7)<<7)
000117BB 3801 7A34                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000117BF 59D9 5F9C                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000117C3 0F04 0F0A                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000117C7 0202 0505                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000117CB AFAF 6666                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000117CF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000117D3 2880 A380                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000117D7 4E41 54                  M 	dc.b	'NAT'
000117DA                            
000117DA                            	; Patch $50
000117DA                            	; $3A
000117DA                            	; $31, $37, $72, $02,	$0F, $0B, $0B, $8B
000117DA                            	; $04, $10, $09, $0A,	$00, $00, $03, $00
000117DA                            	; $19, $08, $08, $18,	$1E, $21, $37, $00
000117DA                            	spAlgorithm	$02
000117DA =00000051                M spatnum	=	spatnum+1
000117DA =00000002                M spal	=	val
000117DA                            	spFeedback	$07
000117DA =00000007                M spfe	=	val
000117DA                            	spDetune	$03, $07, $03, $00
000117DA =00000003                M spde1	=	op1
000117DA =00000007                M spde2	=	op2
000117DA =00000003                M spde3	=	op3
000117DA =00000000                M spde4	=	op4
000117DA                            	spMultiple	$01, $02, $07, $02
000117DA =00000001                M spmu1	=	op1
000117DA =00000002                M spmu2	=	op2
000117DA =00000007                M spmu3	=	op3
000117DA =00000002                M spmu4	=	op4
000117DA                            	spRateScale	$00, $00, $00, $02
000117DA =00000000                M sprs1	=	op1
000117DA =00000000                M sprs2	=	op2
000117DA =00000000                M sprs3	=	op3
000117DA =00000002                M sprs4	=	op4
000117DA                            	spAttackRt	$0F, $0B, $0B, $0B
000117DA =0000000F                M spar1	=	op1
000117DA =0000000B                M spar2	=	op2
000117DA =0000000B                M spar3	=	op3
000117DA =0000000B                M spar4	=	op4
000117DA                            	spAmpMod	$00, $00, $00, $00
000117DA =00000000                M spam1	=	op1
000117DA =00000000                M spam2	=	op2
000117DA =00000000                M spam3	=	op3
000117DA =00000000                M spam4	=	op4
000117DA                            	spSustainRt	$04, $09, $10, $0A
000117DA =00000004                M spsr1	=	op1
000117DA =00000009                M spsr2	=	op2
000117DA =00000010                M spsr3	=	op3
000117DA =0000000A                M spsr4	=	op4
000117DA                            	spDecayRt	$00, $03, $00, $00
000117DA =00000000                M spdr1	=	op1
000117DA =00000003                M spdr2	=	op2
000117DA =00000000                M spdr3	=	op3
000117DA =00000000                M spdr4	=	op4
000117DA                            	spSustainLv	$01, $00, $00, $01
000117DA =00000001                M spsl1	=	op1
000117DA =00000000                M spsl2	=	op2
000117DA =00000000                M spsl3	=	op3
000117DA =00000001                M spsl4	=	op4
000117DA                            	spReleaseRt	$09, $08, $08, $08
000117DA =00000009                M sprr1	=	op1
000117DA =00000008                M sprr2	=	op2
000117DA =00000008                M sprr3	=	op3
000117DA =00000008                M sprr4	=	op4
000117DA                            	spSSGEG		$00, $00, $00, $00
000117DA =00000000                M spss1	=	op1
000117DA =00000000                M spss2	=	op2
000117DA =00000000                M spss3	=	op3
000117DA =00000000                M spss4	=	op4
000117DA                            	spTotalLv	$1E, $37, $21, $00
000117DA =0000001E                M sptl1	=	op1
000117DA =00000037                M sptl2	=	op2
000117DA =00000021                M sptl3	=	op3
000117DA =00000000                M sptl4	=	op4
000117DA 3A                       M 	dc.b	(spfe<<3)+spal
000117DB =00000080                M sptlmask4	set	$80
000117DB =00000000                M sptlmask2	set	((spal>=5)<<7)
000117DB =00000000                M sptlmask3	set	((spal>=4)<<7)
000117DB =00000000                M sptlmask1	set	((spal=7)<<7)
000117DB 3137 7202                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000117DF 0F0B 0B8B                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000117E3 0410 090A                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000117E7 0000 0300                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000117EB 1908 0818                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000117EF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000117F3 1E21 3780                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000117F7 4E41 54                  M 	dc.b	'NAT'
000117FA                            
000117FA                            	; Patch $51
000117FA                            	; $3D
000117FA                            	; $0A, $06, $06, $06,	$1F, $0C, $0C, $0C
000117FA                            	; $00, $09, $09, $01,	$01, $02, $05, $01
000117FA                            	; $F6, $F8, $F7, $F7,	$00, $00, $00, $00
000117FA                            	spAlgorithm	$05
000117FA =00000052                M spatnum	=	spatnum+1
000117FA =00000005                M spal	=	val
000117FA                            	spFeedback	$07
000117FA =00000007                M spfe	=	val
000117FA                            	spDetune	$00, $00, $00, $00
000117FA =00000000                M spde1	=	op1
000117FA =00000000                M spde2	=	op2
000117FA =00000000                M spde3	=	op3
000117FA =00000000                M spde4	=	op4
000117FA                            	spMultiple	$0A, $06, $06, $06
000117FA =0000000A                M spmu1	=	op1
000117FA =00000006                M spmu2	=	op2
000117FA =00000006                M spmu3	=	op3
000117FA =00000006                M spmu4	=	op4
000117FA                            	spRateScale	$00, $00, $00, $00
000117FA =00000000                M sprs1	=	op1
000117FA =00000000                M sprs2	=	op2
000117FA =00000000                M sprs3	=	op3
000117FA =00000000                M sprs4	=	op4
000117FA                            	spAttackRt	$1F, $0C, $0C, $0C
000117FA =0000001F                M spar1	=	op1
000117FA =0000000C                M spar2	=	op2
000117FA =0000000C                M spar3	=	op3
000117FA =0000000C                M spar4	=	op4
000117FA                            	spAmpMod	$00, $00, $00, $00
000117FA =00000000                M spam1	=	op1
000117FA =00000000                M spam2	=	op2
000117FA =00000000                M spam3	=	op3
000117FA =00000000                M spam4	=	op4
000117FA                            	spSustainRt	$00, $09, $09, $01
000117FA =00000000                M spsr1	=	op1
000117FA =00000009                M spsr2	=	op2
000117FA =00000009                M spsr3	=	op3
000117FA =00000001                M spsr4	=	op4
000117FA                            	spSustainLv	$0F, $0F, $0F, $0F
000117FA =0000000F                M spsl1	=	op1
000117FA =0000000F                M spsl2	=	op2
000117FA =0000000F                M spsl3	=	op3
000117FA =0000000F                M spsl4	=	op4
000117FA                            	spDecayRt	$01, $05, $02, $01
000117FA =00000001                M spdr1	=	op1
000117FA =00000005                M spdr2	=	op2
000117FA =00000002                M spdr3	=	op3
000117FA =00000001                M spdr4	=	op4
000117FA                            	spReleaseRt	$06, $07, $08, $07
000117FA =00000006                M sprr1	=	op1
000117FA =00000007                M sprr2	=	op2
000117FA =00000008                M sprr3	=	op3
000117FA =00000007                M sprr4	=	op4
000117FA                            	spSSGEG		$00, $00, $00, $00
000117FA =00000000                M spss1	=	op1
000117FA =00000000                M spss2	=	op2
000117FA =00000000                M spss3	=	op3
000117FA =00000000                M spss4	=	op4
000117FA                            	spTotalLv	$00, $00, $00, $00
000117FA =00000000                M sptl1	=	op1
000117FA =00000000                M sptl2	=	op2
000117FA =00000000                M sptl3	=	op3
000117FA =00000000                M sptl4	=	op4
000117FA 3D                       M 	dc.b	(spfe<<3)+spal
000117FB =00000080                M sptlmask4	set	$80
000117FB =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
000117FB =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
000117FB =00000000                M sptlmask1	set	((spal=7)<<7)
000117FB 0A06 0606                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000117FF 1F0C 0C0C                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011803 0009 0901                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011807 0102 0501                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001180B F6F8 F7F7                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001180F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011813 0080 8080                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011817 4E41 54                  M 	dc.b	'NAT'
0001181A                            
0001181A                            	; Patch $52
0001181A                            	; $3C
0001181A                            	; $31, $73, $71, $31,	$10, $8C, $0A, $13
0001181A                            	; $00, $00, $00, $00,	$00, $0C, $00, $03
0001181A                            	; $0F, $0F, $0F, $0F,	$20, $00, $20, $00
0001181A                            	spAlgorithm	$04
0001181A =00000053                M spatnum	=	spatnum+1
0001181A =00000004                M spal	=	val
0001181A                            	spFeedback	$07
0001181A =00000007                M spfe	=	val
0001181A                            	spDetune	$03, $07, $07, $03
0001181A =00000003                M spde1	=	op1
0001181A =00000007                M spde2	=	op2
0001181A =00000007                M spde3	=	op3
0001181A =00000003                M spde4	=	op4
0001181A                            	spMultiple	$01, $01, $03, $01
0001181A =00000001                M spmu1	=	op1
0001181A =00000001                M spmu2	=	op2
0001181A =00000003                M spmu3	=	op3
0001181A =00000001                M spmu4	=	op4
0001181A                            	spRateScale	$00, $00, $02, $00
0001181A =00000000                M sprs1	=	op1
0001181A =00000000                M sprs2	=	op2
0001181A =00000002                M sprs3	=	op3
0001181A =00000000                M sprs4	=	op4
0001181A                            	spAttackRt	$10, $0A, $0C, $13
0001181A =00000010                M spar1	=	op1
0001181A =0000000A                M spar2	=	op2
0001181A =0000000C                M spar3	=	op3
0001181A =00000013                M spar4	=	op4
0001181A                            	spAmpMod	$00, $00, $00, $00
0001181A =00000000                M spam1	=	op1
0001181A =00000000                M spam2	=	op2
0001181A =00000000                M spam3	=	op3
0001181A =00000000                M spam4	=	op4
0001181A                            	spSustainRt	$00, $00, $00, $00
0001181A =00000000                M spsr1	=	op1
0001181A =00000000                M spsr2	=	op2
0001181A =00000000                M spsr3	=	op3
0001181A =00000000                M spsr4	=	op4
0001181A                            	spSustainLv	$00, $00, $00, $00
0001181A =00000000                M spsl1	=	op1
0001181A =00000000                M spsl2	=	op2
0001181A =00000000                M spsl3	=	op3
0001181A =00000000                M spsl4	=	op4
0001181A                            	spDecayRt	$00, $00, $0C, $03
0001181A =00000000                M spdr1	=	op1
0001181A =00000000                M spdr2	=	op2
0001181A =0000000C                M spdr3	=	op3
0001181A =00000003                M spdr4	=	op4
0001181A                            	spReleaseRt	$0F, $0F, $0F, $0F
0001181A =0000000F                M sprr1	=	op1
0001181A =0000000F                M sprr2	=	op2
0001181A =0000000F                M sprr3	=	op3
0001181A =0000000F                M sprr4	=	op4
0001181A                            	spSSGEG		$00, $00, $00, $00
0001181A =00000000                M spss1	=	op1
0001181A =00000000                M spss2	=	op2
0001181A =00000000                M spss3	=	op3
0001181A =00000000                M spss4	=	op4
0001181A                            	spTotalLv	$20, $20, $00, $00
0001181A =00000020                M sptl1	=	op1
0001181A =00000020                M sptl2	=	op2
0001181A =00000000                M sptl3	=	op3
0001181A =00000000                M sptl4	=	op4
0001181A 3C                       M 	dc.b	(spfe<<3)+spal
0001181B =00000080                M sptlmask4	set	$80
0001181B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001181B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
0001181B =00000000                M sptlmask1	set	((spal=7)<<7)
0001181B 3173 7131                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001181F 108C 0A13                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011823 0000 0000                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011827 000C 0003                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001182B 0F0F 0F0F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001182F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011833 2080 2080                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011837 4E41 54                  M 	dc.b	'NAT'
0001183A                            
0001183A                            	; Patch $53
0001183A                            	; $3C
0001183A                            	; $33, $41, $7F, $74,	$5B, $9F, $5F, $1F
0001183A                            	; $04, $07, $07, $08,	$00, $00, $00, $00
0001183A                            	; $A7, $C6, $C9, $D9,	$21, $00, $2D, $06
0001183A                            	spAlgorithm	$04
0001183A =00000054                M spatnum	=	spatnum+1
0001183A =00000004                M spal	=	val
0001183A                            	spFeedback	$07
0001183A =00000007                M spfe	=	val
0001183A                            	spDetune	$03, $07, $04, $07
0001183A =00000003                M spde1	=	op1
0001183A =00000007                M spde2	=	op2
0001183A =00000004                M spde3	=	op3
0001183A =00000007                M spde4	=	op4
0001183A                            	spMultiple	$03, $0F, $01, $04
0001183A =00000003                M spmu1	=	op1
0001183A =0000000F                M spmu2	=	op2
0001183A =00000001                M spmu3	=	op3
0001183A =00000004                M spmu4	=	op4
0001183A                            	spRateScale	$01, $01, $02, $00
0001183A =00000001                M sprs1	=	op1
0001183A =00000001                M sprs2	=	op2
0001183A =00000002                M sprs3	=	op3
0001183A =00000000                M sprs4	=	op4
0001183A                            	spAttackRt	$1B, $1F, $1F, $1F
0001183A =0000001B                M spar1	=	op1
0001183A =0000001F                M spar2	=	op2
0001183A =0000001F                M spar3	=	op3
0001183A =0000001F                M spar4	=	op4
0001183A                            	spAmpMod	$00, $00, $00, $00
0001183A =00000000                M spam1	=	op1
0001183A =00000000                M spam2	=	op2
0001183A =00000000                M spam3	=	op3
0001183A =00000000                M spam4	=	op4
0001183A                            	spSustainRt	$04, $07, $07, $08
0001183A =00000004                M spsr1	=	op1
0001183A =00000007                M spsr2	=	op2
0001183A =00000007                M spsr3	=	op3
0001183A =00000008                M spsr4	=	op4
0001183A                            	spSustainLv	$0A, $0C, $0C, $0D
0001183A =0000000A                M spsl1	=	op1
0001183A =0000000C                M spsl2	=	op2
0001183A =0000000C                M spsl3	=	op3
0001183A =0000000D                M spsl4	=	op4
0001183A                            	spDecayRt	$00, $00, $00, $00
0001183A =00000000                M spdr1	=	op1
0001183A =00000000                M spdr2	=	op2
0001183A =00000000                M spdr3	=	op3
0001183A =00000000                M spdr4	=	op4
0001183A                            	spReleaseRt	$07, $09, $06, $09
0001183A =00000007                M sprr1	=	op1
0001183A =00000009                M sprr2	=	op2
0001183A =00000006                M sprr3	=	op3
0001183A =00000009                M sprr4	=	op4
0001183A                            	spSSGEG		$00, $00, $00, $00
0001183A =00000000                M spss1	=	op1
0001183A =00000000                M spss2	=	op2
0001183A =00000000                M spss3	=	op3
0001183A =00000000                M spss4	=	op4
0001183A                            	spTotalLv	$21, $2D, $00, $06
0001183A =00000021                M sptl1	=	op1
0001183A =0000002D                M sptl2	=	op2
0001183A =00000000                M sptl3	=	op3
0001183A =00000006                M sptl4	=	op4
0001183A 3C                       M 	dc.b	(spfe<<3)+spal
0001183B =00000080                M sptlmask4	set	$80
0001183B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001183B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
0001183B =00000000                M sptlmask1	set	((spal=7)<<7)
0001183B 3341 7F74                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001183F 5B9F 5F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011843 0407 0708                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011847 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001184B A7C6 C9D9                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001184F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011853 2180 2D86                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011857 4E41 54                  M 	dc.b	'NAT'
0001185A                            
0001185A                            	; Patch $54
0001185A                            	; $22
0001185A                            	; $61, $77, $02, $31,	$14, $D0, $8F, $54
0001185A                            	; $01, $05, $05, $08,	$02, $02, $05, $1F
0001185A                            	; $01, $11, $31, $88,	$19, $28, $20, $00
0001185A                            	spAlgorithm	$02
0001185A =00000055                M spatnum	=	spatnum+1
0001185A =00000002                M spal	=	val
0001185A                            	spFeedback	$04
0001185A =00000004                M spfe	=	val
0001185A                            	spDetune	$06, $00, $07, $03
0001185A =00000006                M spde1	=	op1
0001185A =00000000                M spde2	=	op2
0001185A =00000007                M spde3	=	op3
0001185A =00000003                M spde4	=	op4
0001185A                            	spMultiple	$01, $02, $07, $01
0001185A =00000001                M spmu1	=	op1
0001185A =00000002                M spmu2	=	op2
0001185A =00000007                M spmu3	=	op3
0001185A =00000001                M spmu4	=	op4
0001185A                            	spRateScale	$00, $02, $03, $01
0001185A =00000000                M sprs1	=	op1
0001185A =00000002                M sprs2	=	op2
0001185A =00000003                M sprs3	=	op3
0001185A =00000001                M sprs4	=	op4
0001185A                            	spAttackRt	$14, $0F, $10, $14
0001185A =00000014                M spar1	=	op1
0001185A =0000000F                M spar2	=	op2
0001185A =00000010                M spar3	=	op3
0001185A =00000014                M spar4	=	op4
0001185A                            	spAmpMod	$00, $00, $00, $00
0001185A =00000000                M spam1	=	op1
0001185A =00000000                M spam2	=	op2
0001185A =00000000                M spam3	=	op3
0001185A =00000000                M spam4	=	op4
0001185A                            	spSustainRt	$01, $05, $05, $08
0001185A =00000001                M spsr1	=	op1
0001185A =00000005                M spsr2	=	op2
0001185A =00000005                M spsr3	=	op3
0001185A =00000008                M spsr4	=	op4
0001185A                            	spSustainLv	$00, $03, $01, $08
0001185A =00000000                M spsl1	=	op1
0001185A =00000003                M spsl2	=	op2
0001185A =00000001                M spsl3	=	op3
0001185A =00000008                M spsl4	=	op4
0001185A                            	spDecayRt	$02, $05, $02, $1F
0001185A =00000002                M spdr1	=	op1
0001185A =00000005                M spdr2	=	op2
0001185A =00000002                M spdr3	=	op3
0001185A =0000001F                M spdr4	=	op4
0001185A                            	spReleaseRt	$01, $01, $01, $08
0001185A =00000001                M sprr1	=	op1
0001185A =00000001                M sprr2	=	op2
0001185A =00000001                M sprr3	=	op3
0001185A =00000008                M sprr4	=	op4
0001185A                            	spSSGEG		$00, $00, $00, $00
0001185A =00000000                M spss1	=	op1
0001185A =00000000                M spss2	=	op2
0001185A =00000000                M spss3	=	op3
0001185A =00000000                M spss4	=	op4
0001185A                            	spTotalLv	$19, $20, $28, $00
0001185A =00000019                M sptl1	=	op1
0001185A =00000020                M sptl2	=	op2
0001185A =00000028                M sptl3	=	op3
0001185A =00000000                M sptl4	=	op4
0001185A 22                       M 	dc.b	(spfe<<3)+spal
0001185B =00000080                M sptlmask4	set	$80
0001185B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001185B =00000000                M sptlmask3	set	((spal>=4)<<7)
0001185B =00000000                M sptlmask1	set	((spal=7)<<7)
0001185B 6177 0231                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001185F 14D0 8F54                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011863 0105 0508                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011867 0202 051F                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001186B 0111 3188                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001186F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011873 1928 2080                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011877 4E41 54                  M 	dc.b	'NAT'
0001187A                            
0001187A                            	; Patch $55
0001187A                            	; $22
0001187A                            	; $61, $7C, $04, $31,	$14, $D0, $8F, $54
0001187A                            	; $01, $05, $05, $08,	$02, $02, $05, $1F
0001187A                            	; $01, $11, $31, $88,	$19, $28, $24, $00
0001187A                            	spAlgorithm	$02
0001187A =00000056                M spatnum	=	spatnum+1
0001187A =00000002                M spal	=	val
0001187A                            	spFeedback	$04
0001187A =00000004                M spfe	=	val
0001187A                            	spDetune	$06, $00, $07, $03
0001187A =00000006                M spde1	=	op1
0001187A =00000000                M spde2	=	op2
0001187A =00000007                M spde3	=	op3
0001187A =00000003                M spde4	=	op4
0001187A                            	spMultiple	$01, $04, $0C, $01
0001187A =00000001                M spmu1	=	op1
0001187A =00000004                M spmu2	=	op2
0001187A =0000000C                M spmu3	=	op3
0001187A =00000001                M spmu4	=	op4
0001187A                            	spRateScale	$00, $02, $03, $01
0001187A =00000000                M sprs1	=	op1
0001187A =00000002                M sprs2	=	op2
0001187A =00000003                M sprs3	=	op3
0001187A =00000001                M sprs4	=	op4
0001187A                            	spAttackRt	$14, $0F, $10, $14
0001187A =00000014                M spar1	=	op1
0001187A =0000000F                M spar2	=	op2
0001187A =00000010                M spar3	=	op3
0001187A =00000014                M spar4	=	op4
0001187A                            	spAmpMod	$00, $00, $00, $00
0001187A =00000000                M spam1	=	op1
0001187A =00000000                M spam2	=	op2
0001187A =00000000                M spam3	=	op3
0001187A =00000000                M spam4	=	op4
0001187A                            	spSustainRt	$01, $05, $05, $08
0001187A =00000001                M spsr1	=	op1
0001187A =00000005                M spsr2	=	op2
0001187A =00000005                M spsr3	=	op3
0001187A =00000008                M spsr4	=	op4
0001187A                            	spSustainLv	$00, $03, $01, $08
0001187A =00000000                M spsl1	=	op1
0001187A =00000003                M spsl2	=	op2
0001187A =00000001                M spsl3	=	op3
0001187A =00000008                M spsl4	=	op4
0001187A                            	spDecayRt	$02, $05, $02, $1F
0001187A =00000002                M spdr1	=	op1
0001187A =00000005                M spdr2	=	op2
0001187A =00000002                M spdr3	=	op3
0001187A =0000001F                M spdr4	=	op4
0001187A                            	spReleaseRt	$01, $01, $01, $08
0001187A =00000001                M sprr1	=	op1
0001187A =00000001                M sprr2	=	op2
0001187A =00000001                M sprr3	=	op3
0001187A =00000008                M sprr4	=	op4
0001187A                            	spSSGEG		$00, $00, $00, $00
0001187A =00000000                M spss1	=	op1
0001187A =00000000                M spss2	=	op2
0001187A =00000000                M spss3	=	op3
0001187A =00000000                M spss4	=	op4
0001187A                            	spTotalLv	$19, $24, $28, $00
0001187A =00000019                M sptl1	=	op1
0001187A =00000024                M sptl2	=	op2
0001187A =00000028                M sptl3	=	op3
0001187A =00000000                M sptl4	=	op4
0001187A 22                       M 	dc.b	(spfe<<3)+spal
0001187B =00000080                M sptlmask4	set	$80
0001187B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001187B =00000000                M sptlmask3	set	((spal>=4)<<7)
0001187B =00000000                M sptlmask1	set	((spal=7)<<7)
0001187B 617C 0431                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001187F 14D0 8F54                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011883 0105 0508                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011887 0202 051F                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001188B 0111 3188                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001188F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011893 1928 2480                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011897 4E41 54                  M 	dc.b	'NAT'
0001189A                            
0001189A                            	; Patch $56
0001189A                            	; $20
0001189A                            	; $66, $65, $60, $61,	$DF, $DF, $9F, $9F
0001189A                            	; $07, $06, $09, $06,	$07, $06, $06, $08
0001189A                            	; $29, $19, $19, $F9,	$1C, $3A, $16, $00
0001189A                            	spAlgorithm	$00
0001189A =00000057                M spatnum	=	spatnum+1
0001189A =00000000                M spal	=	val
0001189A                            	spFeedback	$04
0001189A =00000004                M spfe	=	val
0001189A                            	spDetune	$06, $06, $06, $06
0001189A =00000006                M spde1	=	op1
0001189A =00000006                M spde2	=	op2
0001189A =00000006                M spde3	=	op3
0001189A =00000006                M spde4	=	op4
0001189A                            	spMultiple	$06, $00, $05, $01
0001189A =00000006                M spmu1	=	op1
0001189A =00000000                M spmu2	=	op2
0001189A =00000005                M spmu3	=	op3
0001189A =00000001                M spmu4	=	op4
0001189A                            	spRateScale	$03, $02, $03, $02
0001189A =00000003                M sprs1	=	op1
0001189A =00000002                M sprs2	=	op2
0001189A =00000003                M sprs3	=	op3
0001189A =00000002                M sprs4	=	op4
0001189A                            	spAttackRt	$1F, $1F, $1F, $1F
0001189A =0000001F                M spar1	=	op1
0001189A =0000001F                M spar2	=	op2
0001189A =0000001F                M spar3	=	op3
0001189A =0000001F                M spar4	=	op4
0001189A                            	spAmpMod	$00, $00, $00, $00
0001189A =00000000                M spam1	=	op1
0001189A =00000000                M spam2	=	op2
0001189A =00000000                M spam3	=	op3
0001189A =00000000                M spam4	=	op4
0001189A                            	spSustainRt	$07, $09, $06, $06
0001189A =00000007                M spsr1	=	op1
0001189A =00000009                M spsr2	=	op2
0001189A =00000006                M spsr3	=	op3
0001189A =00000006                M spsr4	=	op4
0001189A                            	spDecayRt	$07, $06, $06, $08
0001189A =00000007                M spdr1	=	op1
0001189A =00000006                M spdr2	=	op2
0001189A =00000006                M spdr3	=	op3
0001189A =00000008                M spdr4	=	op4
0001189A                            	spSustainLv	$02, $01, $01, $0F
0001189A =00000002                M spsl1	=	op1
0001189A =00000001                M spsl2	=	op2
0001189A =00000001                M spsl3	=	op3
0001189A =0000000F                M spsl4	=	op4
0001189A                            	spReleaseRt	$09, $09, $09, $09
0001189A =00000009                M sprr1	=	op1
0001189A =00000009                M sprr2	=	op2
0001189A =00000009                M sprr3	=	op3
0001189A =00000009                M sprr4	=	op4
0001189A                            	spSSGEG		$00, $00, $00, $00
0001189A =00000000                M spss1	=	op1
0001189A =00000000                M spss2	=	op2
0001189A =00000000                M spss3	=	op3
0001189A =00000000                M spss4	=	op4
0001189A                            	spTotalLv	$1C, $16, $3A, $00
0001189A =0000001C                M sptl1	=	op1
0001189A =00000016                M sptl2	=	op2
0001189A =0000003A                M sptl3	=	op3
0001189A =00000000                M sptl4	=	op4
0001189A 20                       M 	dc.b	(spfe<<3)+spal
0001189B =00000080                M sptlmask4	set	$80
0001189B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001189B =00000000                M sptlmask3	set	((spal>=4)<<7)
0001189B =00000000                M sptlmask1	set	((spal=7)<<7)
0001189B 6665 6061                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001189F DFDF 9F9F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000118A3 0706 0906                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000118A7 0706 0608                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000118AB 2919 19F9                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000118AF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000118B3 1C3A 1680                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000118B7 4E41 54                  M 	dc.b	'NAT'
000118BA                            
000118BA                            	; Patch $57
000118BA                            	; $3A
000118BA                            	; $31, $01, $01, $71,	$8F, $8F, $4F, $4D
000118BA                            	; $09, $09, $00, $03,	$00, $00, $00, $00
000118BA                            	; $15, $F5, $05, $0A,	$19, $1F, $19, $01
000118BA                            	spAlgorithm	$02
000118BA =00000058                M spatnum	=	spatnum+1
000118BA =00000002                M spal	=	val
000118BA                            	spFeedback	$07
000118BA =00000007                M spfe	=	val
000118BA                            	spDetune	$03, $00, $00, $07
000118BA =00000003                M spde1	=	op1
000118BA =00000000                M spde2	=	op2
000118BA =00000000                M spde3	=	op3
000118BA =00000007                M spde4	=	op4
000118BA                            	spMultiple	$01, $01, $01, $01
000118BA =00000001                M spmu1	=	op1
000118BA =00000001                M spmu2	=	op2
000118BA =00000001                M spmu3	=	op3
000118BA =00000001                M spmu4	=	op4
000118BA                            	spRateScale	$02, $01, $02, $01
000118BA =00000002                M sprs1	=	op1
000118BA =00000001                M sprs2	=	op2
000118BA =00000002                M sprs3	=	op3
000118BA =00000001                M sprs4	=	op4
000118BA                            	spAttackRt	$0F, $0F, $0F, $0D
000118BA =0000000F                M spar1	=	op1
000118BA =0000000F                M spar2	=	op2
000118BA =0000000F                M spar3	=	op3
000118BA =0000000D                M spar4	=	op4
000118BA                            	spAmpMod	$00, $00, $00, $00
000118BA =00000000                M spam1	=	op1
000118BA =00000000                M spam2	=	op2
000118BA =00000000                M spam3	=	op3
000118BA =00000000                M spam4	=	op4
000118BA                            	spSustainRt	$09, $00, $09, $03
000118BA =00000009                M spsr1	=	op1
000118BA =00000000                M spsr2	=	op2
000118BA =00000009                M spsr3	=	op3
000118BA =00000003                M spsr4	=	op4
000118BA                            	spDecayRt	$00, $00, $00, $00
000118BA =00000000                M spdr1	=	op1
000118BA =00000000                M spdr2	=	op2
000118BA =00000000                M spdr3	=	op3
000118BA =00000000                M spdr4	=	op4
000118BA                            	spSustainLv	$01, $00, $0F, $00
000118BA =00000001                M spsl1	=	op1
000118BA =00000000                M spsl2	=	op2
000118BA =0000000F                M spsl3	=	op3
000118BA =00000000                M spsl4	=	op4
000118BA                            	spReleaseRt	$05, $05, $05, $0A
000118BA =00000005                M sprr1	=	op1
000118BA =00000005                M sprr2	=	op2
000118BA =00000005                M sprr3	=	op3
000118BA =0000000A                M sprr4	=	op4
000118BA                            	spSSGEG		$00, $00, $00, $00
000118BA =00000000                M spss1	=	op1
000118BA =00000000                M spss2	=	op2
000118BA =00000000                M spss3	=	op3
000118BA =00000000                M spss4	=	op4
000118BA                            	spTotalLv	$19, $19, $1F, $01
000118BA =00000019                M sptl1	=	op1
000118BA =00000019                M sptl2	=	op2
000118BA =0000001F                M sptl3	=	op3
000118BA =00000001                M sptl4	=	op4
000118BA 3A                       M 	dc.b	(spfe<<3)+spal
000118BB =00000080                M sptlmask4	set	$80
000118BB =00000000                M sptlmask2	set	((spal>=5)<<7)
000118BB =00000000                M sptlmask3	set	((spal>=4)<<7)
000118BB =00000000                M sptlmask1	set	((spal=7)<<7)
000118BB 3101 0171                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000118BF 8F8F 4F4D                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000118C3 0909 0003                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000118C7 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000118CB 15F5 050A                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000118CF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000118D3 191F 1981                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000118D7 4E41 54                  M 	dc.b	'NAT'
000118DA                            
000118DA                            	; Patch $58
000118DA                            	; $3A
000118DA                            	; $01, $07, $01, $01,	$8E, $8E, $8D, $53
000118DA                            	; $0E, $0E, $0E, $03,	$00, $00, $00, $00
000118DA                            	; $1F, $FF, $1F, $0F,	$17, $28, $27, $86
000118DA                            	spAlgorithm	$02
000118DA =00000059                M spatnum	=	spatnum+1
000118DA =00000002                M spal	=	val
000118DA                            	spFeedback	$07
000118DA =00000007                M spfe	=	val
000118DA                            	spDetune	$00, $00, $00, $00
000118DA =00000000                M spde1	=	op1
000118DA =00000000                M spde2	=	op2
000118DA =00000000                M spde3	=	op3
000118DA =00000000                M spde4	=	op4
000118DA                            	spMultiple	$01, $01, $07, $01
000118DA =00000001                M spmu1	=	op1
000118DA =00000001                M spmu2	=	op2
000118DA =00000007                M spmu3	=	op3
000118DA =00000001                M spmu4	=	op4
000118DA                            	spRateScale	$02, $02, $02, $01
000118DA =00000002                M sprs1	=	op1
000118DA =00000002                M sprs2	=	op2
000118DA =00000002                M sprs3	=	op3
000118DA =00000001                M sprs4	=	op4
000118DA                            	spAttackRt	$0E, $0D, $0E, $13
000118DA =0000000E                M spar1	=	op1
000118DA =0000000D                M spar2	=	op2
000118DA =0000000E                M spar3	=	op3
000118DA =00000013                M spar4	=	op4
000118DA                            	spAmpMod	$00, $00, $00, $00
000118DA =00000000                M spam1	=	op1
000118DA =00000000                M spam2	=	op2
000118DA =00000000                M spam3	=	op3
000118DA =00000000                M spam4	=	op4
000118DA                            	spSustainRt	$0E, $0E, $0E, $03
000118DA =0000000E                M spsr1	=	op1
000118DA =0000000E                M spsr2	=	op2
000118DA =0000000E                M spsr3	=	op3
000118DA =00000003                M spsr4	=	op4
000118DA                            	spDecayRt	$00, $00, $00, $00
000118DA =00000000                M spdr1	=	op1
000118DA =00000000                M spdr2	=	op2
000118DA =00000000                M spdr3	=	op3
000118DA =00000000                M spdr4	=	op4
000118DA                            	spSustainLv	$01, $01, $0F, $00
000118DA =00000001                M spsl1	=	op1
000118DA =00000001                M spsl2	=	op2
000118DA =0000000F                M spsl3	=	op3
000118DA =00000000                M spsl4	=	op4
000118DA                            	spReleaseRt	$0F, $0F, $0F, $0F
000118DA =0000000F                M sprr1	=	op1
000118DA =0000000F                M sprr2	=	op2
000118DA =0000000F                M sprr3	=	op3
000118DA =0000000F                M sprr4	=	op4
000118DA                            	spSSGEG		$00, $00, $00, $00
000118DA =00000000                M spss1	=	op1
000118DA =00000000                M spss2	=	op2
000118DA =00000000                M spss3	=	op3
000118DA =00000000                M spss4	=	op4
000118DA                            	spTotalLv	$17, $27, $28, $06
000118DA =00000017                M sptl1	=	op1
000118DA =00000027                M sptl2	=	op2
000118DA =00000028                M sptl3	=	op3
000118DA =00000006                M sptl4	=	op4
000118DA 3A                       M 	dc.b	(spfe<<3)+spal
000118DB =00000080                M sptlmask4	set	$80
000118DB =00000000                M sptlmask2	set	((spal>=5)<<7)
000118DB =00000000                M sptlmask3	set	((spal>=4)<<7)
000118DB =00000000                M sptlmask1	set	((spal=7)<<7)
000118DB 0107 0101                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000118DF 8E8E 8D53                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000118E3 0E0E 0E03                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000118E7 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000118EB 1FFF 1F0F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000118EF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000118F3 1728 2786                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
000118F7 4E41 54                  M 	dc.b	'NAT'
000118FA                            
000118FA                            	; Patch $59
000118FA                            	; $3A
000118FA                            	; $51, $07, $51, $02,	$0F, $0B, $0F, $0F
000118FA                            	; $1F, $1F, $1F, $0F,	$00, $00, $00, $02
000118FA                            	; $0F, $0F, $0F, $1F,	$1C, $28, $22, $81
000118FA                            	spAlgorithm	$02
000118FA =0000005A                M spatnum	=	spatnum+1
000118FA =00000002                M spal	=	val
000118FA                            	spFeedback	$07
000118FA =00000007                M spfe	=	val
000118FA                            	spDetune	$05, $05, $00, $00
000118FA =00000005                M spde1	=	op1
000118FA =00000005                M spde2	=	op2
000118FA =00000000                M spde3	=	op3
000118FA =00000000                M spde4	=	op4
000118FA                            	spMultiple	$01, $01, $07, $02
000118FA =00000001                M spmu1	=	op1
000118FA =00000001                M spmu2	=	op2
000118FA =00000007                M spmu3	=	op3
000118FA =00000002                M spmu4	=	op4
000118FA                            	spRateScale	$00, $00, $00, $00
000118FA =00000000                M sprs1	=	op1
000118FA =00000000                M sprs2	=	op2
000118FA =00000000                M sprs3	=	op3
000118FA =00000000                M sprs4	=	op4
000118FA                            	spAttackRt	$0F, $0F, $0B, $0F
000118FA =0000000F                M spar1	=	op1
000118FA =0000000F                M spar2	=	op2
000118FA =0000000B                M spar3	=	op3
000118FA =0000000F                M spar4	=	op4
000118FA                            	spAmpMod	$00, $00, $00, $00
000118FA =00000000                M spam1	=	op1
000118FA =00000000                M spam2	=	op2
000118FA =00000000                M spam3	=	op3
000118FA =00000000                M spam4	=	op4
000118FA                            	spSustainRt	$1F, $1F, $1F, $0F
000118FA =0000001F                M spsr1	=	op1
000118FA =0000001F                M spsr2	=	op2
000118FA =0000001F                M spsr3	=	op3
000118FA =0000000F                M spsr4	=	op4
000118FA                            	spDecayRt	$00, $00, $00, $02
000118FA =00000000                M spdr1	=	op1
000118FA =00000000                M spdr2	=	op2
000118FA =00000000                M spdr3	=	op3
000118FA =00000002                M spdr4	=	op4
000118FA                            	spSustainLv	$00, $00, $00, $01
000118FA =00000000                M spsl1	=	op1
000118FA =00000000                M spsl2	=	op2
000118FA =00000000                M spsl3	=	op3
000118FA =00000001                M spsl4	=	op4
000118FA                            	spReleaseRt	$0F, $0F, $0F, $0F
000118FA =0000000F                M sprr1	=	op1
000118FA =0000000F                M sprr2	=	op2
000118FA =0000000F                M sprr3	=	op3
000118FA =0000000F                M sprr4	=	op4
000118FA                            	spSSGEG		$00, $00, $00, $00
000118FA =00000000                M spss1	=	op1
000118FA =00000000                M spss2	=	op2
000118FA =00000000                M spss3	=	op3
000118FA =00000000                M spss4	=	op4
000118FA                            	spTotalLv	$1C, $22, $28, $01
000118FA =0000001C                M sptl1	=	op1
000118FA =00000022                M sptl2	=	op2
000118FA =00000028                M sptl3	=	op3
000118FA =00000001                M sptl4	=	op4
000118FA 3A                       M 	dc.b	(spfe<<3)+spal
000118FB =00000080                M sptlmask4	set	$80
000118FB =00000000                M sptlmask2	set	((spal>=5)<<7)
000118FB =00000000                M sptlmask3	set	((spal>=4)<<7)
000118FB =00000000                M sptlmask1	set	((spal=7)<<7)
000118FB 5107 5102                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000118FF 0F0B 0F0F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011903 1F1F 1F0F                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011907 0000 0002                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001190B 0F0F 0F1F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001190F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011913 1C28 2281                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011917 4E41 54                  M 	dc.b	'NAT'
0001191A                            
0001191A                            	even
0001191A                            
0001191A                            ; -------------------------------------------------------------------------
0001191A                            VoiceBankSFX:
0001191A =00000000                  sPatNum = 0
0001191A                            	include "Sound/unipatchsfx.asm"; include universal Voice banks
0001191A                            
0001191A                            ; ------------------------------------------------------------------------
0001191A                            ; AMPS SFX patch list
0001191A                            ; -------------------------------------------------------------------------
0001191A                            
0001191A                            	; Patch $00
0001191A                            	; $07
0001191A                            	; $07, $07, $08, $08,	$1F, $1F, $1F, $1F
0001191A                            	; $00, $00, $00, $00,	$00, $00, $00, $00
0001191A                            	; $0F, $0F, $0F, $0F,	$80, $80, $80, $80
0001191A                            	spAlgorithm	$07
0001191A =00000001                M spatnum	=	spatnum+1
0001191A =00000007                M spal	=	val
0001191A                            	spFeedback	$00
0001191A =00000000                M spfe	=	val
0001191A                            	spDetune	$00, $00, $00, $00
0001191A =00000000                M spde1	=	op1
0001191A =00000000                M spde2	=	op2
0001191A =00000000                M spde3	=	op3
0001191A =00000000                M spde4	=	op4
0001191A                            	spMultiple	$07, $08, $07, $08
0001191A =00000007                M spmu1	=	op1
0001191A =00000008                M spmu2	=	op2
0001191A =00000007                M spmu3	=	op3
0001191A =00000008                M spmu4	=	op4
0001191A                            	spRateScale	$00, $00, $00, $00
0001191A =00000000                M sprs1	=	op1
0001191A =00000000                M sprs2	=	op2
0001191A =00000000                M sprs3	=	op3
0001191A =00000000                M sprs4	=	op4
0001191A                            	spAttackRt	$1F, $1F, $1F, $1F
0001191A =0000001F                M spar1	=	op1
0001191A =0000001F                M spar2	=	op2
0001191A =0000001F                M spar3	=	op3
0001191A =0000001F                M spar4	=	op4
0001191A                            	spAmpMod	$00, $00, $00, $00
0001191A =00000000                M spam1	=	op1
0001191A =00000000                M spam2	=	op2
0001191A =00000000                M spam3	=	op3
0001191A =00000000                M spam4	=	op4
0001191A                            	spSustainRt	$00, $00, $00, $00
0001191A =00000000                M spsr1	=	op1
0001191A =00000000                M spsr2	=	op2
0001191A =00000000                M spsr3	=	op3
0001191A =00000000                M spsr4	=	op4
0001191A                            	spDecayRt	$00, $00, $00, $00
0001191A =00000000                M spdr1	=	op1
0001191A =00000000                M spdr2	=	op2
0001191A =00000000                M spdr3	=	op3
0001191A =00000000                M spdr4	=	op4
0001191A                            	spSustainLv	$00, $00, $00, $00
0001191A =00000000                M spsl1	=	op1
0001191A =00000000                M spsl2	=	op2
0001191A =00000000                M spsl3	=	op3
0001191A =00000000                M spsl4	=	op4
0001191A                            	spReleaseRt	$0F, $0F, $0F, $0F
0001191A =0000000F                M sprr1	=	op1
0001191A =0000000F                M sprr2	=	op2
0001191A =0000000F                M sprr3	=	op3
0001191A =0000000F                M sprr4	=	op4
0001191A                            	spSSGEG		$00, $00, $00, $00
0001191A =00000000                M spss1	=	op1
0001191A =00000000                M spss2	=	op2
0001191A =00000000                M spss3	=	op3
0001191A =00000000                M spss4	=	op4
0001191A                            	spTotalLv2	$80, $80, $80, $80
0001191A =00000080                M sptl1	=	op1
0001191A =00000080                M sptl2	=	op2
0001191A =00000080                M sptl3	=	op3
0001191A =00000080                M sptl4	=	op4
0001191A 07                       M 	dc.b	(spfe<<3)+spal
0001191B 0707 0808                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001191F 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011923 0000 0000                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011927 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001192B 0F0F 0F0F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001192F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011933 8080 8080                M 	dc.b	sptl1,sptl3,sptl2,sptl4
00011937 4E41 54                  M 	dc.b	'NAT'
0001193A                            
0001193A                            	; Patch $01
0001193A                            	; $0C
0001193A                            	; $08, $08, $08, $08,	$1F, $1F, $1F, $1F
0001193A                            	; $00, $0A, $00, $0A,	$00, $00, $00, $0A
0001193A                            	; $FF, $FF, $FF, $FF,	$55, $81, $33, $81
0001193A                            	spAlgorithm	$04
0001193A =00000002                M spatnum	=	spatnum+1
0001193A =00000004                M spal	=	val
0001193A                            	spFeedback	$01
0001193A =00000001                M spfe	=	val
0001193A                            	spDetune	$00, $00, $00, $00
0001193A =00000000                M spde1	=	op1
0001193A =00000000                M spde2	=	op2
0001193A =00000000                M spde3	=	op3
0001193A =00000000                M spde4	=	op4
0001193A                            	spMultiple	$08, $08, $08, $08
0001193A =00000008                M spmu1	=	op1
0001193A =00000008                M spmu2	=	op2
0001193A =00000008                M spmu3	=	op3
0001193A =00000008                M spmu4	=	op4
0001193A                            	spRateScale	$00, $00, $00, $00
0001193A =00000000                M sprs1	=	op1
0001193A =00000000                M sprs2	=	op2
0001193A =00000000                M sprs3	=	op3
0001193A =00000000                M sprs4	=	op4
0001193A                            	spAttackRt	$1F, $1F, $1F, $1F
0001193A =0000001F                M spar1	=	op1
0001193A =0000001F                M spar2	=	op2
0001193A =0000001F                M spar3	=	op3
0001193A =0000001F                M spar4	=	op4
0001193A                            	spAmpMod	$00, $00, $00, $00
0001193A =00000000                M spam1	=	op1
0001193A =00000000                M spam2	=	op2
0001193A =00000000                M spam3	=	op3
0001193A =00000000                M spam4	=	op4
0001193A                            	spSustainRt	$00, $00, $0A, $0A
0001193A =00000000                M spsr1	=	op1
0001193A =00000000                M spsr2	=	op2
0001193A =0000000A                M spsr3	=	op3
0001193A =0000000A                M spsr4	=	op4
0001193A                            	spDecayRt	$00, $00, $00, $0A
0001193A =00000000                M spdr1	=	op1
0001193A =00000000                M spdr2	=	op2
0001193A =00000000                M spdr3	=	op3
0001193A =0000000A                M spdr4	=	op4
0001193A                            	spSustainLv	$0F, $0F, $0F, $0F
0001193A =0000000F                M spsl1	=	op1
0001193A =0000000F                M spsl2	=	op2
0001193A =0000000F                M spsl3	=	op3
0001193A =0000000F                M spsl4	=	op4
0001193A                            	spReleaseRt	$0F, $0F, $0F, $0F
0001193A =0000000F                M sprr1	=	op1
0001193A =0000000F                M sprr2	=	op2
0001193A =0000000F                M sprr3	=	op3
0001193A =0000000F                M sprr4	=	op4
0001193A                            	spSSGEG		$00, $00, $00, $00
0001193A =00000000                M spss1	=	op1
0001193A =00000000                M spss2	=	op2
0001193A =00000000                M spss3	=	op3
0001193A =00000000                M spss4	=	op4
0001193A                            	spTotalLv	$55, $33, $01, $01
0001193A =00000055                M sptl1	=	op1
0001193A =00000033                M sptl2	=	op2
0001193A =00000001                M sptl3	=	op3
0001193A =00000001                M sptl4	=	op4
0001193A 0C                       M 	dc.b	(spfe<<3)+spal
0001193B =00000080                M sptlmask4	set	$80
0001193B =00000000                M sptlmask2	set	((spal>=5)<<7)
0001193B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
0001193B =00000000                M sptlmask1	set	((spal=7)<<7)
0001193B 0808 0808                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001193F 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011943 000A 000A                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011947 0000 000A                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001194B FFFF FFFF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001194F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011953 5581 3381                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011957 4E41 54                  M 	dc.b	'NAT'
0001195A                            
0001195A                            	; Patch $02
0001195A                            	; $30
0001195A                            	; $30, $30, $30, $30,	$9E, $D8, $DC, $DC
0001195A                            	; $0E, $0A, $04, $05,	$08, $08, $08, $08
0001195A                            	; $BF, $BF, $BF, $BF,	$14, $3A, $14, $80
0001195A                            	spAlgorithm	$00
0001195A =00000003                M spatnum	=	spatnum+1
0001195A =00000000                M spal	=	val
0001195A                            	spFeedback	$06
0001195A =00000006                M spfe	=	val
0001195A                            	spDetune	$03, $03, $03, $03
0001195A =00000003                M spde1	=	op1
0001195A =00000003                M spde2	=	op2
0001195A =00000003                M spde3	=	op3
0001195A =00000003                M spde4	=	op4
0001195A                            	spMultiple	$00, $00, $00, $00
0001195A =00000000                M spmu1	=	op1
0001195A =00000000                M spmu2	=	op2
0001195A =00000000                M spmu3	=	op3
0001195A =00000000                M spmu4	=	op4
0001195A                            	spRateScale	$02, $03, $03, $03
0001195A =00000002                M sprs1	=	op1
0001195A =00000003                M sprs2	=	op2
0001195A =00000003                M sprs3	=	op3
0001195A =00000003                M sprs4	=	op4
0001195A                            	spAttackRt	$1E, $1C, $18, $1C
0001195A =0000001E                M spar1	=	op1
0001195A =0000001C                M spar2	=	op2
0001195A =00000018                M spar3	=	op3
0001195A =0000001C                M spar4	=	op4
0001195A                            	spAmpMod	$00, $00, $00, $00
0001195A =00000000                M spam1	=	op1
0001195A =00000000                M spam2	=	op2
0001195A =00000000                M spam3	=	op3
0001195A =00000000                M spam4	=	op4
0001195A                            	spSustainRt	$0E, $04, $0A, $05
0001195A =0000000E                M spsr1	=	op1
0001195A =00000004                M spsr2	=	op2
0001195A =0000000A                M spsr3	=	op3
0001195A =00000005                M spsr4	=	op4
0001195A                            	spDecayRt	$08, $08, $08, $08
0001195A =00000008                M spdr1	=	op1
0001195A =00000008                M spdr2	=	op2
0001195A =00000008                M spdr3	=	op3
0001195A =00000008                M spdr4	=	op4
0001195A                            	spSustainLv	$0B, $0B, $0B, $0B
0001195A =0000000B                M spsl1	=	op1
0001195A =0000000B                M spsl2	=	op2
0001195A =0000000B                M spsl3	=	op3
0001195A =0000000B                M spsl4	=	op4
0001195A                            	spReleaseRt	$0F, $0F, $0F, $0F
0001195A =0000000F                M sprr1	=	op1
0001195A =0000000F                M sprr2	=	op2
0001195A =0000000F                M sprr3	=	op3
0001195A =0000000F                M sprr4	=	op4
0001195A                            	spSSGEG		$00, $00, $00, $00
0001195A =00000000                M spss1	=	op1
0001195A =00000000                M spss2	=	op2
0001195A =00000000                M spss3	=	op3
0001195A =00000000                M spss4	=	op4
0001195A                            	spTotalLv2	$14, $14, $3A, $80
0001195A =00000014                M sptl1	=	op1
0001195A =00000014                M sptl2	=	op2
0001195A =0000003A                M sptl3	=	op3
0001195A =00000080                M sptl4	=	op4
0001195A 30                       M 	dc.b	(spfe<<3)+spal
0001195B 3030 3030                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001195F 9ED8 DCDC                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011963 0E0A 0405                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011967 0808 0808                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001196B BFBF BFBF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001196F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011973 143A 1480                M 	dc.b	sptl1,sptl3,sptl2,sptl4
00011977 4E41 54                  M 	dc.b	'NAT'
0001197A                            
0001197A                            	; Patch $03
0001197A                            	; $04
0001197A                            	; $37, $72, $77, $49,	$1F, $1F, $1F, $1F
0001197A                            	; $07, $0A, $07, $0D,	$00, $0B, $00, $0B
0001197A                            	; $1F, $0F, $1F, $0F,	$23, $00, $23, $00
0001197A                            	spAlgorithm	$04
0001197A =00000004                M spatnum	=	spatnum+1
0001197A =00000004                M spal	=	val
0001197A                            	spFeedback	$00
0001197A =00000000                M spfe	=	val
0001197A                            	spDetune	$03, $07, $07, $04
0001197A =00000003                M spde1	=	op1
0001197A =00000007                M spde2	=	op2
0001197A =00000007                M spde3	=	op3
0001197A =00000004                M spde4	=	op4
0001197A                            	spMultiple	$07, $07, $02, $09
0001197A =00000007                M spmu1	=	op1
0001197A =00000007                M spmu2	=	op2
0001197A =00000002                M spmu3	=	op3
0001197A =00000009                M spmu4	=	op4
0001197A                            	spRateScale	$00, $00, $00, $00
0001197A =00000000                M sprs1	=	op1
0001197A =00000000                M sprs2	=	op2
0001197A =00000000                M sprs3	=	op3
0001197A =00000000                M sprs4	=	op4
0001197A                            	spAttackRt	$1F, $1F, $1F, $1F
0001197A =0000001F                M spar1	=	op1
0001197A =0000001F                M spar2	=	op2
0001197A =0000001F                M spar3	=	op3
0001197A =0000001F                M spar4	=	op4
0001197A                            	spAmpMod	$00, $00, $00, $00
0001197A =00000000                M spam1	=	op1
0001197A =00000000                M spam2	=	op2
0001197A =00000000                M spam3	=	op3
0001197A =00000000                M spam4	=	op4
0001197A                            	spSustainRt	$07, $07, $0A, $0D
0001197A =00000007                M spsr1	=	op1
0001197A =00000007                M spsr2	=	op2
0001197A =0000000A                M spsr3	=	op3
0001197A =0000000D                M spsr4	=	op4
0001197A                            	spDecayRt	$00, $00, $0B, $0B
0001197A =00000000                M spdr1	=	op1
0001197A =00000000                M spdr2	=	op2
0001197A =0000000B                M spdr3	=	op3
0001197A =0000000B                M spdr4	=	op4
0001197A                            	spSustainLv	$01, $01, $00, $00
0001197A =00000001                M spsl1	=	op1
0001197A =00000001                M spsl2	=	op2
0001197A =00000000                M spsl3	=	op3
0001197A =00000000                M spsl4	=	op4
0001197A                            	spReleaseRt	$0F, $0F, $0F, $0F
0001197A =0000000F                M sprr1	=	op1
0001197A =0000000F                M sprr2	=	op2
0001197A =0000000F                M sprr3	=	op3
0001197A =0000000F                M sprr4	=	op4
0001197A                            	spSSGEG		$00, $00, $00, $00
0001197A =00000000                M spss1	=	op1
0001197A =00000000                M spss2	=	op2
0001197A =00000000                M spss3	=	op3
0001197A =00000000                M spss4	=	op4
0001197A                            	spTotalLv2	$23, $23, $00, $00
0001197A =00000023                M sptl1	=	op1
0001197A =00000023                M sptl2	=	op2
0001197A =00000000                M sptl3	=	op3
0001197A =00000000                M sptl4	=	op4
0001197A 04                       M 	dc.b	(spfe<<3)+spal
0001197B 3772 7749                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001197F 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011983 070A 070D                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011987 000B 000B                M 	dc.b	spdr1,spdr3,spdr2,spdr4
0001198B 1F0F 1F0F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
0001198F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011993 2300 2300                M 	dc.b	sptl1,sptl3,sptl2,sptl4
00011997 4E41 54                  M 	dc.b	'NAT'
0001199A                            
0001199A                            	; Patch $04
0001199A                            	; $3C
0001199A                            	; $0F, $01, $03, $01,	$1F, $1F, $1F, $1F
0001199A                            	; $19, $12, $19, $0E,	$05, $12, $00, $0F
0001199A                            	; $0F, $7F, $FF, $FF,	$00, $00, $00, $00
0001199A                            	spAlgorithm	$04
0001199A =00000005                M spatnum	=	spatnum+1
0001199A =00000004                M spal	=	val
0001199A                            	spFeedback	$07
0001199A =00000007                M spfe	=	val
0001199A                            	spDetune	$00, $00, $00, $00
0001199A =00000000                M spde1	=	op1
0001199A =00000000                M spde2	=	op2
0001199A =00000000                M spde3	=	op3
0001199A =00000000                M spde4	=	op4
0001199A                            	spMultiple	$0F, $03, $01, $01
0001199A =0000000F                M spmu1	=	op1
0001199A =00000003                M spmu2	=	op2
0001199A =00000001                M spmu3	=	op3
0001199A =00000001                M spmu4	=	op4
0001199A                            	spRateScale	$00, $00, $00, $00
0001199A =00000000                M sprs1	=	op1
0001199A =00000000                M sprs2	=	op2
0001199A =00000000                M sprs3	=	op3
0001199A =00000000                M sprs4	=	op4
0001199A                            	spAttackRt	$1F, $1F, $1F, $1F
0001199A =0000001F                M spar1	=	op1
0001199A =0000001F                M spar2	=	op2
0001199A =0000001F                M spar3	=	op3
0001199A =0000001F                M spar4	=	op4
0001199A                            	spAmpMod	$00, $00, $00, $00
0001199A =00000000                M spam1	=	op1
0001199A =00000000                M spam2	=	op2
0001199A =00000000                M spam3	=	op3
0001199A =00000000                M spam4	=	op4
0001199A                            	spSustainRt	$19, $19, $12, $0E
0001199A =00000019                M spsr1	=	op1
0001199A =00000019                M spsr2	=	op2
0001199A =00000012                M spsr3	=	op3
0001199A =0000000E                M spsr4	=	op4
0001199A                            	spDecayRt	$05, $00, $12, $0F
0001199A =00000005                M spdr1	=	op1
0001199A =00000000                M spdr2	=	op2
0001199A =00000012                M spdr3	=	op3
0001199A =0000000F                M spdr4	=	op4
0001199A                            	spSustainLv	$00, $0F, $07, $0F
0001199A =00000000                M spsl1	=	op1
0001199A =0000000F                M spsl2	=	op2
0001199A =00000007                M spsl3	=	op3
0001199A =0000000F                M spsl4	=	op4
0001199A                            	spReleaseRt	$0F, $0F, $0F, $0F
0001199A =0000000F                M sprr1	=	op1
0001199A =0000000F                M sprr2	=	op2
0001199A =0000000F                M sprr3	=	op3
0001199A =0000000F                M sprr4	=	op4
0001199A                            	spSSGEG		$00, $00, $00, $00
0001199A =00000000                M spss1	=	op1
0001199A =00000000                M spss2	=	op2
0001199A =00000000                M spss3	=	op3
0001199A =00000000                M spss4	=	op4
0001199A                            	spTotalLv2	$00, $00, $00, $00
0001199A =00000000                M sptl1	=	op1
0001199A =00000000                M sptl2	=	op2
0001199A =00000000                M sptl3	=	op3
0001199A =00000000                M sptl4	=	op4
0001199A 3C                       M 	dc.b	(spfe<<3)+spal
0001199B 0F01 0301                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
0001199F 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000119A3 1912 190E                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000119A7 0512 000F                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000119AB 0F7F FFFF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000119AF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000119B3 0000 0000                M 	dc.b	sptl1,sptl3,sptl2,sptl4
000119B7 4E41 54                  M 	dc.b	'NAT'
000119BA                            
000119BA                            	; Patch $05
000119BA                            	; $30
000119BA                            	; $30, $30, $30, $30,	$9E, $A8, $AC, $DC
000119BA                            	; $0E, $0A, $04, $05,	$08, $08, $08, $08
000119BA                            	; $BF, $BF, $BF, $BF,	$04, $2C, $14, $00
000119BA                            	spAlgorithm	$00
000119BA =00000006                M spatnum	=	spatnum+1
000119BA =00000000                M spal	=	val
000119BA                            	spFeedback	$06
000119BA =00000006                M spfe	=	val
000119BA                            	spDetune	$03, $03, $03, $03
000119BA =00000003                M spde1	=	op1
000119BA =00000003                M spde2	=	op2
000119BA =00000003                M spde3	=	op3
000119BA =00000003                M spde4	=	op4
000119BA                            	spMultiple	$00, $00, $00, $00
000119BA =00000000                M spmu1	=	op1
000119BA =00000000                M spmu2	=	op2
000119BA =00000000                M spmu3	=	op3
000119BA =00000000                M spmu4	=	op4
000119BA                            	spRateScale	$02, $02, $02, $03
000119BA =00000002                M sprs1	=	op1
000119BA =00000002                M sprs2	=	op2
000119BA =00000002                M sprs3	=	op3
000119BA =00000003                M sprs4	=	op4
000119BA                            	spAttackRt	$1E, $0C, $08, $1C
000119BA =0000001E                M spar1	=	op1
000119BA =0000000C                M spar2	=	op2
000119BA =00000008                M spar3	=	op3
000119BA =0000001C                M spar4	=	op4
000119BA                            	spAmpMod	$00, $00, $00, $00
000119BA =00000000                M spam1	=	op1
000119BA =00000000                M spam2	=	op2
000119BA =00000000                M spam3	=	op3
000119BA =00000000                M spam4	=	op4
000119BA                            	spSustainRt	$0E, $04, $0A, $05
000119BA =0000000E                M spsr1	=	op1
000119BA =00000004                M spsr2	=	op2
000119BA =0000000A                M spsr3	=	op3
000119BA =00000005                M spsr4	=	op4
000119BA                            	spDecayRt	$08, $08, $08, $08
000119BA =00000008                M spdr1	=	op1
000119BA =00000008                M spdr2	=	op2
000119BA =00000008                M spdr3	=	op3
000119BA =00000008                M spdr4	=	op4
000119BA                            	spSustainLv	$0B, $0B, $0B, $0B
000119BA =0000000B                M spsl1	=	op1
000119BA =0000000B                M spsl2	=	op2
000119BA =0000000B                M spsl3	=	op3
000119BA =0000000B                M spsl4	=	op4
000119BA                            	spReleaseRt	$0F, $0F, $0F, $0F
000119BA =0000000F                M sprr1	=	op1
000119BA =0000000F                M sprr2	=	op2
000119BA =0000000F                M sprr3	=	op3
000119BA =0000000F                M sprr4	=	op4
000119BA                            	spSSGEG		$00, $00, $00, $00
000119BA =00000000                M spss1	=	op1
000119BA =00000000                M spss2	=	op2
000119BA =00000000                M spss3	=	op3
000119BA =00000000                M spss4	=	op4
000119BA                            	spTotalLv2	$04, $14, $2C, $00
000119BA =00000004                M sptl1	=	op1
000119BA =00000014                M sptl2	=	op2
000119BA =0000002C                M sptl3	=	op3
000119BA =00000000                M sptl4	=	op4
000119BA 30                       M 	dc.b	(spfe<<3)+spal
000119BB 3030 3030                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000119BF 9E88 8CDC                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000119C3 0E0A 0405                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000119C7 0808 0808                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000119CB BFBF BFBF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000119CF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000119D3 042C 1400                M 	dc.b	sptl1,sptl3,sptl2,sptl4
000119D7 4E41 54                  M 	dc.b	'NAT'
000119DA                            
000119DA                            	; Patch $06
000119DA                            	; $20
000119DA                            	; $36, $35, $30, $31,	$DF, $DF, $9F, $9F
000119DA                            	; $07, $06, $09, $06,	$07, $06, $06, $08
000119DA                            	; $2F, $1F, $1F, $FF,	$16, $30, $13, $00
000119DA                            	spAlgorithm	$00
000119DA =00000007                M spatnum	=	spatnum+1
000119DA =00000000                M spal	=	val
000119DA                            	spFeedback	$04
000119DA =00000004                M spfe	=	val
000119DA                            	spDetune	$03, $03, $03, $03
000119DA =00000003                M spde1	=	op1
000119DA =00000003                M spde2	=	op2
000119DA =00000003                M spde3	=	op3
000119DA =00000003                M spde4	=	op4
000119DA                            	spMultiple	$06, $00, $05, $01
000119DA =00000006                M spmu1	=	op1
000119DA =00000000                M spmu2	=	op2
000119DA =00000005                M spmu3	=	op3
000119DA =00000001                M spmu4	=	op4
000119DA                            	spRateScale	$03, $02, $03, $02
000119DA =00000003                M sprs1	=	op1
000119DA =00000002                M sprs2	=	op2
000119DA =00000003                M sprs3	=	op3
000119DA =00000002                M sprs4	=	op4
000119DA                            	spAttackRt	$1F, $1F, $1F, $1F
000119DA =0000001F                M spar1	=	op1
000119DA =0000001F                M spar2	=	op2
000119DA =0000001F                M spar3	=	op3
000119DA =0000001F                M spar4	=	op4
000119DA                            	spAmpMod	$00, $00, $00, $00
000119DA =00000000                M spam1	=	op1
000119DA =00000000                M spam2	=	op2
000119DA =00000000                M spam3	=	op3
000119DA =00000000                M spam4	=	op4
000119DA                            	spSustainRt	$07, $09, $06, $06
000119DA =00000007                M spsr1	=	op1
000119DA =00000009                M spsr2	=	op2
000119DA =00000006                M spsr3	=	op3
000119DA =00000006                M spsr4	=	op4
000119DA                            	spDecayRt	$07, $06, $06, $08
000119DA =00000007                M spdr1	=	op1
000119DA =00000006                M spdr2	=	op2
000119DA =00000006                M spdr3	=	op3
000119DA =00000008                M spdr4	=	op4
000119DA                            	spSustainLv	$02, $01, $01, $0F
000119DA =00000002                M spsl1	=	op1
000119DA =00000001                M spsl2	=	op2
000119DA =00000001                M spsl3	=	op3
000119DA =0000000F                M spsl4	=	op4
000119DA                            	spReleaseRt	$0F, $0F, $0F, $0F
000119DA =0000000F                M sprr1	=	op1
000119DA =0000000F                M sprr2	=	op2
000119DA =0000000F                M sprr3	=	op3
000119DA =0000000F                M sprr4	=	op4
000119DA                            	spSSGEG		$00, $00, $00, $00
000119DA =00000000                M spss1	=	op1
000119DA =00000000                M spss2	=	op2
000119DA =00000000                M spss3	=	op3
000119DA =00000000                M spss4	=	op4
000119DA                            	spTotalLv2	$16, $13, $30, $00
000119DA =00000016                M sptl1	=	op1
000119DA =00000013                M sptl2	=	op2
000119DA =00000030                M sptl3	=	op3
000119DA =00000000                M sptl4	=	op4
000119DA 20                       M 	dc.b	(spfe<<3)+spal
000119DB 3635 3031                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000119DF DFDF 9F9F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
000119E3 0706 0906                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
000119E7 0706 0608                M 	dc.b	spdr1,spdr3,spdr2,spdr4
000119EB 2F1F 1FFF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
000119EF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
000119F3 1630 1300                M 	dc.b	sptl1,sptl3,sptl2,sptl4
000119F7 4E41 54                  M 	dc.b	'NAT'
000119FA                            
000119FA                            	; Patch $07
000119FA                            	; $35
000119FA                            	; $05, $09, $08, $07,	$1E, $0D, $0D, $0E
000119FA                            	; $0C, $15, $03, $06,	$16, $0E, $09, $10
000119FA                            	; $2F, $2F, $1F, $1F,	$15, $12, $12, $00
000119FA                            	spAlgorithm	$05
000119FA =00000008                M spatnum	=	spatnum+1
000119FA =00000005                M spal	=	val
000119FA                            	spFeedback	$06
000119FA =00000006                M spfe	=	val
000119FA                            	spDetune	$00, $00, $00, $00
000119FA =00000000                M spde1	=	op1
000119FA =00000000                M spde2	=	op2
000119FA =00000000                M spde3	=	op3
000119FA =00000000                M spde4	=	op4
000119FA                            	spMultiple	$05, $08, $09, $07
000119FA =00000005                M spmu1	=	op1
000119FA =00000008                M spmu2	=	op2
000119FA =00000009                M spmu3	=	op3
000119FA =00000007                M spmu4	=	op4
000119FA                            	spRateScale	$00, $00, $00, $00
000119FA =00000000                M sprs1	=	op1
000119FA =00000000                M sprs2	=	op2
000119FA =00000000                M sprs3	=	op3
000119FA =00000000                M sprs4	=	op4
000119FA                            	spAttackRt	$1E, $0D, $0D, $0E
000119FA =0000001E                M spar1	=	op1
000119FA =0000000D                M spar2	=	op2
000119FA =0000000D                M spar3	=	op3
000119FA =0000000E                M spar4	=	op4
000119FA                            	spAmpMod	$00, $00, $00, $00
000119FA =00000000                M spam1	=	op1
000119FA =00000000                M spam2	=	op2
000119FA =00000000                M spam3	=	op3
000119FA =00000000                M spam4	=	op4
000119FA                            	spSustainRt	$0C, $03, $15, $06
000119FA =0000000C                M spsr1	=	op1
000119FA =00000003                M spsr2	=	op2
000119FA =00000015                M spsr3	=	op3
000119FA =00000006                M spsr4	=	op4
000119FA                            	spDecayRt	$16, $09, $0E, $10
000119FA =00000016                M spdr1	=	op1
000119FA =00000009                M spdr2	=	op2
000119FA =0000000E                M spdr3	=	op3
000119FA =00000010                M spdr4	=	op4
000119FA                            	spSustainLv	$02, $01, $02, $01
000119FA =00000002                M spsl1	=	op1
000119FA =00000001                M spsl2	=	op2
000119FA =00000002                M spsl3	=	op3
000119FA =00000001                M spsl4	=	op4
000119FA                            	spReleaseRt	$0F, $0F, $0F, $0F
000119FA =0000000F                M sprr1	=	op1
000119FA =0000000F                M sprr2	=	op2
000119FA =0000000F                M sprr3	=	op3
000119FA =0000000F                M sprr4	=	op4
000119FA                            	spSSGEG		$00, $00, $00, $00
000119FA =00000000                M spss1	=	op1
000119FA =00000000                M spss2	=	op2
000119FA =00000000                M spss3	=	op3
000119FA =00000000                M spss4	=	op4
000119FA                            	spTotalLv2	$15, $12, $12, $00
000119FA =00000015                M sptl1	=	op1
000119FA =00000012                M sptl2	=	op2
000119FA =00000012                M sptl3	=	op3
000119FA =00000000                M sptl4	=	op4
000119FA 35                       M 	dc.b	(spfe<<3)+spal
000119FB 0509 0807                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
000119FF 1E0D 0D0E                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011A03 0C15 0306                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011A07 160E 0910                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011A0B 2F2F 1F1F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011A0F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011A13 1512 1200                M 	dc.b	sptl1,sptl3,sptl2,sptl4
00011A17 4E41 54                  M 	dc.b	'NAT'
00011A1A                            
00011A1A                            	; Patch $08
00011A1A                            	; $3E
00011A1A                            	; $36, $01, $00, $04,	$59, $D9, $5F, $9C
00011A1A                            	; $0F, $04, $0F, $0A,	$02, $02, $05, $05
00011A1A                            	; $A9, $AF, $66, $66,	$20, $00, $0A, $00
00011A1A                            	spAlgorithm	$06
00011A1A =00000009                M spatnum	=	spatnum+1
00011A1A =00000006                M spal	=	val
00011A1A                            	spFeedback	$07
00011A1A =00000007                M spfe	=	val
00011A1A                            	spDetune	$03, $00, $00, $00
00011A1A =00000003                M spde1	=	op1
00011A1A =00000000                M spde2	=	op2
00011A1A =00000000                M spde3	=	op3
00011A1A =00000000                M spde4	=	op4
00011A1A                            	spMultiple	$06, $00, $01, $04
00011A1A =00000006                M spmu1	=	op1
00011A1A =00000000                M spmu2	=	op2
00011A1A =00000001                M spmu3	=	op3
00011A1A =00000004                M spmu4	=	op4
00011A1A                            	spRateScale	$01, $01, $03, $02
00011A1A =00000001                M sprs1	=	op1
00011A1A =00000001                M sprs2	=	op2
00011A1A =00000003                M sprs3	=	op3
00011A1A =00000002                M sprs4	=	op4
00011A1A                            	spAttackRt	$19, $1F, $19, $1C
00011A1A =00000019                M spar1	=	op1
00011A1A =0000001F                M spar2	=	op2
00011A1A =00000019                M spar3	=	op3
00011A1A =0000001C                M spar4	=	op4
00011A1A                            	spAmpMod	$00, $00, $00, $00
00011A1A =00000000                M spam1	=	op1
00011A1A =00000000                M spam2	=	op2
00011A1A =00000000                M spam3	=	op3
00011A1A =00000000                M spam4	=	op4
00011A1A                            	spSustainRt	$0F, $0F, $04, $0A
00011A1A =0000000F                M spsr1	=	op1
00011A1A =0000000F                M spsr2	=	op2
00011A1A =00000004                M spsr3	=	op3
00011A1A =0000000A                M spsr4	=	op4
00011A1A                            	spDecayRt	$02, $05, $02, $05
00011A1A =00000002                M spdr1	=	op1
00011A1A =00000005                M spdr2	=	op2
00011A1A =00000002                M spdr3	=	op3
00011A1A =00000005                M spdr4	=	op4
00011A1A                            	spSustainLv	$0A, $06, $0A, $06
00011A1A =0000000A                M spsl1	=	op1
00011A1A =00000006                M spsl2	=	op2
00011A1A =0000000A                M spsl3	=	op3
00011A1A =00000006                M spsl4	=	op4
00011A1A                            	spReleaseRt	$09, $06, $0F, $06
00011A1A =00000009                M sprr1	=	op1
00011A1A =00000006                M sprr2	=	op2
00011A1A =0000000F                M sprr3	=	op3
00011A1A =00000006                M sprr4	=	op4
00011A1A                            	spSSGEG		$00, $00, $00, $00
00011A1A =00000000                M spss1	=	op1
00011A1A =00000000                M spss2	=	op2
00011A1A =00000000                M spss3	=	op3
00011A1A =00000000                M spss4	=	op4
00011A1A                            	spTotalLv2	$20, $0A, $00, $00
00011A1A =00000020                M sptl1	=	op1
00011A1A =0000000A                M sptl2	=	op2
00011A1A =00000000                M sptl3	=	op3
00011A1A =00000000                M sptl4	=	op4
00011A1A 3E                       M 	dc.b	(spfe<<3)+spal
00011A1B 3601 0004                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011A1F 59D9 5F9C                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011A23 0F04 0F0A                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011A27 0202 0505                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011A2B A9AF 6666                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011A2F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011A33 2000 0A00                M 	dc.b	sptl1,sptl3,sptl2,sptl4
00011A37 4E41 54                  M 	dc.b	'NAT'
00011A3A                            
00011A3A                            	; Patch $09
00011A3A                            	; $3A
00011A3A                            	; $21, $30, $10, $32,	$1F, $1F, $1F, $1F
00011A3A                            	; $05, $18, $05, $10,	$0B, $1F, $10, $10
00011A3A                            	; $1F, $2F, $4F, $2F,	$0D, $07, $04, $00
00011A3A                            	spAlgorithm	$02
00011A3A =0000000A                M spatnum	=	spatnum+1
00011A3A =00000002                M spal	=	val
00011A3A                            	spFeedback	$07
00011A3A =00000007                M spfe	=	val
00011A3A                            	spDetune	$02, $01, $03, $03
00011A3A =00000002                M spde1	=	op1
00011A3A =00000001                M spde2	=	op2
00011A3A =00000003                M spde3	=	op3
00011A3A =00000003                M spde4	=	op4
00011A3A                            	spMultiple	$01, $00, $00, $02
00011A3A =00000001                M spmu1	=	op1
00011A3A =00000000                M spmu2	=	op2
00011A3A =00000000                M spmu3	=	op3
00011A3A =00000002                M spmu4	=	op4
00011A3A                            	spRateScale	$00, $00, $00, $00
00011A3A =00000000                M sprs1	=	op1
00011A3A =00000000                M sprs2	=	op2
00011A3A =00000000                M sprs3	=	op3
00011A3A =00000000                M sprs4	=	op4
00011A3A                            	spAttackRt	$1F, $1F, $1F, $1F
00011A3A =0000001F                M spar1	=	op1
00011A3A =0000001F                M spar2	=	op2
00011A3A =0000001F                M spar3	=	op3
00011A3A =0000001F                M spar4	=	op4
00011A3A                            	spAmpMod	$00, $00, $00, $00
00011A3A =00000000                M spam1	=	op1
00011A3A =00000000                M spam2	=	op2
00011A3A =00000000                M spam3	=	op3
00011A3A =00000000                M spam4	=	op4
00011A3A                            	spSustainRt	$05, $05, $18, $10
00011A3A =00000005                M spsr1	=	op1
00011A3A =00000005                M spsr2	=	op2
00011A3A =00000018                M spsr3	=	op3
00011A3A =00000010                M spsr4	=	op4
00011A3A                            	spDecayRt	$0B, $10, $1F, $10
00011A3A =0000000B                M spdr1	=	op1
00011A3A =00000010                M spdr2	=	op2
00011A3A =0000001F                M spdr3	=	op3
00011A3A =00000010                M spdr4	=	op4
00011A3A                            	spSustainLv	$01, $04, $02, $02
00011A3A =00000001                M spsl1	=	op1
00011A3A =00000004                M spsl2	=	op2
00011A3A =00000002                M spsl3	=	op3
00011A3A =00000002                M spsl4	=	op4
00011A3A                            	spReleaseRt	$0F, $0F, $0F, $0F
00011A3A =0000000F                M sprr1	=	op1
00011A3A =0000000F                M sprr2	=	op2
00011A3A =0000000F                M sprr3	=	op3
00011A3A =0000000F                M sprr4	=	op4
00011A3A                            	spSSGEG		$00, $00, $00, $00
00011A3A =00000000                M spss1	=	op1
00011A3A =00000000                M spss2	=	op2
00011A3A =00000000                M spss3	=	op3
00011A3A =00000000                M spss4	=	op4
00011A3A                            	spTotalLv2	$0D, $04, $07, $00
00011A3A =0000000D                M sptl1	=	op1
00011A3A =00000004                M sptl2	=	op2
00011A3A =00000007                M sptl3	=	op3
00011A3A =00000000                M sptl4	=	op4
00011A3A 3A                       M 	dc.b	(spfe<<3)+spal
00011A3B 2130 1032                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011A3F 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011A43 0518 0510                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011A47 0B1F 1010                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011A4B 1F2F 4F2F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011A4F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011A53 0D07 0400                M 	dc.b	sptl1,sptl3,sptl2,sptl4
00011A57 4E41 54                  M 	dc.b	'NAT'
00011A5A                            
00011A5A                            	; Patch $0A
00011A5A                            	; $3C
00011A5A                            	; $00, $44, $02, $02, 	$1F, $1F, $1F, $15
00011A5A                            	; $00, $1F, $00, $00,	$00, $00, $00, $00
00011A5A                            	; $0F, $0F, $0F, $0F, 	$0D, $80, $28, $80
00011A5A                            	spAlgorithm	$04
00011A5A =0000000B                M spatnum	=	spatnum+1
00011A5A =00000004                M spal	=	val
00011A5A                            	spFeedback	$07
00011A5A =00000007                M spfe	=	val
00011A5A                            	spDetune	$00, $00, $04, $00
00011A5A =00000000                M spde1	=	op1
00011A5A =00000000                M spde2	=	op2
00011A5A =00000004                M spde3	=	op3
00011A5A =00000000                M spde4	=	op4
00011A5A                            	spMultiple	$00, $02, $04, $02
00011A5A =00000000                M spmu1	=	op1
00011A5A =00000002                M spmu2	=	op2
00011A5A =00000004                M spmu3	=	op3
00011A5A =00000002                M spmu4	=	op4
00011A5A                            	spRateScale	$00, $00, $00, $00
00011A5A =00000000                M sprs1	=	op1
00011A5A =00000000                M sprs2	=	op2
00011A5A =00000000                M sprs3	=	op3
00011A5A =00000000                M sprs4	=	op4
00011A5A                            	spAttackRt	$1F, $1F, $1F, $15
00011A5A =0000001F                M spar1	=	op1
00011A5A =0000001F                M spar2	=	op2
00011A5A =0000001F                M spar3	=	op3
00011A5A =00000015                M spar4	=	op4
00011A5A                            	spAmpMod	$00, $00, $00, $00
00011A5A =00000000                M spam1	=	op1
00011A5A =00000000                M spam2	=	op2
00011A5A =00000000                M spam3	=	op3
00011A5A =00000000                M spam4	=	op4
00011A5A                            	spSustainRt	$00, $00, $1F, $00
00011A5A =00000000                M spsr1	=	op1
00011A5A =00000000                M spsr2	=	op2
00011A5A =0000001F                M spsr3	=	op3
00011A5A =00000000                M spsr4	=	op4
00011A5A                            	spDecayRt	$00, $00, $00, $00
00011A5A =00000000                M spdr1	=	op1
00011A5A =00000000                M spdr2	=	op2
00011A5A =00000000                M spdr3	=	op3
00011A5A =00000000                M spdr4	=	op4
00011A5A                            	spSustainLv	$00, $00, $00, $00
00011A5A =00000000                M spsl1	=	op1
00011A5A =00000000                M spsl2	=	op2
00011A5A =00000000                M spsl3	=	op3
00011A5A =00000000                M spsl4	=	op4
00011A5A                            	spReleaseRt	$0F, $0F, $0F, $0F
00011A5A =0000000F                M sprr1	=	op1
00011A5A =0000000F                M sprr2	=	op2
00011A5A =0000000F                M sprr3	=	op3
00011A5A =0000000F                M sprr4	=	op4
00011A5A                            	spSSGEG		$00, $00, $00, $00
00011A5A =00000000                M spss1	=	op1
00011A5A =00000000                M spss2	=	op2
00011A5A =00000000                M spss3	=	op3
00011A5A =00000000                M spss4	=	op4
00011A5A                            	spTotalLv2	$0D, $28, $80, $80
00011A5A =0000000D                M sptl1	=	op1
00011A5A =00000028                M sptl2	=	op2
00011A5A =00000080                M sptl3	=	op3
00011A5A =00000080                M sptl4	=	op4
00011A5A 3C                       M 	dc.b	(spfe<<3)+spal
00011A5B 0044 0202                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011A5F 1F1F 1F15                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011A63 001F 0000                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011A67 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011A6B 0F0F 0F0F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011A6F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011A73 0D80 2880                M 	dc.b	sptl1,sptl3,sptl2,sptl4
00011A77 4E41 54                  M 	dc.b	'NAT'
00011A7A                            
00011A7A                            	; Patch $0B
00011A7A                            	; $3A
00011A7A                            	; $21, $30, $10, $32,	$1F, $1F, $1F, $1F
00011A7A                            	; $05, $18, $09, $02,	$06, $0F, $06, $02
00011A7A                            	; $1F, $2F, $4F, $2F,	$0F, $1A, $0E, $00
00011A7A                            	spAlgorithm	$02
00011A7A =0000000C                M spatnum	=	spatnum+1
00011A7A =00000002                M spal	=	val
00011A7A                            	spFeedback	$07
00011A7A =00000007                M spfe	=	val
00011A7A                            	spDetune	$02, $01, $03, $03
00011A7A =00000002                M spde1	=	op1
00011A7A =00000001                M spde2	=	op2
00011A7A =00000003                M spde3	=	op3
00011A7A =00000003                M spde4	=	op4
00011A7A                            	spMultiple	$01, $00, $00, $02
00011A7A =00000001                M spmu1	=	op1
00011A7A =00000000                M spmu2	=	op2
00011A7A =00000000                M spmu3	=	op3
00011A7A =00000002                M spmu4	=	op4
00011A7A                            	spRateScale	$00, $00, $00, $00
00011A7A =00000000                M sprs1	=	op1
00011A7A =00000000                M sprs2	=	op2
00011A7A =00000000                M sprs3	=	op3
00011A7A =00000000                M sprs4	=	op4
00011A7A                            	spAttackRt	$1F, $1F, $1F, $1F
00011A7A =0000001F                M spar1	=	op1
00011A7A =0000001F                M spar2	=	op2
00011A7A =0000001F                M spar3	=	op3
00011A7A =0000001F                M spar4	=	op4
00011A7A                            	spAmpMod	$00, $00, $00, $00
00011A7A =00000000                M spam1	=	op1
00011A7A =00000000                M spam2	=	op2
00011A7A =00000000                M spam3	=	op3
00011A7A =00000000                M spam4	=	op4
00011A7A                            	spSustainRt	$05, $09, $18, $02
00011A7A =00000005                M spsr1	=	op1
00011A7A =00000009                M spsr2	=	op2
00011A7A =00000018                M spsr3	=	op3
00011A7A =00000002                M spsr4	=	op4
00011A7A                            	spDecayRt	$06, $06, $0F, $02
00011A7A =00000006                M spdr1	=	op1
00011A7A =00000006                M spdr2	=	op2
00011A7A =0000000F                M spdr3	=	op3
00011A7A =00000002                M spdr4	=	op4
00011A7A                            	spSustainLv	$01, $04, $02, $02
00011A7A =00000001                M spsl1	=	op1
00011A7A =00000004                M spsl2	=	op2
00011A7A =00000002                M spsl3	=	op3
00011A7A =00000002                M spsl4	=	op4
00011A7A                            	spReleaseRt	$0F, $0F, $0F, $0F
00011A7A =0000000F                M sprr1	=	op1
00011A7A =0000000F                M sprr2	=	op2
00011A7A =0000000F                M sprr3	=	op3
00011A7A =0000000F                M sprr4	=	op4
00011A7A                            	spSSGEG		$00, $00, $00, $00
00011A7A =00000000                M spss1	=	op1
00011A7A =00000000                M spss2	=	op2
00011A7A =00000000                M spss3	=	op3
00011A7A =00000000                M spss4	=	op4
00011A7A                            	spTotalLv2	$0F, $0E, $1A, $00
00011A7A =0000000F                M sptl1	=	op1
00011A7A =0000000E                M sptl2	=	op2
00011A7A =0000001A                M sptl3	=	op3
00011A7A =00000000                M sptl4	=	op4
00011A7A 3A                       M 	dc.b	(spfe<<3)+spal
00011A7B 2130 1032                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011A7F 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011A83 0518 0902                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011A87 060F 0602                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011A8B 1F2F 4F2F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011A8F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011A93 0F1A 0E00                M 	dc.b	sptl1,sptl3,sptl2,sptl4
00011A97 4E41 54                  M 	dc.b	'NAT'
00011A9A                            
00011A9A                            	; Patch $0C
00011A9A                            	; $FD
00011A9A                            	; $09, $03, $00, $00, 	$1F, $1F, $1F, $1F
00011A9A                            	; $10, $0C, $0C, $0C,	$0B, $1F, $10, $05
00011A9A                            	; $1F, $2F, $4F, $2F, 	$09, $80, $8E, $88
00011A9A                            	spAlgorithm	$05
00011A9A =0000000D                M spatnum	=	spatnum+1
00011A9A =00000005                M spal	=	val
00011A9A                            	spFeedback	$07
00011A9A =00000007                M spfe	=	val
00011A9A                            	spDetune	$00, $00, $00, $00
00011A9A =00000000                M spde1	=	op1
00011A9A =00000000                M spde2	=	op2
00011A9A =00000000                M spde3	=	op3
00011A9A =00000000                M spde4	=	op4
00011A9A                            	spMultiple	$09, $00, $03, $00
00011A9A =00000009                M spmu1	=	op1
00011A9A =00000000                M spmu2	=	op2
00011A9A =00000003                M spmu3	=	op3
00011A9A =00000000                M spmu4	=	op4
00011A9A                            	spRateScale	$00, $00, $00, $00
00011A9A =00000000                M sprs1	=	op1
00011A9A =00000000                M sprs2	=	op2
00011A9A =00000000                M sprs3	=	op3
00011A9A =00000000                M sprs4	=	op4
00011A9A                            	spAttackRt	$1F, $1F, $1F, $1F
00011A9A =0000001F                M spar1	=	op1
00011A9A =0000001F                M spar2	=	op2
00011A9A =0000001F                M spar3	=	op3
00011A9A =0000001F                M spar4	=	op4
00011A9A                            	spAmpMod	$00, $00, $00, $00
00011A9A =00000000                M spam1	=	op1
00011A9A =00000000                M spam2	=	op2
00011A9A =00000000                M spam3	=	op3
00011A9A =00000000                M spam4	=	op4
00011A9A                            	spSustainRt	$10, $0C, $0C, $0C
00011A9A =00000010                M spsr1	=	op1
00011A9A =0000000C                M spsr2	=	op2
00011A9A =0000000C                M spsr3	=	op3
00011A9A =0000000C                M spsr4	=	op4
00011A9A                            	spDecayRt	$0B, $10, $1F, $05
00011A9A =0000000B                M spdr1	=	op1
00011A9A =00000010                M spdr2	=	op2
00011A9A =0000001F                M spdr3	=	op3
00011A9A =00000005                M spdr4	=	op4
00011A9A                            	spSustainLv	$01, $04, $02, $02
00011A9A =00000001                M spsl1	=	op1
00011A9A =00000004                M spsl2	=	op2
00011A9A =00000002                M spsl3	=	op3
00011A9A =00000002                M spsl4	=	op4
00011A9A                            	spReleaseRt	$0F, $0F, $0F, $0F
00011A9A =0000000F                M sprr1	=	op1
00011A9A =0000000F                M sprr2	=	op2
00011A9A =0000000F                M sprr3	=	op3
00011A9A =0000000F                M sprr4	=	op4
00011A9A                            	spSSGEG		$00, $00, $00, $00
00011A9A =00000000                M spss1	=	op1
00011A9A =00000000                M spss2	=	op2
00011A9A =00000000                M spss3	=	op3
00011A9A =00000000                M spss4	=	op4
00011A9A                            	spTotalLv2	$09, $8E, $80, $88
00011A9A =00000009                M sptl1	=	op1
00011A9A =0000008E                M sptl2	=	op2
00011A9A =00000080                M sptl3	=	op3
00011A9A =00000088                M sptl4	=	op4
00011A9A 3D                       M 	dc.b	(spfe<<3)+spal
00011A9B 0903 0000                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011A9F 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011AA3 100C 0C0C                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011AA7 0B1F 1005                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011AAB 1F2F 4F2F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011AAF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011AB3 0980 8E88                M 	dc.b	sptl1,sptl3,sptl2,sptl4
00011AB7 4E41 54                  M 	dc.b	'NAT'
00011ABA                            
00011ABA                            	; Patch $0D
00011ABA                            	; $3C
00011ABA                            	; $05, $01, $0A, $01,	$56, $5C, $5C, $5C
00011ABA                            	; $0E, $11, $11, $11,	$09, $0A, $06, $0A
00011ABA                            	; $4F, $3F, $3F, $3F,	$1F, $00, $2B, $00
00011ABA                            	spAlgorithm	$04
00011ABA =0000000E                M spatnum	=	spatnum+1
00011ABA =00000004                M spal	=	val
00011ABA                            	spFeedback	$07
00011ABA =00000007                M spfe	=	val
00011ABA                            	spDetune	$00, $00, $00, $00
00011ABA =00000000                M spde1	=	op1
00011ABA =00000000                M spde2	=	op2
00011ABA =00000000                M spde3	=	op3
00011ABA =00000000                M spde4	=	op4
00011ABA                            	spMultiple	$05, $0A, $01, $01
00011ABA =00000005                M spmu1	=	op1
00011ABA =0000000A                M spmu2	=	op2
00011ABA =00000001                M spmu3	=	op3
00011ABA =00000001                M spmu4	=	op4
00011ABA                            	spRateScale	$01, $01, $01, $01
00011ABA =00000001                M sprs1	=	op1
00011ABA =00000001                M sprs2	=	op2
00011ABA =00000001                M sprs3	=	op3
00011ABA =00000001                M sprs4	=	op4
00011ABA                            	spAttackRt	$16, $1C, $1C, $1C
00011ABA =00000016                M spar1	=	op1
00011ABA =0000001C                M spar2	=	op2
00011ABA =0000001C                M spar3	=	op3
00011ABA =0000001C                M spar4	=	op4
00011ABA                            	spAmpMod	$00, $00, $00, $00
00011ABA =00000000                M spam1	=	op1
00011ABA =00000000                M spam2	=	op2
00011ABA =00000000                M spam3	=	op3
00011ABA =00000000                M spam4	=	op4
00011ABA                            	spSustainRt	$0E, $11, $11, $11
00011ABA =0000000E                M spsr1	=	op1
00011ABA =00000011                M spsr2	=	op2
00011ABA =00000011                M spsr3	=	op3
00011ABA =00000011                M spsr4	=	op4
00011ABA                            	spDecayRt	$09, $06, $0A, $0A
00011ABA =00000009                M spdr1	=	op1
00011ABA =00000006                M spdr2	=	op2
00011ABA =0000000A                M spdr3	=	op3
00011ABA =0000000A                M spdr4	=	op4
00011ABA                            	spSustainLv	$04, $03, $03, $03
00011ABA =00000004                M spsl1	=	op1
00011ABA =00000003                M spsl2	=	op2
00011ABA =00000003                M spsl3	=	op3
00011ABA =00000003                M spsl4	=	op4
00011ABA                            	spReleaseRt	$0F, $0F, $0F, $0F
00011ABA =0000000F                M sprr1	=	op1
00011ABA =0000000F                M sprr2	=	op2
00011ABA =0000000F                M sprr3	=	op3
00011ABA =0000000F                M sprr4	=	op4
00011ABA                            	spSSGEG		$00, $00, $00, $00
00011ABA =00000000                M spss1	=	op1
00011ABA =00000000                M spss2	=	op2
00011ABA =00000000                M spss3	=	op3
00011ABA =00000000                M spss4	=	op4
00011ABA                            	spTotalLv2	$1F, $2B, $00, $00
00011ABA =0000001F                M sptl1	=	op1
00011ABA =0000002B                M sptl2	=	op2
00011ABA =00000000                M sptl3	=	op3
00011ABA =00000000                M sptl4	=	op4
00011ABA 3C                       M 	dc.b	(spfe<<3)+spal
00011ABB 0501 0A01                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011ABF 565C 5C5C                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011AC3 0E11 1111                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011AC7 090A 060A                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011ACB 4F3F 3F3F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011ACF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011AD3 1F00 2B00                M 	dc.b	sptl1,sptl3,sptl2,sptl4
00011AD7 4E41 54                  M 	dc.b	'NAT'
00011ADA                            
00011ADA                            	; Patch $0E
00011ADA                            	; $05
00011ADA                            	; $00, $00, $00, $00,	$1F, $1F, $1F, $1F
00011ADA                            	; $12, $0C, $0C, $0C,	$12, $08, $08, $08
00011ADA                            	; $1F, $5F, $5F, $5F,	$07, $00, $00, $00
00011ADA                            	spAlgorithm	$05
00011ADA =0000000F                M spatnum	=	spatnum+1
00011ADA =00000005                M spal	=	val
00011ADA                            	spFeedback	$00
00011ADA =00000000                M spfe	=	val
00011ADA                            	spDetune	$00, $00, $00, $00
00011ADA =00000000                M spde1	=	op1
00011ADA =00000000                M spde2	=	op2
00011ADA =00000000                M spde3	=	op3
00011ADA =00000000                M spde4	=	op4
00011ADA                            	spMultiple	$00, $00, $00, $00
00011ADA =00000000                M spmu1	=	op1
00011ADA =00000000                M spmu2	=	op2
00011ADA =00000000                M spmu3	=	op3
00011ADA =00000000                M spmu4	=	op4
00011ADA                            	spRateScale	$00, $00, $00, $00
00011ADA =00000000                M sprs1	=	op1
00011ADA =00000000                M sprs2	=	op2
00011ADA =00000000                M sprs3	=	op3
00011ADA =00000000                M sprs4	=	op4
00011ADA                            	spAttackRt	$1F, $1F, $1F, $1F
00011ADA =0000001F                M spar1	=	op1
00011ADA =0000001F                M spar2	=	op2
00011ADA =0000001F                M spar3	=	op3
00011ADA =0000001F                M spar4	=	op4
00011ADA                            	spAmpMod	$00, $00, $00, $00
00011ADA =00000000                M spam1	=	op1
00011ADA =00000000                M spam2	=	op2
00011ADA =00000000                M spam3	=	op3
00011ADA =00000000                M spam4	=	op4
00011ADA                            	spSustainRt	$12, $0C, $0C, $0C
00011ADA =00000012                M spsr1	=	op1
00011ADA =0000000C                M spsr2	=	op2
00011ADA =0000000C                M spsr3	=	op3
00011ADA =0000000C                M spsr4	=	op4
00011ADA                            	spDecayRt	$12, $08, $08, $08
00011ADA =00000012                M spdr1	=	op1
00011ADA =00000008                M spdr2	=	op2
00011ADA =00000008                M spdr3	=	op3
00011ADA =00000008                M spdr4	=	op4
00011ADA                            	spSustainLv	$01, $05, $05, $05
00011ADA =00000001                M spsl1	=	op1
00011ADA =00000005                M spsl2	=	op2
00011ADA =00000005                M spsl3	=	op3
00011ADA =00000005                M spsl4	=	op4
00011ADA                            	spReleaseRt	$0F, $0F, $0F, $0F
00011ADA =0000000F                M sprr1	=	op1
00011ADA =0000000F                M sprr2	=	op2
00011ADA =0000000F                M sprr3	=	op3
00011ADA =0000000F                M sprr4	=	op4
00011ADA                            	spSSGEG		$00, $00, $00, $00
00011ADA =00000000                M spss1	=	op1
00011ADA =00000000                M spss2	=	op2
00011ADA =00000000                M spss3	=	op3
00011ADA =00000000                M spss4	=	op4
00011ADA                            	spTotalLv2	$07, $00, $00, $00
00011ADA =00000007                M sptl1	=	op1
00011ADA =00000000                M sptl2	=	op2
00011ADA =00000000                M sptl3	=	op3
00011ADA =00000000                M sptl4	=	op4
00011ADA 05                       M 	dc.b	(spfe<<3)+spal
00011ADB 0000 0000                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011ADF 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011AE3 120C 0C0C                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011AE7 1208 0808                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011AEB 1F5F 5F5F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011AEF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011AF3 0700 0000                M 	dc.b	sptl1,sptl3,sptl2,sptl4
00011AF7 4E41 54                  M 	dc.b	'NAT'
00011AFA                            
00011AFA                            	; Patch $0F
00011AFA                            	; $39
00011AFA                            	; $21, $30, $10, $32,	$1F, $1F, $1F, $1F
00011AFA                            	; $05, $18, $09, $02,	$0B, $1F, $10, $05
00011AFA                            	; $1F, $2F, $4F, $2F,	$0E, $07, $04, $00
00011AFA                            	spAlgorithm	$01
00011AFA =00000010                M spatnum	=	spatnum+1
00011AFA =00000001                M spal	=	val
00011AFA                            	spFeedback	$07
00011AFA =00000007                M spfe	=	val
00011AFA                            	spDetune	$02, $01, $03, $03
00011AFA =00000002                M spde1	=	op1
00011AFA =00000001                M spde2	=	op2
00011AFA =00000003                M spde3	=	op3
00011AFA =00000003                M spde4	=	op4
00011AFA                            	spMultiple	$01, $00, $00, $02
00011AFA =00000001                M spmu1	=	op1
00011AFA =00000000                M spmu2	=	op2
00011AFA =00000000                M spmu3	=	op3
00011AFA =00000002                M spmu4	=	op4
00011AFA                            	spRateScale	$00, $00, $00, $00
00011AFA =00000000                M sprs1	=	op1
00011AFA =00000000                M sprs2	=	op2
00011AFA =00000000                M sprs3	=	op3
00011AFA =00000000                M sprs4	=	op4
00011AFA                            	spAttackRt	$1F, $1F, $1F, $1F
00011AFA =0000001F                M spar1	=	op1
00011AFA =0000001F                M spar2	=	op2
00011AFA =0000001F                M spar3	=	op3
00011AFA =0000001F                M spar4	=	op4
00011AFA                            	spAmpMod	$00, $00, $00, $00
00011AFA =00000000                M spam1	=	op1
00011AFA =00000000                M spam2	=	op2
00011AFA =00000000                M spam3	=	op3
00011AFA =00000000                M spam4	=	op4
00011AFA                            	spSustainRt	$05, $09, $18, $02
00011AFA =00000005                M spsr1	=	op1
00011AFA =00000009                M spsr2	=	op2
00011AFA =00000018                M spsr3	=	op3
00011AFA =00000002                M spsr4	=	op4
00011AFA                            	spDecayRt	$0B, $10, $1F, $05
00011AFA =0000000B                M spdr1	=	op1
00011AFA =00000010                M spdr2	=	op2
00011AFA =0000001F                M spdr3	=	op3
00011AFA =00000005                M spdr4	=	op4
00011AFA                            	spSustainLv	$01, $04, $02, $02
00011AFA =00000001                M spsl1	=	op1
00011AFA =00000004                M spsl2	=	op2
00011AFA =00000002                M spsl3	=	op3
00011AFA =00000002                M spsl4	=	op4
00011AFA                            	spReleaseRt	$0F, $0F, $0F, $0F
00011AFA =0000000F                M sprr1	=	op1
00011AFA =0000000F                M sprr2	=	op2
00011AFA =0000000F                M sprr3	=	op3
00011AFA =0000000F                M sprr4	=	op4
00011AFA                            	spSSGEG		$00, $00, $00, $00
00011AFA =00000000                M spss1	=	op1
00011AFA =00000000                M spss2	=	op2
00011AFA =00000000                M spss3	=	op3
00011AFA =00000000                M spss4	=	op4
00011AFA                            	spTotalLv	$0E, $04, $07, $00
00011AFA =0000000E                M sptl1	=	op1
00011AFA =00000004                M sptl2	=	op2
00011AFA =00000007                M sptl3	=	op3
00011AFA =00000000                M sptl4	=	op4
00011AFA 39                       M 	dc.b	(spfe<<3)+spal
00011AFB =00000080                M sptlmask4	set	$80
00011AFB =00000000                M sptlmask2	set	((spal>=5)<<7)
00011AFB =00000000                M sptlmask3	set	((spal>=4)<<7)
00011AFB =00000000                M sptlmask1	set	((spal=7)<<7)
00011AFB 2130 1032                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011AFF 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011B03 0518 0902                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011B07 0B1F 1005                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011B0B 1F2F 4F2F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011B0F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011B13 0E07 0480                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011B17 4E41 54                  M 	dc.b	'NAT'
00011B1A                            
00011B1A                            	; Patch $10
00011B1A                            	; $35
00011B1A                            	; $14, $1A, $04, $09,	$0E, $10, $11, $0E
00011B1A                            	; $0C, $15, $03, $06,	$16, $0E, $09, $10
00011B1A                            	; $2F, $2F, $4F, $4F,	$2F, $12, $12, $80
00011B1A                            	spAlgorithm	$05
00011B1A =00000011                M spatnum	=	spatnum+1
00011B1A =00000005                M spal	=	val
00011B1A                            	spFeedback	$06
00011B1A =00000006                M spfe	=	val
00011B1A                            	spDetune	$01, $00, $01, $00
00011B1A =00000001                M spde1	=	op1
00011B1A =00000000                M spde2	=	op2
00011B1A =00000001                M spde3	=	op3
00011B1A =00000000                M spde4	=	op4
00011B1A                            	spMultiple	$04, $04, $0A, $09
00011B1A =00000004                M spmu1	=	op1
00011B1A =00000004                M spmu2	=	op2
00011B1A =0000000A                M spmu3	=	op3
00011B1A =00000009                M spmu4	=	op4
00011B1A                            	spRateScale	$00, $00, $00, $00
00011B1A =00000000                M sprs1	=	op1
00011B1A =00000000                M sprs2	=	op2
00011B1A =00000000                M sprs3	=	op3
00011B1A =00000000                M sprs4	=	op4
00011B1A                            	spAttackRt	$0E, $11, $10, $0E
00011B1A =0000000E                M spar1	=	op1
00011B1A =00000011                M spar2	=	op2
00011B1A =00000010                M spar3	=	op3
00011B1A =0000000E                M spar4	=	op4
00011B1A                            	spAmpMod	$00, $00, $00, $00
00011B1A =00000000                M spam1	=	op1
00011B1A =00000000                M spam2	=	op2
00011B1A =00000000                M spam3	=	op3
00011B1A =00000000                M spam4	=	op4
00011B1A                            	spSustainRt	$0C, $03, $15, $06
00011B1A =0000000C                M spsr1	=	op1
00011B1A =00000003                M spsr2	=	op2
00011B1A =00000015                M spsr3	=	op3
00011B1A =00000006                M spsr4	=	op4
00011B1A                            	spDecayRt	$16, $09, $0E, $10
00011B1A =00000016                M spdr1	=	op1
00011B1A =00000009                M spdr2	=	op2
00011B1A =0000000E                M spdr3	=	op3
00011B1A =00000010                M spdr4	=	op4
00011B1A                            	spSustainLv	$02, $04, $02, $04
00011B1A =00000002                M spsl1	=	op1
00011B1A =00000004                M spsl2	=	op2
00011B1A =00000002                M spsl3	=	op3
00011B1A =00000004                M spsl4	=	op4
00011B1A                            	spReleaseRt	$0F, $0F, $0F, $0F
00011B1A =0000000F                M sprr1	=	op1
00011B1A =0000000F                M sprr2	=	op2
00011B1A =0000000F                M sprr3	=	op3
00011B1A =0000000F                M sprr4	=	op4
00011B1A                            	spSSGEG		$00, $00, $00, $00
00011B1A =00000000                M spss1	=	op1
00011B1A =00000000                M spss2	=	op2
00011B1A =00000000                M spss3	=	op3
00011B1A =00000000                M spss4	=	op4
00011B1A                            	spTotalLv2	$2F, $12, $12, $80
00011B1A =0000002F                M sptl1	=	op1
00011B1A =00000012                M sptl2	=	op2
00011B1A =00000012                M sptl3	=	op3
00011B1A =00000080                M sptl4	=	op4
00011B1A 35                       M 	dc.b	(spfe<<3)+spal
00011B1B 141A 0409                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011B1F 0E10 110E                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011B23 0C15 0306                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011B27 160E 0910                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011B2B 2F2F 4F4F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011B2F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011B33 2F12 1280                M 	dc.b	sptl1,sptl3,sptl2,sptl4
00011B37 4E41 54                  M 	dc.b	'NAT'
00011B3A                            
00011B3A                            	; Patch $11
00011B3A                            	; $38
00011B3A                            	; $01, $00, $00, $00,	$1F, $1F, $1F, $1F
00011B3A                            	; $09, $09, $09, $0B,	$00, $00, $00, $00
00011B3A                            	; $FF, $FF, $FF, $FF,	$5C, $22, $27, $80
00011B3A                            	spAlgorithm	$00
00011B3A =00000012                M spatnum	=	spatnum+1
00011B3A =00000000                M spal	=	val
00011B3A                            	spFeedback	$07
00011B3A =00000007                M spfe	=	val
00011B3A                            	spDetune	$00, $00, $00, $00
00011B3A =00000000                M spde1	=	op1
00011B3A =00000000                M spde2	=	op2
00011B3A =00000000                M spde3	=	op3
00011B3A =00000000                M spde4	=	op4
00011B3A                            	spMultiple	$01, $00, $00, $00
00011B3A =00000001                M spmu1	=	op1
00011B3A =00000000                M spmu2	=	op2
00011B3A =00000000                M spmu3	=	op3
00011B3A =00000000                M spmu4	=	op4
00011B3A                            	spRateScale	$00, $00, $00, $00
00011B3A =00000000                M sprs1	=	op1
00011B3A =00000000                M sprs2	=	op2
00011B3A =00000000                M sprs3	=	op3
00011B3A =00000000                M sprs4	=	op4
00011B3A                            	spAttackRt	$1F, $1F, $1F, $1F
00011B3A =0000001F                M spar1	=	op1
00011B3A =0000001F                M spar2	=	op2
00011B3A =0000001F                M spar3	=	op3
00011B3A =0000001F                M spar4	=	op4
00011B3A                            	spAmpMod	$00, $00, $00, $00
00011B3A =00000000                M spam1	=	op1
00011B3A =00000000                M spam2	=	op2
00011B3A =00000000                M spam3	=	op3
00011B3A =00000000                M spam4	=	op4
00011B3A                            	spSustainRt	$09, $09, $09, $0B
00011B3A =00000009                M spsr1	=	op1
00011B3A =00000009                M spsr2	=	op2
00011B3A =00000009                M spsr3	=	op3
00011B3A =0000000B                M spsr4	=	op4
00011B3A                            	spDecayRt	$00, $00, $00, $00
00011B3A =00000000                M spdr1	=	op1
00011B3A =00000000                M spdr2	=	op2
00011B3A =00000000                M spdr3	=	op3
00011B3A =00000000                M spdr4	=	op4
00011B3A                            	spSustainLv	$0F, $0F, $0F, $0F
00011B3A =0000000F                M spsl1	=	op1
00011B3A =0000000F                M spsl2	=	op2
00011B3A =0000000F                M spsl3	=	op3
00011B3A =0000000F                M spsl4	=	op4
00011B3A                            	spReleaseRt	$0F, $0F, $0F, $0F
00011B3A =0000000F                M sprr1	=	op1
00011B3A =0000000F                M sprr2	=	op2
00011B3A =0000000F                M sprr3	=	op3
00011B3A =0000000F                M sprr4	=	op4
00011B3A                            	spSSGEG		$00, $00, $00, $00
00011B3A =00000000                M spss1	=	op1
00011B3A =00000000                M spss2	=	op2
00011B3A =00000000                M spss3	=	op3
00011B3A =00000000                M spss4	=	op4
00011B3A                            	spTotalLv2	$5C, $27, $22, $80
00011B3A =0000005C                M sptl1	=	op1
00011B3A =00000027                M sptl2	=	op2
00011B3A =00000022                M sptl3	=	op3
00011B3A =00000080                M sptl4	=	op4
00011B3A 38                       M 	dc.b	(spfe<<3)+spal
00011B3B 0100 0000                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011B3F 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011B43 0909 090B                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011B47 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011B4B FFFF FFFF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011B4F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011B53 5C22 2780                M 	dc.b	sptl1,sptl3,sptl2,sptl4
00011B57 4E41 54                  M 	dc.b	'NAT'
00011B5A                            
00011B5A                            	; Patch $12
00011B5A                            	; $3B
00011B5A                            	; $3C, $39, $30, $31,	$DF, $1F, $1F, $DF
00011B5A                            	; $04, $05, $04, $01,	$04, $04, $04, $02
00011B5A                            	; $FF, $0F, $1F, $AF,	$29, $20, $0F, $00
00011B5A                            	spAlgorithm	$03
00011B5A =00000013                M spatnum	=	spatnum+1
00011B5A =00000003                M spal	=	val
00011B5A                            	spFeedback	$07
00011B5A =00000007                M spfe	=	val
00011B5A                            	spDetune	$03, $03, $03, $03
00011B5A =00000003                M spde1	=	op1
00011B5A =00000003                M spde2	=	op2
00011B5A =00000003                M spde3	=	op3
00011B5A =00000003                M spde4	=	op4
00011B5A                            	spMultiple	$0C, $00, $09, $01
00011B5A =0000000C                M spmu1	=	op1
00011B5A =00000000                M spmu2	=	op2
00011B5A =00000009                M spmu3	=	op3
00011B5A =00000001                M spmu4	=	op4
00011B5A                            	spRateScale	$03, $00, $00, $03
00011B5A =00000003                M sprs1	=	op1
00011B5A =00000000                M sprs2	=	op2
00011B5A =00000000                M sprs3	=	op3
00011B5A =00000003                M sprs4	=	op4
00011B5A                            	spAttackRt	$1F, $1F, $1F, $1F
00011B5A =0000001F                M spar1	=	op1
00011B5A =0000001F                M spar2	=	op2
00011B5A =0000001F                M spar3	=	op3
00011B5A =0000001F                M spar4	=	op4
00011B5A                            	spAmpMod	$00, $00, $00, $00
00011B5A =00000000                M spam1	=	op1
00011B5A =00000000                M spam2	=	op2
00011B5A =00000000                M spam3	=	op3
00011B5A =00000000                M spam4	=	op4
00011B5A                            	spSustainRt	$04, $04, $05, $01
00011B5A =00000004                M spsr1	=	op1
00011B5A =00000004                M spsr2	=	op2
00011B5A =00000005                M spsr3	=	op3
00011B5A =00000001                M spsr4	=	op4
00011B5A                            	spDecayRt	$04, $04, $04, $02
00011B5A =00000004                M spdr1	=	op1
00011B5A =00000004                M spdr2	=	op2
00011B5A =00000004                M spdr3	=	op3
00011B5A =00000002                M spdr4	=	op4
00011B5A                            	spSustainLv	$0F, $01, $00, $0A
00011B5A =0000000F                M spsl1	=	op1
00011B5A =00000001                M spsl2	=	op2
00011B5A =00000000                M spsl3	=	op3
00011B5A =0000000A                M spsl4	=	op4
00011B5A                            	spReleaseRt	$0F, $0F, $0F, $0F
00011B5A =0000000F                M sprr1	=	op1
00011B5A =0000000F                M sprr2	=	op2
00011B5A =0000000F                M sprr3	=	op3
00011B5A =0000000F                M sprr4	=	op4
00011B5A                            	spSSGEG		$00, $00, $00, $00
00011B5A =00000000                M spss1	=	op1
00011B5A =00000000                M spss2	=	op2
00011B5A =00000000                M spss3	=	op3
00011B5A =00000000                M spss4	=	op4
00011B5A                            	spTotalLv2	$29, $0F, $20, $00
00011B5A =00000029                M sptl1	=	op1
00011B5A =0000000F                M sptl2	=	op2
00011B5A =00000020                M sptl3	=	op3
00011B5A =00000000                M sptl4	=	op4
00011B5A 3B                       M 	dc.b	(spfe<<3)+spal
00011B5B 3C39 3031                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011B5F DF1F 1FDF                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011B63 0405 0401                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011B67 0404 0402                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011B6B FF0F 1FAF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011B6F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011B73 2920 0F00                M 	dc.b	sptl1,sptl3,sptl2,sptl4
00011B77 4E41 54                  M 	dc.b	'NAT'
00011B7A                            
00011B7A                            	; Patch $13
00011B7A                            	; $3A
00011B7A                            	; $21, $30, $10, $32,	$1F, $1F, $1F, $1F
00011B7A                            	; $05, $18, $09, $02,	$06, $0F, $06, $02
00011B7A                            	; $1F, $2F, $4F, $2F,	$0F, $0E, $0E, $00
00011B7A                            	spAlgorithm	$02
00011B7A =00000014                M spatnum	=	spatnum+1
00011B7A =00000002                M spal	=	val
00011B7A                            	spFeedback	$07
00011B7A =00000007                M spfe	=	val
00011B7A                            	spDetune	$02, $01, $03, $03
00011B7A =00000002                M spde1	=	op1
00011B7A =00000001                M spde2	=	op2
00011B7A =00000003                M spde3	=	op3
00011B7A =00000003                M spde4	=	op4
00011B7A                            	spMultiple	$01, $00, $00, $02
00011B7A =00000001                M spmu1	=	op1
00011B7A =00000000                M spmu2	=	op2
00011B7A =00000000                M spmu3	=	op3
00011B7A =00000002                M spmu4	=	op4
00011B7A                            	spRateScale	$00, $00, $00, $00
00011B7A =00000000                M sprs1	=	op1
00011B7A =00000000                M sprs2	=	op2
00011B7A =00000000                M sprs3	=	op3
00011B7A =00000000                M sprs4	=	op4
00011B7A                            	spAttackRt	$1F, $1F, $1F, $1F
00011B7A =0000001F                M spar1	=	op1
00011B7A =0000001F                M spar2	=	op2
00011B7A =0000001F                M spar3	=	op3
00011B7A =0000001F                M spar4	=	op4
00011B7A                            	spAmpMod	$00, $00, $00, $00
00011B7A =00000000                M spam1	=	op1
00011B7A =00000000                M spam2	=	op2
00011B7A =00000000                M spam3	=	op3
00011B7A =00000000                M spam4	=	op4
00011B7A                            	spSustainRt	$05, $09, $18, $02
00011B7A =00000005                M spsr1	=	op1
00011B7A =00000009                M spsr2	=	op2
00011B7A =00000018                M spsr3	=	op3
00011B7A =00000002                M spsr4	=	op4
00011B7A                            	spDecayRt	$06, $06, $0F, $02
00011B7A =00000006                M spdr1	=	op1
00011B7A =00000006                M spdr2	=	op2
00011B7A =0000000F                M spdr3	=	op3
00011B7A =00000002                M spdr4	=	op4
00011B7A                            	spSustainLv	$01, $04, $02, $02
00011B7A =00000001                M spsl1	=	op1
00011B7A =00000004                M spsl2	=	op2
00011B7A =00000002                M spsl3	=	op3
00011B7A =00000002                M spsl4	=	op4
00011B7A                            	spReleaseRt	$0F, $0F, $0F, $0F
00011B7A =0000000F                M sprr1	=	op1
00011B7A =0000000F                M sprr2	=	op2
00011B7A =0000000F                M sprr3	=	op3
00011B7A =0000000F                M sprr4	=	op4
00011B7A                            	spSSGEG		$00, $00, $00, $00
00011B7A =00000000                M spss1	=	op1
00011B7A =00000000                M spss2	=	op2
00011B7A =00000000                M spss3	=	op3
00011B7A =00000000                M spss4	=	op4
00011B7A                            	spTotalLv2	$0F, $0E, $0E, $00
00011B7A =0000000F                M sptl1	=	op1
00011B7A =0000000E                M sptl2	=	op2
00011B7A =0000000E                M sptl3	=	op3
00011B7A =00000000                M sptl4	=	op4
00011B7A 3A                       M 	dc.b	(spfe<<3)+spal
00011B7B 2130 1032                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011B7F 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011B83 0518 0902                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011B87 060F 0602                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011B8B 1F2F 4F2F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011B8F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011B93 0F0E 0E00                M 	dc.b	sptl1,sptl3,sptl2,sptl4
00011B97 4E41 54                  M 	dc.b	'NAT'
00011B9A                            
00011B9A                            	; Patch $14
00011B9A                            	; $07
00011B9A                            	; $04, $04, $05, $04,	$1F, $1F, $15, $15
00011B9A                            	; $00, $00, $00, $00,	$00, $00, $00, $00
00011B9A                            	; $1F, $1F, $1F, $1F,	$7F, $7F, $80, $80
00011B9A                            	spAlgorithm	$07
00011B9A =00000015                M spatnum	=	spatnum+1
00011B9A =00000007                M spal	=	val
00011B9A                            	spFeedback	$00
00011B9A =00000000                M spfe	=	val
00011B9A                            	spDetune	$00, $00, $00, $00
00011B9A =00000000                M spde1	=	op1
00011B9A =00000000                M spde2	=	op2
00011B9A =00000000                M spde3	=	op3
00011B9A =00000000                M spde4	=	op4
00011B9A                            	spMultiple	$04, $05, $04, $04
00011B9A =00000004                M spmu1	=	op1
00011B9A =00000005                M spmu2	=	op2
00011B9A =00000004                M spmu3	=	op3
00011B9A =00000004                M spmu4	=	op4
00011B9A                            	spRateScale	$00, $00, $00, $00
00011B9A =00000000                M sprs1	=	op1
00011B9A =00000000                M sprs2	=	op2
00011B9A =00000000                M sprs3	=	op3
00011B9A =00000000                M sprs4	=	op4
00011B9A                            	spAttackRt	$1F, $15, $1F, $15
00011B9A =0000001F                M spar1	=	op1
00011B9A =00000015                M spar2	=	op2
00011B9A =0000001F                M spar3	=	op3
00011B9A =00000015                M spar4	=	op4
00011B9A                            	spAmpMod	$00, $00, $00, $00
00011B9A =00000000                M spam1	=	op1
00011B9A =00000000                M spam2	=	op2
00011B9A =00000000                M spam3	=	op3
00011B9A =00000000                M spam4	=	op4
00011B9A                            	spSustainRt	$00, $00, $00, $00
00011B9A =00000000                M spsr1	=	op1
00011B9A =00000000                M spsr2	=	op2
00011B9A =00000000                M spsr3	=	op3
00011B9A =00000000                M spsr4	=	op4
00011B9A                            	spDecayRt	$00, $00, $00, $00
00011B9A =00000000                M spdr1	=	op1
00011B9A =00000000                M spdr2	=	op2
00011B9A =00000000                M spdr3	=	op3
00011B9A =00000000                M spdr4	=	op4
00011B9A                            	spSustainLv	$01, $01, $01, $01
00011B9A =00000001                M spsl1	=	op1
00011B9A =00000001                M spsl2	=	op2
00011B9A =00000001                M spsl3	=	op3
00011B9A =00000001                M spsl4	=	op4
00011B9A                            	spReleaseRt	$0F, $0F, $0F, $0F
00011B9A =0000000F                M sprr1	=	op1
00011B9A =0000000F                M sprr2	=	op2
00011B9A =0000000F                M sprr3	=	op3
00011B9A =0000000F                M sprr4	=	op4
00011B9A                            	spSSGEG		$00, $00, $00, $00
00011B9A =00000000                M spss1	=	op1
00011B9A =00000000                M spss2	=	op2
00011B9A =00000000                M spss3	=	op3
00011B9A =00000000                M spss4	=	op4
00011B9A                            	spTotalLv2	$7F, $80, $7F, $80
00011B9A =0000007F                M sptl1	=	op1
00011B9A =00000080                M sptl2	=	op2
00011B9A =0000007F                M sptl3	=	op3
00011B9A =00000080                M sptl4	=	op4
00011B9A 07                       M 	dc.b	(spfe<<3)+spal
00011B9B 0404 0504                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011B9F 1F1F 1515                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011BA3 0000 0000                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011BA7 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011BAB 1F1F 1F1F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011BAF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011BB3 7F7F 8080                M 	dc.b	sptl1,sptl3,sptl2,sptl4
00011BB7 4E41 54                  M 	dc.b	'NAT'
00011BBA                            
00011BBA                            	; Patch $15
00011BBA                            	; $00
00011BBA                            	; $00, $03, $02, $00,	$D9, $DF, $1F, $1F
00011BBA                            	; $12, $11, $14, $0F,	$0A, $00, $0A, $0D
00011BBA                            	; $FF, $FF, $FF, $FF,	$22, $07, $27, $00
00011BBA                            	spAlgorithm	$00
00011BBA =00000016                M spatnum	=	spatnum+1
00011BBA =00000000                M spal	=	val
00011BBA                            	spFeedback	$00
00011BBA =00000000                M spfe	=	val
00011BBA                            	spDetune	$00, $00, $00, $00
00011BBA =00000000                M spde1	=	op1
00011BBA =00000000                M spde2	=	op2
00011BBA =00000000                M spde3	=	op3
00011BBA =00000000                M spde4	=	op4
00011BBA                            	spMultiple	$00, $02, $03, $00
00011BBA =00000000                M spmu1	=	op1
00011BBA =00000002                M spmu2	=	op2
00011BBA =00000003                M spmu3	=	op3
00011BBA =00000000                M spmu4	=	op4
00011BBA                            	spRateScale	$03, $00, $03, $00
00011BBA =00000003                M sprs1	=	op1
00011BBA =00000000                M sprs2	=	op2
00011BBA =00000003                M sprs3	=	op3
00011BBA =00000000                M sprs4	=	op4
00011BBA                            	spAttackRt	$19, $1F, $1F, $1F
00011BBA =00000019                M spar1	=	op1
00011BBA =0000001F                M spar2	=	op2
00011BBA =0000001F                M spar3	=	op3
00011BBA =0000001F                M spar4	=	op4
00011BBA                            	spAmpMod	$00, $00, $00, $00
00011BBA =00000000                M spam1	=	op1
00011BBA =00000000                M spam2	=	op2
00011BBA =00000000                M spam3	=	op3
00011BBA =00000000                M spam4	=	op4
00011BBA                            	spSustainRt	$12, $14, $11, $0F
00011BBA =00000012                M spsr1	=	op1
00011BBA =00000014                M spsr2	=	op2
00011BBA =00000011                M spsr3	=	op3
00011BBA =0000000F                M spsr4	=	op4
00011BBA                            	spDecayRt	$0A, $0A, $00, $0D
00011BBA =0000000A                M spdr1	=	op1
00011BBA =0000000A                M spdr2	=	op2
00011BBA =00000000                M spdr3	=	op3
00011BBA =0000000D                M spdr4	=	op4
00011BBA                            	spSustainLv	$0F, $0F, $0F, $0F
00011BBA =0000000F                M spsl1	=	op1
00011BBA =0000000F                M spsl2	=	op2
00011BBA =0000000F                M spsl3	=	op3
00011BBA =0000000F                M spsl4	=	op4
00011BBA                            	spReleaseRt	$0F, $0F, $0F, $0F
00011BBA =0000000F                M sprr1	=	op1
00011BBA =0000000F                M sprr2	=	op2
00011BBA =0000000F                M sprr3	=	op3
00011BBA =0000000F                M sprr4	=	op4
00011BBA                            	spSSGEG		$00, $00, $00, $00
00011BBA =00000000                M spss1	=	op1
00011BBA =00000000                M spss2	=	op2
00011BBA =00000000                M spss3	=	op3
00011BBA =00000000                M spss4	=	op4
00011BBA                            	spTotalLv2	$22, $27, $07, $00
00011BBA =00000022                M sptl1	=	op1
00011BBA =00000027                M sptl2	=	op2
00011BBA =00000007                M sptl3	=	op3
00011BBA =00000000                M sptl4	=	op4
00011BBA 00                       M 	dc.b	(spfe<<3)+spal
00011BBB 0003 0200                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011BBF D9DF 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011BC3 1211 140F                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011BC7 0A00 0A0D                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011BCB FFFF FFFF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011BCF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011BD3 2207 2700                M 	dc.b	sptl1,sptl3,sptl2,sptl4
00011BD7 4E41 54                  M 	dc.b	'NAT'
00011BDA                            
00011BDA                            	; Patch $16
00011BDA                            	; $20
00011BDA                            	; $36, $35, $30, $31,	$41, $49, $3B, $4B
00011BDA                            	; $09, $06, $09, $08,	$01, $03, $02, $A9
00011BDA                            	; $0F, $0F, $0F, $0F,	$29, $27, $23, $00
00011BDA                            	spAlgorithm	$00
00011BDA =00000017                M spatnum	=	spatnum+1
00011BDA =00000000                M spal	=	val
00011BDA                            	spFeedback	$04
00011BDA =00000004                M spfe	=	val
00011BDA                            	spDetune	$03, $03, $03, $03
00011BDA =00000003                M spde1	=	op1
00011BDA =00000003                M spde2	=	op2
00011BDA =00000003                M spde3	=	op3
00011BDA =00000003                M spde4	=	op4
00011BDA                            	spMultiple	$06, $00, $05, $01
00011BDA =00000006                M spmu1	=	op1
00011BDA =00000000                M spmu2	=	op2
00011BDA =00000005                M spmu3	=	op3
00011BDA =00000001                M spmu4	=	op4
00011BDA                            	spRateScale	$01, $00, $01, $01
00011BDA =00000001                M sprs1	=	op1
00011BDA =00000000                M sprs2	=	op2
00011BDA =00000001                M sprs3	=	op3
00011BDA =00000001                M sprs4	=	op4
00011BDA                            	spAttackRt	$01, $1B, $09, $0B
00011BDA =00000001                M spar1	=	op1
00011BDA =0000001B                M spar2	=	op2
00011BDA =00000009                M spar3	=	op3
00011BDA =0000000B                M spar4	=	op4
00011BDA                            	spAmpMod	$00, $00, $00, $00
00011BDA =00000000                M spam1	=	op1
00011BDA =00000000                M spam2	=	op2
00011BDA =00000000                M spam3	=	op3
00011BDA =00000000                M spam4	=	op4
00011BDA                            	spSustainRt	$09, $09, $06, $08
00011BDA =00000009                M spsr1	=	op1
00011BDA =00000009                M spsr2	=	op2
00011BDA =00000006                M spsr3	=	op3
00011BDA =00000008                M spsr4	=	op4
00011BDA                            	spDecayRt	$01, $02, $03, $A9
00011BDA =00000001                M spdr1	=	op1
00011BDA =00000002                M spdr2	=	op2
00011BDA =00000003                M spdr3	=	op3
00011BDA =000000A9                M spdr4	=	op4
00011BDA                            	spSustainLv	$00, $00, $00, $00
00011BDA =00000000                M spsl1	=	op1
00011BDA =00000000                M spsl2	=	op2
00011BDA =00000000                M spsl3	=	op3
00011BDA =00000000                M spsl4	=	op4
00011BDA                            	spReleaseRt	$0F, $0F, $0F, $0F
00011BDA =0000000F                M sprr1	=	op1
00011BDA =0000000F                M sprr2	=	op2
00011BDA =0000000F                M sprr3	=	op3
00011BDA =0000000F                M sprr4	=	op4
00011BDA                            	spSSGEG		$00, $00, $00, $00
00011BDA =00000000                M spss1	=	op1
00011BDA =00000000                M spss2	=	op2
00011BDA =00000000                M spss3	=	op3
00011BDA =00000000                M spss4	=	op4
00011BDA                            	spTotalLv2	$29, $23, $27, $00
00011BDA =00000029                M sptl1	=	op1
00011BDA =00000023                M sptl2	=	op2
00011BDA =00000027                M sptl3	=	op3
00011BDA =00000000                M sptl4	=	op4
00011BDA 20                       M 	dc.b	(spfe<<3)+spal
00011BDB 3635 3031                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011BDF 4149 1B4B                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011BE3 0906 0908                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011BE7 0103 02A9                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011BEB 0F0F 0F0F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011BEF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011BF3 2927 2300                M 	dc.b	sptl1,sptl3,sptl2,sptl4
00011BF7 4E41 54                  M 	dc.b	'NAT'
00011BFA                            
00011BFA                            	; Patch $17
00011BFA                            	; $30
00011BFA                            	; $30, $30, $30, $30,	$9E, $D8, $DC, $DC
00011BFA                            	; $0E, $0A, $04, $05,	$08, $08, $08, $08
00011BFA                            	; $BF, $BF, $BF, $BF,	$10, $3A, $10, $00
00011BFA                            	spAlgorithm	$00
00011BFA =00000018                M spatnum	=	spatnum+1
00011BFA =00000000                M spal	=	val
00011BFA                            	spFeedback	$06
00011BFA =00000006                M spfe	=	val
00011BFA                            	spDetune	$03, $03, $03, $03
00011BFA =00000003                M spde1	=	op1
00011BFA =00000003                M spde2	=	op2
00011BFA =00000003                M spde3	=	op3
00011BFA =00000003                M spde4	=	op4
00011BFA                            	spMultiple	$00, $00, $00, $00
00011BFA =00000000                M spmu1	=	op1
00011BFA =00000000                M spmu2	=	op2
00011BFA =00000000                M spmu3	=	op3
00011BFA =00000000                M spmu4	=	op4
00011BFA                            	spRateScale	$02, $03, $03, $03
00011BFA =00000002                M sprs1	=	op1
00011BFA =00000003                M sprs2	=	op2
00011BFA =00000003                M sprs3	=	op3
00011BFA =00000003                M sprs4	=	op4
00011BFA                            	spAttackRt	$1E, $1C, $18, $1C
00011BFA =0000001E                M spar1	=	op1
00011BFA =0000001C                M spar2	=	op2
00011BFA =00000018                M spar3	=	op3
00011BFA =0000001C                M spar4	=	op4
00011BFA                            	spAmpMod	$00, $00, $00, $00
00011BFA =00000000                M spam1	=	op1
00011BFA =00000000                M spam2	=	op2
00011BFA =00000000                M spam3	=	op3
00011BFA =00000000                M spam4	=	op4
00011BFA                            	spSustainRt	$0E, $04, $0A, $05
00011BFA =0000000E                M spsr1	=	op1
00011BFA =00000004                M spsr2	=	op2
00011BFA =0000000A                M spsr3	=	op3
00011BFA =00000005                M spsr4	=	op4
00011BFA                            	spDecayRt	$08, $08, $08, $08
00011BFA =00000008                M spdr1	=	op1
00011BFA =00000008                M spdr2	=	op2
00011BFA =00000008                M spdr3	=	op3
00011BFA =00000008                M spdr4	=	op4
00011BFA                            	spSustainLv	$0B, $0B, $0B, $0B
00011BFA =0000000B                M spsl1	=	op1
00011BFA =0000000B                M spsl2	=	op2
00011BFA =0000000B                M spsl3	=	op3
00011BFA =0000000B                M spsl4	=	op4
00011BFA                            	spReleaseRt	$0F, $0F, $0F, $0F
00011BFA =0000000F                M sprr1	=	op1
00011BFA =0000000F                M sprr2	=	op2
00011BFA =0000000F                M sprr3	=	op3
00011BFA =0000000F                M sprr4	=	op4
00011BFA                            	spSSGEG		$00, $00, $00, $00
00011BFA =00000000                M spss1	=	op1
00011BFA =00000000                M spss2	=	op2
00011BFA =00000000                M spss3	=	op3
00011BFA =00000000                M spss4	=	op4
00011BFA                            	spTotalLv2	$10, $10, $3A, $00
00011BFA =00000010                M sptl1	=	op1
00011BFA =00000010                M sptl2	=	op2
00011BFA =0000003A                M sptl3	=	op3
00011BFA =00000000                M sptl4	=	op4
00011BFA 30                       M 	dc.b	(spfe<<3)+spal
00011BFB 3030 3030                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011BFF 9ED8 DCDC                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011C03 0E0A 0405                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011C07 0808 0808                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011C0B BFBF BFBF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011C0F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011C13 103A 1000                M 	dc.b	sptl1,sptl3,sptl2,sptl4
00011C17 4E41 54                  M 	dc.b	'NAT'
00011C1A                            
00011C1A                            	; Patch $18
00011C1A                            	; $04
00011C1A                            	; $00, $01, $00, $05,	$0F, $1F, $0F, $1F
00011C1A                            	; $00, $00, $00, $00,	$00, $00, $00, $00
00011C1A                            	; $8F, $8F, $8F, $8F,	$1F, $8D, $1F, $80
00011C1A                            	spAlgorithm	$04
00011C1A =00000019                M spatnum	=	spatnum+1
00011C1A =00000004                M spal	=	val
00011C1A                            	spFeedback	$00
00011C1A =00000000                M spfe	=	val
00011C1A                            	spDetune	$00, $00, $00, $00
00011C1A =00000000                M spde1	=	op1
00011C1A =00000000                M spde2	=	op2
00011C1A =00000000                M spde3	=	op3
00011C1A =00000000                M spde4	=	op4
00011C1A                            	spMultiple	$00, $00, $01, $05
00011C1A =00000000                M spmu1	=	op1
00011C1A =00000000                M spmu2	=	op2
00011C1A =00000001                M spmu3	=	op3
00011C1A =00000005                M spmu4	=	op4
00011C1A                            	spRateScale	$00, $00, $00, $00
00011C1A =00000000                M sprs1	=	op1
00011C1A =00000000                M sprs2	=	op2
00011C1A =00000000                M sprs3	=	op3
00011C1A =00000000                M sprs4	=	op4
00011C1A                            	spAttackRt	$0F, $0F, $1F, $1F
00011C1A =0000000F                M spar1	=	op1
00011C1A =0000000F                M spar2	=	op2
00011C1A =0000001F                M spar3	=	op3
00011C1A =0000001F                M spar4	=	op4
00011C1A                            	spAmpMod	$00, $00, $00, $00
00011C1A =00000000                M spam1	=	op1
00011C1A =00000000                M spam2	=	op2
00011C1A =00000000                M spam3	=	op3
00011C1A =00000000                M spam4	=	op4
00011C1A                            	spSustainRt	$00, $00, $00, $00
00011C1A =00000000                M spsr1	=	op1
00011C1A =00000000                M spsr2	=	op2
00011C1A =00000000                M spsr3	=	op3
00011C1A =00000000                M spsr4	=	op4
00011C1A                            	spDecayRt	$00, $00, $00, $00
00011C1A =00000000                M spdr1	=	op1
00011C1A =00000000                M spdr2	=	op2
00011C1A =00000000                M spdr3	=	op3
00011C1A =00000000                M spdr4	=	op4
00011C1A                            	spSustainLv	$08, $08, $08, $08
00011C1A =00000008                M spsl1	=	op1
00011C1A =00000008                M spsl2	=	op2
00011C1A =00000008                M spsl3	=	op3
00011C1A =00000008                M spsl4	=	op4
00011C1A                            	spReleaseRt	$0F, $0F, $0F, $0F
00011C1A =0000000F                M sprr1	=	op1
00011C1A =0000000F                M sprr2	=	op2
00011C1A =0000000F                M sprr3	=	op3
00011C1A =0000000F                M sprr4	=	op4
00011C1A                            	spSSGEG		$00, $00, $00, $00
00011C1A =00000000                M spss1	=	op1
00011C1A =00000000                M spss2	=	op2
00011C1A =00000000                M spss3	=	op3
00011C1A =00000000                M spss4	=	op4
00011C1A                            	spTotalLv2	$1F, $1F, $8D, $80
00011C1A =0000001F                M sptl1	=	op1
00011C1A =0000001F                M sptl2	=	op2
00011C1A =0000008D                M sptl3	=	op3
00011C1A =00000080                M sptl4	=	op4
00011C1A 04                       M 	dc.b	(spfe<<3)+spal
00011C1B 0001 0005                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011C1F 0F1F 0F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011C23 0000 0000                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011C27 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011C2B 8F8F 8F8F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011C2F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011C33 1F8D 1F80                M 	dc.b	sptl1,sptl3,sptl2,sptl4
00011C37 4E41 54                  M 	dc.b	'NAT'
00011C3A                            
00011C3A                            	; Patch $19
00011C3A                            	; $3C
00011C3A                            	; $05, $01, $0A, $01,	$56, $5C, $5C, $5C
00011C3A                            	; $0E, $11, $11, $11,	$09, $0A, $06, $0A
00011C3A                            	; $4F, $3F, $3F, $3F,	$17, $80, $20, $80
00011C3A                            	spAlgorithm	$04
00011C3A =0000001A                M spatnum	=	spatnum+1
00011C3A =00000004                M spal	=	val
00011C3A                            	spFeedback	$07
00011C3A =00000007                M spfe	=	val
00011C3A                            	spDetune	$00, $00, $00, $00
00011C3A =00000000                M spde1	=	op1
00011C3A =00000000                M spde2	=	op2
00011C3A =00000000                M spde3	=	op3
00011C3A =00000000                M spde4	=	op4
00011C3A                            	spMultiple	$05, $0A, $01, $01
00011C3A =00000005                M spmu1	=	op1
00011C3A =0000000A                M spmu2	=	op2
00011C3A =00000001                M spmu3	=	op3
00011C3A =00000001                M spmu4	=	op4
00011C3A                            	spRateScale	$01, $01, $01, $01
00011C3A =00000001                M sprs1	=	op1
00011C3A =00000001                M sprs2	=	op2
00011C3A =00000001                M sprs3	=	op3
00011C3A =00000001                M sprs4	=	op4
00011C3A                            	spAttackRt	$16, $1C, $1C, $1C
00011C3A =00000016                M spar1	=	op1
00011C3A =0000001C                M spar2	=	op2
00011C3A =0000001C                M spar3	=	op3
00011C3A =0000001C                M spar4	=	op4
00011C3A                            	spAmpMod	$00, $00, $00, $00
00011C3A =00000000                M spam1	=	op1
00011C3A =00000000                M spam2	=	op2
00011C3A =00000000                M spam3	=	op3
00011C3A =00000000                M spam4	=	op4
00011C3A                            	spSustainRt	$0E, $11, $11, $11
00011C3A =0000000E                M spsr1	=	op1
00011C3A =00000011                M spsr2	=	op2
00011C3A =00000011                M spsr3	=	op3
00011C3A =00000011                M spsr4	=	op4
00011C3A                            	spDecayRt	$09, $06, $0A, $0A
00011C3A =00000009                M spdr1	=	op1
00011C3A =00000006                M spdr2	=	op2
00011C3A =0000000A                M spdr3	=	op3
00011C3A =0000000A                M spdr4	=	op4
00011C3A                            	spSustainLv	$04, $03, $03, $03
00011C3A =00000004                M spsl1	=	op1
00011C3A =00000003                M spsl2	=	op2
00011C3A =00000003                M spsl3	=	op3
00011C3A =00000003                M spsl4	=	op4
00011C3A                            	spReleaseRt	$0F, $0F, $0F, $0F
00011C3A =0000000F                M sprr1	=	op1
00011C3A =0000000F                M sprr2	=	op2
00011C3A =0000000F                M sprr3	=	op3
00011C3A =0000000F                M sprr4	=	op4
00011C3A                            	spSSGEG		$00, $00, $00, $00
00011C3A =00000000                M spss1	=	op1
00011C3A =00000000                M spss2	=	op2
00011C3A =00000000                M spss3	=	op3
00011C3A =00000000                M spss4	=	op4
00011C3A                            	spTotalLv	$17, $20, $00, $00
00011C3A =00000017                M sptl1	=	op1
00011C3A =00000020                M sptl2	=	op2
00011C3A =00000000                M sptl3	=	op3
00011C3A =00000000                M sptl4	=	op4
00011C3A 3C                       M 	dc.b	(spfe<<3)+spal
00011C3B =00000080                M sptlmask4	set	$80
00011C3B =00000000                M sptlmask2	set	((spal>=5)<<7)
00011C3B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00011C3B =00000000                M sptlmask1	set	((spal=7)<<7)
00011C3B 0501 0A01                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011C3F 565C 5C5C                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011C43 0E11 1111                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011C47 090A 060A                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011C4B 4F3F 3F3F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011C4F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011C53 1780 2080                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011C57 4E41 54                  M 	dc.b	'NAT'
00011C5A                            
00011C5A                            	; Patch $1A
00011C5A                            	; $F9
00011C5A                            	; $21, $30, $10, $32,	$1C, $1F, $1F, $10
00011C5A                            	; $05, $18, $09, $02,	$0B, $1F, $10, $05
00011C5A                            	; $1F, $2F, $4F, $2F,	$0C, $06, $04, $80
00011C5A                            	spAlgorithm	$01
00011C5A =0000001B                M spatnum	=	spatnum+1
00011C5A =00000001                M spal	=	val
00011C5A                            	spFeedback	$07
00011C5A =00000007                M spfe	=	val
00011C5A                            	spDetune	$02, $01, $03, $03
00011C5A =00000002                M spde1	=	op1
00011C5A =00000001                M spde2	=	op2
00011C5A =00000003                M spde3	=	op3
00011C5A =00000003                M spde4	=	op4
00011C5A                            	spMultiple	$01, $00, $00, $02
00011C5A =00000001                M spmu1	=	op1
00011C5A =00000000                M spmu2	=	op2
00011C5A =00000000                M spmu3	=	op3
00011C5A =00000002                M spmu4	=	op4
00011C5A                            	spRateScale	$00, $00, $00, $00
00011C5A =00000000                M sprs1	=	op1
00011C5A =00000000                M sprs2	=	op2
00011C5A =00000000                M sprs3	=	op3
00011C5A =00000000                M sprs4	=	op4
00011C5A                            	spAttackRt	$1C, $1F, $1F, $10
00011C5A =0000001C                M spar1	=	op1
00011C5A =0000001F                M spar2	=	op2
00011C5A =0000001F                M spar3	=	op3
00011C5A =00000010                M spar4	=	op4
00011C5A                            	spAmpMod	$00, $00, $00, $00
00011C5A =00000000                M spam1	=	op1
00011C5A =00000000                M spam2	=	op2
00011C5A =00000000                M spam3	=	op3
00011C5A =00000000                M spam4	=	op4
00011C5A                            	spSustainRt	$05, $09, $18, $02
00011C5A =00000005                M spsr1	=	op1
00011C5A =00000009                M spsr2	=	op2
00011C5A =00000018                M spsr3	=	op3
00011C5A =00000002                M spsr4	=	op4
00011C5A                            	spDecayRt	$0B, $10, $1F, $05
00011C5A =0000000B                M spdr1	=	op1
00011C5A =00000010                M spdr2	=	op2
00011C5A =0000001F                M spdr3	=	op3
00011C5A =00000005                M spdr4	=	op4
00011C5A                            	spSustainLv	$01, $04, $02, $02
00011C5A =00000001                M spsl1	=	op1
00011C5A =00000004                M spsl2	=	op2
00011C5A =00000002                M spsl3	=	op3
00011C5A =00000002                M spsl4	=	op4
00011C5A                            	spReleaseRt	$0F, $0F, $0F, $0F
00011C5A =0000000F                M sprr1	=	op1
00011C5A =0000000F                M sprr2	=	op2
00011C5A =0000000F                M sprr3	=	op3
00011C5A =0000000F                M sprr4	=	op4
00011C5A                            	spSSGEG		$00, $00, $00, $00
00011C5A =00000000                M spss1	=	op1
00011C5A =00000000                M spss2	=	op2
00011C5A =00000000                M spss3	=	op3
00011C5A =00000000                M spss4	=	op4
00011C5A                            	spTotalLv	$0C, $04, $06, $00
00011C5A =0000000C                M sptl1	=	op1
00011C5A =00000004                M sptl2	=	op2
00011C5A =00000006                M sptl3	=	op3
00011C5A =00000000                M sptl4	=	op4
00011C5A 39                       M 	dc.b	(spfe<<3)+spal
00011C5B =00000080                M sptlmask4	set	$80
00011C5B =00000000                M sptlmask2	set	((spal>=5)<<7)
00011C5B =00000000                M sptlmask3	set	((spal>=4)<<7)
00011C5B =00000000                M sptlmask1	set	((spal=7)<<7)
00011C5B 2130 1032                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011C5F 1C1F 1F10                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011C63 0518 0902                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011C67 0B1F 1005                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011C6B 1F2F 4F2F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011C6F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011C73 0C06 0480                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011C77 4E41 54                  M 	dc.b	'NAT'
00011C7A                            
00011C7A                            	; Patch $1B
00011C7A                            	; $00
00011C7A                            	; $00, $03, $02, $00,	$D9, $DF, $1F, $1F
00011C7A                            	; $12, $11, $14, $0F,	$0A, $00, $0A, $0D
00011C7A                            	; $FF, $FF, $FF, $FF,	$22, $07, $27, $80
00011C7A                            	spAlgorithm	$00
00011C7A =0000001C                M spatnum	=	spatnum+1
00011C7A =00000000                M spal	=	val
00011C7A                            	spFeedback	$00
00011C7A =00000000                M spfe	=	val
00011C7A                            	spDetune	$00, $00, $00, $00
00011C7A =00000000                M spde1	=	op1
00011C7A =00000000                M spde2	=	op2
00011C7A =00000000                M spde3	=	op3
00011C7A =00000000                M spde4	=	op4
00011C7A                            	spMultiple	$00, $02, $03, $00
00011C7A =00000000                M spmu1	=	op1
00011C7A =00000002                M spmu2	=	op2
00011C7A =00000003                M spmu3	=	op3
00011C7A =00000000                M spmu4	=	op4
00011C7A                            	spRateScale	$03, $00, $03, $00
00011C7A =00000003                M sprs1	=	op1
00011C7A =00000000                M sprs2	=	op2
00011C7A =00000003                M sprs3	=	op3
00011C7A =00000000                M sprs4	=	op4
00011C7A                            	spAttackRt	$19, $1F, $1F, $1F
00011C7A =00000019                M spar1	=	op1
00011C7A =0000001F                M spar2	=	op2
00011C7A =0000001F                M spar3	=	op3
00011C7A =0000001F                M spar4	=	op4
00011C7A                            	spAmpMod	$00, $00, $00, $00
00011C7A =00000000                M spam1	=	op1
00011C7A =00000000                M spam2	=	op2
00011C7A =00000000                M spam3	=	op3
00011C7A =00000000                M spam4	=	op4
00011C7A                            	spSustainRt	$12, $14, $11, $0F
00011C7A =00000012                M spsr1	=	op1
00011C7A =00000014                M spsr2	=	op2
00011C7A =00000011                M spsr3	=	op3
00011C7A =0000000F                M spsr4	=	op4
00011C7A                            	spDecayRt	$0A, $0A, $00, $0D
00011C7A =0000000A                M spdr1	=	op1
00011C7A =0000000A                M spdr2	=	op2
00011C7A =00000000                M spdr3	=	op3
00011C7A =0000000D                M spdr4	=	op4
00011C7A                            	spSustainLv	$0F, $0F, $0F, $0F
00011C7A =0000000F                M spsl1	=	op1
00011C7A =0000000F                M spsl2	=	op2
00011C7A =0000000F                M spsl3	=	op3
00011C7A =0000000F                M spsl4	=	op4
00011C7A                            	spReleaseRt	$0F, $0F, $0F, $0F
00011C7A =0000000F                M sprr1	=	op1
00011C7A =0000000F                M sprr2	=	op2
00011C7A =0000000F                M sprr3	=	op3
00011C7A =0000000F                M sprr4	=	op4
00011C7A                            	spSSGEG		$00, $00, $00, $00
00011C7A =00000000                M spss1	=	op1
00011C7A =00000000                M spss2	=	op2
00011C7A =00000000                M spss3	=	op3
00011C7A =00000000                M spss4	=	op4
00011C7A                            	spTotalLv	$22, $27, $07, $00
00011C7A =00000022                M sptl1	=	op1
00011C7A =00000027                M sptl2	=	op2
00011C7A =00000007                M sptl3	=	op3
00011C7A =00000000                M sptl4	=	op4
00011C7A 00                       M 	dc.b	(spfe<<3)+spal
00011C7B =00000080                M sptlmask4	set	$80
00011C7B =00000000                M sptlmask2	set	((spal>=5)<<7)
00011C7B =00000000                M sptlmask3	set	((spal>=4)<<7)
00011C7B =00000000                M sptlmask1	set	((spal=7)<<7)
00011C7B 0003 0200                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011C7F D9DF 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011C83 1211 140F                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011C87 0A00 0A0D                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011C8B FFFF FFFF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011C8F 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011C93 2207 2780                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011C97 4E41 54                  M 	dc.b	'NAT'
00011C9A                            
00011C9A                            	; Patch $1C
00011C9A                            	; $34
00011C9A                            	; $09, $0F, $01, $D7,	$1F, $1F, $1F, $1F
00011C9A                            	; $0C, $11, $09, $0F,	$0A, $0E, $0D, $0E
00011C9A                            	; $35, $1A, $55, $3A,	$0C, $80, $0F, $80
00011C9A                            	spAlgorithm	$04
00011C9A =0000001D                M spatnum	=	spatnum+1
00011C9A =00000004                M spal	=	val
00011C9A                            	spFeedback	$06
00011C9A =00000006                M spfe	=	val
00011C9A                            	spDetune	$00, $00, $00, $0D
00011C9A =00000000                M spde1	=	op1
00011C9A =00000000                M spde2	=	op2
00011C9A =00000000                M spde3	=	op3
00011C9A =0000000D                M spde4	=	op4
00011C9A                            	spMultiple	$09, $01, $0F, $07
00011C9A =00000009                M spmu1	=	op1
00011C9A =00000001                M spmu2	=	op2
00011C9A =0000000F                M spmu3	=	op3
00011C9A =00000007                M spmu4	=	op4
00011C9A                            	spRateScale	$00, $00, $00, $00
00011C9A =00000000                M sprs1	=	op1
00011C9A =00000000                M sprs2	=	op2
00011C9A =00000000                M sprs3	=	op3
00011C9A =00000000                M sprs4	=	op4
00011C9A                            	spAttackRt	$1F, $1F, $1F, $1F
00011C9A =0000001F                M spar1	=	op1
00011C9A =0000001F                M spar2	=	op2
00011C9A =0000001F                M spar3	=	op3
00011C9A =0000001F                M spar4	=	op4
00011C9A                            	spAmpMod	$00, $00, $00, $00
00011C9A =00000000                M spam1	=	op1
00011C9A =00000000                M spam2	=	op2
00011C9A =00000000                M spam3	=	op3
00011C9A =00000000                M spam4	=	op4
00011C9A                            	spSustainRt	$0C, $09, $11, $0F
00011C9A =0000000C                M spsr1	=	op1
00011C9A =00000009                M spsr2	=	op2
00011C9A =00000011                M spsr3	=	op3
00011C9A =0000000F                M spsr4	=	op4
00011C9A                            	spDecayRt	$0A, $0D, $0E, $0E
00011C9A =0000000A                M spdr1	=	op1
00011C9A =0000000D                M spdr2	=	op2
00011C9A =0000000E                M spdr3	=	op3
00011C9A =0000000E                M spdr4	=	op4
00011C9A                            	spSustainLv	$03, $05, $01, $03
00011C9A =00000003                M spsl1	=	op1
00011C9A =00000005                M spsl2	=	op2
00011C9A =00000001                M spsl3	=	op3
00011C9A =00000003                M spsl4	=	op4
00011C9A                            	spReleaseRt	$05, $05, $0A, $0A
00011C9A =00000005                M sprr1	=	op1
00011C9A =00000005                M sprr2	=	op2
00011C9A =0000000A                M sprr3	=	op3
00011C9A =0000000A                M sprr4	=	op4
00011C9A                            	spSSGEG		$00, $00, $00, $00
00011C9A =00000000                M spss1	=	op1
00011C9A =00000000                M spss2	=	op2
00011C9A =00000000                M spss3	=	op3
00011C9A =00000000                M spss4	=	op4
00011C9A                            	spTotalLv	$0C, $0F, $00, $00
00011C9A =0000000C                M sptl1	=	op1
00011C9A =0000000F                M sptl2	=	op2
00011C9A =00000000                M sptl3	=	op3
00011C9A =00000000                M sptl4	=	op4
00011C9A 34                       M 	dc.b	(spfe<<3)+spal
00011C9B =00000080                M sptlmask4	set	$80
00011C9B =00000000                M sptlmask2	set	((spal>=5)<<7)
00011C9B =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00011C9B =00000000                M sptlmask1	set	((spal=7)<<7)
00011C9B 090F 01D7                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011C9F 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011CA3 0C11 090F                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011CA7 0A0E 0D0E                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011CAB 351A 553A                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011CAF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011CB3 0C80 0F80                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011CB7 4E41 54                  M 	dc.b	'NAT'
00011CBA                            
00011CBA                            	; Patch $1D
00011CBA                            	; $FA
00011CBA                            	; $21, $3A, $19, $30,	$1F, $1F, $1F, $1F
00011CBA                            	; $05, $18, $09, $02,	$0B, $1F, $10, $05
00011CBA                            	; $1F, $2F, $4F, $2F,	$0E, $07, $04, $80
00011CBA                            	spAlgorithm	$02
00011CBA =0000001E                M spatnum	=	spatnum+1
00011CBA =00000002                M spal	=	val
00011CBA                            	spFeedback	$07
00011CBA =00000007                M spfe	=	val
00011CBA                            	spDetune	$02, $01, $03, $03
00011CBA =00000002                M spde1	=	op1
00011CBA =00000001                M spde2	=	op2
00011CBA =00000003                M spde3	=	op3
00011CBA =00000003                M spde4	=	op4
00011CBA                            	spMultiple	$01, $09, $0A, $00
00011CBA =00000001                M spmu1	=	op1
00011CBA =00000009                M spmu2	=	op2
00011CBA =0000000A                M spmu3	=	op3
00011CBA =00000000                M spmu4	=	op4
00011CBA                            	spRateScale	$00, $00, $00, $00
00011CBA =00000000                M sprs1	=	op1
00011CBA =00000000                M sprs2	=	op2
00011CBA =00000000                M sprs3	=	op3
00011CBA =00000000                M sprs4	=	op4
00011CBA                            	spAttackRt	$1F, $1F, $1F, $1F
00011CBA =0000001F                M spar1	=	op1
00011CBA =0000001F                M spar2	=	op2
00011CBA =0000001F                M spar3	=	op3
00011CBA =0000001F                M spar4	=	op4
00011CBA                            	spAmpMod	$00, $00, $00, $00
00011CBA =00000000                M spam1	=	op1
00011CBA =00000000                M spam2	=	op2
00011CBA =00000000                M spam3	=	op3
00011CBA =00000000                M spam4	=	op4
00011CBA                            	spSustainRt	$05, $09, $18, $02
00011CBA =00000005                M spsr1	=	op1
00011CBA =00000009                M spsr2	=	op2
00011CBA =00000018                M spsr3	=	op3
00011CBA =00000002                M spsr4	=	op4
00011CBA                            	spDecayRt	$0B, $10, $1F, $05
00011CBA =0000000B                M spdr1	=	op1
00011CBA =00000010                M spdr2	=	op2
00011CBA =0000001F                M spdr3	=	op3
00011CBA =00000005                M spdr4	=	op4
00011CBA                            	spSustainLv	$01, $04, $02, $02
00011CBA =00000001                M spsl1	=	op1
00011CBA =00000004                M spsl2	=	op2
00011CBA =00000002                M spsl3	=	op3
00011CBA =00000002                M spsl4	=	op4
00011CBA                            	spReleaseRt	$0F, $0F, $0F, $0F
00011CBA =0000000F                M sprr1	=	op1
00011CBA =0000000F                M sprr2	=	op2
00011CBA =0000000F                M sprr3	=	op3
00011CBA =0000000F                M sprr4	=	op4
00011CBA                            	spSSGEG		$00, $00, $00, $00
00011CBA =00000000                M spss1	=	op1
00011CBA =00000000                M spss2	=	op2
00011CBA =00000000                M spss3	=	op3
00011CBA =00000000                M spss4	=	op4
00011CBA                            	spTotalLv	$0E, $04, $07, $00
00011CBA =0000000E                M sptl1	=	op1
00011CBA =00000004                M sptl2	=	op2
00011CBA =00000007                M sptl3	=	op3
00011CBA =00000000                M sptl4	=	op4
00011CBA 3A                       M 	dc.b	(spfe<<3)+spal
00011CBB =00000080                M sptlmask4	set	$80
00011CBB =00000000                M sptlmask2	set	((spal>=5)<<7)
00011CBB =00000000                M sptlmask3	set	((spal>=4)<<7)
00011CBB =00000000                M sptlmask1	set	((spal=7)<<7)
00011CBB 213A 1930                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011CBF 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011CC3 0518 0902                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011CC7 0B1F 1005                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011CCB 1F2F 4F2F                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011CCF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011CD3 0E07 0480                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011CD7 4E41 54                  M 	dc.b	'NAT'
00011CDA                            
00011CDA                            	; Patch $1E
00011CDA                            	; $1C
00011CDA                            	; $2E, $02, $0F, $02,	$1F, $1F, $1F, $1F
00011CDA                            	; $18, $04, $14, $0E,	$00, $00, $00, $00
00011CDA                            	; $FF, $FF, $FF, $FF,	$20, $80, $1B, $80
00011CDA                            	spAlgorithm	$0C
00011CDA =0000001F                M spatnum	=	spatnum+1
00011CDA =0000000C                M spal	=	val
00011CDA                            	spFeedback	$01
00011CDA =00000001                M spfe	=	val
00011CDA                            	spDetune	$02, $00, $00, $00
00011CDA =00000002                M spde1	=	op1
00011CDA =00000000                M spde2	=	op2
00011CDA =00000000                M spde3	=	op3
00011CDA =00000000                M spde4	=	op4
00011CDA                            	spMultiple	$0E, $0F, $02, $02
00011CDA =0000000E                M spmu1	=	op1
00011CDA =0000000F                M spmu2	=	op2
00011CDA =00000002                M spmu3	=	op3
00011CDA =00000002                M spmu4	=	op4
00011CDA                            	spRateScale	$00, $00, $00, $00
00011CDA =00000000                M sprs1	=	op1
00011CDA =00000000                M sprs2	=	op2
00011CDA =00000000                M sprs3	=	op3
00011CDA =00000000                M sprs4	=	op4
00011CDA                            	spAttackRt	$1F, $1F, $1F, $1F
00011CDA =0000001F                M spar1	=	op1
00011CDA =0000001F                M spar2	=	op2
00011CDA =0000001F                M spar3	=	op3
00011CDA =0000001F                M spar4	=	op4
00011CDA                            	spAmpMod	$00, $00, $00, $00
00011CDA =00000000                M spam1	=	op1
00011CDA =00000000                M spam2	=	op2
00011CDA =00000000                M spam3	=	op3
00011CDA =00000000                M spam4	=	op4
00011CDA                            	spSustainRt	$18, $14, $04, $0E
00011CDA =00000018                M spsr1	=	op1
00011CDA =00000014                M spsr2	=	op2
00011CDA =00000004                M spsr3	=	op3
00011CDA =0000000E                M spsr4	=	op4
00011CDA                            	spDecayRt	$00, $00, $00, $00
00011CDA =00000000                M spdr1	=	op1
00011CDA =00000000                M spdr2	=	op2
00011CDA =00000000                M spdr3	=	op3
00011CDA =00000000                M spdr4	=	op4
00011CDA                            	spSustainLv	$0F, $0F, $0F, $0F
00011CDA =0000000F                M spsl1	=	op1
00011CDA =0000000F                M spsl2	=	op2
00011CDA =0000000F                M spsl3	=	op3
00011CDA =0000000F                M spsl4	=	op4
00011CDA                            	spReleaseRt	$0F, $0F, $0F, $0F
00011CDA =0000000F                M sprr1	=	op1
00011CDA =0000000F                M sprr2	=	op2
00011CDA =0000000F                M sprr3	=	op3
00011CDA =0000000F                M sprr4	=	op4
00011CDA                            	spSSGEG		$00, $00, $00, $00
00011CDA =00000000                M spss1	=	op1
00011CDA =00000000                M spss2	=	op2
00011CDA =00000000                M spss3	=	op3
00011CDA =00000000                M spss4	=	op4
00011CDA                            	spTotalLv	$20, $1B, $00, $00
00011CDA =00000020                M sptl1	=	op1
00011CDA =0000001B                M sptl2	=	op2
00011CDA =00000000                M sptl3	=	op3
00011CDA =00000000                M sptl4	=	op4
00011CDA 14                       M 	dc.b	(spfe<<3)+spal
00011CDB =00000080                M sptlmask4	set	$80
00011CDB =FFFFFF80                M sptlmask2	set	((spal>=5)<<7)
00011CDB =FFFFFF80                M sptlmask3	set	((spal>=4)<<7)
00011CDB =00000000                M sptlmask1	set	((spal=7)<<7)
00011CDB 2E02 0F02                M 	dc.b	(spde1<<4)+spmu1,(spde3<<4)+spmu3,(spde2<<4)+spmu2,(spde4<<4)+spmu4
00011CDF 1F1F 1F1F                M 	dc.b	(sprs1<<6)+spar1,(sprs3<<6)+spar3,(sprs2<<6)+spar2,(sprs4<<6)+spar4
00011CE3 1804 140E                M 	dc.b	(spam1<<7)+spsr1,(spam3<<7)+spsr3,(spam2<<7)+spsr2,(spam4<<7)+spsr4
00011CE7 0000 0000                M 	dc.b	spdr1,spdr3,spdr2,spdr4
00011CEB FFFF FFFF                M 	dc.b	(spsl1<<4)+sprr1,(spsl3<<4)+sprr3,(spsl2<<4)+sprr2,(spsl4<<4)+sprr4
00011CEF 0000 0000                M 	dc.b	spss1,spss3,spss2,spss4
00011CF3 2080 9B80                M 	dc.b	sptl1|sptlmask1,sptl3|sptlmask3,sptl2|sptlmask2,sptl4|sptlmask4
00011CF7 4E41 54                  M 	dc.b	'NAT'
00011CFA                            
00011CFA                            	even
00011CFA                            
00011CFA                            ; -------------------------------------------------------------------------
00011CFA                            	opt ae-				; disable automatic evens
00011CFA                            
00011CFA                            sfxaddr	include	"Sound/sfxdata.asm"	; include all sfx
00011CFA                            
00011CFA                            
00011CFA                            ; ------------------------------------------------------------------------
00011CFA                            ; AMPS SFX data
00011CFA                            ; -------------------------------------------------------------------------
00011CFA                            
00011CFA                            Snd_Jump:
00011CFA                            		include	"Sound/sfx/Jump.asm"
00011CFA                            SndJump_Header:
00011CFA                            	sHeaderInit	
00011CFA =00011CFA                M spointzero	=	*
00011CFA =00000000                M spatnum	=	0
00011CFA                            	sHeaderPrio	$60
00011CFA 60                       M 	dc.b	$60
00011CFB                            	sHeaderCh	$01
00011CFB 00                       M 	dc.b	$01-1
00011CFC                            	sHeaderSFX	$80, $C0, SndJump_FM5, -1, $00
00011CFC 80C0                     M 	dc.b	$80,$c0
00011CFE 0000                     M 	dc.w	sndjump_fm5-spointzero
00011D00 FF00                     M 	dc.b	-1,$00
00011D02                            
00011D02                            SndJump_FM5:
00011D02 F3E7                       	dc.b	$F3,	$E7
00011D04                            	ssMod68k	$00, $01, -5, $10
00011D04 F000 01FB 10             M 	dc.b	$f0,$00,$01,-5,$10
00011D09 A510                       	dc.b nC3, $10
00011D0B                            	sModOff
00011D0B EC                       M 	dc.b	$ec
00011D0C                            	
00011D0C                            Jumploop:
00011D0C E702                       	dc.b	$E7,	$02
00011D0E                            	saVol	$01
00011D0E ED01                     M 	dc.b	$ed,$01
00011D10                            	sLoop		$00, $0B, Jumploop
00011D10 F700                     M 	dc.b	$f7,$00
00011D12 FFF9                     M 	dc.w	jumploop-*-1
00011D14 0B                       M 	dc.b	$0b
00011D15                            	
00011D15                            	sStop	
00011D15 F5                       M 	dc.b	$f5
00011D16                            		even
00011D16                            Snd_Skid:
00011D16                            		include	"Sound/sfx/Skid.asm"
00011D16                            Skid_Header:
00011D16                            	sHeaderInit	
00011D16 =00011D16                M spointzero	=	*
00011D16 =00000000                M spatnum	=	0
00011D16                            	sHeaderPrio	$60
00011D16 60                       M 	dc.b	$60
00011D17                            	sHeaderCh	$01
00011D17 00                       M 	dc.b	$01-1
00011D18                            	sHeaderSFX	$80, $C0, Skid_FM5, $00, $00
00011D18 80C0                     M 	dc.b	$80,$c0
00011D1A 0000                     M 	dc.w	skid_fm5-spointzero
00011D1C 0000                     M 	dc.b	$00,$00
00011D1E                            
00011D1E                            Skid_FM5:
00011D1E F3E7                       	dc.b	$F3,	$E7
00011D20 8001                       	dc.b nRst, $01
00011D22                            	
00011D22                            Skid_Loop1:
00011D22 AD01 8001                  	dc.b nAb3, $01, nRst, $01
00011D26                            	sLoop		$00, $03, Skid_Loop1
00011D26 F700                     M 	dc.b	$f7,$00
00011D28 FFF9                     M 	dc.w	skid_loop1-*-1
00011D2A 03                       M 	dc.b	$03
00011D2B                            
00011D2B                            Skid_Loop2:
00011D2B AD01 8001                  	dc.b nAb3, $01, nRst, $01
00011D2F                            	saVol	$01
00011D2F ED01                     M 	dc.b	$ed,$01
00011D31                            	sLoop		$00, $09, Skid_Loop2
00011D31 F700                     M 	dc.b	$f7,$00
00011D33 FFF7                     M 	dc.w	skid_loop2-*-1
00011D35 09                       M 	dc.b	$09
00011D36                            	sStop	
00011D36 F5                       M 	dc.b	$f5
00011D38 00                         		even
00011D38                            Snd_Death:
00011D38                            		include	"Sound/sfx/Death.asm"
00011D38                            Death_Header:
00011D38                            	sHeaderInit	
00011D38 =00011D38                M spointzero	=	*
00011D38 =00000000                M spatnum	=	0
00011D38                            	sHeaderPrio	$60
00011D38 60                       M 	dc.b	$60
00011D39                            	sHeaderCh	$01
00011D39 00                       M 	dc.b	$01-1
00011D3A                            	sHeaderSFX	$80, $05, Death_FM5, $F4, $00
00011D3A 8005                     M 	dc.b	$80,$05
00011D3C 0000                     M 	dc.w	death_fm5-spointzero
00011D3E F400                     M 	dc.b	$f4,$00
00011D40                            
00011D40                            Death_FM5:
00011D40                            	sVoice		$02
00011D40 E802                     M 	dc.b	$e8,$02
00011D42 B007 E7AD                  	dc.b nB3, $07, sHold, nAb3
00011D46                            
00011D46                            Death_Loop1:
00011D46 01                         	dc.b $01
00011D47                            	saVol		$01
00011D47 ED01                     M 	dc.b	$ed,$01
00011D49                            	sLoop		$00, $2F, Death_Loop1
00011D49 F700                     M 	dc.b	$f7,$00
00011D4B FFFA                     M 	dc.w	death_loop1-*-1
00011D4D 2F                       M 	dc.b	$2f
00011D4E                            	sStop	
00011D4E F5                       M 	dc.b	$f5
00011D50 00                         		even
00011D50                            Snd_Push:
00011D50                            		include	"Sound/sfx/Push.asm"
00011D50                            Push_Header:
00011D50                            	sHeaderInit	
00011D50 =00011D50                M spointzero	=	*
00011D50 =00000000                M spatnum	=	0
00011D50                            	sHeaderPrio	$60
00011D50 60                       M 	dc.b	$60
00011D51                            	sHeaderCh	$01
00011D51 00                       M 	dc.b	$01-1
00011D52                            	sHeaderSFX	$80, $05, Push_FM5, $00, $06
00011D52 8005                     M 	dc.b	$80,$05
00011D54 0000                     M 	dc.w	push_fm5-spointzero
00011D56 0006                     M 	dc.b	$00,$06
00011D58                            
00011D58                            Push_FM5:
00011D58                            	sVoice		$13
00011D58 E813                     M 	dc.b	$e8,$13
00011D5A 8F07 8002 8F06 8010        	dc.b nD1, $07, nRst, $02, nD1, $06, nRst, $10
00011D62                            	sStop	
00011D62 F5                       M 	dc.b	$f5
00011D64 00                         		even
00011D64                            Snd_Bubble:
00011D64                            Snd_Drown:
00011D64                            Snd_DrownWarning:
00011D64                            Snd_DrownCountdown:
00011D64                            Snd_Checkpoint:
00011D64                            		include	"Sound/sfx/Checkpoint.asm"
00011D64                            Attack_Header:
00011D64                            	sHeaderInit	
00011D64 =00011D64                M spointzero	=	*
00011D64 =00000000                M spatnum	=	0
00011D64                            	sHeaderPrio	$60
00011D64 60                       M 	dc.b	$60
00011D65                            	sHeaderCh	$02
00011D65 01                       M 	dc.b	$02-1
00011D66                            	sHeaderSFX	$80, $80, Attack_FM5, $00, $00
00011D66 8080                     M 	dc.b	$80,$80
00011D68 0000                     M 	dc.w	attack_fm5-spointzero
00011D6A 0000                     M 	dc.b	$00,$00
00011D6C                            	sHeaderSFX	$80, $A0, Attack_FM5B, $00, $04
00011D6C 80A0                     M 	dc.b	$80,$a0
00011D6E 0000                     M 	dc.w	attack_fm5b-spointzero
00011D70 0004                     M 	dc.b	$00,$04
00011D72                            
00011D72                            Attack_FM5B:
00011D72 8002                       	dc.b	nRst,	$02
00011D74                            
00011D74                            Attack_FM5:
00011D74                            
00011D74                            Attack_Loop1:
00011D74 B103 8001                  	dc.b nC4, $03, nRst, $01
00011D78                            	sLoop		$00, $01, Attack_Loop1
00011D78 F700                     M 	dc.b	$f7,$00
00011D7A FFF9                     M 	dc.w	attack_loop1-*-1
00011D7C 01                       M 	dc.b	$01
00011D7D                            
00011D7D                            Attack_Loop2:
00011D7D B103 8001                  	dc.b nC4, $03, nRst, $01
00011D81                            	saVol	$01
00011D81 ED01                     M 	dc.b	$ed,$01
00011D83 B003 8001                  	dc.b nB3, $03, nRst, $01
00011D87                            	saVol	$01
00011D87 ED01                     M 	dc.b	$ed,$01
00011D89 AF03 8001                  	dc.b nBb3, $03, nRst, $01
00011D8D                            	saVol	$01
00011D8D ED01                     M 	dc.b	$ed,$01
00011D8F AE03 8001                  	dc.b nBb3-1, $03, nRst, $01
00011D93                            	saVol	$01
00011D93 ED01                     M 	dc.b	$ed,$01
00011D95                            	sLoop		$00, $03, Attack_Loop2
00011D95 F700                     M 	dc.b	$f7,$00
00011D97 FFE5                     M 	dc.w	attack_loop2-*-1
00011D99 03                       M 	dc.b	$03
00011D9A                            	sStop	
00011D9A F5                       M 	dc.b	$f5
00011D9C 00                         		even
00011D9C                            Snd_SpikeMove:
00011D9C                            Snd_Ring:
00011D9C                            		include	"Sound/sfx/Ring.asm"
00011D9C                            Ring_Header:
00011D9C                            	sHeaderInit	
00011D9C =00011D9C                M spointzero	=	*
00011D9C =00000000                M spatnum	=	0
00011D9C                            	sHeaderPrio	$60
00011D9C 60                       M 	dc.b	$60
00011D9D                            	sHeaderCh	$01
00011D9D 00                       M 	dc.b	$01-1
00011D9E                            	sHeaderSFX	$80, $05, Ring_FM5, $00, $0A
00011D9E 8005                     M 	dc.b	$80,$05
00011DA0 0000                     M 	dc.w	ring_fm5-spointzero
00011DA2 000A                     M 	dc.b	$00,$0a
00011DA4                            
00011DA4                            Ring_FM5:
00011DA4                            	sVoice		$03
00011DA4 E803                     M 	dc.b	$e8,$03
00011DA6 C105 C405 C91B             	dc.b nE5, $05, nG5, $05, nC6, $1B
00011DAC                            	sStop	
00011DAC F5                       M 	dc.b	$f5
00011DAE 00                         		even
00011DAE                            Snd_RingLoss:
00011DAE                            		include	"Sound/sfx/Ring Loss.asm"
00011DAE                            RingLoss_Header:
00011DAE                            	sHeaderInit	
00011DAE =00011DAE                M spointzero	=	*
00011DAE =00000000                M spatnum	=	0
00011DAE                            	sHeaderPrio	$60
00011DAE 60                       M 	dc.b	$60
00011DAF                            	sHeaderCh	$02
00011DAF 01                       M 	dc.b	$02-1
00011DB0                            	sHeaderSFX	$80, $04, RingLoss_FM4, $00, $05
00011DB0 8004                     M 	dc.b	$80,$04
00011DB2 0000                     M 	dc.w	ringloss_fm4-spointzero
00011DB4 0005                     M 	dc.b	$00,$05
00011DB6                            	sHeaderSFX	$80, $05, RingLoss_FM5, $00, $08
00011DB6 8005                     M 	dc.b	$80,$05
00011DB8 0000                     M 	dc.w	ringloss_fm5-spointzero
00011DBA 0008                     M 	dc.b	$00,$08
00011DBC                            
00011DBC                            RingLoss_FM4:
00011DBC                            	sVoice		$03
00011DBC E803                     M 	dc.b	$e8,$03
00011DBE C602 0505 0505 0505 3A     	dc.b nA5, $02, $05, $05, $05, $05, $05, $05, $3A
00011DC7                            	sStop	
00011DC7 F5                       M 	dc.b	$f5
00011DC8                            
00011DC8                            RingLoss_FM5:
00011DC8                            	sVoice		$03
00011DC8 E803                     M 	dc.b	$e8,$03
00011DCA 8002 C402 0515 0205 32     	dc.b nRst, $02, nG5, $02, $05, $15, $02, $05, $32
00011DD3                            	sStop	
00011DD3 F5                       M 	dc.b	$f5
00011DD4                            		even
00011DD4                            Snd_Spring:
00011DD4                            		include	"Sound/sfx/Spring.asm"
00011DD4                            Spring_Header:
00011DD4                            	sHeaderInit	
00011DD4 =00011DD4                M spointzero	=	*
00011DD4 =00000000                M spatnum	=	0
00011DD4                            	sHeaderPrio	$60
00011DD4 60                       M 	dc.b	$60
00011DD5                            	sHeaderCh	$01
00011DD5 00                       M 	dc.b	$01-1
00011DD6                            	sHeaderSFX	$80, $04, Spring_FM4, $00, $02
00011DD6 8004                     M 	dc.b	$80,$04
00011DD8 0000                     M 	dc.w	spring_fm4-spointzero
00011DDA 0002                     M 	dc.b	$00,$02
00011DDC                            
00011DDC                            Spring_FM4:
00011DDC                            	sVoice		$06
00011DDC E806                     M 	dc.b	$e8,$06
00011DDE 8001                       	dc.b nRst, $01
00011DE0                            	ssMod68k	$03, $01, $5D, $0F
00011DE0 F003 015D 0F             M 	dc.b	$f0,$03,$01,$5d,$0f
00011DE5 B00C                       	dc.b nB3, $0C
00011DE7                            	sModOff	
00011DE7 EC                       M 	dc.b	$ec
00011DE8                            
00011DE8                            Spring_Loop1:
00011DE8 E7                         	dc.b sHold
00011DE9                            	saVol		$02
00011DE9 ED02                     M 	dc.b	$ed,$02
00011DEB BD02                       	dc.b nC5, $02
00011DED                            	sLoop		$00, $19, Spring_Loop1
00011DED F700                     M 	dc.b	$f7,$00
00011DEF FFF8                     M 	dc.w	spring_loop1-*-1
00011DF1 19                       M 	dc.b	$19
00011DF2                            	sStop	
00011DF2 F5                       M 	dc.b	$f5
00011DF4 00                         		even
00011DF4                            Snd_Shield:
00011DF4                            Snd_Splash:
00011DF4                            Snd_Bumper:
00011DF4                            		include	"Sound/sfx/Bumper.asm"
00011DF4                            BumperHeader:
00011DF4                            	sHeaderInit	
00011DF4 =00011DF4                M spointzero	=	*
00011DF4 =00000000                M spatnum	=	0
00011DF4                            	sHeaderPrio	$60
00011DF4 60                       M 	dc.b	$60
00011DF5                            	sHeaderCh	$03
00011DF5 02                       M 	dc.b	$03-1
00011DF6                            	sHeaderSFX	$80, $05, BumperFM5, $00, $00
00011DF6 8005                     M 	dc.b	$80,$05
00011DF8 0000                     M 	dc.w	bumperfm5-spointzero
00011DFA 0000                     M 	dc.b	$00,$00
00011DFC                            	sHeaderSFX	$80, $04, BumperFM4, $00, $00
00011DFC 8004                     M 	dc.b	$80,$04
00011DFE 0000                     M 	dc.w	bumperfm4-spointzero
00011E00 0000                     M 	dc.b	$00,$00
00011E02                            	sHeaderSFX	$80, $02, BumperFM3, $00, $02
00011E02 8002                     M 	dc.b	$80,$02
00011E04 0000                     M 	dc.w	bumperfm3-spointzero
00011E06 0002                     M 	dc.b	$00,$02
00011E08                            
00011E08                            BumperFM5:
00011E08                            	sVoice		$0D
00011E08 E80D                     M 	dc.b	$e8,$0d
00011E0A                            	ssJump		BumperJump1
00011E0A F6                       M 	dc.b	$f6
00011E0B 0000                     M 	dc.w	bumperjump1-*-1
00011E0D                            
00011E0D                            BumperFM4:
00011E0D                            	sVoice		$0D
00011E0D E80D                     M 	dc.b	$e8,$0d
00011E0F                            	saDetune	$07
00011E0F E207                     M 	dc.b	$e2,$07
00011E11 8001                       	dc.b nRst, $01
00011E13                            
00011E13                            BumperJump1:
00011E13 BA20                       	dc.b nA4, $20
00011E15                            	sStop	
00011E15 F5                       M 	dc.b	$f5
00011E16                            
00011E16                            BumperFM3:
00011E16                            	sVoice		$0E
00011E16 E80E                     M 	dc.b	$e8,$0e
00011E18 9A03                       	dc.b nCs2, $03
00011E1A                            	sStop	
00011E1A F5                       M 	dc.b	$f5
00011E1C 00                         		even
00011E1C                            Snd_Switch:
00011E1C                            Snd_Signpost:
00011E1C                            Snd_Collapse:
00011E1C                            Snd_WallSmash:
00011E1C                            Snd_Rumble:
00011E1C                            Snd_Warp:
00011E1C                            Snd_BossHit:
00011E1C                            		include	"Sound/sfx/Boss Hit.asm"
00011E1C                            BossHit_Header:
00011E1C                            	sHeaderInit	
00011E1C =00011E1C                M spointzero	=	*
00011E1C =00000000                M spatnum	=	0
00011E1C                            	sHeaderPrio	$60
00011E1C 60                       M 	dc.b	$60
00011E1D                            	sHeaderCh	$01
00011E1D 00                       M 	dc.b	$01-1
00011E1E                            	sHeaderSFX	$80, $05, BossHit_FM4, $00, $00
00011E1E 8005                     M 	dc.b	$80,$05
00011E20 0000                     M 	dc.w	bosshit_fm4-spointzero
00011E22 0000                     M 	dc.b	$00,$00
00011E24                            
00011E24                            BossHit_FM4:
00011E24                            	sVoice		$0F
00011E24 E80F                     M 	dc.b	$e8,$0f
00011E26                            	ssMod68k	$01, $01, $0C, $01
00011E26 F001 010C 01             M 	dc.b	$f0,$01,$01,$0c,$01
00011E2B                            
00011E2B                            BossHit_Loop1:
00011E2B 810A                       	dc.b nC0, $0A
00011E2D                            	saVol		$10
00011E2D ED10                     M 	dc.b	$ed,$10
00011E2F                            	sLoop		$00, $04, BossHit_Loop1
00011E2F F700                     M 	dc.b	$f7,$00
00011E31 FFF9                     M 	dc.w	bosshit_loop1-*-1
00011E33 04                       M 	dc.b	$04
00011E34                            	sStop	
00011E34 F5                       M 	dc.b	$f5
00011E36 00                         		even
00011E36                            Snd_Bomb:
00011E36                            		include	"Sound/sfx/Bomb.asm"
00011E36                            Bomb_Header:
00011E36                            	sHeaderInit	
00011E36 =00011E36                M spointzero	=	*
00011E36 =00000000                M spatnum	=	0
00011E36                            	sHeaderPrio	$60
00011E36 60                       M 	dc.b	$60
00011E37                            	sHeaderCh	$01
00011E37 00                       M 	dc.b	$01-1
00011E38                            	sHeaderSFX	$80, $05, Bomb_FM5, $00, $00
00011E38 8005                     M 	dc.b	$80,$05
00011E3A 0000                     M 	dc.w	bomb_fm5-spointzero
00011E3C 0000                     M 	dc.b	$00,$00
00011E3E                            
00011E3E                            Bomb_FM5:
00011E3E                            	sVoice		$09
00011E3E E809                     M 	dc.b	$e8,$09
00011E40 8A22                       	dc.b nA0, $22
00011E42                            	sStop	
00011E42 F5                       M 	dc.b	$f5
00011E44 00                         		even
00011E44                            Snd_BreakItem:
00011E44                            		include	"Sound/sfx/Break Item.asm"
00011E44                            BreakItem_Header:
00011E44                            	sHeaderInit	
00011E44 =00011E44                M spointzero	=	*
00011E44 =00000000                M spatnum	=	0
00011E44                            	sHeaderPrio	$60
00011E44 60                       M 	dc.b	$60
00011E45                            	sHeaderCh	$01
00011E45 00                       M 	dc.b	$01-1
00011E46                            	sHeaderSFX	$80, $05, BreakItem_FM5, $00, $00
00011E46 8005                     M 	dc.b	$80,$05
00011E48 0000                     M 	dc.w	breakitem_fm5-spointzero
00011E4A 0000                     M 	dc.b	$00,$00
00011E4C                            
00011E4C                            BreakItem_FM5:
00011E4C                            	ssMod68k	$03, $01, $72, $0B
00011E4C F003 0172 0B             M 	dc.b	$f0,$03,$01,$72,$0b
00011E51                            	sVoice		$04
00011E51 E804                     M 	dc.b	$e8,$04
00011E53 BA16                       	dc.b nA4, $16
00011E55                            	sStop	
00011E55 F5                       M 	dc.b	$f5
00011E56                            		even
00011E56                            Snd_FloorBounce:
00011E56                            		include	"Sound/sfx/Floor Bounce.asm"
00011E56                            FloorBounce_Header:
00011E56                            	sHeaderInit	
00011E56 =00011E56                M spointzero	=	*
00011E56 =00000000                M spatnum	=	0
00011E56                            	sHeaderPrio	$60
00011E56 60                       M 	dc.b	$60
00011E57                            	sHeaderCh	$01
00011E57 00                       M 	dc.b	$01-1
00011E58                            	sHeaderSFX	$80, $05, FloorBounce_FM5, $00, $00
00011E58 8005                     M 	dc.b	$80,$05
00011E5A 0000                     M 	dc.w	floorbounce_fm5-spointzero
00011E5C 0000                     M 	dc.b	$00,$00
00011E5E                            
00011E5E                            FloorBounce_FM5:
00011E5E                            	sVoice		$18
00011E5E E818                     M 	dc.b	$e8,$18
00011E60 A00F                       	dc.b nG2, $0F
00011E62                            	saVol		$0F
00011E62 ED0F                     M 	dc.b	$ed,$0f
00011E64                            	sLoop		$00, $04, FloorBounce_FM5
00011E64 F700                     M 	dc.b	$f7,$00
00011E66 FFF7                     M 	dc.w	floorbounce_fm5-*-1
00011E68 04                       M 	dc.b	$04
00011E69                            	sStop	
00011E69 F5                       M 	dc.b	$f5
00011E6A                            		even
00011E6A                            Snd_Charge:
00011E6A                            		include	"Sound/sfx/Charge.asm"
00011E6A                            PeeloutCharge_Header:
00011E6A                            	sHeaderInit
00011E6A =00011E6A                M spointzero	=	*
00011E6A =00000000                M spatnum	=	0
00011E6A                            	sHeaderPrio	$60
00011E6A 60                       M 	dc.b	$60
00011E6B                            	sHeaderCh	$01
00011E6B 00                       M 	dc.b	$01-1
00011E6C                            
00011E6C                            	sHeaderSFX	$80, $05, PeeloutCharge_FM5, $00, $05
00011E6C 8005                     M 	dc.b	$80,$05
00011E6E 0000                     M 	dc.w	peeloutcharge_fm5-spointzero
00011E70 0005                     M 	dc.b	$00,$05
00011E72                            
00011E72                            ; FM5 Data
00011E72                            PeeloutCharge_FM5:
00011E72                            	sVoice	$0A
00011E72 E80A                     M 	dc.b	$e8,$0a
00011E74 8001                       	dc.b	nRst, $01
00011E76                            	ssMod68k	$01, $01, $09, $FF
00011E76 F001 0109 FF             M 	dc.b	$f0,$01,$01,$09,$ff
00011E7B CA22                       	dc.b	nCs6, $22
00011E7D                            	sModOn
00011E7D EB                       M 	dc.b	$eb
00011E7E                            	saVol	$02
00011E7E ED02                     M 	dc.b	$ed,$02
00011E80                            	sModOff
00011E80 EC                       M 	dc.b	$ec
00011E81                            
00011E81                            PeeloutCharge_Jump00:
00011E81 E7D1 02                    	dc.b	sHold, nAb6, $02
00011E84                            	ssJump	PeeloutCharge_Jump00
00011E84 F6                       M 	dc.b	$f6
00011E85 FFFB                     M 	dc.w	peeloutcharge_jump00-*-1
00011E88 00                         		even
00011E88                            Snd_ChargeStop:
00011E88                            		include	"Sound/sfx/Charge Stop.asm"
00011E88                            PeeloutStop_Header:
00011E88                            	sHeaderInit
00011E88 =00011E88                M spointzero	=	*
00011E88 =00000000                M spatnum	=	0
00011E88                            	sHeaderPrio	$60
00011E88 60                       M 	dc.b	$60
00011E89                            	sHeaderCh   $01
00011E89 00                       M 	dc.b	$01-1
00011E8A                            
00011E8A                            	sHeaderSFX $80, $05, PeeloutStop_FM5,	$00, $00
00011E8A 8005                     M 	dc.b	$80,$05
00011E8C 0000                     M 	dc.w	peeloutstop_fm5-spointzero
00011E8E 0000                     M 	dc.b	$00,$00
00011E90                            
00011E90                            ; FM5 Data
00011E90                            PeeloutStop_FM5:
00011E90                            	sStop
00011E90 F5                       M 	dc.b	$f5
00011E92 00                         		even
00011E92                            Snd_ChargeRelease:
00011E92                            		include	"Sound/sfx/Charge Release.asm"
00011E92                            Peelout_Release_Header:
00011E92                            	sHeaderInit
00011E92 =00011E92                M spointzero	=	*
00011E92 =00000000                M spatnum	=	0
00011E92                            	sHeaderPrio	$60
00011E92 60                       M 	dc.b	$60
00011E93                            	sHeaderCh	$02
00011E93 01                       M 	dc.b	$02-1
00011E94                            
00011E94                            	sHeaderSFX	$80, $04, Peelout_Release_FM4, $00, $00
00011E94 8004                     M 	dc.b	$80,$04
00011E96 0000                     M 	dc.w	peelout_release_fm4-spointzero
00011E98 0000                     M 	dc.b	$00,$00
00011E9A                            	sHeaderSFX	$80, $05, Peelout_Release_FM5, $00, $08
00011E9A 8005                     M 	dc.b	$80,$05
00011E9C 0000                     M 	dc.w	peelout_release_fm5-spointzero
00011E9E 0008                     M 	dc.b	$00,$08
00011EA0                            
00011EA0                            ; FM4 Data
00011EA0                            Peelout_Release_FM4:
00011EA0                            	sVoice		$0C
00011EA0 E80C                     M 	dc.b	$e8,$0c
00011EA2                            	ssMod68k	$01, $01, $C5, $1A
00011EA2 F001 01C5 1A             M 	dc.b	$f0,$01,$01,$c5,$1a
00011EA7 CD07                       	dc.b		nE6, $07
00011EA9                            	saVol		$09
00011EA9 ED09                     M 	dc.b	$ed,$09
00011EAB                            	sPan		spCenter, $00
00011EAB E0C0                     M 	dc.b	$e0,spcenter|$00
00011EAD                            	sVoice		$0A
00011EAD E80A                     M 	dc.b	$e8,$0a
00011EAF                            	ssMod68k	$03, $01, $09, $FF
00011EAF F003 0109 FF             M 	dc.b	$f0,$03,$01,$09,$ff
00011EB4 D625                       	dc.b		nCs7, $25
00011EB6                            	sModOff
00011EB6 EC                       M 	dc.b	$ec
00011EB7                            
00011EB7                            Peelout_Release_Loop00:
00011EB7 E7                         	dc.b		sHold
00011EB8                            	saVol		$01
00011EB8 ED01                     M 	dc.b	$ed,$01
00011EBA DC02                       	dc.b		nG7, $02
00011EBC                            	sLoop		$00, $2A, Peelout_Release_Loop00
00011EBC F700                     M 	dc.b	$f7,$00
00011EBE FFF8                     M 	dc.w	peelout_release_loop00-*-1
00011EC0 2A                       M 	dc.b	$2a
00011EC1                            	sStop
00011EC1 F5                       M 	dc.b	$f5
00011EC2                            
00011EC2                            ; FM5 Data
00011EC2                            Peelout_Release_FM5:
00011EC2                            	sVoice		$0B
00011EC2 E80B                     M 	dc.b	$e8,$0b
00011EC4                            	ssMod68k	$01, $01, $20, $08
00011EC4 F001 0120 08             M 	dc.b	$f0,$01,$01,$20,$08
00011EC9 800A                       	dc.b		nRst, $0A
00011ECB                            
00011ECB                            Peelout_Release_Loop01:
00011ECB 880F                       	dc.b		nG0, $0F
00011ECD                            	sLoop		$00, $03, Peelout_Release_Loop01
00011ECD F700                     M 	dc.b	$f7,$00
00011ECF FFFB                     M 	dc.w	peelout_release_loop01-*-1
00011ED1 03                       M 	dc.b	$03
00011ED2                            
00011ED2                            Peelout_Release_Loop02:
00011ED2 880A                       	dc.b		nG0, $0A
00011ED4                            	saVol		$05
00011ED4 ED05                     M 	dc.b	$ed,$05
00011ED6                            	sLoop		$00, $06, Peelout_Release_Loop02
00011ED6 F700                     M 	dc.b	$f7,$00
00011ED8 FFF9                     M 	dc.w	peelout_release_loop02-*-1
00011EDA 06                       M 	dc.b	$06
00011EDB                            	sStop
00011EDB F5                       M 	dc.b	$f5
00011EDC                            		even
00011EDC                            Snd_DiamondBreak:
00011EDC                            		include	"Sound/sfx/Diamond Break.asm"
00011EDC                            DiamondBreak_Header:
00011EDC                            	sHeaderInit	
00011EDC =00011EDC                M spointzero	=	*
00011EDC =00000000                M spatnum	=	0
00011EDC                            	sHeaderPrio	$60
00011EDC 60                       M 	dc.b	$60
00011EDD                            	sHeaderCh	$01
00011EDD 00                       M 	dc.b	$01-1
00011EDE                            	sHeaderSFX	$80, $05, DiamondBreak_FM5, $00, $07
00011EDE 8005                     M 	dc.b	$80,$05
00011EE0 0000                     M 	dc.w	diamondbreak_fm5-spointzero
00011EE2 0007                     M 	dc.b	$00,$07
00011EE4                            
00011EE4                            DiamondBreak_FM5:
00011EE4                            	sVoice		$1E
00011EE4 E81E                     M 	dc.b	$e8,$1e
00011EE6 AE08                       	dc.b nA3, $08
00011EE8                            	sStop	
00011EE8 F5                       M 	dc.b	$f5
00011EEA 00                         		even
00011EEA                            
00011EEA                            ; -------------------------------------------------------------------------
00011EEA                            musaddr	include	"Sound/musicdata.asm"	; include all music
00011EEA                            
00011EEA                            
00011EEA                            ; ------------------------------------------------------------------------
00011EEA                            ; AMPS music data
00011EEA                            ; -------------------------------------------------------------------------
00011EEA                            
00011EEA                            Mus_WWZ:
00011EEA                            		include	"Sound/music/Wacky Workbench.asm"
00011EEA                            ; Level music was replaced with a silent music track, since I did not create the music, 
00011EEA                            ; nor do I currently have permission to share it.
00011EEA                            
00011EEA                            Mus_WWZ_Header:
00011EEA                            	sHeaderInit
00011EEA =00011EEA                M spointzero	=	*
00011EEA =00000000                M spatnum	=	0
00011EEA                            	sHeaderTempo	$02, $33
00011EEA 0133                     M 	dc.b	$02-1,$33
00011EEC                            	sHeaderCh	$05, $03
00011EEC 04                       M 	dc.b	$05-1
00011EED 02                       M 	dc.b	$03-1
00011EEE                            	sHeaderDAC	Mus_WWZ_DAC2
00011EEE 0000                     M 	dc.w	mus_wwz_dac2-spointzero
00011EF0 0000                     M 	dc.w	$00
00011EF2                            	sHeaderDAC	Mus_WWZ_DAC
00011EF2 0000                     M 	dc.w	mus_wwz_dac-spointzero
00011EF4 0000                     M 	dc.w	$00
00011EF6                            	sHeaderFM	Mus_WWZ_FM1, $00, $0A
00011EF6 0000                     M 	dc.w	mus_wwz_fm1-spointzero
00011EF8 000A                     M 	dc.b	$00,$0a
00011EFA                            	sHeaderFM	Mus_WWZ_FM2, $00, $11
00011EFA 0000                     M 	dc.w	mus_wwz_fm2-spointzero
00011EFC 0011                     M 	dc.b	$00,$11
00011EFE                            	sHeaderFM	Mus_WWZ_FM3, $00, $10
00011EFE 0000                     M 	dc.w	mus_wwz_fm3-spointzero
00011F00 0010                     M 	dc.b	$00,$10
00011F02                            	sHeaderFM	Mus_WWZ_FM4, $00, $10
00011F02 0000                     M 	dc.w	mus_wwz_fm4-spointzero
00011F04 0010                     M 	dc.b	$00,$10
00011F06                            	sHeaderFM	Mus_WWZ_FM5, $00, $0C
00011F06 0000                     M 	dc.w	mus_wwz_fm5-spointzero
00011F08 000C                     M 	dc.b	$00,$0c
00011F0A                            	sHeaderPSG	Mus_WWZ_PSG1, $00, $20>>3, $00, v00
00011F0A 0000                     M 	dc.w	mus_wwz_psg1-spointzero
00011F0C 0004 0000                M 	dc.b	$00,$20>>3,$00,v00
00011F10                            	sHeaderPSG	Mus_WWZ_PSG2, $00, $40>>3, $00, v00
00011F10 0000                     M 	dc.w	mus_wwz_psg2-spointzero
00011F12 0008 0000                M 	dc.b	$00,$40>>3,$00,v00
00011F16                            	sHeaderPSG	Mus_WWZ_PSG3, $00, $18>>3, $00, v00
00011F16 0000                     M 	dc.w	mus_wwz_psg3-spointzero
00011F18 0003 0000                M 	dc.b	$00,$18>>3,$00,v00
00011F1C                            
00011F1C                            Mus_WWZ_DAC:
00011F1C                            Mus_WWZ_DAC2:
00011F1C                            Mus_WWZ_FM1:
00011F1C                            Mus_WWZ_FM2:
00011F1C                            Mus_WWZ_FM3:
00011F1C                            Mus_WWZ_FM4:
00011F1C                            Mus_WWZ_FM5:
00011F1C                            Mus_WWZ_PSG1:
00011F1C                            Mus_WWZ_PSG2:
00011F1C                            Mus_WWZ_PSG3:
00011F1C                            	sStop
00011F1C F5                       M 	dc.b	$f5
00011F1E 00                         		even
00011F1E                            Mus_Boss:
00011F1E                            		include	"Sound/music/Boss.asm"
00011F1E                            Boss_Header:
00011F1E                            	sHeaderInit
00011F1E =00011F1E                M spointzero	=	*
00011F1E =00000000                M spatnum	=	0
00011F1E                            	sHeaderTempo	$01, $1D
00011F1E 001D                     M 	dc.b	$01-1,$1d
00011F20                            	sHeaderCh	$05, $03
00011F20 04                       M 	dc.b	$05-1
00011F21 02                       M 	dc.b	$03-1
00011F22                            
00011F22                            	sHeaderDAC	Boss_DAC2
00011F22 0000                     M 	dc.w	boss_dac2-spointzero
00011F24 0000                     M 	dc.w	$00
00011F26                            	sHeaderDAC	Boss_DAC
00011F26 0000                     M 	dc.w	boss_dac-spointzero
00011F28 0000                     M 	dc.w	$00
00011F2A                            	sHeaderFM	Boss_FM1,	$0C, $0A
00011F2A 0000                     M 	dc.w	boss_fm1-spointzero
00011F2C 0C0A                     M 	dc.b	$0c,$0a
00011F2E                            	sHeaderFM	Boss_FM2,	$0C, $06
00011F2E 0000                     M 	dc.w	boss_fm2-spointzero
00011F30 0C06                     M 	dc.b	$0c,$06
00011F32                            	sHeaderFM	Boss_FM3,	$0C, $08
00011F32 0000                     M 	dc.w	boss_fm3-spointzero
00011F34 0C08                     M 	dc.b	$0c,$08
00011F36                            	sHeaderFM	Boss_FM4,	$00, $0F
00011F36 0000                     M 	dc.w	boss_fm4-spointzero
00011F38 000F                     M 	dc.b	$00,$0f
00011F3A                            	sHeaderFM	Boss_FM5,	$00, $0F
00011F3A 0000                     M 	dc.w	boss_fm5-spointzero
00011F3C 000F                     M 	dc.b	$00,$0f
00011F3E                            	sHeaderPSG	Boss_PSG1,	$E8-$0C, $04, $00, v0C
00011F3E 0000                     M 	dc.w	boss_psg1-spointzero
00011F40 DC04 000C                M 	dc.b	$e8-$0c,$04,$00,v0c
00011F44                            	sHeaderPSG	Boss_PSG2,	$E8-$0C, $06, $00, v0C
00011F44 0000                     M 	dc.w	boss_psg2-spointzero
00011F46 DC06 000C                M 	dc.b	$e8-$0c,$06,$00,v0c
00011F4A                            	sHeaderPSG	Boss_PSG3,	$FE-$0C, $03, $00, v04
00011F4A 0000                     M 	dc.w	boss_psg3-spointzero
00011F4C F203 0004                M 	dc.b	$fe-$0c,$03,$00,v04
00011F50                            
00011F50                            ; FM1 Data
00011F50                            Boss_FM1:
00011F50                            	sVoice        $56
00011F50 E856                     M 	dc.b	$e8,$56
00011F52                            
00011F52                            Boss_Jump01:
00011F52                            	sNoteTimeOut        $08
00011F52 FD08                     M 	dc.b	$fd,$08
00011F54                            	sCall            Boss_Call02
00011F54 F8                       M 	dc.b	$f8
00011F55 0000                     M 	dc.w	boss_call02-*-1
00011F57                            	sNoteTimeOut        $0A
00011F57 FD0A                     M 	dc.b	$fd,$0a
00011F59                            
00011F59                            Boss_Loop0B:
00011F59 910C 9D                    	dc.b	nE1, $0C, nE2
00011F5C                            	sLoop            $00, $04, Boss_Loop0B
00011F5C F700                     M 	dc.b	$f7,$00
00011F5E FFFA                     M 	dc.w	boss_loop0b-*-1
00011F60 04                       M 	dc.b	$04
00011F61                            	sNoteTimeOut        $08
00011F61 FD08                     M 	dc.b	$fd,$08
00011F63                            	sCall            Boss_Call02
00011F63 F8                       M 	dc.b	$f8
00011F64 0000                     M 	dc.w	boss_call02-*-1
00011F66                            	sNoteTimeOut        $0A
00011F66 FD0A                     M 	dc.b	$fd,$0a
00011F68 910C 9D93 9F94 A095 A1     	dc.b	nE1, $0C, nE2, nFs1, nFs2, nG1, nG2, nAb1, nAb2
00011F71                            
00011F71                            Boss_Loop0C:
00011F71                            	sCall            Boss_Call03
00011F71 F8                       M 	dc.b	$f8
00011F72 0000                     M 	dc.w	boss_call03-*-1
00011F74 940C A006 A094 0CA0 06A0   	dc.b	nG1, $0C, nG2, $06, nG2, nG1, $0C, nG2, $06, nG2
00011F7E                            	sCall            Boss_Call03
00011F7E F8                       M 	dc.b	$f8
00011F7F 0000                     M 	dc.w	boss_call03-*-1
00011F81 910C 9D06 9D91 0C9D 069D   	dc.b	nE1, $0C, nE2, $06, nE2, nE1, $0C, nE2, $06, nE2
00011F8B                            	sLoop            $00, $04, Boss_Loop0C
00011F8B F700                     M 	dc.b	$f7,$00
00011F8D FFE3                     M 	dc.w	boss_loop0c-*-1
00011F8F 04                       M 	dc.b	$04
00011F90                            	ssJump            Boss_Jump01
00011F90 F6                       M 	dc.b	$f6
00011F91 FFC0                     M 	dc.w	boss_jump01-*-1
00011F93                            
00011F93                            Boss_Call03:
00011F93 960C A206 A296 0CA2 06A2+  	dc.b	nA1, $0C, nA2, $06, nA2, nA1, $0C, nA2, $06, nA2, nA1, $0C
00011F9F A206 A296 0CA2 06A2 940C+  	dc.b	nA2, $06, nA2, nA1, $0C, nA2, $06, nA2, nG1, $0C, nG2, $06
00011FAB A094 0CA0 06A0             	dc.b	nG2, nG1, $0C, nG2, $06, nG2
00011FB1                            	sRet
00011FB1 F9                       M 	dc.b	$f9
00011FB2                            
00011FB2                            Boss_Call02:
00011FB2 960C A2A2 96A2 A296 A2     	dc.b	nA1, $0C, nA2, nA2, nA1, nA2, nA2, nA1, nA2
00011FBB                            	sRet
00011FBB F9                       M 	dc.b	$f9
00011FBC                            
00011FBC                            ; PSG1 Data
00011FBC                            Boss_PSG1:
00011FBC                            ; PSG2 Data
00011FBC                            Boss_PSG2:
00011FBC                            Boss_DAC2:
00011FBC                            	sStop
00011FBC F5                       M 	dc.b	$f5
00011FBD                            
00011FBD                            ; FM2 Data
00011FBD                            Boss_FM2:
00011FBD                            	sVoice        $58
00011FBD E858                     M 	dc.b	$e8,$58
00011FBF                            
00011FBF                            Boss_Loop09:
00011FBF                            	sNoteTimeOut        $08
00011FBF FD08                     M 	dc.b	$fd,$08
00011FC1 AE0C A9A9 AEA9 A9AE A9     	dc.b	nA3, $0C, nE3, nE3, nA3, nE3, nE3, nA3, nE3
00011FCA                            	sNoteTimeOut        $17
00011FCA FD17                     M 	dc.b	$fd,$17
00011FCC B018 B0B0 B0               	dc.b	nB3, $18, nB3, nB3, nB3
00011FD1                            	sLoop            $00, $02, Boss_Loop09
00011FD1 F700                     M 	dc.b	$f7,$00
00011FD3 FFEB                     M 	dc.w	boss_loop09-*-1
00011FD5 02                       M 	dc.b	$02
00011FD6                            	saTranspose      $F4
00011FD6 E4F4                     M 	dc.b	$e4,$f4
00011FD8                            	sVoice        $59
00011FD8 E859                     M 	dc.b	$e8,$59
00011FDA                            
00011FDA                            Boss_Loop0A:
00011FDA                            	sCall            Boss_Call01
00011FDA F8                       M 	dc.b	$f8
00011FDB 0000                     M 	dc.w	boss_call01-*-1
00011FDD                            	sLoop            $00, $04, Boss_Loop0A
00011FDD F700                     M 	dc.b	$f7,$00
00011FDF FFFA                     M 	dc.w	boss_loop0a-*-1
00011FE1 04                       M 	dc.b	$04
00011FE2                            	saTranspose      $0C
00011FE2 E40C                     M 	dc.b	$e4,$0c
00011FE4                            	ssJump            Boss_FM2
00011FE4 F6                       M 	dc.b	$f6
00011FE5 FFD7                     M 	dc.w	boss_fm2-*-1
00011FE7                            
00011FE7                            Boss_Call01:
00011FE7 AE06 80B0 80B1 18B3 B1B0+  	dc.b	nA3, $06, nRst, nB3, nRst, nC4, $18, nD4, nC4, nB3, $06, nRst
00011FF3 B180 B080 AC18 A906 80AC+  	dc.b	nC4, nRst, nB3, nRst, nG3, $18, nE3, $06, nRst, nG3, $18, nA3
00011FFF 0680 B080 B118 B3B1 B006+  	dc.b	$06, nRst, nB3, nRst, nC4, $18, nD4, nC4, nB3, $06, nRst, nC4
0001200B 80B3 80B4 80B5 0C80 24     	dc.b	nRst, nD4, nRst, nEb4, nRst, nE4, $0C, nRst, $24
00012014                            	sRet
00012014 F9                       M 	dc.b	$f9
00012015                            
00012015                            ; FM3 Data
00012015                            Boss_FM3:
00012015                            	sVoice        $58
00012015 E858                     M 	dc.b	$e8,$58
00012017                            
00012017                            Boss_Loop06:
00012017                            	sNoteTimeOut        $08
00012017 FD08                     M 	dc.b	$fd,$08
00012019 B10C AEAE B1AE AEB1 AE     	dc.b	nC4, $0C, nA3, nA3, nC4, nA3, nA3, nC4, nA3
00012022                            	sNoteTimeOut        $17
00012022 FD17                     M 	dc.b	$fd,$17
00012024 AD18 ADAD AD               	dc.b	nAb3, $18, nAb3, nAb3, nAb3
00012029                            	sLoop            $00, $02, Boss_Loop06
00012029 F700                     M 	dc.b	$f7,$00
0001202B FFEB                     M 	dc.w	boss_loop06-*-1
0001202D 02                       M 	dc.b	$02
0001202E                            
0001202E                            Boss_Loop07:
0001202E 8030                       	dc.b	nRst, $30
00012030                            	sLoop            $00, $10, Boss_Loop07
00012030 F700                     M 	dc.b	$f7,$00
00012032 FFFB                     M 	dc.w	boss_loop07-*-1
00012034 10                       M 	dc.b	$10
00012035                            	ssDetune       $03
00012035 E103                     M 	dc.b	$e1,$03
00012037                            	saVol        $FC
00012037 EDFC                     M 	dc.b	$ed,$fc
00012039                            
00012039                            Boss_Loop08:
00012039                            	sCall            Boss_Call01
00012039 F8                       M 	dc.b	$f8
0001203A FFAC                     M 	dc.w	boss_call01-*-1
0001203C                            	sLoop            $00, $02, Boss_Loop08
0001203C F700                     M 	dc.b	$f7,$00
0001203E FFFA                     M 	dc.w	boss_loop08-*-1
00012040 02                       M 	dc.b	$02
00012041                            	ssDetune       $00
00012041 E100                     M 	dc.b	$e1,$00
00012043                            	saVol        $04
00012043 ED04                     M 	dc.b	$ed,$04
00012045                            	ssJump            Boss_FM3
00012045 F6                       M 	dc.b	$f6
00012046 FFCE                     M 	dc.w	boss_fm3-*-1
00012048                            
00012048                            ; FM4 Data
00012048                            Boss_FM4:
00012048                            	sPan             spLeft, $00
00012048 E080                     M 	dc.b	$e0,spleft|$00
0001204A                            	ssDetune       $02
0001204A E102                     M 	dc.b	$e1,$02
0001204C                            	ssMod68k          $0C, $01, $04, $04
0001204C F00C 0104 04             M 	dc.b	$f0,$0c,$01,$04,$04
00012051                            	ssJump            Boss_Jump00
00012051 F6                       M 	dc.b	$f6
00012052 0000                     M 	dc.w	boss_jump00-*-1
00012054                            
00012054                            ; FM5 Data
00012054                            Boss_FM5:
00012054                            	sPan             spRight, $00
00012054 E040                     M 	dc.b	$e0,spright|$00
00012056                            	ssMod68k          $0C, $01, $FC, $04
00012056 F00C 01FC 04             M 	dc.b	$f0,$0c,$01,$fc,$04
0001205B                            
0001205B                            Boss_Jump00:
0001205B                            	sModOff
0001205B EC                       M 	dc.b	$ec
0001205C                            	sVoice        $57
0001205C E857                     M 	dc.b	$e8,$57
0001205E 8030 8024 BF06 C1C2 0CC2+  	dc.b	nRst, $30, nRst, $24, nD5, $06, nE5, nF5, $0C, nF5, nE5, nE5
0001206A BFBF C180 8030 8024 BF06+  	dc.b	nD5, nD5, nE5, nRst, nRst, $30, nRst, $24, nD5, $06, nE5, nF5
00012076 0CC1 C0C1 C518 C1          	dc.b	$0C, nE5, nEb5, nE5, nAb5, $18, nE5
0001207D                            
0001207D                            Boss_Loop05:
0001207D 8030 80                    	dc.b	nRst, $30, nRst
00012080                            	sLoop            $00, $04, Boss_Loop05
00012080 F700                     M 	dc.b	$f7,$00
00012082 FFFA                     M 	dc.w	boss_loop05-*-1
00012084 04                       M 	dc.b	$04
00012085                            	sModOn
00012085 EB                       M 	dc.b	$eb
00012086                            	saVol        $02
00012086 ED02                     M 	dc.b	$ed,$02
00012088                            	sCall            Boss_Call00
00012088 F8                       M 	dc.b	$f8
00012089 0000                     M 	dc.w	boss_call00-*-1
0001208B AC                         	dc.b	nG3
0001208C                            	sCall            Boss_Call00
0001208C F8                       M 	dc.b	$f8
0001208D 0000                     M 	dc.w	boss_call00-*-1
0001208F ADBD E718 BF0C BDBC 30B8+  	dc.b	nAb3, nC5, sHold, $18, nD5, $0C, nC5, nB4, $30, nG4, nC5, sHold
0001209B 18BF 0CBD BC30 B9          	dc.b	$18, nD5, $0C, nC5, nB4, $30, nAb4
000120A2                            	saVol        $F5
000120A2 EDF5                     M 	dc.b	$ed,$f5
000120A4                            	sVoice        $58
000120A4 E858                     M 	dc.b	$e8,$58
000120A6 BD06 80BF 80C1 18C2 C1BF+  	dc.b	nC5, $06, nRst, nD5, nRst, nE5, $18, nF5, nE5, nD5, $06, nRst
000120B2 C180 BF80 BC18 B806 80BC+  	dc.b	nE5, nRst, nD5, nRst, nB4, $18, nG4, $06, nRst, nB4, $18, nC5
000120BE 0680 BF80 C118 C2C1 BF06+  	dc.b	$06, nRst, nD5, nRst, nE5, $18, nF5, nE5, nD5, $06, nRst, nE5
000120CA 80C2 80C3 80C5 0C80 24     	dc.b	nRst, nF5, nRst, nFs5, nRst, nAb5, $0C, nRst, $24
000120D3                            	saVol        $09
000120D3 ED09                     M 	dc.b	$ed,$09
000120D5                            	ssJump            Boss_Jump00
000120D5 F6                       M 	dc.b	$f6
000120D6 FF84                     M 	dc.w	boss_jump00-*-1
000120D8                            
000120D8                            Boss_Call00:
000120D8 B130 E718 B30C B1B0 30     	dc.b	nC4, $30, sHold, $18, nD4, $0C, nC4, nB3, $30
000120E1                            	sRet
000120E1 F9                       M 	dc.b	$f9
000120E2                            
000120E2                            ; PSG3 Data
000120E2                            Boss_PSG3:
000120E2                            	sNoisePSG         $E7
000120E2 F3E7                     M 	dc.b	$f3,$e7
000120E4                            	sNoteTimeOut        $05
000120E4 FD05                     M 	dc.b	$fd,$05
000120E6                            
000120E6                            Boss_Loop0D:
000120E6 C624 2418 8030 80          	dc.b	nA5, $24, $24, $18, nRst, $30, nRst
000120ED                            	sLoop            $00, $02, Boss_Loop0D
000120ED F700                     M 	dc.b	$f7,$00
000120EF FFF6                     M 	dc.w	boss_loop0d-*-1
000120F1 02                       M 	dc.b	$02
000120F2                            
000120F2                            Boss_Loop0E:
000120F2 C618                       	dc.b	nA5, $18
000120F4                            	sLoop            $00, $40, Boss_Loop0E
000120F4 F700                     M 	dc.b	$f7,$00
000120F6 FFFB                     M 	dc.w	boss_loop0e-*-1
000120F8 40                       M 	dc.b	$40
000120F9                            	ssJump            Boss_Loop0D
000120F9 F6                       M 	dc.b	$f6
000120FA FFEB                     M 	dc.w	boss_loop0d-*-1
000120FC                            
000120FC                            ; DAC Data
000120FC                            Boss_DAC:
000120FC 830C 8383 8383 8383 8387+  	dc.b	dSnare, $0C, dSnare, dSnare, dSnare, dSnare, dSnare, dSnare, dSnare, dTomMid, $0C, dTomL
00012108 8789 8789 8789             	dc.b	dTomMid, dTomL, dTomMid, dTomL, dTomMid, dTomL
0001210E                            	sLoop            $00, $02, Boss_DAC
0001210E F700                     M 	dc.b	$f7,$00
00012110 FFEB                     M 	dc.w	boss_dac-*-1
00012112 02                       M 	dc.b	$02
00012113 810C 8306 83               	dc.b	dKick, $0C, dSnare, $06, dSnare
00012118                            
00012118                            Boss_Loop00:
00012118 810C 8306 83               	dc.b	dKick, $0C, dSnare, $06, dSnare
0001211D                            	sLoop            $00, $06, Boss_Loop00
0001211D F700                     M 	dc.b	$f7,$00
0001211F FFF8                     M 	dc.w	boss_loop00-*-1
00012121 06                       M 	dc.b	$06
00012122 810C 8302 8704 8302 8704+  	dc.b	dKick, $0C, dSnare, $02, dTomMid, $04, dSnare, $02, dTomMid, $04, dTomL, $0C
0001212E 8306 83                    	dc.b	dSnare, $06, dSnare
00012131                            
00012131                            Boss_Loop01:
00012131 810C 8306 83               	dc.b	dKick, $0C, dSnare, $06, dSnare
00012136                            	sLoop            $00, $05, Boss_Loop01
00012136 F700                     M 	dc.b	$f7,$00
00012138 FFF8                     M 	dc.w	boss_loop01-*-1
0001213A 05                       M 	dc.b	$05
0001213B 810C 8302 8704 8302 8704+  	dc.b	dKick, $0C, dSnare, $02, dTomMid, $04, dSnare, $02, dTomMid, $04, dTomL, $0C
00012147 8302 8704 8302 8704 890C+  	dc.b	dSnare, $02, dTomMid, $04, dSnare, $02, dTomMid, $04, dTomL, $0C, dSnare, $06
00012153 83                         	dc.b	dSnare
00012154                            	sLoop            $01, $03, Boss_Loop00
00012154 F701                     M 	dc.b	$f7,$01
00012156 FFC1                     M 	dc.w	boss_loop00-*-1
00012158 03                       M 	dc.b	$03
00012159                            
00012159                            Boss_Loop02:
00012159 810C 8306 83               	dc.b	dKick, $0C, dSnare, $06, dSnare
0001215E                            	sLoop            $00, $06, Boss_Loop02
0001215E F700                     M 	dc.b	$f7,$00
00012160 FFF8                     M 	dc.w	boss_loop02-*-1
00012162 06                       M 	dc.b	$06
00012163 810C 8302 8704 8302 8704+  	dc.b	dKick, $0C, dSnare, $02, dTomMid, $04, dSnare, $02, dTomMid, $04, dTomL, $0C
0001216F 8306 83                    	dc.b	dSnare, $06, dSnare
00012172                            
00012172                            Boss_Loop03:
00012172 810C 8306 83               	dc.b	dKick, $0C, dSnare, $06, dSnare
00012177                            	sLoop            $00, $03, Boss_Loop03
00012177 F700                     M 	dc.b	$f7,$00
00012179 FFF8                     M 	dc.w	boss_loop03-*-1
0001217B 03                       M 	dc.b	$03
0001217C                            
0001217C                            Boss_Loop04:
0001217C 890C 8302 8704 8302 8704   	dc.b	dTomL, $0C, dSnare, $02, dTomMid, $04, dSnare, $02, dTomMid, $04
00012186                            	sLoop            $00, $04, Boss_Loop04
00012186 F700                     M 	dc.b	$f7,$00
00012188 FFF3                     M 	dc.w	boss_loop04-*-1
0001218A 04                       M 	dc.b	$04
0001218B                            	ssJump            Boss_DAC
0001218B F6                       M 	dc.b	$f6
0001218C FF6F                     M 	dc.w	boss_dac-*-1
0001218E                            		even
0001218E                            
0001218E                            ; -------------------------------------------------------------------------
0001218E                            musend
0001218E                            ; ===========================================================================
0001218E                            ; ---------------------------------------------------------------------------
0001218E                            ; Include samples and filters
0001218E                            ; ---------------------------------------------------------------------------
0001218E                            
0001218E                            		align	$8000		; must be aligned to bank...
0001218E                          M 	cnop	0,$8000
00018000                            fLog:		incbin "Sound/amps/filters/Logarithmic.dat"	; logarithmic filter (no filter)
00020000                            ;fLinear:	incbin "Sound/amps/filters/Linear.dat"	; linear filter (no filter)
00020000                            
00020000                            dacaddr		dcb.b	Z80E_Read*(MaxPitch/$100),$00
00020180                            SWF_Stop:	dcb.b	$8000-(2*Z80E_Read*(MaxPitch/$100)),$80
00027E80                            SWFR_Stop:	dcb.b	Z80E_Read*(MaxPitch/$100),$00
00028000                            
00028000                            	include	"Sound/dacdata.asm"
00028000                            
00028000                            
00028000                            ; ------------------------------------------------------------------------
00028000                            ; AMPS sample data
00028000                            ; -------------------------------------------------------------------------
00028000                            
00028000                            	incSWF	Kick,		"Sound/dac/incswf/Kick.swf"
00028000                          M swf_kick	incbin	"Sound/dac/incswf/Kick.swf"
00028E4A                          M swfr_kick	dcb.b	z80e_read*(maxpitch/$100),$00
00028FCA                            	incSWF	Snare,		"Sound/dac/incswf/Snare.swf"
00028FCA                          M swf_snare	incbin	"Sound/dac/incswf/Snare.swf"
0002B874                          M swfr_snare	dcb.b	z80e_read*(maxpitch/$100),$00
0002B9F4                            	incSWF	Tom,		"Sound/dac/incswf/Space Tom.swf"
0002B9F4                          M swf_tom	incbin	"Sound/dac/incswf/Space Tom.swf"
0002E288                          M swfr_tom	dcb.b	z80e_read*(maxpitch/$100),$00
0002E408                            	incSWF	Title,		"Sound/dac/incswf/Title.swf"
0002E408                          M swf_title	incbin	"Sound/dac/incswf/Title.swf"
00084EC7                          M swfr_title	dcb.b	z80e_read*(maxpitch/$100),$00
00085047                            	incSWF	Sega,		"Sound/dac/incswf/Sega.swf"
00085047                          M swf_sega	incbin	"Sound/dac/incswf/Sega.swf"
0008AC9D                          M swfr_sega	dcb.b	z80e_read*(maxpitch/$100),$00
0008AE1D                            	incSWF	Punch,		"Sound/dac/incswf/Punch.swf"
0008AE1D                          M swf_punch	incbin	"Sound/dac/incswf/Punch.swf"
0008D145                          M swfr_punch	dcb.b	z80e_read*(maxpitch/$100),$00
0008D2C5                            	incSWF	EndingSong,	"Sound/dac/incswf/EndingSong.swf"
0008D2C5                          M swf_endingsong	incbin	"Sound/dac/incswf/EndingSong.swf"
0009A6D8                          M swfr_endingsong	dcb.b	z80e_read*(maxpitch/$100),$00
0009A858                            	incSWF	BinBowie,	"Sound/dac/incswf/BinBowie.swf"
0009A858                          M swf_binbowie	incbin	"Sound/dac/incswf/BinBowie.swf"
000AF3FE                          M swfr_binbowie	dcb.b	z80e_read*(maxpitch/$100),$00
000AF57E                            	incSWF	Wacky_Base_Loud,"Sound/dac/incswf/Wacky_Base_Loud.swf"
000AF57E                          M swf_wacky_base_loud	incbin	"Sound/dac/incswf/Wacky_Base_Loud.swf"
000BB808                          M swfr_wacky_base_loud	dcb.b	z80e_read*(maxpitch/$100),$00
000BB988                            
000BB988                            ; -------------------------------------------------------------------------
000BB988                            	opt ae+				; enable automatic evens
000BB988                            	list				; continue source listing
000BB988                            ; ===========================================================================
000BB988                            DualPCM:
000BB988                            		z80prog	0
000BB988                          M 	pusho
000BB988                          M 	opt	ae-
000BB988                          M 	opt	an+
00000000                            		include	"Sound/amps/code/Z80.asm"
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; DUAL-PCM - by MarkeyJester
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_Read		macro
00000000                            		ldi					; 16	; copy from window to buffer, and increment register
00000000                            		zadd	a,b				; 04	; add dividend
00000000                            		adc	hl,sp				; 15	; add quotient
00000000                            		endm					; Total: 35
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_CapPCM	macro
00000000                            		jp	po, .ov\@			; 10	; if the sample hasn't overflown the 7F/80 boundary, branch
00000000                            		sbc	a,a				; 04	; erase sample, and subtract the carry to get either FF or 00, depending on overflow direction
00000000                            		xor	07Fh				; 07	; reverse FF/00 (xor 80 below helps)
00000000                            .ov\@		xor	080h				; 07	; convert to unsigned
00000000                            		endm					; Total: 17/28
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_Flush01	macro
00000000                            		ld	e,(hl)				; 07	; load byte from OUT buffer 1 to volume pointer
00000000                            		ld	a,(de)				; 07	; copy to a
00000000                            		zset	001h,h				; 08	; move forwards to OUT buffer 2
00000000                            		inc	d				; 04	; move forwards to volume pointer 2
00000000                            		ld	e,(hl)				; 07	; load byte from OUT buffer 2 to volume pointer
00000000                            		ex	de,hl				; 04	; swap for hl powers
00000000                            		zadd	a,(hl)				; 07	; add volume 2 to volume 1
00000000                            		ex	de,hl				; 04	; swap back
00000000                            		M_CapPCM					; cap the sample overflow
00000000                            		ld	(bc),a				; 07	; save to the YM2612
00000000                            		inc	l				; 04	; advance OUT buffers
00000000                            		endm					; Total: 59
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_Flush02	macro
00000000                            		ld	e,(hl)				; 07	; load byte from OUT buffer 2 to volume pointer
00000000                            		ld	a,(de)				; 07	; copy to a
00000000                            		res	001h,h				; 08	; move back to OUT buffer 1
00000000                            		dec	d				; 04	; move back to volume pointer 1
00000000                            		ld	e,(hl)				; 07	; load byte from OUT buffer 1 to volume pointer
00000000                            		ex	de,hl				; 04	; swap for hl powers
00000000                            		zadd	a,(hl)				; 07	; add volume 1 to volume 2
00000000                            		ex	de,hl				; 04	; swap back
00000000                            		M_CapPCM					; cap the sample overflow
00000000                            		ld	(bc),a				; 07	; save to the YM2612
00000000                            		inc	l				; 04	; advance OUT buffers
00000000                            		endm					; Total: 59
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_Revert01	macro
00000000                            		res	001h,h				; 08	; move back to OUT buffer 1
00000000                            		dec	d				; 04	; move back to volume pointer 1
00000000                            		dec	l				; 04	; move OUT buffers back
00000000                            		endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_Revert02	macro
00000000                            		zset	001h,h				; 08	; move forwards to OUT buffer 2
00000000                            		inc	d				; 04	; move forwards to volume pointer 2
00000000                            		dec	l				; 04	; move OUT buffers back
00000000                            		endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_Wrap		macro
00000000                            		dec	l				; 04	; check l...
00000000                            		inc	l				; 04	; ''
00000000                            		M_WrapCondition
00000000                            		endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_WrapCondition	macro
00000000                            		jp	nz, .c\@			; 10	; if it's not 0, branch
00000000                            		inc	h				; 04	; advance OUT buffers
00000000                            		bit	004h,h				; 08	; have the OUT buffer addresses reached 1000 (end of buffer) yet?
00000000                            		jp	z, .c\@				; 10	; if not, branch
00000000                            		ld	hl,PCM_Buffer2			; 10	; reset OUT buffers
00000000                            .c\@
00000000                            		endm
00000000                            
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Start of Z80 ROM
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            Z80_Start:
0000000B                            
0000000B 0000 0000 00               		align	MaxPitch/$100
00000010                            
00000010                            	; The space from "Start" until the maximum pitch amount, is the space
00000010                            	; where data could potentially be pushed into, thanks to the sp.
00000010                            
00000010                            	; The sp will likely be from roughly FFEF - 000F for the quotient of
00000010                            	; the pitch.  Now, FFEF - FFFF will be fine, since that points to the
00000010                            	; 68k window, which will be pointing to 68k ROM, so nothing will happen.
00000010                            	; But the address from 0000 - 000F points to the beginning of ROM, so
00000010                            	; this place must be free from use outside of V-blank.
00000010                            
00000010                            Z80_Stack:
00000010                            
00000010                            ; ===========================================================================
00000010                            ; ---------------------------------------------------------------------------
00000010                            ; PCM 1 Resetting
00000010                            ; ---------------------------------------------------------------------------
00000010                            		align	010h
00000010                            ; ---------------------------------------------------------------------------
00000010                            
00000010                            BreakLate:
00000019                            
00000019                            ; ===========================================================================
00000019                            ; ---------------------------------------------------------------------------
00000019                            ; PCM 1 Resetting
00000019                            ; ---------------------------------------------------------------------------
00000019 0000 0000 0000 0000 0000+  		align	028h
00000028                            ; ---------------------------------------------------------------------------
00000028                            
00000028                            PCM1_ResetJmp:
0000002B                            
0000002B                            ; ===========================================================================
0000002B                            ; ---------------------------------------------------------------------------
0000002B                            ; PCM 2 Resetting
0000002B                            ; ---------------------------------------------------------------------------
0000002B 0000 0000 00               		align	030h
00000030                            ; ---------------------------------------------------------------------------
00000030                            
00000030                            PCM2_ResetJmp:
00000033                            
00000033                            ; ===========================================================================
00000033                            ; ---------------------------------------------------------------------------
00000033                            ; Breaking out for V-blank
00000033                            ; ---------------------------------------------------------------------------
00000033 0000 0000 00               		align	038h
00000038                            ; ---------------------------------------------------------------------------
00000038                            
00000038                            BreakVBlank:
0000003C 2F                         		cpl					; 04	; change buffer
00000040                            
00000040                            BVB_Check:
00000046                            
00000046                            ; ---------------------------------------------------------------------------
00000046                            ; Breaking out for V-blank, during non-read
00000046                            ; ---------------------------------------------------------------------------
00000046                            
00000046                            BreakPrep:
00000061                            	;	ei					; 04	; enable interrupts
00000061 ED4D                       		reti					; 14	; return
00000063                            
00000063                            ; ===========================================================================
00000063                            ; ---------------------------------------------------------------------------
00000063                            ; Breaking out for V-blank, during read of window or bank register
00000063                            ; ---------------------------------------------------------------------------
00000063                            
00000063                            BreakDMA:
00000066                            
00000066                            	; --- Finding out which registers we're dealing with ---
00000066                            
00000074 1F                         BDMA_NoExchange:	rra					; 04	; get buffer we're currently reading from
00000083 D9                         BDMA_NoFixFlush:	exx					; 04	; swap to the "read" set of exx registers
00000084                            BDMA_ReadSet:
00000084                            
00000084                            ; ---------------------------------------------------------------------------
00000084                            ; Flush remaining data
00000084                            ; ---------------------------------------------------------------------------
00000084                            
00000084                            BreakBank:
00000084 D9                         			exx					; 04	; switch registers
00000086 D9                         			exx					; 04	; switch registers
00000087 ED44                       		zneg	a				; 08	; reverse position
00000090                            
00000090                            BDMA_NoMax:
0000009A                            
0000009A                            BDMA_FlushLoop:
0000009E                            
0000009E                            BDMA_Flush02:
0000009E D9                         			exx					; 04	; switch registers
000000B2 D9                         			exx					; 04	; switch registers
000000B7                            
000000B7                            BDMA_Flush01:
000000B7 D9                         			exx					; 04	; switch registers
000000CB D9                         			exx					; 04	; switch registers
000000D0                            
000000D0                            ; ---------------------------------------------------------------------------
000000D0                            ; Wrapping OUT buffers
000000D0                            ; ---------------------------------------------------------------------------
000000D0                            
000000D0 D9                         			exx					; 04	; switch registers
000000DF D9                         			exx					; 04	; switch back
000000E0                            
000000E0                            ; ---------------------------------------------------------------------------
000000E0                            ; Restore interrupt instructions
000000E0                            ; ---------------------------------------------------------------------------
000000E0                            
00000107                            
00000107                            BDMA_NoRestore:
00000107                            
00000107                            ; ---------------------------------------------------------------------------
00000107                            ; YM2612 flushing
00000107                            ; ---------------------------------------------------------------------------
00000107                            
0000010A                            
00000116                            
00000116                            YMF_Buff1:
0000011F D9                         			exx					; 04	; switch registers back
00000120                            
00000120                            YM_Flush:
00000123                            
00000123                            YMF_NextByte:
00000136 D9                         			exx					; 04	; switch registers
00000149 D9                         			exx					; 04	; switch registers
0000015D D9                         			exx					; 04	; switch registers
00000170 D9                         			exx					; 04	; switch registers
00000176                            
00000176                            	; --- Advance/Wrap OUT buffers ---
00000176                            
00000189                            
00000189                            YMF_Finish02:
00000192                            
00000192                            YMF_Finish01:
0000019B                            
0000019B                            ; ---------------------------------------------------------------------------
0000019B                            ; Waiting for v-blank to finish
0000019B                            ; ---------------------------------------------------------------------------
0000019B                            
0000019B                            PCM_Flush_exx:
0000019B D9                         			exx
0000019C                            
0000019C                            PCM_Flush:
0000019F                            
0000019F                            PCM_NextByte:
000001B2 D9                         			exx					; 04	; switch registers
000001B7                            
000001B7                            
000001B7 D9                         			exx					; 04	; switch registers
000001CB D9                         			exx					; 04	; switch registers
000001CC                            
000001D0                            
000001D0 D9                         			exx					; 04	; switch registers
000001D6                            
000001D6                            	; --- Advance/Wrap OUT buffers ---
000001D6                            
000001E4                            
000001E9 D9                         		exx					; 04	; switch registers down again...
000001EA                            
000001F6                            
000001F6                            YMF_SetBuff1:
000001F8                            
00000202                            
00000202                            VB_PCM1_VolOK:
0000020C                            
0000020C                            VB_PCM2_VolOK:
0000020C                            
0000020C 37                         		scf					; 04	; set carry flag
0000020D                            
00000222                            
00000222                            PCM_VolChangeNo:
00000222                            
00000222                            
0000022D                            
0000022D                            ; ===========================================================================
0000022D                            ; ---------------------------------------------------------------------------
0000022D                            ; Setup/Init
0000022D                            ; ---------------------------------------------------------------------------
0000022D                            
0000022D                            Z80_Init:
00000230                            
00000230                            	; --- YM2612 DAC Setup ---
00000230                            
0000023F                            
0000023F                            	; --- Setting up channels to be mute ---
0000023F                            
00000251                            
0000025A EDB0                       			ldir					; 21 16	; copy mute sample data over...
00000261 EDB0                       			ldir					; 21 16	; copy mute sample data over...
00000268 EDB0                       			ldir					; 21 16	; copy mute sample data over...
0000026F EDB0                       			ldir					; 21 16	; copy mute sample data over...
00000271                            
00000271                            	; --- Setting up PCM 1 switch ---
00000271                            
0000027A                            
0000027A                            	; --- Setting up PCM 2 switch ---
0000027A                            
00000283                            
00000283                            	; --- Final register setup ---
00000283                            
0000028B                            
00000290                            
00000290 D9                         			exx					; 04	; switch registers
00000291                            
00000291                            ; ===========================================================================
00000291                            ; ---------------------------------------------------------------------------
00000291                            ; The catch up loop
00000291                            ; ---------------------------------------------------------------------------
00000291                            
00000291                            CatchUp:
00000291 D9                         			exx					; 04	; switch registers
00000292                            
00000292                            CatchUp_Exx:
000002A5 D9                         			exx					; 04	; switch registers
000002A6                            
000002A6                            Z80_Int2:	;ei
000002A6 00                         		znop					; 04
000002A7                            
000002A7                            ; ---------------------------------------------------------------------------
000002A7                            ; PCM 1
000002A7                            ; ---------------------------------------------------------------------------
000002A7                            
000002A7                            PCM1_MuteRet:
000002AC 00                         Int1_nop:	znop					; 04	; CANNOT CHANGE "ld  (hl),h" since it's altered by Z80 elsewhere
000002C8 D9                         			exx					; 04	; switch registers
000002DC D9                         			exx					; 04	; switch registers
000002E4                            
000002E4                            PCM1_PrepRet:
000002E4                            
000002F2                            
000002FC EDA0                       PCM1_PreInst03:	ldi					; 16	; copy from window to buffer, and increment register
000002FE D9                         			exx					; 04	; switch registers
00000313 D9                         			exx					; 04	; switch registers
0000032C D9                         			exx					; 04	; switch registers
00000341 D9                         			exx					; 04	; switch registers
00000357 EDA0                       PCM1_PreInst0C:	ldi					; 16	; copy from window to buffer, and increment register
00000359 D9                         			exx					; 04	; switch registers
0000036E D9                         			exx					; 04	; switch registers
00000387 D9                         			exx					; 04	; switch registers
0000039C D9                         			exx					; 04	; switch registers
000003B2 EDA0                       PCM1_PreInst15:	ldi					; 16	; copy from window to buffer, and increment register
000003B4 D9                         			exx					; 04	; switch registers
000003C9 D9                         			exx					; 04	; switch registers
000003E6 D9                         			exx					; 04	; switch registers
000003FB D9                         			exx					; 04	; switch registers
00000403                            
00000403                            ; ---------------------------------------------------------------------------
00000403                            ; PCM 2
00000403                            ; ---------------------------------------------------------------------------
00000403                            
00000403                            PCM2_MuteRet:
00000408 00                         Int2_nop:	znop					; 04	; CANNOT CHANGE "ld  (hl),h" since it's altered by Z80 elsewhere
0000041A D9                         			exx					; 04	; switch registers
0000042E D9                         			exx					; 04	; switch registers
00000440                            
00000440                            PCM2_PrepRet:
00000440                            
0000044E                            
00000453 D9                         			exx					; 04	; switch registers
00000468 D9                         			exx					; 04	; switch registers
0000047E EDA0                       PCM2_PreInst06:	ldi					; 16	; copy from window to buffer, and increment register
00000480 D9                         			exx					; 04	; switch registers
00000495 D9                         			exx					; 04	; switch registers
000004AE D9                         			exx					; 04	; switch registers
000004C3 D9                         			exx					; 04	; switch registers
000004D9 EDA0                       PCM2_PreInst0F:	ldi					; 16	; copy from window to buffer, and increment register
000004DB D9                         			exx					; 04	; switch registers
000004F0 D9                         			exx					; 04	; switch registers
00000509 D9                         			exx					; 04	; switch registers
0000051E D9                         			exx					; 04	; switch registers
00000534 EDA0                       PCM2_PreInst18:	ldi					; 16	; copy from window to buffer, and increment register
00000536 D9                         			exx					; 04	; switch registers
0000054B D9                         			exx					; 04	; switch registers
0000055F                            
00000570                            
00000570                            ; ---------------------------------------------------------------------------
00000570                            ; Wrapping OUT buffers
00000570                            ; ---------------------------------------------------------------------------
00000570                            
00000570 D9                         			exx					; 04	; switch registers
00000590 D9                         			exx					; 04	; switch back
00000591                            
00000591                            ; ---------------------------------------------------------------------------
00000591                            ; Wrap IN buffers
00000591                            ; ---------------------------------------------------------------------------
00000591                            
000005A3                            
000005A3                            PCM_BuffNoReset:
000005A3                            
000005A3                            ; ---------------------------------------------------------------------------
000005A3                            ; Rebank...
000005A3                            ; ---------------------------------------------------------------------------
000005A3                            
000005A3 37                         		scf					; 04	; set carry flag
000005BA 37                         		scf					; 04	; set carry flag
000005BB                            
000005BB                            PCM1_IgnoreBank:
000005D1 37                         		scf					; 04	; set carry flag
000005D2                            
000005D2                            PCM2_IgnoreBank:
000005D2                            
000005D2                            ; ---------------------------------------------------------------------------
000005D2                            ; Pitch control
000005D2                            ; ---------------------------------------------------------------------------
000005D2                            
000005DA                            
00000602 37                         		scf					; 04	; set carry flag
00000603                            
00000603                            PCM1_IgnorePitch:
00000603                            
0000060B                            
00000633 37                         		scf					; 04	; set carry flag
00000634                            
00000634                            PCM2_IgnorePitch:
00000634                            
00000634                            ; ---------------------------------------------------------------------------
00000634                            ; Updating Volume
00000634                            ; ---------------------------------------------------------------------------
00000634                            
0000064B                            	;	scf					; 04	; don't think it's necessary here...
0000064B                            
0000064E                            PCM_VolumeRet:
0000064E                            
0000064E                            
0000064E                            ; ---------------------------------------------------------------------------
0000064E                            ; New samples...
0000064E                            ; ---------------------------------------------------------------------------
0000064E                            
00000654                            
00000654                            ; ---------------------------------------------------------------------------
00000654                            ; Checking for "Flush" mode
00000654                            ; ---------------------------------------------------------------------------
00000654                            
00000654                            PCM_NoUpdate:
00000654 D9                         		exx					; 04	; switch registers
00000656 1F                         			rra					; 04	; get upper bit only into carry
00000658 1F                         			rra					; 04	; shift address down with carry
00000659 D9                         		exx					; 04	; switch registers
0000066A                            
0000066A                            CU_ValidDist:
0000066F                            
0000066F                            ; ---------------------------------------------------------------------------
0000066F                            ; New sample playback
0000066F                            ; ---------------------------------------------------------------------------
0000066F                            
0000066F                            CU_Flush:
0000066F                            
0000066F                            ; ---------------------------------------------------------------------------
0000066F                            ; Main "Flush" loop
0000066F                            ; ---------------------------------------------------------------------------
0000066F                            
0000066F D9                         			exx					; 04	; switch registers back
00000673                            
00000673                            FL_NextByte:
00000686 D9                         			exx					; 04	; switch registers
0000068C D9                         			exx					; 04	; switch registers
000006A0 D9                         			exx					; 04	; switch registers
000006A5 D9                         			exx					; 04	; switch registers
000006A6                            
000006AB                            
000006AB                            	; --- Advance/Wrap OUT buffers ---
000006AB                            
000006BC                            
000006BC                            ; ===========================================================================
000006BC                            ; ---------------------------------------------------------------------------
000006BC                            ; When PCM sample 1 has reached an end marker & needs to loop back
000006BC                            ; ---------------------------------------------------------------------------
000006BC                            
000006BC                            PCM1_Mute:
000006CE                            
000006CE                            PCM1_Normal:
000006D4                            
000006D4                            PCM1_Reverse:
000006E4 D9                         			exx					; 04	; switch registers
000006E9 D9                         			exx					; 04	; switch registers
000006ED                            
000006ED                            ; ===========================================================================
000006ED                            ; ---------------------------------------------------------------------------
000006ED                            ; When PCM sample 1 address has reached the end of a window, just to play the last bit
000006ED                            ; ---------------------------------------------------------------------------
000006ED                            
000006ED                            PCM1_PrepReset:
000006FC                            
000006FC                            PCM1_PrepCount:
00000715 D9                         			exx					; 04	; switch registers
00000729 D9                         			exx					; 04	; switch registers
00000731                            
00000731                            ; ===========================================================================
00000731                            ; ---------------------------------------------------------------------------
00000731                            ; When PCM sample 1 address has gone outside the window, and needs to reset
00000731                            ; ---------------------------------------------------------------------------
00000731                            
00000731                            PCM1_Reset:
0000074B                            
00000755                            
00000758                            
0000075A                            
0000075F                            
0000076B                            
00000771 0F                         		rrca					; 04
00000773 0F                         		rrca					; 04
00000775 0F                         		rrca					; 04
00000777 0F                         		rrca					; 04
00000779 0F                         		rrca					; 04
0000077B 0F                         		rrca					; 04
0000077D 0F                         		rrca					; 04
00000780                            
00000782                            
00000787                            
00000797                            
0000079A                            
0000079A                            ; ===========================================================================
0000079A                            ; ---------------------------------------------------------------------------
0000079A                            ; 68K SET - routine to load a new sample 1
0000079A                            ; ---------------------------------------------------------------------------
0000079A                            
0000079A                            PCM1_NewSample:
000007AA                            
000007AA                            PCM1_NewNormal:
000007B0                            
000007B0                            PCM1_NewReverse:
000007C0                            
000007C5 37                         		scf					; 04	; set C flag (for "JP NC" instruction)
000007C7                            
000007C7                            ; ===========================================================================
000007C7                            ; ---------------------------------------------------------------------------
000007C7                            ; When PCM sample 2 has reached an end marker & needs to loop back
000007C7                            ; ---------------------------------------------------------------------------
000007C7                            
000007C7                            PCM2_Mute:
000007D9                            
000007D9                            PCM2_Normal:
000007DF                            
000007DF                            PCM2_Reverse:
000007EF D9                         			exx					; 04	; switch registers
000007F4 D9                         			exx					; 04	; switch registers
000007F8                            
000007F8                            ; ===========================================================================
000007F8                            ; ---------------------------------------------------------------------------
000007F8                            ; When PCM sample 2 address has reached the end of a window, just to play the last bit
000007F8                            ; ---------------------------------------------------------------------------
000007F8                            
000007F8                            PCM2_PrepReset:
00000807                            
00000807                            PCM2_PrepCount:
00000827                            
00000827                            ; ===========================================================================
00000827                            ; ---------------------------------------------------------------------------
00000827                            ; When PCM sample 2 address has gone outside the window, and needs to reset
00000827                            ; ---------------------------------------------------------------------------
00000827                            
00000827                            PCM2_Reset:
00000841                            
0000084B                            
0000084E                            
00000850                            
00000855                            
00000861                            
00000867 0F                         		rrca					; 04
00000869 0F                         		rrca					; 04
0000086B 0F                         		rrca					; 04
0000086D 0F                         		rrca					; 04
0000086F 0F                         		rrca					; 04
00000871 0F                         		rrca					; 04
00000873 0F                         		rrca					; 04
00000876                            
00000878                            
0000087D                            
0000088D                            
00000890                            
00000890                            ; ===========================================================================
00000890                            ; ---------------------------------------------------------------------------
00000890                            ; 68K SET - routine to load a new sample 2
00000890                            ; ---------------------------------------------------------------------------
00000890                            
00000890                            PCM2_NewSample:
000008A0                            
000008A0                            PCM2_NewNormal:
000008A6                            
000008A6                            PCM2_NewReverse:
000008B6                            
000008BB 37                         		scf					; 04	; set C flag (for "JP NC" instruction)
000008BD                            
000008BD                            ; ===========================================================================
000008BD                            ; ---------------------------------------------------------------------------
000008BD                            ; PCM volume Lists
000008BD                            ; ---------------------------------------------------------------------------
000008BD                            		align	00200h
00000A00                            ; ---------------------------------------------------------------------------
00000A00                            
00000A00 0081 8283 8485 8687 8889+  PCM_Volume1:	db	000h,081h,082h,083h,084h,085h,086h,087h,088h,089h,08Ah,08Bh,08Ch,08Dh,08Eh,08Fh
00000A10 9091 9293 9495 9697 9899+  		db	090h,091h,092h,093h,094h,095h,096h,097h,098h,099h,09Ah,09Bh,09Ch,09Dh,09Eh,09Fh
00000A20 A0A1 A2A3 A4A5 A6A7 A8A9+  		db	0A0h,0A1h,0A2h,0A3h,0A4h,0A5h,0A6h,0A7h,0A8h,0A9h,0AAh,0ABh,0ACh,0ADh,0AEh,0AFh
00000A30 B0B1 B2B3 B4B5 B6B7 B8B9+  		db	0B0h,0B1h,0B2h,0B3h,0B4h,0B5h,0B6h,0B7h,0B8h,0B9h,0BAh,0BBh,0BCh,0BDh,0BEh,0BFh
00000A40 C0C1 C2C3 C4C5 C6C7 C8C9+  		db	0C0h,0C1h,0C2h,0C3h,0C4h,0C5h,0C6h,0C7h,0C8h,0C9h,0CAh,0CBh,0CCh,0CDh,0CEh,0CFh
00000A50 D0D1 D2D3 D4D5 D6D7 D8D9+  		db	0D0h,0D1h,0D2h,0D3h,0D4h,0D5h,0D6h,0D7h,0D8h,0D9h,0DAh,0DBh,0DCh,0DDh,0DEh,0DFh
00000A60 E0E1 E2E3 E4E5 E6E7 E8E9+  		db	0E0h,0E1h,0E2h,0E3h,0E4h,0E5h,0E6h,0E7h,0E8h,0E9h,0EAh,0EBh,0ECh,0EDh,0EEh,0EFh
00000A70 F0F1 F2F3 F4F5 F6F7 F8F9+  		db	0F0h,0F1h,0F2h,0F3h,0F4h,0F5h,0F6h,0F7h,0F8h,0F9h,0FAh,0FBh,0FCh,0FDh,0FEh,0FFh
00000A80 0001 0203 0405 0607 0809+  		db	000h,001h,002h,003h,004h,005h,006h,007h,008h,009h,00Ah,00Bh,00Ch,00Dh,00Eh,00Fh
00000A90 1011 1213 1415 1617 1819+  		db	010h,011h,012h,013h,014h,015h,016h,017h,018h,019h,01Ah,01Bh,01Ch,01Dh,01Eh,01Fh
00000AA0 2021 2223 2425 2627 2829+  		db	020h,021h,022h,023h,024h,025h,026h,027h,028h,029h,02Ah,02Bh,02Ch,02Dh,02Eh,02Fh
00000AB0 3031 3233 3435 3637 3839+  		db	030h,031h,032h,033h,034h,035h,036h,037h,038h,039h,03Ah,03Bh,03Ch,03Dh,03Eh,03Fh
00000AC0 4041 4243 4445 4647 4849+  		db	040h,041h,042h,043h,044h,045h,046h,047h,048h,049h,04Ah,04Bh,04Ch,04Dh,04Eh,04Fh
00000AD0 5051 5253 5455 5657 5859+  		db	050h,051h,052h,053h,054h,055h,056h,057h,058h,059h,05Ah,05Bh,05Ch,05Dh,05Eh,05Fh
00000AE0 6061 6263 6465 6667 6869+  		db	060h,061h,062h,063h,064h,065h,066h,067h,068h,069h,06Ah,06Bh,06Ch,06Dh,06Eh,06Fh
00000AF0 7071 7273 7475 7677 7879+  		db	070h,071h,072h,073h,074h,075h,076h,077h,078h,079h,07Ah,07Bh,07Ch,07Dh,07Eh,07Fh
00000B00                            
00000B00 0081 8283 8485 8687 8889+  PCM_Volume2:	db	000h,081h,082h,083h,084h,085h,086h,087h,088h,089h,08Ah,08Bh,08Ch,08Dh,08Eh,08Fh
00000B10 9091 9293 9495 9697 9899+  		db	090h,091h,092h,093h,094h,095h,096h,097h,098h,099h,09Ah,09Bh,09Ch,09Dh,09Eh,09Fh
00000B20 A0A1 A2A3 A4A5 A6A7 A8A9+  		db	0A0h,0A1h,0A2h,0A3h,0A4h,0A5h,0A6h,0A7h,0A8h,0A9h,0AAh,0ABh,0ACh,0ADh,0AEh,0AFh
00000B30 B0B1 B2B3 B4B5 B6B7 B8B9+  		db	0B0h,0B1h,0B2h,0B3h,0B4h,0B5h,0B6h,0B7h,0B8h,0B9h,0BAh,0BBh,0BCh,0BDh,0BEh,0BFh
00000B40 C0C1 C2C3 C4C5 C6C7 C8C9+  		db	0C0h,0C1h,0C2h,0C3h,0C4h,0C5h,0C6h,0C7h,0C8h,0C9h,0CAh,0CBh,0CCh,0CDh,0CEh,0CFh
00000B50 D0D1 D2D3 D4D5 D6D7 D8D9+  		db	0D0h,0D1h,0D2h,0D3h,0D4h,0D5h,0D6h,0D7h,0D8h,0D9h,0DAh,0DBh,0DCh,0DDh,0DEh,0DFh
00000B60 E0E1 E2E3 E4E5 E6E7 E8E9+  		db	0E0h,0E1h,0E2h,0E3h,0E4h,0E5h,0E6h,0E7h,0E8h,0E9h,0EAh,0EBh,0ECh,0EDh,0EEh,0EFh
00000B70 F0F1 F2F3 F4F5 F6F7 F8F9+  		db	0F0h,0F1h,0F2h,0F3h,0F4h,0F5h,0F6h,0F7h,0F8h,0F9h,0FAh,0FBh,0FCh,0FDh,0FEh,0FFh
00000B80 0001 0203 0405 0607 0809+  		db	000h,001h,002h,003h,004h,005h,006h,007h,008h,009h,00Ah,00Bh,00Ch,00Dh,00Eh,00Fh
00000B90 1011 1213 1415 1617 1819+  		db	010h,011h,012h,013h,014h,015h,016h,017h,018h,019h,01Ah,01Bh,01Ch,01Dh,01Eh,01Fh
00000BA0 2021 2223 2425 2627 2829+  		db	020h,021h,022h,023h,024h,025h,026h,027h,028h,029h,02Ah,02Bh,02Ch,02Dh,02Eh,02Fh
00000BB0 3031 3233 3435 3637 3839+  		db	030h,031h,032h,033h,034h,035h,036h,037h,038h,039h,03Ah,03Bh,03Ch,03Dh,03Eh,03Fh
00000BC0 4041 4243 4445 4647 4849+  		db	040h,041h,042h,043h,044h,045h,046h,047h,048h,049h,04Ah,04Bh,04Ch,04Dh,04Eh,04Fh
00000BD0 5051 5253 5455 5657 5859+  		db	050h,051h,052h,053h,054h,055h,056h,057h,058h,059h,05Ah,05Bh,05Ch,05Dh,05Eh,05Fh
00000BE0 6061 6263 6465 6667 6869+  		db	060h,061h,062h,063h,064h,065h,066h,067h,068h,069h,06Ah,06Bh,06Ch,06Dh,06Eh,06Fh
00000BF0 7071 7273 7475 7677 7879+  		db	070h,071h,072h,073h,074h,075h,076h,077h,078h,079h,07Ah,07Bh,07Ch,07Dh,07Eh,07Fh
00000C00                            
00000C00                            ; ===========================================================================
00000C00                            ; ---------------------------------------------------------------------------
00000C00                            ; Bank interrupt preparation list
00000C00                            ; ---------------------------------------------------------------------------
00000C00                            		align	00080h
00000C00                            ; ---------------------------------------------------------------------------
00000C00                            
00000C00 F202                       PCM1_PrepTable:	dw	PCM1_PreInst01
00000C02 F702                       		dw	PCM1_PreInst02
00000C04 FC02                       		dw	PCM1_PreInst03
00000C06 1803                       		dw	PCM1_PreInst04
00000C08 1D03                       		dw	PCM1_PreInst05
00000C0A 2203                       		dw	PCM1_PreInst06
00000C0C 2703                       		dw	PCM1_PreInst07
00000C0E 4303                       		dw	PCM1_PreInst08
00000C10 4803                       		dw	PCM1_PreInst09
00000C12 4D03                       		dw	PCM1_PreInst0A
00000C14 5203                       		dw	PCM1_PreInst0B
00000C16 5703                       		dw	PCM1_PreInst0C
00000C18 7303                       		dw	PCM1_PreInst0D
00000C1A 7803                       		dw	PCM1_PreInst0E
00000C1C 7D03                       		dw	PCM1_PreInst0F
00000C1E 8203                       		dw	PCM1_PreInst10
00000C20 9E03                       		dw	PCM1_PreInst11
00000C22 A303                       		dw	PCM1_PreInst12
00000C24 A803                       		dw	PCM1_PreInst13
00000C26 AD03                       		dw	PCM1_PreInst14
00000C28 B203                       		dw	PCM1_PreInst15
00000C2A CE03                       		dw	PCM1_PreInst16
00000C2C D303                       		dw	PCM1_PreInst17
00000C2E D803                       		dw	PCM1_PreInst18
00000C30 4E04                       PCM2_PrepTable:	dw	PCM2_PreInst01
00000C32 6A04                       		dw	PCM2_PreInst02
00000C34 6F04                       		dw	PCM2_PreInst03
00000C36 7404                       		dw	PCM2_PreInst04
00000C38 7904                       		dw	PCM2_PreInst05
00000C3A 7E04                       		dw	PCM2_PreInst06
00000C3C 9A04                       		dw	PCM2_PreInst07
00000C3E 9F04                       		dw	PCM2_PreInst08
00000C40 A404                       		dw	PCM2_PreInst09
00000C42 A904                       		dw	PCM2_PreInst0A
00000C44 C504                       		dw	PCM2_PreInst0B
00000C46 CA04                       		dw	PCM2_PreInst0C
00000C48 CF04                       		dw	PCM2_PreInst0D
00000C4A D404                       		dw	PCM2_PreInst0E
00000C4C D904                       		dw	PCM2_PreInst0F
00000C4E F504                       		dw	PCM2_PreInst10
00000C50 FA04                       		dw	PCM2_PreInst11
00000C52 FF04                       		dw	PCM2_PreInst12
00000C54 0405                       		dw	PCM2_PreInst13
00000C56 2005                       		dw	PCM2_PreInst14
00000C58 2505                       		dw	PCM2_PreInst15
00000C5A 2A05                       		dw	PCM2_PreInst16
00000C5C 2F05                       		dw	PCM2_PreInst17
00000C5E 3405                       		dw	PCM2_PreInst18
00000C60                            
00000C60                            ; ===========================================================================
00000C60                            ; ---------------------------------------------------------------------------
00000C60                            ; Specific variable data...
00000C60                            ; ---------------------------------------------------------------------------
00000C60                            
00000C60                            	; --- Current bank address for PCM channels ---
00000C60                            
00000C60 00                         PCM1_BankCur:	db	000h					; The current bank address of PCM 1
00000C61 00                         PCM2_BankCur:	db	000h					; The current bank address of PCM 2
00000C62                            
00000C62                            	; --- "Mute Sample" pointer into 68k memory ---
00000C62                            
00000C62 0000                       MuteSample:	dw	00000h					; sample window address
00000C64 00                         MuteBank:	db	000h					; sample bank address
00000C65 0000                       MuteSample_Rev:	dw	00000h					; sample window address
00000C67 00                         MuteBank_Rev:	db	000h					; sample bank address
00000C68                            
00000C68                            	; --- YM2612 Pointers ---
00000C68                            
00000C68 00                         YM_Buffer:	db	000h					; 00 = Z80 Buffer 1 | 68k Buffer 2 ... FF = Z80 Buffer 2 | 68k Buffer 1
00000C69                            
00000C69                            ; ===========================================================================
00000C69                            ; ---------------------------------------------------------------------------
00000C69                            ; Sample requested by 68k
00000C69                            ; ---------------------------------------------------------------------------
00000C69                            
00000C69                            	; --- PCM 1 start sample ---
00000C69                            
00000C69 0000                       PCM1_Sample:		dw	00000h					; PCM 1 requested sample
00000C6B 00                         PCM1_Bank:		db	000h					; PCM 1 requested bank
00000C6C 0000                       PCM1_Sample_Rev:	dw	00000h					; PCM 1 requested sample (reverse position)
00000C6E 00                         PCM1_Bank_Rev:		db	000h					; PCM 1 requested bank (reverse position)
00000C6F                            
00000C6F                            	; --- PCM 1 next sample ---
00000C6F                            
00000C6F 0000                       PCM1_SampleNext:	dw	00000h					; PCM 1 requested sample
00000C71 00                         PCM1_BankNext:		db	000h					; PCM 1 requested bank
00000C72 0000                       PCM1_SampleNext_Rev:	dw	00000h					; PCM 1 requested sample (reverse position)
00000C74 00                         PCM1_BankNext_Rev:	db	000h					; PCM 1 requested bank (reverse position)
00000C75                            
00000C75                            	; --- PCM 2 start sample ---
00000C75                            
00000C75 0000                       PCM2_Sample:		dw	00000h					; PCM 2 requested sample
00000C77 00                         PCM2_Bank:		db	000h					; PCM 2 requested bank
00000C78 0000                       PCM2_Sample_Rev:	dw	00000h					; PCM 2 requested sample (reverse position)
00000C7A 00                         PCM2_Bank_Rev:		db	000h					; PCM 2 requested bank (reverse position)
00000C7B                            
00000C7B                            	; --- PCM 2 next sample ---
00000C7B                            
00000C7B 0000                       PCM2_SampleNext:	dw	00000h					; PCM 2 requested sample
00000C7D 00                         PCM2_BankNext:		db	000h					; PCM 2 requested bank
00000C7E 0000                       PCM2_SampleNext_Rev:	dw	00000h					; PCM 2 requested sample (reverse position)
00000C80 00                         PCM2_BankNext_Rev:	db	000h					; PCM 2 requested bank (reverse position)
00000C81                            
00000C81                            ; ===========================================================================
00000C81                            ; ---------------------------------------------------------------------------
00000C81                            ; PCM buffer (1000h = start of cue, Make sure both buffers end in a multiple of 100)
00000C81                            ; ---------------------------------------------------------------------------
00000C81                            
00000C81 0000 0000 0000 0000 0000+  		align	(01000h-00200h)-00150h
00000CB0                            PCM_Buffer1:	rept	00150h
00000CB0                            		db	080h
00000CB0 8080 8080 8080 8080 8080+  		endr
00000E00                            
00000E00 0000 0000 0000 0000 0000+  		align	01000h-00150h
00000EB0                            PCM_Buffer2:	rept	00150h
00000EB0                            		db	080h
00000EB0 8080 8080 8080 8080 8080+  		endr
00001000                            
00001000                            ; ===========================================================================
00001000                            ; ---------------------------------------------------------------------------
00001000                            ; The YM2612 operator writing lists (68k writes here, z80 must flush off)
00001000                            ; ---------------------------------------------------------------------------
00001000                            
00001000                            YM_Buffer1:	rept	00400h
00001000                            		db	0FFh
00001000 FFFF FFFF FFFF FFFF FFFF+  		endr
00001400                            
00001400                            YM_Buffer2:	rept	00400h
00001400                            		db	0FFh
00001400 FFFF FFFF FFFF FFFF FFFF+  		endr
00001800                            
00001800                            ; ===========================================================================
00001800                            ; ---------------------------------------------------------------------------
00001800                            ; Overflow calculation multiplication tables
00001800                            ; ---------------------------------------------------------------------------
00001800                            
00001800                            PCM_OverflwCalc:
00001800                            
00001800                            		; --- Lower byte ---
00001800                            
00001800 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
00001810 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
00001820 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
00001830 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
00001840 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
00001850 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
00001860 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
00001870 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
00001880 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
00001890 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
000018A0 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
000018B0 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
000018C0 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
000018D0 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
000018E0 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
000018F0 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
00001900                            
00001900                            		; --- Upper byte ---
00001900                            
00001900 0000 0000 0000 0000 0000+  		db	000h,000h,000h,000h,000h,000h,000h,000h,000h,000h,000h,001h,001h,001h,001h,001h
00001910 0101 0101 0101 0202 0202+  		db	001h,001h,001h,001h,001h,001h,002h,002h,002h,002h,002h,002h,002h,002h,002h,002h
00001920 0303 0303 0303 0303 0303+  		db	003h,003h,003h,003h,003h,003h,003h,003h,003h,003h,003h,004h,004h,004h,004h,004h
00001930 0404 0404 0404 0505 0505+  		db	004h,004h,004h,004h,004h,004h,005h,005h,005h,005h,005h,005h,005h,005h,005h,005h
00001940 0606 0606 0606 0606 0606+  		db	006h,006h,006h,006h,006h,006h,006h,006h,006h,006h,006h,007h,007h,007h,007h,007h
00001950 0707 0707 0707 0808 0808+  		db	007h,007h,007h,007h,007h,007h,008h,008h,008h,008h,008h,008h,008h,008h,008h,008h
00001960 0909 0909 0909 0909 0909+  		db	009h,009h,009h,009h,009h,009h,009h,009h,009h,009h,009h,00Ah,00Ah,00Ah,00Ah,00Ah
00001970 0A0A 0A0A 0A0A 0B0B 0B0B+  		db	00Ah,00Ah,00Ah,00Ah,00Ah,00Ah,00Bh,00Bh,00Bh,00Bh,00Bh,00Bh,00Bh,00Bh,00Bh,00Bh
00001980 0C0C 0C0C 0C0C 0C0C 0C0C+  		db	00Ch,00Ch,00Ch,00Ch,00Ch,00Ch,00Ch,00Ch,00Ch,00Ch,00Ch,00Dh,00Dh,00Dh,00Dh,00Dh
00001990 0D0D 0D0D 0D0D 0E0E 0E0E+  		db	00Dh,00Dh,00Dh,00Dh,00Dh,00Dh,00Eh,00Eh,00Eh,00Eh,00Eh,00Eh,00Eh,00Eh,00Eh,00Eh
000019A0 0F0F 0F0F 0F0F 0F0F 0F0F+  		db	00Fh,00Fh,00Fh,00Fh,00Fh,00Fh,00Fh,00Fh,00Fh,00Fh,00Fh,010h,010h,010h,010h,010h
000019B0 1010 1010 1010 1111 1111+  		db	010h,010h,010h,010h,010h,010h,011h,011h,011h,011h,011h,011h,011h,011h,011h,011h
000019C0 1212 1212 1212 1212 1212+  		db	012h,012h,012h,012h,012h,012h,012h,012h,012h,012h,012h,013h,013h,013h,013h,013h
000019D0 1313 1313 1313 1414 1414+  		db	013h,013h,013h,013h,013h,013h,014h,014h,014h,014h,014h,014h,014h,014h,014h,014h
000019E0 1515 1515 1515 1515 1515+  		db	015h,015h,015h,015h,015h,015h,015h,015h,015h,015h,015h,016h,016h,016h,016h,016h
000019F0 1616 1616 1616 1717 1717+  		db	016h,016h,016h,016h,016h,016h,017h,017h,017h,017h,017h,017h,017h,017h,017h,017h
00001A00                            
00001A00                            ; ===========================================================================
00001A00                            ; ---------------------------------------------------------------------------
00001A00                            ; Subroutine to change a channel's volume table
00001A00                            ; ---------------------------------------------------------------------------
00001A00                            
00001A00                            PCM_VolumeControl:
00001A06                            
00001A1B                            
00001A1B                            PCM1_NoVolume:
00001A1B                            
00001A30                            
00001A30                            PCM2_NoVolume:
00001A31 37                         		scf					; 04	; set carry flag
00001A35                            
00001A35                            ; ---------------------------------------------------------------------------
00001A35                            ; The volume changing itself
00001A35                            ; ---------------------------------------------------------------------------
00001A35                            
00001A35                            SwitchVolume:
00001A35                            
00001A35                            ; ---------------------------------------------------------------------------
00001A35                            ; Software version of volume table (This is slower to process but will save
00001A35                            ; 8000 bytes of ROM space).  It'll also cause chopping in the sample playback
00001A35                            ; ---------------------------------------------------------------------------
00001A35                            
00001A35                            ;		ld	b,a				; 04	; store volume
00001A35                            ;		zneg					; 08	; convert volume to 00 - 80 (mute - loud)
00001A35                            ;		zadd	a,080h				; 07	; ''
00001A35                            ;		zadd	a,a				; 04	; shift MSB into carry
00001A35                            ;		ld	(SV_fraction+001h),a		; 13	; store fraction
00001A35                            ;		sbc	a,a				; 04	; get only the carry (for quotient)
00001A35                            ;		zneg					; 08	; ''
00001A35                            ;		ld	c,a				; 04	; store quotient in c
00001A35                            ;		ld	hl,00000h			; 10	; reset current fraction/dividend
00001A35                            ;		ld	a,b				; 04	; reload volume
00001A35                            ;		zadd	a,080h				; 07	; rotate starting volume
00001A35                            ;SV_fraction:	ld	b,000h				; 07	; set fraction/dividend
00001A35                            ;
00001A35                            ;SV_SetNormal:
00001A35                            ;		ld	(de),a				; 07	; save to table
00001A35                            ;		zadd	hl,bc 				; 11	; add fraction/dividend
00001A35                            ;		adc	a,c				; 04	; add carry to quotient
00001A35                            ;		inc	e				; 04	; advance table
00001A35                            ;		jp	nz,SV_SetNormal			; 10	; repeat until the table is finished (should reach 100)
00001A35                            ;
00001A35                            ;SV_Return:	jp	00000h				; 10	; return
00001A35                            
00001A35                            ; ---------------------------------------------------------------------------
00001A35                            
00001A46                            
00001A46                            	; --- Non-flush version ---
00001A46                            
00001A55                            
00001A55                            SV_NoMute:
00001A5A                            
00001A5A                            SV_LoadVolume:
00001A5A                            		rept	008h
00001A5A                            		ldi					; 16	; copy volume bytes over
00001A5A EDA0 EDA0 EDA0 EDA0 EDA0+  		endr
00001A6E                            
00001A6E                            	; --- Flush version ---
00001A6E                            
00001A6E                            SV_Flush:
00001A79 D9                         			exx					; 04	; switch registers
00001A8D D9                         			exx					; 04	; switch registers
00001A91                            
00001A91                            SVF_NoMute:
00001A96                            
00001A96                            SVF_LoadVolume:
00001A96 D9                         			exx					; 04	; switch registers
00001AAA D9                         			exx					; 04	; switch registers
00001AAB                            
00001AAB                            SVF_StartVolume:
00001AAB                            		rept	008h
00001AAB                            		ldi					; 16	; copy volume bytes over
00001AAB EDA0 EDA0 EDA0 EDA0 EDA0+  		endr
00001ABB D9                         			exx					; 04	; switch registers
00001ACF D9                         			exx					; 04	; switch registers
00001AD0                            		rept	008h
00001AD0                            		ldi					; 16	; copy volume bytes over
00001AD0 EDA0 EDA0 EDA0 EDA0 EDA0+  		endr
00001AE2 D9                         			exx					; 04	; switch registers
00001AF1 D9                         			exx					; 04	; switch registers
00001AFC                            
00001AFC                            ; ===========================================================================
00001AFC                            ; ---------------------------------------------------------------------------
00001AFC                            ; Switching a channel's bank address
00001AFC                            ; ---------------------------------------------------------------------------
00001AFC                            ;		ld	hl,PCM1_BankCur			; 10	; address of bank ID
00001AFC                            ;		ld	de,PCM1_Switch			; 10	; load PCM switch list to edit
00001AFC                            ;		ld	a,(PCM1_PitchQuo+001h)		; 13	; load pitch quotient
00001AFC                            ;		call	SwitchBank			; 17	; change the bank address
00001AFC                            ; ---------------------------------------------------------------------------
00001AFC                            ;		ld	a,(PCM1_BankCur)		; 13	; load bank ID
00001AFC                            ;		ld	de,PCM1_Switch			; 10	; load PCM switch list to edit
00001AFC                            ;		call	SetBank				; 17	; set bank address
00001AFC                            ; ---------------------------------------------------------------------------
00001AFC                            
00001AFC                            SwitchBank:
00001B03                            
00001B03                            SetBank:
00001B06                            	rept	008h
00001B06                            		xor	a				; 04	; clear a
00001B06                            		rrc	l				; 08	; shift bit into carry
00001B06                            		adc	a,h				; 04	; set instruction bits (with carry register bit)
00001B06                            		ld	(de),a				; 07	; write instruction
00001B06                            		inc	e	; WARNING (see comment)	; 04	; advance to next instruction (ONLY WORKS IF THE INSTRUCTIONS DON'T CROSS A 100 BYTE BOUNDARY, please align)
00001B37                            
00001B37                            ; ===========================================================================
00001B37                            ; ---------------------------------------------------------------------------
00001B37                            ; Warning stuff
00001B37                            ; ---------------------------------------------------------------------------
00001B37                            
00001B37                            
00001B37                            
00001B37                            ; ===========================================================================
00001B37                            ; ===========================================================================
00001B37                            DualPCM_sz:
000BD4BF =00000000                M z80prg	=	0
000BD4BF                          M 	mexit
000BD4BF                            
000BD4BF                            ; =========================================================================================================================================================
000BD4BF                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000BD4BF                            ; Error handler
000BD4BF                            ; -------------------------------------------------------------------------------------------------------------------------------------------------------
000BD4BF                            		include	"Config/Error/error.asm"
000BD4BF                            ; -------------------------------------------------------------------------
000BD4BF                            ; Vladikcomper's debugger
000BD4BF                            ; -------------------------------------------------------------------------
000BD4BF                            
000BD4BF                            
000BD4BF                            ; -------------------------------------------------------------------------
000BD4BF                            ; Error handler control flags
000BD4BF                            ; -------------------------------------------------------------------------
000BD4BF                            
000BD4BF                            ; Screen appearence flags
000BD4BF =00000001                  _eh_address_error	equ	$01	; use for address and bus errors only (tells error handler to display additional "Address" field)
000BD4BF =00000002                  _eh_show_sr_usp		equ	$02	; displays SR and USP registers content on error screen
000BD4BF                            
000BD4BF                            ; Advanced execution flags
000BD4BF                            ; WARNING! For experts only, DO NOT USES them unless you know what you're doing
000BD4BF =00000020                  _eh_return		equ	$20
000BD4BF =00000040                  _eh_enter_console	equ	$40
000BD4BF =00000080                  _eh_align_offset	equ	$80
000BD4BF                            
000BD4BF                            ; -------------------------------------------------------------------------
000BD4BF                            ; Errors vector table
000BD4BF                            ; -------------------------------------------------------------------------
000BD4BF                            
000BD4BF                            ; Default screen configuration
000BD4BF =00000000                  _eh_default		equ	0	;_eh_show_sr_usp
000BD4BF                            
000BD4BF                            ; -------------------------------------------------------------------------
000BD4BF                            
000BD4BF                            exBus:
000BD4BF                            	__ErrorMessage "BUS ERROR", _eh_default|_eh_address_error
000BD4BF                          M 	__fstring_generateargumentscode	"BUS ERROR"
000BD4BF =00000000                M 	__pos:	set instr("BUS ERROR",'%<')
000BD4BF =00000000                M 	__stack:set	0
000BD4BF =00000000                M 	__sp:	set 0
000BD4BF                          M 	while	(__pos)
000BD4BF                          M 	rept	__stack
000BD4C0 004E B900 0000 00        M 	jsr	errorhandler
000BD4C6                          M 	__fstring_generatedecodedstring	"BUS ERROR"
000BD4C6 =00000001                M 	__lpos:	set 1
000BD4C6 =00000000                M 	__pos:	set instr("BUS ERROR",'%<')
000BD4C6                          M 	while	(__pos)
000BD4C6                          M 	__substr:	substr __lpos,,"BUS ERROR"
000BD4C6 4255 5320 4552 524F 52   M 	dc.b	"BUS ERROR"
000BD4CF 00                       M 	dc.b	0
000BD4D0 01                       M 	dc.b	_eh_default|_eh_address_error+0
000BD4D2 00                       M 	even
000BD4D2                            
000BD4D2                            exAddr:
000BD4D2                            	__ErrorMessage "ADDRESS ERROR", _eh_default|_eh_address_error
000BD4D2                          M 	__fstring_generateargumentscode	"ADDRESS ERROR"
000BD4D2 =00000000                M 	__pos:	set instr("ADDRESS ERROR",'%<')
000BD4D2 =00000000                M 	__stack:set	0
000BD4D2 =00000000                M 	__sp:	set 0
000BD4D2                          M 	while	(__pos)
000BD4D2                          M 	rept	__stack
000BD4D2 4EB9 0000 0000           M 	jsr	errorhandler
000BD4D8                          M 	__fstring_generatedecodedstring	"ADDRESS ERROR"
000BD4D8 =00000001                M 	__lpos:	set 1
000BD4D8 =00000000                M 	__pos:	set instr("ADDRESS ERROR",'%<')
000BD4D8                          M 	while	(__pos)
000BD4D8                          M 	__substr:	substr __lpos,,"ADDRESS ERROR"
000BD4D8 4144 4452 4553 5320 4552+M 	dc.b	"ADDRESS ERROR"
000BD4E5 00                       M 	dc.b	0
000BD4E6 01                       M 	dc.b	_eh_default|_eh_address_error+0
000BD4E8 00                       M 	even
000BD4E8                            
000BD4E8                            exIll:
000BD4E8                            	__ErrorMessage "ILLEGAL INSTRUCTION", _eh_default
000BD4E8                          M 	__fstring_generateargumentscode	"ILLEGAL INSTRUCTION"
000BD4E8 =00000000                M 	__pos:	set instr("ILLEGAL INSTRUCTION",'%<')
000BD4E8 =00000000                M 	__stack:set	0
000BD4E8 =00000000                M 	__sp:	set 0
000BD4E8                          M 	while	(__pos)
000BD4E8                          M 	rept	__stack
000BD4E8 4EB9 0000 0000           M 	jsr	errorhandler
000BD4EE                          M 	__fstring_generatedecodedstring	"ILLEGAL INSTRUCTION"
000BD4EE =00000001                M 	__lpos:	set 1
000BD4EE =00000000                M 	__pos:	set instr("ILLEGAL INSTRUCTION",'%<')
000BD4EE                          M 	while	(__pos)
000BD4EE                          M 	__substr:	substr __lpos,,"ILLEGAL INSTRUCTION"
000BD4EE 494C 4C45 4741 4C20 494E+M 	dc.b	"ILLEGAL INSTRUCTION"
000BD501 00                       M 	dc.b	0
000BD502 00                       M 	dc.b	_eh_default+0
000BD504 00                       M 	even
000BD504                            
000BD504                            exDiv:
000BD504                            	__ErrorMessage "ZERO DIVIDE", _eh_default
000BD504                          M 	__fstring_generateargumentscode	"ZERO DIVIDE"
000BD504 =00000000                M 	__pos:	set instr("ZERO DIVIDE",'%<')
000BD504 =00000000                M 	__stack:set	0
000BD504 =00000000                M 	__sp:	set 0
000BD504                          M 	while	(__pos)
000BD504                          M 	rept	__stack
000BD504 4EB9 0000 0000           M 	jsr	errorhandler
000BD50A                          M 	__fstring_generatedecodedstring	"ZERO DIVIDE"
000BD50A =00000001                M 	__lpos:	set 1
000BD50A =00000000                M 	__pos:	set instr("ZERO DIVIDE",'%<')
000BD50A                          M 	while	(__pos)
000BD50A                          M 	__substr:	substr __lpos,,"ZERO DIVIDE"
000BD50A 5A45 524F 2044 4956 4944+M 	dc.b	"ZERO DIVIDE"
000BD515 00                       M 	dc.b	0
000BD516 00                       M 	dc.b	_eh_default+0
000BD518 00                       M 	even
000BD518                            
000BD518                            exChk:
000BD518                            	__ErrorMessage "CHK INSTRUCTION", _eh_default
000BD518                          M 	__fstring_generateargumentscode	"CHK INSTRUCTION"
000BD518 =00000000                M 	__pos:	set instr("CHK INSTRUCTION",'%<')
000BD518 =00000000                M 	__stack:set	0
000BD518 =00000000                M 	__sp:	set 0
000BD518                          M 	while	(__pos)
000BD518                          M 	rept	__stack
000BD518 4EB9 0000 0000           M 	jsr	errorhandler
000BD51E                          M 	__fstring_generatedecodedstring	"CHK INSTRUCTION"
000BD51E =00000001                M 	__lpos:	set 1
000BD51E =00000000                M 	__pos:	set instr("CHK INSTRUCTION",'%<')
000BD51E                          M 	while	(__pos)
000BD51E                          M 	__substr:	substr __lpos,,"CHK INSTRUCTION"
000BD51E 4348 4B20 494E 5354 5255+M 	dc.b	"CHK INSTRUCTION"
000BD52D 00                       M 	dc.b	0
000BD52E 00                       M 	dc.b	_eh_default+0
000BD530 00                       M 	even
000BD530                            
000BD530                            Trapv:
000BD530                            	__ErrorMessage "TRAPV INSTRUCTION", _eh_default
000BD530                          M 	__fstring_generateargumentscode	"TRAPV INSTRUCTION"
000BD530 =00000000                M 	__pos:	set instr("TRAPV INSTRUCTION",'%<')
000BD530 =00000000                M 	__stack:set	0
000BD530 =00000000                M 	__sp:	set 0
000BD530                          M 	while	(__pos)
000BD530                          M 	rept	__stack
000BD530 4EB9 0000 0000           M 	jsr	errorhandler
000BD536                          M 	__fstring_generatedecodedstring	"TRAPV INSTRUCTION"
000BD536 =00000001                M 	__lpos:	set 1
000BD536 =00000000                M 	__pos:	set instr("TRAPV INSTRUCTION",'%<')
000BD536                          M 	while	(__pos)
000BD536                          M 	__substr:	substr __lpos,,"TRAPV INSTRUCTION"
000BD536 5452 4150 5620 494E 5354+M 	dc.b	"TRAPV INSTRUCTION"
000BD547 00                       M 	dc.b	0
000BD548 00                       M 	dc.b	_eh_default+0
000BD54A 00                       M 	even
000BD54A                            
000BD54A                            exPriv:
000BD54A                            	__ErrorMessage "PRIVILEGE VIOLATION", _eh_default
000BD54A                          M 	__fstring_generateargumentscode	"PRIVILEGE VIOLATION"
000BD54A =00000000                M 	__pos:	set instr("PRIVILEGE VIOLATION",'%<')
000BD54A =00000000                M 	__stack:set	0
000BD54A =00000000                M 	__sp:	set 0
000BD54A                          M 	while	(__pos)
000BD54A                          M 	rept	__stack
000BD54A 4EB9 0000 0000           M 	jsr	errorhandler
000BD550                          M 	__fstring_generatedecodedstring	"PRIVILEGE VIOLATION"
000BD550 =00000001                M 	__lpos:	set 1
000BD550 =00000000                M 	__pos:	set instr("PRIVILEGE VIOLATION",'%<')
000BD550                          M 	while	(__pos)
000BD550                          M 	__substr:	substr __lpos,,"PRIVILEGE VIOLATION"
000BD550 5052 4956 494C 4547 4520+M 	dc.b	"PRIVILEGE VIOLATION"
000BD563 00                       M 	dc.b	0
000BD564 00                       M 	dc.b	_eh_default+0
000BD566 00                       M 	even
000BD566                            
000BD566                            exTrace:
000BD566                            	__ErrorMessage "TRACE", _eh_default
000BD566                          M 	__fstring_generateargumentscode	"TRACE"
000BD566 =00000000                M 	__pos:	set instr("TRACE",'%<')
000BD566 =00000000                M 	__stack:set	0
000BD566 =00000000                M 	__sp:	set 0
000BD566                          M 	while	(__pos)
000BD566                          M 	rept	__stack
000BD566 4EB9 0000 0000           M 	jsr	errorhandler
000BD56C                          M 	__fstring_generatedecodedstring	"TRACE"
000BD56C =00000001                M 	__lpos:	set 1
000BD56C =00000000                M 	__pos:	set instr("TRACE",'%<')
000BD56C                          M 	while	(__pos)
000BD56C                          M 	__substr:	substr __lpos,,"TRACE"
000BD56C 5452 4143 45             M 	dc.b	"TRACE"
000BD571 00                       M 	dc.b	0
000BD572 00                       M 	dc.b	_eh_default+0
000BD574 00                       M 	even
000BD574                            
000BD574                            exLineA:
000BD574                            	__ErrorMessage "LINE A EMULATOR", _eh_default
000BD574                          M 	__fstring_generateargumentscode	"LINE A EMULATOR"
000BD574 =00000000                M 	__pos:	set instr("LINE A EMULATOR",'%<')
000BD574 =00000000                M 	__stack:set	0
000BD574 =00000000                M 	__sp:	set 0
000BD574                          M 	while	(__pos)
000BD574                          M 	rept	__stack
000BD574 4EB9 0000 0000           M 	jsr	errorhandler
000BD57A                          M 	__fstring_generatedecodedstring	"LINE A EMULATOR"
000BD57A =00000001                M 	__lpos:	set 1
000BD57A =00000000                M 	__pos:	set instr("LINE A EMULATOR",'%<')
000BD57A                          M 	while	(__pos)
000BD57A                          M 	__substr:	substr __lpos,,"LINE A EMULATOR"
000BD57A 4C49 4E45 2041 2045 4D55+M 	dc.b	"LINE A EMULATOR"
000BD589 00                       M 	dc.b	0
000BD58A 00                       M 	dc.b	_eh_default+0
000BD58C 00                       M 	even
000BD58C                            
000BD58C                            exLineF:
000BD58C                            	__ErrorMessage "LINE F EMULATOR", _eh_default
000BD58C                          M 	__fstring_generateargumentscode	"LINE F EMULATOR"
000BD58C =00000000                M 	__pos:	set instr("LINE F EMULATOR",'%<')
000BD58C =00000000                M 	__stack:set	0
000BD58C =00000000                M 	__sp:	set 0
000BD58C                          M 	while	(__pos)
000BD58C                          M 	rept	__stack
000BD58C 4EB9 0000 0000           M 	jsr	errorhandler
000BD592                          M 	__fstring_generatedecodedstring	"LINE F EMULATOR"
000BD592 =00000001                M 	__lpos:	set 1
000BD592 =00000000                M 	__pos:	set instr("LINE F EMULATOR",'%<')
000BD592                          M 	while	(__pos)
000BD592                          M 	__substr:	substr __lpos,,"LINE F EMULATOR"
000BD592 4C49 4E45 2046 2045 4D55+M 	dc.b	"LINE F EMULATOR"
000BD5A1 00                       M 	dc.b	0
000BD5A2 00                       M 	dc.b	_eh_default+0
000BD5A4 00                       M 	even
000BD5A4                            
000BD5A4                            exMisc:
000BD5A4                            	__ErrorMessage "MISC EXCEPTION", _eh_default
000BD5A4                          M 	__fstring_generateargumentscode	"MISC EXCEPTION"
000BD5A4 =00000000                M 	__pos:	set instr("MISC EXCEPTION",'%<')
000BD5A4 =00000000                M 	__stack:set	0
000BD5A4 =00000000                M 	__sp:	set 0
000BD5A4                          M 	while	(__pos)
000BD5A4                          M 	rept	__stack
000BD5A4 4EB9 0000 0000           M 	jsr	errorhandler
000BD5AA                          M 	__fstring_generatedecodedstring	"MISC EXCEPTION"
000BD5AA =00000001                M 	__lpos:	set 1
000BD5AA =00000000                M 	__pos:	set instr("MISC EXCEPTION",'%<')
000BD5AA                          M 	while	(__pos)
000BD5AA                          M 	__substr:	substr __lpos,,"MISC EXCEPTION"
000BD5AA 4D49 5343 2045 5843 4550+M 	dc.b	"MISC EXCEPTION"
000BD5B8 00                       M 	dc.b	0
000BD5B9 00                       M 	dc.b	_eh_default+0
000BD5BA                          M 	even
000BD5BA                            
000BD5BA                            ; -------------------------------------------------------------------------
000BD5BA                            ; Import error handler global functions
000BD5BA                            ; -------------------------------------------------------------------------
000BD5BA                            
000BD5BA                            ErrorHandler.__global__error_initconsole		equ	ErrorHandler+$146
000BD5BA                            ErrorHandler.__global__errorhandler_setupvdp		equ	ErrorHandler+$234
000BD5BA                            ErrorHandler.__global__console_loadpalette		equ	ErrorHandler+$A1C
000BD5BA                            ErrorHandler.__global__console_setposasxy_stack		equ	ErrorHandler+$A58
000BD5BA                            ErrorHandler.__global__console_setposasxy		equ	ErrorHandler+$A5E
000BD5BA                            ErrorHandler.__global__console_getposasxy		equ	ErrorHandler+$A8A
000BD5BA                            ErrorHandler.__global__console_startnewline		equ	ErrorHandler+$AAC
000BD5BA                            ErrorHandler.__global__console_setbasepattern		equ	ErrorHandler+$AD4
000BD5BA                            ErrorHandler.__global__console_setwidth			equ	ErrorHandler+$AE8
000BD5BA                            ErrorHandler.__global__console_writeline_withpattern	equ	ErrorHandler+$AFE
000BD5BA                            ErrorHandler.__global__console_writeline		equ	ErrorHandler+$B00
000BD5BA                            ErrorHandler.__global__console_write			equ	ErrorHandler+$B04
000BD5BA                            ErrorHandler.__global__console_writeline_formatted	equ	ErrorHandler+$BB0
000BD5BA                            ErrorHandler.__global__console_write_formatted		equ	ErrorHandler+$BB4
000BD5BA                            
000BD5BA                            ; -------------------------------------------------------------------------
000BD5BA                            ; Error handler external functions (compiled only when used)
000BD5BA                            ; -------------------------------------------------------------------------
000BD5BA                            
000BD5BA                            
000BD5BA                            ErrorHandler.__extern__console_only:
000BD5BA 46FC 2700 4FEF FFF2 48E7+  	dc.l	$46FC2700, $4FEFFFF2, $48E7FFFE, $47EF003C
000BD5CA 4EBA 0000                  	jsr		ErrorHandler.__global__errorhandler_setupvdp(pc)
000BD5CE 4EBA 0000                  	jsr		ErrorHandler.__global__error_initconsole(pc)
000BD5D2 4CDF 7FFF 487A 0008 2F2F+  	dc.l	$4CDF7FFF, $487A0008, $2F2F0012, $4E7560FE
000BD5E2                            
000BD5E2                            
000BD5E2                            ; -------------------------------------------------------------------------
000BD5E2                            ; Include error handler binary module
000BD5E2                            ; -------------------------------------------------------------------------
000BD5E2                            
000BD5E2                            ErrorHandler:
000BD5E2                            	incbin	"Config/Error/ErrorHandler.bin"
000BEFF6                            
000BEFF6                            ; -------------------------------------------------------------------------
000BEFF6                            ; WARNING!
000BEFF6                            ;	DO NOT put any data from now on! DO NOT use ROM padding!
000BEFF6                            ;	Symbol data should be appended here after ROM is compiled
000BEFF6                            ;	by ConvSym utility, otherwise debugger modules won't be able
000BEFF6                            ;	to resolve symbol names.
000BEFF6                            ; -------------------------------------------------------------------------
000BEFF6                            
000BEFF6                            
000BEFF6                            ; -------------------------------------------------------------------------
000BEFF6                            ; =========================================================================================================================================================
