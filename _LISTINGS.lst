00000000                            ; =========================================================================================================================================================
00000000                            ; Hedgebrew Engine (Clean, Overhauled, Enhanced S3&K Engine)
00000000                            ; =========================================================================================================================================================
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Configuration
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		include	"Config/Configuration.asm"	; Configuration
00000000                            ; =========================================================================================================================================================
00000000                            ; Configuration
00000000                            ; =========================================================================================================================================================
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; ASM68K Options
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		opt	l.				; Use "." for local labels
00000000                            		opt	ws+				; allow white spaces in operand parsing
00000000                            		opt	op+				; Optimize to PC relative addressing
00000000                            		opt	os+				; Optimize short branches
00000000                            		opt	ow+				; Optimize absolute long addressing
00000000                            		opt	oz+				; Optimize zero displacements
00000000                            		opt	oaq+				; Optimize to addq
00000000                            		opt	osq+				; Optimize to subq
00000000                            		opt	omq+				; Optimize to moveq
00000000                            		opt	ae-				; Disable automatic evens
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Required
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            GAME_NAME	equs	"Hedgebrew Engine Project                        "; International name
00000000                            IO_SUPPORT	equs	"J"				; I/O support
00000000 =20202020                  SRAM_SUPPORT	equ	$20202020			; SRAM support
00000000 =20202020                  SRAM_START	equ	$20202020			; SRAM start address
00000000 =20202020                  SRAM_END	equ	$20202020			; SRAM end address
00000000                            NOTES		equs	""; Notes
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; User defined
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =00000000                  DEBUG_BUILD	equ	0				; Debug build flag (0 = Disabled)
00000000                            ENABLE_HANDLER	equ	0|DEBUG				; Vladikcomper's error handler enable flag (0 = Disabled)
00000000 =00000000                  ENABLE_LAGMETER	equ	0				; Lag meter enable flag (0 = Disabled)
00000000 =00000000                  DEBUG		equ	DEBUG_BUILD			; Hack
00000000                            ; =========================================================================================================================================================
00000000                            
00000000                            		include	"Sound/langZ80.asm"		; Z80 Language macros
00000000                            ; MADE BY NATSUMI 2017
00000000                            
00000000                            ; DEFINE HELPERS
00000000 =00000000                  z80prg =	0		; 0 IN 68K MODE, 1 IN Z80 MODE
00000000 =00000000                  ztemp =		0		; TEMPORARY REGISTER
00000000 =00000000                  zundoc =	0		; SET TO 0 TO USE UNDOCUMENTED OPCODES
00000000 =00000001                  zchkoffs =	1		; SET TO 0 TO NOT CHECK IX/IY AND JR OFFSETS
00000000                            z80regstr	EQUS "a b c d e h l bc de hl sp af ix iy i r ixh ixl iyh iyl (bc) (de) (hl) (sp) af' (ix) (iy)"
00000000                            
00000000                            ; EASILY MAKE SECTIONS
00000000                            z80prog	macro obj
00000000                            	if narg=0
00000000                            		OBJEND
00000000                            	; magic function that fixes all the jr and djnz opcodes, along with offsets.
00000000                            	; Used for detecting illegal forward jumps
00000000                            		local lastpos
00000000                            lastpos =	*
00000000                            			local off, byte
00000000                            		rept zfuturec
00000000                            			popp off
00000000                            			popp byte
00000000                            			org zfuturepos-zfutureobj+off
00000000                            			dc.b byte
00000000                            		endr
00000000                            		org lastpos
00000000                            		POPO		; restore options
00000000                            z80prg =	0
00000000                            		MEXIT		; exit macro here
00000000                            	endif
00000000                            	PUSHO			; push options
00000000                            	OPT AE-			; automatic evens off
00000000                            	OPT AN+			; allow use of 100H instead of $100
00000000                            	OPT M-			; do not print better macro info. Comment out for large text dump.
00000000                            	OPT D-			; make sure EQU/SET do not descope local lables
00000000                            zfutureobj =	\obj
00000000                            zfuturepos =	*
00000000                            zfuturec =	0
00000000                            	if narg=1
00000000                            		OBJ \obj
00000000                            z80prg =	1
00000000                            	else
00000000                            		inform 0,"Invalid num of args!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; CREATE A LITTLE-ENDIAN Z80 ABSOLUTE ADDRESS
00000000                            z80word	macro word
00000000                            	dc.b ((\word)&$FF), ((\word)>>8&$FF)
00000000                                endm
00000000                            
00000000                            ; SAVES THE RÃˆGISTER ID TO ZTEMP
00000000                            zgetreg	macro reg, err
00000000                            	if strlen("\reg")=0
00000000                            		inform \err,"The register must not be empty!"
00000000                            		mexit
00000000                            	endif
00000000                            ztemp = instr("\z80regstr", "\reg")
00000000                            	if (ztemp<>0)&(ztemp<55)
00000000                            ztemp =		(z\reg)
00000000                            	elseif ztemp=56
00000000                            ztemp =		zbcr
00000000                            	elseif ztemp=61
00000000                            ztemp =		zder
00000000                            	elseif ztemp=66
00000000                            ztemp =		zhlr
00000000                            	elseif ztemp=71
00000000                            ztemp =		zspr
00000000                            	elseif ztemp=76
00000000                            ztemp =		zaf2
00000000                            	elseif ztemp=79
00000000                            ztemp =		zixr
00000000                            	elseif ztemp=85
00000000                            ztemp =		ziyr
00000000                            	else
00000000                            		if instr("\reg", "(ix+")<>0|instr("\reg", "(ix-")<>0
00000000                            ztemp =		zixp
00000000                            		elseif instr("\reg", "(iy+")<>0|instr("\reg", "(iy-")<>0
00000000                            ztemp =		ziyp
00000000                            		else
00000000                            ztemp =			-1
00000000                            			local a, cc, p
00000000                            a =			0
00000000                            p =			1
00000000                            d =			0
00000000                            			while a=0
00000000                            				if p>strlen("\reg")
00000000                            ztemp =					-2
00000000                            a =					1
00000000                            				else
00000000                            cc					substr p,p,"\reg"
00000000                            					if '\cc'='('
00000000                            d =						d+1
00000000                            					elseif '\cc'=')'
00000000                            d =						d-1
00000000                            					elseif ('\cc'<>' ')&('\cc'<>'	')
00000000                            						if d<1
00000000                            a =							1
00000000                            						endif
00000000                            					endif
00000000                            				endif
00000000                            p =				p+1
00000000                            			endw
00000000                            		endif
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; PLACES THE SIGNED OFFSET INTO ROM, AND QUEUES A CHECK
00000000                            zindoff	macro reg, byte
00000000                            	local off
00000000                            off	substr 4, strlen("\reg")-1, "\reg"
00000000                            	if zchkoffs
00000000                            		dc.b -(off)-1, off
00000000                            		zfuture \byte
00000000                            	else
00000000                            		dc.b \byte, off
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zjrfuture macro off, byte
00000000                            	if zchkoffs
00000000                            		dc.b -(off)-1, off
00000000                            		zfuture \byte
00000000                            	else
00000000                            		dc.b \byte, off
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; QUEUES SIGNED VALUES TO BE FIXED
00000000                            zfuture	macro byte
00000000                            zfuturec =	zfuturec+1
00000000                            		local p,v
00000000                            p =		*-2
00000000                            v =		\byte
00000000                            		pushp "\#v"
00000000                            		pushp "\#p"
00000000                                endm
00000000                            
00000000                            ; Define equates for registers
00000000 =00000000                  zb = 	0
00000000 =00000001                  zc =	1
00000000 =00000002                  zd =	2
00000000 =00000003                  ze =	3
00000000 =00000004                  zh =	4
00000000 =00000005                  zl =	5
00000000 =00000007                  za =	7
00000000 =00000008                  zbc =	8
00000000 =00000009                  zde =	9
00000000 =0000000A                  zhl =	$A
00000000 =0000000B                  zsp =	$B
00000000 =00000018                  zbcr =	$18
00000000 =00000019                  zder =	$19
00000000 =0000001A                  zhlr =	$1A
00000000 =0000001B                  zspr =	$1B
00000000 =00000020                  zix =	$20
00000000 =00000021                  ziy =	$21
00000000 =00000022                  zixr =	$22
00000000 =00000023                  ziyr =	$23
00000000 =00000024                  zixp =	$24
00000000 =00000025                  ziyp =	$25
00000000 =00000028                  zixh =	$28
00000000 =00000029                  zixl =	$29
00000000 =0000002A                  ziyh =	$2A
00000000 =0000002B                  ziyl =	$2B
00000000 =00000030                  zaf =	$30
00000000 =00000031                  zaf2 =	$31
00000000 =00000038                  zi =	$38
00000000 =00000039                  zr =	$39
00000000                            
00000000                            
00000000                            ; Define instructions
00000000                            
00000000                            db	macro val
00000000                            	dc.b \_
00000000                                endm
00000000                            
00000000                            dsb	macro num, val
00000000                            	dcb.b \_
00000000                                endm
00000000                            
00000000                            dw	macro val
00000000                            	rept narg
00000000                            		dc.b ((\val)&$FF), ((\val)>>8&$FF)
00000000                            		shift
00000000                            	endr
00000000                                endm
00000000                            
00000000                            bw	macro val
00000000                            	rept narg
00000000                            		dc.b ((\val)>>8&$FF), ((\val)&$FF)
00000000                            		shift
00000000                            	endr
00000000                                endm
00000000                            
00000000                            dsw	macro num, val
00000000                            	rept \num
00000000                            		dc.b ((\val)&$FF), ((\val)>>8&$FF)
00000000                            		shift
00000000                            	endr
00000000                                endm
00000000                            
00000000                            bsw	macro num, val
00000000                            	rept \num
00000000                            		dc.b ((\val)>>8&$FF), ((\val)&$FF)
00000000                            		shift
00000000                            	endr
00000000                                endm
00000000                            
00000000                            rlc	macro reg, reg2
00000000                            	zgetreg \reg, 0
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	if narg=2
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $00+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $00+ztemp		; rlc a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $06			; rlc (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; rlc (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $06
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; rlc (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $06
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            rrc	macro reg
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if narg=2
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $08+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $08+ztemp		; rrc a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $0E			; rrc (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; rrc (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $0E
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; rrc (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $0E
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            rl	macro reg
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if narg=2
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $10+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $10+ztemp		; rl a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $16			; rl (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; rl (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $16
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; rl (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $16
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            rr	macro reg
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if narg=2
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $18+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $18+ztemp		; rr a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $1E			; rr (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; rr (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $1E
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; rr (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $1E
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            sla	macro reg
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if narg=2
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $20+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $20+ztemp		; sla a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $26			; sla (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; sla (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $26
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; sla (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $26
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            sra	macro reg
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if narg=2
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $28+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $28+ztemp		; sra a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $2E			; sra (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; sra (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $2E
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; sra (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $2E
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            sll	macro reg
00000000                            	if zundoc
00000000                            		inform 2,"Undocumented opcodes are not enabled."
00000000                            	endif
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if narg=2
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $30+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $30+ztemp		; sll a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $36			; sll (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; sll (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $36
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; sll (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $36
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            srl	macro reg
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if narg=2
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if (ztemp=zixp)
00000000                            			dc.b $DD
00000000                            		elseif (ztemp=ziyp)
00000000                            			dc.b $FD
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		zindoff \reg, $CD
00000000                            		zgetreg \reg2, 0
00000000                            		if (ztemp>=0)&(ztemp<=za)
00000000                            			dc.b $38+ztemp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg' and '\reg2'!"
00000000                            		endif
00000000                            		mexit
00000000                            	endif
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $38+ztemp		; sra a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $3E			; sra (hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; sra (ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $3E
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; sra (iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $3E
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            bit	macro bit, reg
00000000                            	if narg<>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	if (\bit<0)|(\bit>7)
00000000                            		inform 2,"Invalid bit '\bit'!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $40+ztemp+(\bit*$08)	; bit 0-7,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $46+(\bit*$08)	; bit 0-7,(hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; bit 0-7,(ix+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $46+(\bit*$08)
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; bit 0-7,(iy+*)
00000000                            		zindoff \reg, $CB
00000000                            		dc.b $46+(\bit*$08)
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            res	macro bit, reg, reg2
00000000                            	if narg>3
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	if (\bit<0)|(\bit>7)
00000000                            		inform 2,"Invalid bit '\bit'!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $80+ztemp+(\bit*$08)	; res 0-7,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $86+(\bit*$08)	; res 0-7,(hl)
00000000                            	elseif (ztemp=zixp)|(ztemp=ziyp)
00000000                            		dc.b $DD+((ztemp-zixp)*$20)	; res 0-7,(ix/iy+*),  , a, b, c, d, e, h, l
00000000                            		zindoff \reg, $CB
00000000                            		if narg=3
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			zgetreg \reg2, 0
00000000                            			if (ztemp<0)|(ztemp>za)
00000000                            				inform 2,"Invalid or unsupported register '\reg2'!"
00000000                            			endif
00000000                            		else
00000000                            ztemp =			6
00000000                            		endif
00000000                            		dc.b $80+(\bit*$08)+ztemp
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zset	macro bit, reg
00000000                            	if narg>3
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	if (\bit<0)|(\bit>7)
00000000                            		inform 2,"Invalid bit '\bit'!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if (ztemp>=0)&(ztemp<=za)
00000000                            		dc.b $CB, $C0+ztemp+(\bit*$08)	; set 0-7,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $CB, $C6+(\bit*$08)	; set 0-7,(hl)
00000000                            	elseif (ztemp=zixp)|(ztemp=ziyp)
00000000                            		dc.b $DD+((ztemp-zixp)*$20)	; set 0-7,(ix/iy+*),  , a, b, c, d, e, h, l
00000000                            		zindoff \reg, $CB
00000000                            		if narg=3
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			zgetreg \reg2, 0
00000000                            			if (ztemp<0)|(ztemp>za)
00000000                            				inform 2,"Invalid or unsupported register '\reg2'!"
00000000                            			endif
00000000                            		else
00000000                            ztemp =			6
00000000                            		endif
00000000                            		dc.b $C0+(\bit*$08)+ztemp
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            im	macro im
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	if "\im"="0/1"
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $ED, $4E		; im 0/1
00000000                            	elseif (\im<0)|(\im>2)
00000000                            		inform 2,"Interrupt mode must only be 0, 1 or 2!"
00000000                            	elseif \im=2
00000000                            		dc.b $ED, $5E		; im 2
00000000                            	else
00000000                            		dc.b $ED, $46+(\im*$10); im 0 or 1
00000000                            	endif
00000000                                endm
00000000                            
00000000                            rst	macro addr
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	if type(\addr)&1
00000000                            		if (\addr&7)=0
00000000                            			if \addr>$48|\addr<0
00000000                            				inform 2,"Invalid address! Must be at least 0 and at most $38!"
00000000                            			endif
00000000                            		else
00000000                            			inform 2,"Address must be aligned by $8!"
00000000                            		endif
00000000                            	endif
00000000                            		dc.b $C7+\addr	; RST *
00000000                                endm
00000000                            
00000000                            inc	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 2
00000000                            	if ztemp<=za
00000000                            		dc.b $04+(ztemp*$08)		; inc a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $34			; inc (hl)
00000000                            	elseif (ztemp>=zbc)&(ztemp<=zsp)
00000000                            		dc.b $03+((ztemp-zbc)*$10)	; inc bc, de, hl or sp
00000000                            	elseif ztemp=zix
00000000                            		dc.b $DD, $23			; inc ix
00000000                            	elseif ztemp=ziy
00000000                            		dc.b $FD, $23			; inc iy
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; inc ix+
00000000                            		zindoff \reg, $34
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; inc iy+
00000000                            		zindoff \reg, $34
00000000                            	elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((ztemp&$02)*$10), $24+((ztemp&$01)*$08); inc ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            dec	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 2
00000000                            	if ztemp<=za
00000000                            		dc.b $05+(ztemp*$08)		; dec a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $35			; dec (hl)
00000000                            	elseif (ztemp>=zbc)&(ztemp<=zsp)
00000000                            		dc.b $0B+((ztemp-zbc)*$10)	; dec bc, de, hl or sp
00000000                            	elseif ztemp=zix
00000000                            		dc.b $DD, $2B			; dec ix
00000000                            	elseif ztemp=ziy
00000000                            		dc.b $FD, $2B			; dec iy
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; dec ix+
00000000                            		zindoff \reg, $35
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; dec iy+
00000000                            		zindoff \reg, $35
00000000                            	elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((ztemp&$02)*$10), $25+((ztemp&$01)*$08); dec ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zsub	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if ztemp=-1
00000000                            		dc.b $D6			; sub a,*
00000000                            		dc.b \reg
00000000                            	elseif ztemp<=za
00000000                            		dc.b $90+ztemp			; sub a,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $96			; sub a,(hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; sub a,(ix+*)
00000000                            		zindoff \reg, $96
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; sub a,(iy+*)
00000000                            		zindoff \reg, $96
00000000                            	elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((ztemp&$02)*$10), $94+(ztemp&$01); sub a,ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zand	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if ztemp=-1
00000000                            		dc.b $E6			; and a,*
00000000                            		dc.b \reg
00000000                            	elseif ztemp<=za
00000000                            		dc.b $A0+ztemp			; and a,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $A6			; and a,(hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; and a,(ix+*)
00000000                            		zindoff \reg, $A6
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; and a,(iy+*)
00000000                            		zindoff \reg, $A6
00000000                            	elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((ztemp&$02)*$10), $A4+(ztemp&$01); and a,ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zor	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if ztemp=-1
00000000                            		dc.b $F6			; or a,*
00000000                            		dc.b \reg
00000000                            	elseif ztemp<=za
00000000                            		dc.b $B0+ztemp			; or a,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $B6			; or a,(hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; or a,(ix+*)
00000000                            		zindoff \reg, $B6
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; or a,(iy+*)
00000000                            		zindoff \reg, $B6
00000000                            	elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((ztemp&$02)*$10), $B4+(ztemp&$01); or a,ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            xor	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if ztemp=-1
00000000                            		dc.b $EE			; xor a,*
00000000                            		dc.b \reg
00000000                            	elseif ztemp<=za
00000000                            		dc.b $A8+ztemp			; xor a,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $B6			; xor a,(hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; xor a,(ix+*)
00000000                            		zindoff \reg, $AE
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; xor a,(iy+*)
00000000                            		zindoff \reg, $AE
00000000                            	elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((ztemp&$02)*$10), $AC+(ztemp&$01); xor a,ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            cp	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if ztemp=-1
00000000                            		dc.b $FE			; cp a,*
00000000                            		dc.b \reg
00000000                            	elseif ztemp<=za
00000000                            		dc.b $B8+ztemp			; cp a,a, b, c, d, e, h or l
00000000                            	elseif ztemp=zhlr
00000000                            		dc.b $BE			; cp a,(hl)
00000000                            	elseif ztemp=zixp
00000000                            		dc.b $DD			; cp a,(ix+*)
00000000                            		zindoff \reg, $BE
00000000                            	elseif ztemp=ziyp
00000000                            		dc.b $FD			; cp a,(iy+*)
00000000                            		zindoff \reg, $BE
00000000                            	elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((ztemp&$02)*$10), $BC+(ztemp&$01); cp a,ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zadd	macro reg1, reg2
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg1, 0
00000000                            ztemp1 =	ztemp
00000000                            	if narg>1
00000000                            		zgetreg \reg2, 0
00000000                            	endif
00000000                            	if ((narg=1)&((ztemp<=za)|(ztemp=zhlr)|(ztemp=zixp)|(ztemp=ziyp)))|(ztemp1=za)|(ztemp1=zixp)|(ztemp1=ziyp); this complex piece of shit just checks if we omitted the a param
00000000                            		if (ztemp1=zixp)|(ztemp=zixp)
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $DD		; add a,(ix+*)
00000000                            			zindoff \reg1, $86
00000000                            		elseif (ztemp1=ziyp)|(ztemp=ziyp)
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $FD		; add a,(iy+*)
00000000                            			zindoff \reg1, $86
00000000                            		elseif ztemp=zhlr
00000000                            			dc.b $86		; add a,(hl)
00000000                            		elseif ztemp=-1
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $C6		; add a,*
00000000                            			dc.b \reg1
00000000                            		elseif ztemp<=za
00000000                            			dc.b $80+ztemp		; add a,a, b, c, d, e, h or l
00000000                            		elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			dc.b $DD+((ztemp&$02)*$10), $84+(ztemp&$01); add a,ixh, ixl, iyh, iyl
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination: a, \reg2!"
00000000                            		endif
00000000                            	elseif ((narg=1)&(ztemp>=zbc)&(ztemp<=zsp))|(ztemp1=zhl)	; this piece of shit just checks if we omitted the hl param
00000000                            		dc.b $09+((ztemp-zbc)*$10)	; add hl,bc, de, hl or sp
00000000                            	elseif ztemp1=zix
00000000                            		dc.b $DD
00000000                            		if ztemp=zbc
00000000                            			dc.b $09		; add ix,bc
00000000                            		elseif ztemp=zde
00000000                            			dc.b $19		; add ix,de
00000000                            		elseif ztemp=zix
00000000                            			dc.b $29		; add ix,ix
00000000                            		elseif ztemp=zsp
00000000                            			dc.b $39		; add ix,sp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination: ix, \reg2!"
00000000                            		endif
00000000                            	elseif ztemp1=ziy
00000000                            		dc.b $FD
00000000                            		if ztemp=zbc
00000000                            			dc.b $09		; add iy,bc
00000000                            		elseif ztemp=zde
00000000                            			dc.b $19		; add iy,de
00000000                            		elseif ztemp=ziy
00000000                            			dc.b $29		; add iy,iy
00000000                            		elseif ztemp=zsp
00000000                            			dc.b $39		; add iy,sp
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination: iy, \reg2!"
00000000                            		endif
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg1'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            adc	macro reg1, reg2
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg1, 0
00000000                            ztemp1 =	ztemp
00000000                            	if narg>1
00000000                            		zgetreg \reg2, 0
00000000                            	endif
00000000                            	if ((narg=1)&((ztemp<=za)|(ztemp=zhlr)|(ztemp=zixp)|(ztemp=ziyp)))|(ztemp1=za)|(ztemp1=zixp)|(ztemp1=ziyp); this complex piece of shit just checks if we omitted the a param
00000000                            		if (ztemp1=zixp)|(ztemp=zixp)
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $DD		; adc a,(ix+*)
00000000                            			zindoff \reg1, $8E
00000000                            		elseif (ztemp1=ziyp)|(ztemp=ziyp)
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $FD		; adc a,(iy+*)
00000000                            			zindoff \reg1, $8E
00000000                            		elseif ztemp=zhlr
00000000                            			dc.b $8E		; adc a,(hl)
00000000                            		elseif ztemp=-1
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $CE		; adc a,*
00000000                            			dc.b \reg1
00000000                            		elseif ztemp<=za
00000000                            			dc.b $88+ztemp		; adc a,a, b, c, d, e, h or l
00000000                            		elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			dc.b $DD+((ztemp&$02)*$10), $8C+(ztemp&$01); adc a,ixh, ixl, iyh, iyl
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination: a, \reg2!"
00000000                            		endif
00000000                            	elseif ((narg=1)&(ztemp>=zbc)&(ztemp<=zsp))|(ztemp1=zhl)	; this piece of shit just checks if we omitted the hl param
00000000                            		dc.b $ED, $4A+((ztemp-zbc)*$10)	; adc hl,bc, de, hl or sp
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg1'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            sbc	macro reg1, reg2
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg1, 0
00000000                            ztemp1 =	ztemp
00000000                            	if narg>1
00000000                            		zgetreg \reg2, 0
00000000                            	endif
00000000                            	if ((narg=1)&((ztemp<=za)|(ztemp=zhlr)|(ztemp=zixp)|(ztemp=ziyp)))|(ztemp1=za)|(ztemp1=zixp)|(ztemp1=ziyp); this complex piece of shit just checks if we omitted the a param
00000000                            		if (ztemp1=zixp)|(ztemp=zixp)
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $DD		; sbc a,(ix+*)
00000000                            			zindoff \reg1, $9E
00000000                            		elseif (ztemp1=ziyp)|(ztemp=ziyp)
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $FD		; sbc a,(iy+*)
00000000                            			zindoff \reg1, $9E
00000000                            		elseif ztemp=zhlr
00000000                            			dc.b $9E		; sbc a,(hl)
00000000                            		elseif ztemp=-1
00000000                            			if ztemp1=za
00000000                            				shift
00000000                            			endif
00000000                            			dc.b $DE		; sbc a,*
00000000                            			dc.b \reg1
00000000                            		elseif ztemp<=za
00000000                            			dc.b $98+ztemp		; sbc a,a, b, c, d, e, h or l
00000000                            		elseif (ztemp>=zixh)&(ztemp<=ziyl)
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			dc.b $DD+((ztemp&$02)*$10), $9C+(ztemp&$01); sbc a,ixh, ixl, iyh, iyl
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination: a, \reg2!"
00000000                            		endif
00000000                            	elseif ((narg=1)&(ztemp>=zbc)&(ztemp<=zsp))|(ztemp1=zhl)	; this piece of shit just checks if we omitted the hl param
00000000                            		dc.b $ED, $42+((ztemp-zbc)*$10)	; sbc hl,bc, de, hl or sp
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg1'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zpop	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 2
00000000                            	if (ztemp>=zbc)&(ztemp<=zhl)
00000000                            		dc.b $C1+((ztemp-zbc)*$10); pop bc, de or hl
00000000                            	elseif ztemp=zaf
00000000                            		dc.b $F1		; pop af
00000000                            	elseif ztemp=zix
00000000                            		dc.b $DD, $E1		; pop ix
00000000                            	elseif ztemp=ziy
00000000                            		dc.b $FD, $E1		; pop iy
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            zpush	macro reg
00000000                            	if narg<>1
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 2
00000000                            	if (ztemp>=zbc)&(ztemp<=zhl)
00000000                            		dc.b $C5+((ztemp-zbc)*$10); pop bc, de or hl
00000000                            	elseif ztemp=zaf
00000000                            		dc.b $F5		; pop af
00000000                            	elseif ztemp=zix
00000000                            		dc.b $DD, $E5		; pop ix
00000000                            	elseif ztemp=ziy
00000000                            		dc.b $FD, $E5		; pop iy
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register '\reg'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ex	macro reg1, reg2
00000000                            	if narg<>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg1, 0
00000000                            zreg1 =	ztemp
00000000                            	zgetreg \reg2, 0
00000000                            	if ((zreg1=zaf)|(zreg1=zaf2))&((ztemp=zaf)|(ztemp=zaf2))
00000000                            		dc.b $08			; ex af,af' & ex af',af & ex af,af
00000000                            	elseif ((zreg1=zde)|(zreg1=zhl))&((ztemp=zde)|(ztemp=zhl))
00000000                            		dc.b $EB			; ex de,hl & ex hl,de
00000000                            	elseif ((zreg1=zspr)|(zreg1=zhl))&((ztemp=zspr)|(ztemp=zhl))
00000000                            		dc.b $E3			; ex (sp),hl & ex hl,(sp)
00000000                            	elseif ((zreg1=zix)|(zreg1=zspr))&((ztemp=zix)|(ztemp=zspr))
00000000                            		dc.b $DD,$E3			; ex (sp),ix & ex ix,(sp)
00000000                            	elseif ((zreg1=ziy)|(zreg1=zspr))&((ztemp=ziy)|(ztemp=zspr))
00000000                            		dc.b $FD,$E3			; ex (sp),iy & ex iy,(sp)
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register combination '\reg1' and '\reg2'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            out	macro port, reg
00000000                            	if narg<>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if instr("\port", "(c)")<>0
00000000                            		if (ztemp=-1)&(instr("\port", "0")<>0)
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			dc.b $ED, $71		; out (c),0
00000000                            		elseif ztemp<=za
00000000                            			dc.b $ED, $41+(ztemp*$08)		; out (c),a, b, c, d, e, h or l
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register '\reg'!"
00000000                            		endif
00000000                            	elseif ztemp=za
00000000                            		dc.b $D3, \port		; out (*),a
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported port '\port'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            in	macro reg, port
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg, 0
00000000                            	if instr("\port", "(c)")<>0
00000000                            		if narg=1
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			dc.b $ED, $70		; in (c)
00000000                            		elseif ztemp<=za
00000000                            			dc.b $ED, $40+(ztemp*$08)		; in a, b, c, d, e, h or l,(c)
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register '\reg'!"
00000000                            		endif
00000000                            	elseif ztemp=za
00000000                            		dc.b $D3, \port		; in a,(*)
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported port '\port'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ld	macro reg1, reg2
00000000                            	if narg>2
00000000                            		inform 2,"Incorrect number of arguments!"
00000000                            	endif
00000000                            	zgetreg \reg1, 0
00000000                            zreg1 =	ztemp
00000000                            	zgetreg \reg2, 0
00000000                            zreg2 =	ztemp
00000000                            	if zreg1=-2
00000000                            		if zreg2=za
00000000                            			dc.b $32			; ld (**),a
00000000                            			z80word \reg1
00000000                            		elseif zreg2=zhl
00000000                            			dc.b $22			; ld (**),hl
00000000                            			z80word \reg1
00000000                            		elseif (zreg2>=zbc)&(zreg2<=zsp)
00000000                            			dc.b $ED, $43+((zreg2-zbc)*$10)	; ld (**),bc, de, sp
00000000                            			z80word \reg1
00000000                            		elseif zreg2=zix
00000000                            			dc.b $DD, $22			; ld (**),ix
00000000                            			z80word \reg1
00000000                            		elseif zreg2=ziy
00000000                            			dc.b $FD, $22			; ld (**),iy
00000000                            			z80word \reg1
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg1' and '\reg2'!"
00000000                            		endif
00000000                            	elseif zreg2=-1
00000000                            		if (zreg1<=za)
00000000                            			dc.b $06+(zreg1*$08), \reg2	; ld a, b, c, d, e, h or l,*
00000000                            		elseif zreg1=zhlr
00000000                            			dc.b $36, \reg2			; ld (hl),*
00000000                            		elseif (zreg1>=zbc)&(zreg1<=zsp)
00000000                            			dc.b $01+((zreg1-zbc)*$10)	; ld bc, de, hl, sp,**
00000000                            			z80word \reg2
00000000                            		elseif zreg1=zix
00000000                            			dc.b $DD, $21			; ld ix,**
00000000                            			z80word \reg2
00000000                            		elseif zreg1=ziy
00000000                            			dc.b $FD, $21			; ld iy,**
00000000                            			z80word \reg2
00000000                            		elseif zreg1=zixp
00000000                            			dc.b $DD			; ld (ix+*),*
00000000                            			zindoff \reg1, $36
00000000                            			dc.b \reg2
00000000                            		elseif zreg1=ziyp
00000000                            			dc.b $FD			; ld (iy+*),*
00000000                            			zindoff \reg1, $36
00000000                            			dc.b \reg2
00000000                            		elseif (zreg1>=zixh)&(zreg1<=ziyl)
00000000                            			if zundoc
00000000                            				inform 2,"Undocumented opcodes are not enabled."
00000000                            			endif
00000000                            			dc.b $DD+((zreg1&$02)*$10), $26+((zreg1&$01)*$08), \reg2; ld ixh, ixl, iyh, iyl,*
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg1' and '\reg2'!"
00000000                            		endif
00000000                            	elseif zreg2=-2
00000000                            		if (zreg1=za)
00000000                            			dc.b $3A			; ld a,(**)
00000000                            			z80word \reg2
00000000                            		elseif zreg1=zhl
00000000                            			dc.b $2A			; ld hl,(**)
00000000                            			z80word \reg2
00000000                            		elseif (zreg1>=zbc)&(zreg1<=zsp)
00000000                            			dc.b $ED, $4B+((zreg1-zbc)*$10)	; ld bc, de, hl, sp,(**)
00000000                            			z80word \reg2
00000000                            		elseif zreg1=zix
00000000                            			dc.b $DD, $2A			; ld ix,(**)
00000000                            			z80word \reg2
00000000                            		elseif zreg1=ziy
00000000                            			dc.b $FD, $2A			; ld iy,(**)
00000000                            			z80word \reg2
00000000                            		else
00000000                            			inform 2,"Invalid or unsupported register combination '\reg1' and '\reg2'!"
00000000                            		endif
00000000                            	elseif (zreg1<=za)&(zreg2<=za)
00000000                            		dc.b $40+(zreg1*$08)+zreg2		; ld a, b, c, d, e, h or l,a, b, c, d, e, h or l
00000000                            	elseif (zreg1=za)&(zreg2=zbcr)
00000000                            		dc.b $0A				; ld a,(bc)
00000000                            	elseif (zreg1=za)&(zreg2=zder)
00000000                            		dc.b $1A				; ld a,(de)
00000000                            	elseif (zreg1<=za)&(zreg2=zhlr)
00000000                            		dc.b $46+(zreg1*$08)			; ld a, b, c, d, e, h or l,(hl)
00000000                            	elseif (zreg1=zhlr)&(zreg2<=za)
00000000                            		dc.b $70+zreg2				; ld (hl),a, b, c, d, e, h or l
00000000                            	elseif (zreg1<=za)&(zreg2=zixp)
00000000                            		dc.b $DD				; ld a, b, c, d, e, h or l,(ix+*)
00000000                            		zindoff \reg2, $46+(zreg1*$08)
00000000                            	elseif (zreg1<=za)&(zreg2=ziyp)
00000000                            		dc.b $FD				; ld a, b, c, d, e, h or l,(iy+*)
00000000                            		zindoff \reg2, $46+(zreg1*$08)
00000000                            	elseif (zreg2<=za)&(zreg1=zixp)
00000000                            		dc.b $DD				; ld (ix+*),a, b, c, d, e, h or l
00000000                            		zindoff \reg1, $70+zreg2
00000000                            	elseif (zreg2<=za)&(zreg1=ziyp)
00000000                            		dc.b $FD				; ld (iy+*),a, b, c, d, e, h or l
00000000                            		zindoff \reg1, $70+zreg2
00000000                            	elseif (zreg1=zbcr)&(zreg2=za)
00000000                            		dc.b $02				; ld (bc),a
00000000                            	elseif (zreg1=zder)&(zreg2=za)
00000000                            		dc.b $12				; ld (de),a
00000000                            	elseif (zreg1=zsp)&(zreg2=zhl)
00000000                            		dc.b $F9				; ld sp,hl
00000000                            	elseif (zreg1=zi)&(zreg2=za)
00000000                            		dc.b $ED, $47				; ld i,a
00000000                            	elseif (zreg2=zi)&(zreg1=za)
00000000                            		dc.b $ED, $57				; ld a,i
00000000                            	elseif (zreg1=zr)&(zreg2=za)
00000000                            		dc.b $ED, $4F				; ld r,a
00000000                            	elseif (zreg2=zr)&(zreg1=za)
00000000                            		dc.b $ED, $5F				; ld a,r
00000000                            	elseif (zreg1=zsp)&(zreg2=zix)
00000000                            		dc.b $DD, $F9				; ld sp, ix
00000000                            	elseif (zreg1=zsp)&(zreg2=ziy)
00000000                            		dc.b $FD, $F9				; ld sp, iy
00000000                            	elseif (zreg1>=zixh)&(zreg1<=ziyl)&((zreg2<=za)&(zreg2<>zh)&(zreg2<>zl))
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((zreg1&$02)*$10), $60+((zreg1&$01)*$08)+zreg2; ld ixh, ixl, iyh, iyl,a, b, c, d, e
00000000                            	elseif (zreg2>=zixh)&(zreg2<=ziyl)&((zreg1<=za)&(zreg1<>zh)&(zreg1<>zl))
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		dc.b $DD+((zreg2&$02)*$10), $44+(zreg2&$01)+(zreg1*$08); ld a, b, c, d, e,ixh, ixl, iyh, iyl
00000000                            	elseif (zreg1>=zixh)&(zreg1<=ziyl)&(zreg2>=zixh)&(zreg2>=ziyl)
00000000                            		if zundoc
00000000                            			inform 2,"Undocumented opcodes are not enabled."
00000000                            		endif
00000000                            		if ((zreg1&$02)<>(zreg2&$02))
00000000                            			inform 2,"Invalid or unsupported register combination '\reg1' and '\reg2'!"
00000000                            			mexit
00000000                            		endif
00000000                            		dc.b $DD+((zreg1&$02)*$10), $60+((zreg1&$01)*$08)+(zreg2&$01); ld ixh, ixl, iyh, iyl,ixh, ixl, iyh, iyl
00000000                            	else
00000000                            		inform 2,"Invalid or unsupported register combination '\reg1' and '\reg2'!"
00000000                            	endif
00000000                                endm
00000000                            
00000000                            djnz	macro addr
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	zjrfuture \addr-*-2, $10
00000000                                endm
00000000                            
00000000                            jr	macro cond, off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	if narg=1
00000000                            		zjrfuture \cond-*-2, $18
00000000                            	else
00000000                            		jr\cond \off
00000000                            	endif
00000000                                endm
00000000                            
00000000                            jrnz	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	zjrfuture \off-*-2, $20
00000000                                endm
00000000                            
00000000                            jrnc	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	zjrfuture \off-*-2, $30
00000000                                endm
00000000                            
00000000                            jrz	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	zjrfuture \off-*-2, $28
00000000                                endm
00000000                            
00000000                            jrc	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	zjrfuture \off-*-2, $38
00000000                                endm
00000000                            
00000000                            jp	macro cond, off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	if narg=1
00000000                            		zgetreg \cond, 0
00000000                            		if ztemp=zhlr
00000000                            			dc.b $E9		; jp (hl)
00000000                            		elseif ztemp=zixr
00000000                            			dc.b $DD, $E9		; jp (ix)
00000000                            		elseif ztemp=ziyr
00000000                            			dc.b $FD, $E9		; jp (iy)
00000000                            		else
00000000                            			dc.b $C3		; jp **
00000000                            			z80word \cond
00000000                            		endif
00000000                            	else
00000000                            		jp\cond \off
00000000                            	endif
00000000                                endm
00000000                            
00000000                            jpnz	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $C2
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            jpnc	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $D2
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            jpz	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $CA
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            jpc	macro off
00000000                            	dc.b $DA
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            jppo	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $E2
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            jpp	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $F2
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            jppe	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $EA
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            jpm	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $FA
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            call	macro cond, off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	if narg=1
00000000                            		dc.b $CD
00000000                            		z80word \cond
00000000                            	else
00000000                            		call\cond \off
00000000                            	endif
00000000                                endm
00000000                            
00000000                            callnz	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $C4
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            callz	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $CC
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            callnc	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $D4
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            callc	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $DC
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            callpo	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $E4
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            callpe	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $EC
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            callp	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $F4
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            callm	macro off
00000000                            	if narg=0
00000000                            		inform 2,"No jump address supplied!"
00000000                            	endif
00000000                            	dc.b $FC
00000000                            	z80word \off
00000000                                endm
00000000                            
00000000                            ret	macro cond
00000000                            	if narg=0
00000000                            		dc.b $C9
00000000                            	else
00000000                            		ret\cond
00000000                            	endif
00000000                                endm
00000000                            
00000000                            retnz	macro
00000000                            	dc.b $C0
00000000                                endm
00000000                            
00000000                            retz	macro
00000000                            	dc.b $C8
00000000                                endm
00000000                            
00000000                            retnc	macro
00000000                            	dc.b $D0
00000000                                endm
00000000                            
00000000                            retc	macro
00000000                            	dc.b $D8
00000000                                endm
00000000                            
00000000                            retpo	macro
00000000                            	dc.b $E0
00000000                                endm
00000000                            
00000000                            retpe	macro
00000000                            	dc.b $E8
00000000                                endm
00000000                            
00000000                            retp	macro
00000000                            	dc.b $F0
00000000                                endm
00000000                            
00000000                            retm	macro
00000000                            	dc.b $F8
00000000                                endm
00000000                            
00000000                            di	macro
00000000                            	if z80prg=0
00000000                            		move	#$2700,sr	; THIS IS HERE, IF YOU WANNA USE DI IN 68K CODE ;)
00000000                            	else
00000000                            		dc.b $F3
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ei	macro
00000000                            	if z80prg=0
00000000                            		move	#$2300,sr	; THIS IS HERE, IF YOU WANNA USE EI IN 68K CODE ;)
00000000                            	else
00000000                            		dc.b $FB
00000000                            	endif
00000000                                endm
00000000                            
00000000                            halt	macro
00000000                            	if z80prg=0
00000000                            		stop	#$2700		; THIS IS HERE, IF YOU WANNA USE HALT IN 68K CODE ;)
00000000                            	else
00000000                            		dc.b $76
00000000                            	endif
00000000                                endm
00000000                            
00000000                            znop	macro
00000000                            	dc.b $00
00000000                                endm
00000000                            
00000000                            rlca	macro
00000000                            	dc.b $07
00000000                                endm
00000000                            
00000000                            rla	macro
00000000                            	dc.b $17
00000000                                endm
00000000                            
00000000                            daa	macro
00000000                            	dc.b $27
00000000                                endm
00000000                            
00000000                            scf	macro
00000000                            	dc.b $37
00000000                                endm
00000000                            
00000000                            rrca	macro
00000000                            	dc.b $0F
00000000                                endm
00000000                            
00000000                            rra	macro
00000000                            	dc.b $1F
00000000                                endm
00000000                            
00000000                            cpl	macro
00000000                            	dc.b $2F
00000000                                endm
00000000                            
00000000                            ccf	macro
00000000                            	dc.b $3F
00000000                                endm
00000000                            
00000000                            exx	macro
00000000                            	dc.b $D9
00000000                                endm
00000000                            
00000000                            zneg	macro
00000000                            	dc.b $ED, $44
00000000                                endm
00000000                            
00000000                            retn	macro
00000000                            	dc.b $ED, $45
00000000                                endm
00000000                            
00000000                            reti	macro
00000000                            	dc.b $ED, $4D
00000000                                endm
00000000                            
00000000                            rrd	macro
00000000                            	dc.b $ED, $67
00000000                                endm
00000000                            
00000000                            rld	macro
00000000                            	dc.b $ED, $6F
00000000                                endm
00000000                            
00000000                            ldi	macro
00000000                            	dc.b $ED, $A0
00000000                                endm
00000000                            
00000000                            cpi	macro
00000000                            	dc.b $ED, $A1
00000000                                endm
00000000                            
00000000                            ini	macro
00000000                            	dc.b $ED, $A2
00000000                                endm
00000000                            
00000000                            outi	macro
00000000                            	dc.b $ED, $A3
00000000                                endm
00000000                            
00000000                            ldd	macro
00000000                            	dc.b $ED, $A8
00000000                                endm
00000000                            
00000000                            cpd	macro
00000000                            	dc.b $ED, $A9
00000000                                endm
00000000                            
00000000                            ind	macro
00000000                            	dc.b $ED, $AA
00000000                                endm
00000000                            
00000000                            outd	macro
00000000                            	dc.b $ED, $AB
00000000                                endm
00000000                            
00000000                            ldir	macro
00000000                            	dc.b $ED, $B0
00000000                                endm
00000000                            
00000000                            cpir	macro
00000000                            	dc.b $ED, $B1
00000000                                endm
00000000                            
00000000                            inir	macro
00000000                            	dc.b $ED, $B2
00000000                                endm
00000000                            
00000000                            otir	macro
00000000                            	dc.b $ED, $B3
00000000                                endm
00000000                            
00000000                            lddr	macro
00000000                            	dc.b $ED, $B8
00000000                                endm
00000000                            
00000000                            cpdr	macro
00000000                            	dc.b $ED, $B9
00000000                                endm
00000000                            
00000000                            indr	macro
00000000                            	dc.b $ED, $BA
00000000                                endm
00000000                            
00000000                            otdr	macro
00000000                            	dc.b $ED, $BB
00000000                                endm
00000000                            		include	"Sound/amps/code/macro.asm"	; AMPS macros
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Various assembly flags
00000000                            ; ---------------------------------------------------------------------------
00000000                            	opt ae+
00000000                            
00000000                            ; if safe mode is enabled (1), then the driver will attempt to find any issues.
00000000                            ; if Vladik's error debugger is installed, then the error will be displayed.
00000000                            ; else, the CPU is trapped.
00000000                            
00000000 =00000000                  safe =	DEBUG
00000000                            
00000000                            ; Select the tempo algorith.
00000000                            ; 0 = Overflow method.
00000000                            ; 1 = Counter method.
00000000                            
00000000 =00000000                  tempo =	0
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Channel configuration
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset 0
00000000 =00000000                  cFlags		rs.b 1		; various channel flags, see below
00000000 =00000001                  cType		rs.b 1		; hardware type for the channel
00000000 =00000002                  cData		rs.l 1		; 68k tracker address for the channel
00000000 =00000006                  cPanning	rs.b 0		; channel panning and LFO. FM and DAC only
00000000 =00000006                  cEnvPos		rs.b 1		; volume envelope position. PSG only
00000000 =00000007                  cDetune		rs.b 1		; frequency detune (offset)
00000000 =00000008                  cPitch		rs.b 1		; pitch (transposition) offset
00000000 =00000009                  cVolume		rs.b 1		; channel volume
00000000 =0000000A                  cTick		rs.b 1		; channel tick multiplier
00000000 =0000000B                  cSample		rs.b 0		; channel sample ID, DAC only
00000000 =0000000B                  cVolEnv		rs.b 0		; volume envelope ID. PSG only
00000000 =0000000B                  cVoice		rs.b 1		; YM2612 voice ID. FM only
00000000 =0000000C                  cDuration	rs.b 1		; current note duration
00000000 =0000000D                  cLastDur	rs.b 1		; last note duration
00000000 =0000000E                  cFreq		rs.w 1		; channel base frequency
00000000 =00000010                  cModDelay	rs.b 0		; delay before modulation starts
00000000 =00000010                  cMod		rs.l 1		; modulation data address
00000000 =00000014                  cModFreq	rs.w 1		; modulation frequency offset
00000000 =00000016                  cModSpeed	rs.b 1		; number of frames til next modulation step
00000000 =00000017                  cModStep	rs.b 1		; modulation frequency offset per step
00000000 =00000018                  cModCount	rs.b 1		; number of modulation steps until reversal
00000000 =00000019                  cLoop		rs.b 3		; loop counter values
00000000 =0000001B                  cStatPSG4 =	__rs-1		; PSG4 type value. PSG3 only
00000000 =0000001A                  cPrio =		__rs-2		; sound effect channel priority. SFX only
00000000 =0000001C                  cSizeSFX	rs.w 0		; size of each SFX track
00000000                            
00000000 =0000001C                  cNoteTimeCur	rs.b 1		; frame counter to note off. Music only
00000000 =0000001D                  cNoteTimeMain	rs.b 1		; copy of frame counter to note off. Music only
00000000 =0000001E                  cStack		rs.b 1		; channel stack pointer. Music only
00000000                            		rs.b 1		; unused. Music only
00000000                            		rs.l 3		; channel stack data. Music only
00000000 =0000002C                  cSize		rs.w 0		; size of each music track
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Bits for cFlags
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset 0
00000000 =00000000                  cfbMode		rs.b 0		; set if in pitch mode, clear if in sample mode. DAC only
00000000 =00000000                  cfbRest		rs.b 1		; set if channel is resting. FM and PSG only
00000000 =00000001                  cfbInt		rs.b 1		; set if interrupted by SFX. Music only
00000000 =00000002                  cfbHold		rs.b 1		; set if playing notes does not trigger note-on's
00000000 =00000003                  cfbMod		rs.b 1		; set if modulation is enabled
00000000 =00000004                  cfbCond		rs.b 1		; set if ignoring many tracker commands
00000000 =00000005                  cfbVol		rs.b 1		; set if channel should update volume
00000000 =00000007                  cfbRun =	$07		; set if channel is running a tracker
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Misc variables for channel modes
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000 =00000002                  ctbPt2 =	$02		; bit part 2 - FM 4-6
00000000 =00000000                  ctFM1 =		$00		; FM 1
00000000 =00000001                  ctFM2 =		$01		; FM 2
00000000 =00000002                  ctFM3 =		$02		; FM 3	- Valid for SFX
00000000 =00000004                  ctFM4 =		$04		; FM 4	- Valid for SFX
00000000 =00000005                  ctFM5 =		$05		; FM 5	- Valid for SFX
00000000                            
00000000 =00000003                  ctbDAC =	$03		; DAC bit
00000000 =0000000B                  ctDAC1 =	(1<<ctbDAC)|$03	; DAC 1	- Valid for SFX
00000000 =0000000E                  ctDAC2 =	(1<<ctbDAC)|$06	; DAC 2
00000000                            
00000000 =00000080                  ctPSG1 =	$80		; PSG 1	- Valid for SFX
00000000 =000000A0                  ctPSG2 =	$A0		; PSG 2	- Valid for SFX
00000000 =000000C0                  ctPSG3 =	$C0		; PSG 3	- Valid for SFX
00000000 =000000E0                  ctPSG4 =	$E0		; PSG 4
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Misc flags
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000 =00000002                  Mus_DAC =	2		; number of DAC channels
00000000 =00000005                  Mus_FM =	5		; number of FM channels
00000000 =00000003                  Mus_PSG =	3		; number of PSG channels
00000000 =0000000A                  Mus_Ch =	Mus_DAC+Mus_FM+Mus_PSG; total number of music channels
00000000 =00000001                  SFX_DAC =	1		; number of DAC SFX channels
00000000 =00000003                  SFX_FM =	3		; number of FM SFX channels
00000000 =00000003                  SFX_PSG =	3		; number of PSG SFX channels
00000000 =00000007                  SFX_Ch =	SFX_DAC+SFX_FM+SFX_PSG; total number of SFX channels
00000000                            
00000000 =0000001D                  VoiceRegs =	29		; total number of registers inside of a voice
00000000 =00000019                  VoiceTL =	VoiceRegs-4	; location of voice TL levels
00000000                            
00000000 =00001000                  MaxPitch =	$1000		; this is the maximum pitch Dual PCM is capable of processing
00000000 =00000018                  Z80E_Read =	$00018		; this is used by Dual PCM internally but we need this for macros
00000000                            
00000000                            ; NOTE: There is no magic trick to making Dual PCM play samples at higher rates.
00000000                            ; These values are only here to allow you to give lower pitch samples higher
00000000                            ; quality, and playing samples at higher rates than Dual PCM can process them
00000000                            ; may decrease the perceived quality by the end user. Use these equates only
00000000                            ; if you know what you are doing.
00000000                            
00000000 =00000140                  sr17 =		$0140		; 5 Quarter sample rate	17500 Hz
00000000 =00000120                  sr15 =		$0120		; 9 Eights sample rate	15750 Hz
00000000 =00000100                  sr14 =		$0100		; Default sample rate	14000 Hz
00000000 =000000E0                  sr12 =		$00E0		; 7 Eights sample rate	12250 Hz
00000000 =000000C0                  sr10 =		$00C0		; 3 Quarter sample rate	10500 Hz
00000000 =000000A0                  sr8 =		$00A0		; 5 Eights sample rate	8750 Hz
00000000 =00000080                  sr7 =		$0080		; Half sample rate	7000 HZ
00000000 =00000060                  sr5 =		$0060		; 3 Eights sample rate	5250 Hz
00000000 =00000040                  sr3 =		$0040		; 1 Quarter sample rate	3500 Hz
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Sound driver RAM configuration
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000 =00A00000                  dZ80 =		$A00000		; quick reference to Z80 RAM
00000000 =00C00011                  dPSG =		$C00011		; quick reference to PSG port
00000000                            
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Bits for mFlags
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset 0
00000000 =00000000                  mfbRing		rs.b 1		; if set, change speaker (play different sfx)
00000000 =00000001                  mfbSpeed	rs.b 1		; if set, speed shoes are active
00000000 =00000002                  mfbWater	rs.b 1		; if set, underwater mode is active
00000000 =00000003                  mfbNoPAL	rs.b 1		; if set, play songs slowly in PAL region
00000000 =00000007                  mfbPaused =	$07		; if set, sound driver is paused
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Sound ID equates
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset 1
00000000 =00000001                  Mus_Reset	rs.b 1		; reset underwater and speed shoes flags, update volume
00000000 =00000002                  Mus_FadeOut	rs.b 1		; initialize a music fade out
00000000 =00000003                  Mus_Stop	rs.b 1		; stop all music
00000000 =00000004                  Mus_ShoesOn	rs.b 1		; enable speed shoes mode
00000000 =00000005                  Mus_ShoesOff	rs.b 1		; disable speed shoes mode
00000000 =00000006                  Mus_ToWater	rs.b 1		; enable underwater mode
00000000 =00000007                  Mus_OutWater	rs.b 1		; disable underwater mode
00000000 =00000008                  Mus_Pause	rs.b 1		; pause the music
00000000 =00000009                  Mus_Unpause	rs.b 1		; unpause the music
00000000 =0000000A                  MusOff		rs.b 0		; first music ID
00000000                            
00000000 =00000078                  MusCount =	$78		; number of installed music tracks
00000000 =00000082                  SFXoff =	MusCount+MusOff	; first SFX ID
00000000 =00000078                  SFXcount =	$78		; number of intalled sound effects
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Condition modes
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset 0
00000000 =00000000                  dcoT		rs.b 1		; condition T	; True
00000000 =00000001                  dcoF		rs.b 1		; condition F	; False
00000000 =00000002                  dcoHI		rs.b 1		; condition HI	; HIgher (unsigned)
00000000 =00000003                  dcoLS		rs.b 1		; condition LS	; Less or Same (unsigned)
00000000 =00000004                  dcoHS		rs.b 0		; condition HS	; Higher or Sane (unsigned)
00000000 =00000004                  dcoCC		rs.b 1		; condition CC	; Carry Clear (unsigned)
00000000 =00000005                  dcoLO		rs.b 0		; condition LO	; LOwer (unsigned)
00000000 =00000005                  dcoCS		rs.b 1		; condition CS	; Carry Set (unsigned)
00000000 =00000006                  dcoNE		rs.b 1		; condition NE	; Not Equal
00000000 =00000007                  dcoEQ		rs.b 1		; condition EQ	; EQual
00000000 =00000008                  dcoVC		rs.b 1		; condition VC	; oVerflow Clear (signed)
00000000 =00000009                  dcoVS		rs.b 1		; condition VS	; oVerflow Set (signed)
00000000 =0000000A                  dcoPL		rs.b 1		; condition PL	; Positive (PLus)
00000000 =0000000B                  dcoMI		rs.b 1		; condition MI	; Negamite (MInus)
00000000 =0000000C                  dcoGE		rs.b 1		; condition GE	; Greater or Equal (signed)
00000000 =0000000D                  dcoLT		rs.b 1		; condition LT	; Less Than (signed)
00000000 =0000000E                  dcoGT		rs.b 1		; condition GT	; GreaTer (signed)
00000000 =0000000F                  dcoLE		rs.b 1		; condition LE	; Less or Equal (signed)
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Emvelope commands equates
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset $80
00000000 =00000080                  eReset		rs.w 1		; 80 - Restart from position 0
00000000 =00000082                  eHold		rs.w 1		; 82 - Hold volume at current level
00000000 =00000084                  eLoop		rs.w 1		; 84 - Jump back/forwards according to next byte
00000000 =00000086                  eStop		rs.w 1		; 86 - Stop current note and envelope
00000000 =00000088                  eLast		rs.w 0		; safe mode equate
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Fade out end commands
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            	rsset $80
00000000 =00000080                  fEnd		rs.l 1		; 80 - Do nothing
00000000 =00000084                  fStop		rs.l 1		; 84 - Stop all music
00000000 =00000088                  fResVol		rs.l 1		; 88 - Reset volume and update
00000000 =0000008C                  fReset		rs.l 1		; 8C - Stop music playing and reset volume
00000000 =00000090                  fLast		rs.l 0		; safe mode equate
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Quickly read a word from odd address. 28 cycles
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            dREAD_WORD	macro areg, dreg
00000000                            	move.b	(\areg)+,(sp)		; read the next byte into stack
00000000                            	move.w	(sp),\dreg		; get word back from stack (shift byte by 8 bits)
00000000                            	move.b	(\areg),\dreg		; get the next byte into register
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; used to calculate the address of the right FM voice
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            dCALC_VOICE	macro off
00000000                            	lsl.w	#5,d0			; multiply voice ID by $20
00000000                            	if narg>0
00000000                            		add.w	#\off,d0	; if have had extra argument, add it to offset
00000000                            	endif
00000000                            	add.w	d0,a1			; add offset to voice table address
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Tells the Z80 to stop, and waits for it to finish stopping (acquire bus)
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            ;stopZ80 	macro
00000000                            ;	move.w	#$100,$A11100		; stop the Z80
00000000                            ;.loop\@
00000000                            ;	btst	#0,$A11100
00000000                            ;	bne.s	.loop\@			; loop until it says it's stopped
00000000                            ;    endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Tells the Z80 to start again
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            ;startZ80 	macro
00000000                            ;	move.w	#0,$A11100		; start the Z80
00000000                            ;    endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Macro for pausing music
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            AMPS_MUSPAUSE	macro	; enable request pause and paused flags
00000000                            	move.b	#Mus_Pause,mQueue+2.w
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Macro for unpausing music
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            AMPS_MUSUNPAUSE	macro	; enable request unpause flag
00000000                            	move.b	#Mus_Unpause,mQueue+2.w
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Macro for queueing sound
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            playSnd	macro id, queue	; queue sound
00000000                            	move.b	\id,(mQueue+((\queue\)-1)).w
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Create volume envelope table, and SMPS2ASM equates
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            volenv		macro name
00000000                            	rept narg			; repeate for all arguments
00000000                            v\name =	__venv			; create SMPS2ASM equate
00000000                            		dc.l vd\name		; create pointer
00000000                            __venv =	__venv+1		; increase ID
00000000                            	shift				; shift next argument into view
00000000                            	endr
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Creates SFX pointers table, and creates necessary equates
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            ptrSFX		macro type, name
00000000                            .type =		\type<<24		; create equate for the type mask
00000000                            	rept narg-1			; repeat for all arguments
00000000                            		dc.l \name\|.type	; create pointer with specified type
00000000                            __sfx =		__sfx+1			; increase SFX ID
00000000                            	shift				; shift next argument into view
00000000                            	endr
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Creates music pointers table, and creates necessary equates
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            ptrMusic	macro name, sptempo
00000000                            	rept narg/2			; repeat for half of the arguments
00000000                            		dc.l ((\sptempo)<<24)|\name\; create pointer with tempo
00000000                            __mus =		__mus+1			; increase music ID
00000000                            	shift				; shift next argument into view
00000000                            	shift				; ''
00000000                            	endr
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Include PCM data
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            incSWF		macro name, file
00000000                            SWF_\name\	incbin	\file		; include PCM data
00000000                            SWFR_\name\ 	dcb.b Z80E_Read*(MaxPitch/$100),$00; add end markers (for Dual PCM)
00000000                                endm
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Create data for a sample
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            sample		macro freq, start, loop, name
00000000                            	if narg=4		; if we have 4 arguments, we'd like a custom name
00000000                            d\name =	__samp		; use the extra argument to create SMPS2ASM equate
00000000                            	else
00000000                            d\start =	__samp		; else, use the first one!
00000000                            	endif
00000000                            __samp =	__samp+1	; increase sample ID
00000000                            ; create offsets for the sample normal, reverse, loop normal, loop reverse.
00000000                            	dc.b SWF_\start&$FF,((SWF_\start>>$08)&$7F)|$80,(SWF_\start>>$0F)&$FF
00000000                            	dc.b (SWFR_\start-1)&$FF,(((SWFR_\start-1)>>$08)&$7F)|$80,((SWFR_\start-1)>>$0F)&$FF
00000000                            	dc.b SWF_\loop&$FF,((SWF_\loop>>$08)&$7F)|$80, (SWF_\loop>>$0F)&$FF
00000000                            	dc.b (SWFR_\loop-1)&$FF,(((SWFR_\loop-1)>>$08)&$7F)|$80,((SWFR_\loop-1)>>$0F)&$FF
00000000                            	dc.w \freq-$100		; sample frequency (actually offset, so we remove $100)
00000000                            	dc.w 0			; unused!
00000000                                endm
00000000                            ; ===========================================================================
00000000                            	opt ae-
00000000                            		include	"Sound/amps/code/smps2asm.asm"	; AMPS SMPS2ASM
00000000                            ; ===============================================
00000000                            ; Based on Flamewing's SMPS2ASM, and S1SMPS2ASM by Marc (AKA Cinossu)
00000000                            ; Reworked and improved by Natsumi
00000000                            ; ===============================================
00000000                            ; this macro is created to emulate enum in AS
00000000                            enum	macro	num, lable
00000000                            ; copy initial number for referencing later
00000000                            .num	= num
00000000                            	rept narg-1
00000000                            \lable		set .num
00000000                            .num =	.num+1
00000000                            	shift
00000000                            	endr
00000000                                endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------------------------
00000000                            ; Note Equates
00000000                            	enum $80+0, nRst
00000000 =00000080                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =00000080                M nrst	set	.num
00000000 =00000081                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nRst+1,nC0,nCs0,nD0,nEb0,nE0,nF0,nFs0,nG0,nAb0,nA0,nBb0,nB0
00000000 =00000081                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =00000081                M nc0	set	.num
00000000 =00000082                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000082                M ncs0	set	.num
00000000 =00000083                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000083                M nd0	set	.num
00000000 =00000084                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000084                M neb0	set	.num
00000000 =00000085                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000085                M ne0	set	.num
00000000 =00000086                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000086                M nf0	set	.num
00000000 =00000087                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000087                M nfs0	set	.num
00000000 =00000088                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000088                M ng0	set	.num
00000000 =00000089                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000089                M nab0	set	.num
00000000 =0000008A                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000008A                M na0	set	.num
00000000 =0000008B                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000008B                M nbb0	set	.num
00000000 =0000008C                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000008C                M nb0	set	.num
00000000 =0000008D                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nB0+1, nC1,nCs1,nD1,nEb1,nE1,nF1,nFs1,nG1,nAb1,nA1,nBb1,nB1
00000000 =0000008D                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =0000008D                M nc1	set	.num
00000000 =0000008E                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000008E                M ncs1	set	.num
00000000 =0000008F                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000008F                M nd1	set	.num
00000000 =00000090                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000090                M neb1	set	.num
00000000 =00000091                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000091                M ne1	set	.num
00000000 =00000092                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000092                M nf1	set	.num
00000000 =00000093                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000093                M nfs1	set	.num
00000000 =00000094                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000094                M ng1	set	.num
00000000 =00000095                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000095                M nab1	set	.num
00000000 =00000096                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000096                M na1	set	.num
00000000 =00000097                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000097                M nbb1	set	.num
00000000 =00000098                M .num	=	.num+1
00000000                          M 	shift
00000000 =00000098                M nb1	set	.num
00000000 =00000099                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nB1+1, nC2,nCs2,nD2,nEb2,nE2,nF2,nFs2,nG2,nAb2,nA2,nBb2,nB2
00000000 =00000099                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =00000099                M nc2	set	.num
00000000 =0000009A                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000009A                M ncs2	set	.num
00000000 =0000009B                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000009B                M nd2	set	.num
00000000 =0000009C                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000009C                M neb2	set	.num
00000000 =0000009D                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000009D                M ne2	set	.num
00000000 =0000009E                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000009E                M nf2	set	.num
00000000 =0000009F                M .num	=	.num+1
00000000                          M 	shift
00000000 =0000009F                M nfs2	set	.num
00000000 =000000A0                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A0                M ng2	set	.num
00000000 =000000A1                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A1                M nab2	set	.num
00000000 =000000A2                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A2                M na2	set	.num
00000000 =000000A3                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A3                M nbb2	set	.num
00000000 =000000A4                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A4                M nb2	set	.num
00000000 =000000A5                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nB2+1, nC3,nCs3,nD3,nEb3,nE3,nF3,nFs3,nG3,nAb3,nA3,nBb3,nB3
00000000 =000000A5                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =000000A5                M nc3	set	.num
00000000 =000000A6                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A6                M ncs3	set	.num
00000000 =000000A7                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A7                M nd3	set	.num
00000000 =000000A8                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A8                M neb3	set	.num
00000000 =000000A9                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000A9                M ne3	set	.num
00000000 =000000AA                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000AA                M nf3	set	.num
00000000 =000000AB                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000AB                M nfs3	set	.num
00000000 =000000AC                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000AC                M ng3	set	.num
00000000 =000000AD                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000AD                M nab3	set	.num
00000000 =000000AE                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000AE                M na3	set	.num
00000000 =000000AF                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000AF                M nbb3	set	.num
00000000 =000000B0                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B0                M nb3	set	.num
00000000 =000000B1                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nB3+1, nC4,nCs4,nD4,nEb4,nE4,nF4,nFs4,nG4,nAb4,nA4,nBb4,nB4
00000000 =000000B1                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =000000B1                M nc4	set	.num
00000000 =000000B2                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B2                M ncs4	set	.num
00000000 =000000B3                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B3                M nd4	set	.num
00000000 =000000B4                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B4                M neb4	set	.num
00000000 =000000B5                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B5                M ne4	set	.num
00000000 =000000B6                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B6                M nf4	set	.num
00000000 =000000B7                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B7                M nfs4	set	.num
00000000 =000000B8                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B8                M ng4	set	.num
00000000 =000000B9                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000B9                M nab4	set	.num
00000000 =000000BA                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000BA                M na4	set	.num
00000000 =000000BB                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000BB                M nbb4	set	.num
00000000 =000000BC                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000BC                M nb4	set	.num
00000000 =000000BD                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nB4+1, nC5,nCs5,nD5,nEb5,nE5,nF5,nFs5,nG5,nAb5,nA5,nBb5,nB5
00000000 =000000BD                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =000000BD                M nc5	set	.num
00000000 =000000BE                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000BE                M ncs5	set	.num
00000000 =000000BF                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000BF                M nd5	set	.num
00000000 =000000C0                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C0                M neb5	set	.num
00000000 =000000C1                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C1                M ne5	set	.num
00000000 =000000C2                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C2                M nf5	set	.num
00000000 =000000C3                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C3                M nfs5	set	.num
00000000 =000000C4                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C4                M ng5	set	.num
00000000 =000000C5                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C5                M nab5	set	.num
00000000 =000000C6                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C6                M na5	set	.num
00000000 =000000C7                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C7                M nbb5	set	.num
00000000 =000000C8                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000C8                M nb5	set	.num
00000000 =000000C9                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nB5+1, nC6,nCs6,nD6,nEb6,nE6,nF6,nFs6,nG6,nAb6,nA6,nBb6,nB6
00000000 =000000C9                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =000000C9                M nc6	set	.num
00000000 =000000CA                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000CA                M ncs6	set	.num
00000000 =000000CB                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000CB                M nd6	set	.num
00000000 =000000CC                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000CC                M neb6	set	.num
00000000 =000000CD                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000CD                M ne6	set	.num
00000000 =000000CE                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000CE                M nf6	set	.num
00000000 =000000CF                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000CF                M nfs6	set	.num
00000000 =000000D0                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D0                M ng6	set	.num
00000000 =000000D1                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D1                M nab6	set	.num
00000000 =000000D2                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D2                M na6	set	.num
00000000 =000000D3                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D3                M nbb6	set	.num
00000000 =000000D4                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D4                M nb6	set	.num
00000000 =000000D5                M .num	=	.num+1
00000000                          M 	shift
00000000                            	enum nB6+1, nC7,nCs7,nD7,nEb7,nE7,nF7,nFs7,nG7,nAb7,nA7,nBb7
00000000 =000000D5                M .num	=	num
00000000                          M 	rept	narg-1
00000000 =000000D5                M nc7	set	.num
00000000 =000000D6                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D6                M ncs7	set	.num
00000000 =000000D7                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D7                M nd7	set	.num
00000000 =000000D8                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D8                M neb7	set	.num
00000000 =000000D9                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000D9                M ne7	set	.num
00000000 =000000DA                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000DA                M nf7	set	.num
00000000 =000000DB                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000DB                M nfs7	set	.num
00000000 =000000DC                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000DC                M ng7	set	.num
00000000 =000000DD                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000DD                M nab7	set	.num
00000000 =000000DE                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000DE                M na7	set	.num
00000000 =000000DF                M .num	=	.num+1
00000000                          M 	shift
00000000 =000000DF                M nbb7	set	.num
00000000 =000000E0                M .num	=	.num+1
00000000                          M 	shift
00000000                            
00000000                            ; ---------------------------------------------------------------------------------------------
00000000                            ; PSG volume envelope equates
00000000 =00000000                  v00 =	$00
00000000                            
00000000                            ; ---------------------------------------------------------------------------------------------
00000000                            ; Header Macros
00000000                            sHeaderInit	macro
00000000                            sPointZero =	*
00000000                            sPatNum =	0
00000000                                endm
00000000                            
00000000                            ; Header - Set up Channel Usage
00000000                            sHeaderCh	macro fm,psg
00000000                            	dc.b \fm-1
00000000                            	if narg=2
00000000                            		if \fm>5
00000000                            			inform 2,"You sure there are \fm FM channels?"
00000000                            		endif
00000000                            		dc.b \psg-1
00000000                            		if \psg>3
00000000                            			inform 2,"You sure there are \psg PSG channels?"
00000000                            		endif
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; Convert S1 tempo to S3 tempo
00000000                            sConvS1Tempo	macro tempo
00000000                            s2tempo = ((((((((tempo=0)&1)<<8)|tempo)-1)<<8)+(((((tempo=0)&1)<<8)|tempo)>>1))/((((tempo=0)&1)<<8)|tempo))&$FF
00000000                            s3tempo = ($100-(((s2tempo=0)&1)|s2tempo))&$FF
00000000                                endm
00000000                            
00000000                            ; Header - Set up Tempo and Tick Multiplier
00000000                            sHeaderTempo	macro tmul,tempo
00000000                            	dc.b \tmul-1,\tempo
00000000                                endm
00000000                            
00000000                            sHeaderTempoS1	macro tmul,tempo
00000000                            	sConvS1Tempo \tempo
00000000                            	dc.b \tmul-1,s3tempo
00000000                                endm
00000000                            
00000000                            ; Header - Set priority leve
00000000                            sHeaderPrio	macro prio
00000000                            	dc.b \prio
00000000                                endm
00000000                            
00000000                            ; Header - Set up DAC Channel
00000000                            sHeaderDAC	macro loc,vol,samp
00000000                            	dc.w \loc-sPointZero
00000000                            	if narg>=2
00000000                            		dc.b \vol
00000000                            		if narg>=3
00000000                            			dc.b \samp
00000000                            		else
00000000                            			dc.b $00
00000000                            		endif
00000000                            	else
00000000                            		dc.w $00
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; Header - Set up FM Channel
00000000                            sHeaderFM	macro loc,pitch,vol
00000000                            	dc.w \loc-sPointZero
00000000                            	dc.b \pitch,\vol
00000000                                endm
00000000                            
00000000                            ; Header - Set up PSG Channel
00000000                            sHeaderPSG	macro loc,pitch,vol,detune,volenv
00000000                            	dc.w \loc-sPointZero
00000000                            	dc.b \pitch,\vol,\detune,\volenv
00000000                                endm
00000000                            
00000000                            ; Header - Set up SFX Channel
00000000                            sHeaderSFX	macro flags,type,loc,pitch,vol
00000000                            	dc.b \flags,\type
00000000                            	dc.w \loc-sPointZero
00000000                            	dc.b \pitch,\vol
00000000                                endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------------------------
00000000                            ; Command Flag Macros and Equates. Based on the original s1smps2asm, and Flamewing's smps2asm
00000000 =00000000                  spNone set $00
00000000 =00000040                  spRight set $40
00000000 =00000080                  spLeft set $80
00000000 =000000C0                  spCentre set $C0
00000000 =000000C0                  spCenter set $C0
00000000                            
00000000                            ; ---------------------------------------------------------------------------------------------
00000000                            ; Macros for FM instruments
00000000                            ; Patches - Feedback
00000000                            
00000000                            ; Patches - Algorithm
00000000                            spAlgorithm macro val, name
00000000                            	if (sPatNum<>0)&(safe=0)
00000000                            		; align the patch
00000000                            		dc.b (*^(sPatNum*spTL4))&$FF
00000000                            		dc.b ((*>>8)+(spDe3*spDR3))&$FF
00000000                            		dc.b ((*>>16)-(spTL1*spRR3))&$FF
00000000                            	endif
00000000                            	if narg>1
00000000                            p\name =	sPatNum
00000000                            	endif
00000000                            sPatNum =	sPatNum+1
00000000                            spAl	= val
00000000                                endm
00000000                            
00000000                            spFeedback macro val
00000000                            spFe	= val
00000000                                endm
00000000                            
00000000                            ; Patches - Detune
00000000                            spDetune macro op1,op2,op3,op4
00000000                            spDe1	= op1
00000000                            spDe2	= op2
00000000                            spDe3	= op3
00000000                            spDe4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Multiple
00000000                            spMultiple macro op1,op2,op3,op4
00000000                            spMu1	= op1
00000000                            spMu2	= op2
00000000                            spMu3	= op3
00000000                            spMu4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Rate Scale
00000000                            spRateScale macro op1,op2,op3,op4
00000000                            spRS1	= op1
00000000                            spRS2	= op2
00000000                            spRS3	= op3
00000000                            spRS4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Attack Rate
00000000                            spAttackRt macro op1,op2,op3,op4
00000000                            spAR1	= op1
00000000                            spAR2	= op2
00000000                            spAR3	= op3
00000000                            spAR4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Amplitude Modulation
00000000                            spAmpMod macro op1,op2,op3,op4
00000000                            spAM1	= op1
00000000                            spAM2	= op2
00000000                            spAM3	= op3
00000000                            spAM4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Sustain Rate
00000000                            spSustainRt macro op1,op2,op3,op4
00000000                            spSR1	= op1		; Also known as decay 1 rate
00000000                            spSR2	= op2
00000000                            spSR3	= op3
00000000                            spSR4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Sustain Level
00000000                            spSustainLv macro op1,op2,op3,op4
00000000                            spSL1	= op1		; also known as decay 1 level
00000000                            spSL2	= op2
00000000                            spSL3	= op3
00000000                            spSL4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Decay Rate
00000000                            spDecayRt macro op1,op2,op3,op4
00000000                            spDR1	= op1		; Also known as decay 2 rate
00000000                            spDR2	= op2
00000000                            spDR3	= op3
00000000                            spDR4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Release Rate
00000000                            spReleaseRt macro op1,op2,op3,op4
00000000                            spRR1	= op1
00000000                            spRR2	= op2
00000000                            spRR3	= op3
00000000                            spRR4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - SSG-EG
00000000                            spSSGEG macro op1,op2,op3,op4
00000000                            spSS1	= op1
00000000                            spSS2	= op2
00000000                            spSS3	= op3
00000000                            spSS4	= op4
00000000                                endm
00000000                            
00000000                            ; Patches - Total Level
00000000                            spTotalLv macro op1,op2,op3,op4
00000000                            spTL1	= op1
00000000                            spTL2	= op2
00000000                            spTL3	= op3
00000000                            spTL4	= op4
00000000                            ; Construct the patch finally.
00000000                            	dc.b	(spFe<<3)+spAl
00000000                            ;   0     1     2     3     4     5     6     7
00000000                            ;%1000,%1000,%1000,%1000,%1010,%1110,%1110,%1111
00000000                            spTLMask4 set $80
00000000                            spTLMask2 set ((spAl>=5)<<7)
00000000                            spTLMask3 set ((spAl>=4)<<7)
00000000                            spTLMask1 set ((spAl=7)<<7)
00000000                            	dc.b (spDe1<<4)+spMu1, (spDe3<<4)+spMu3, (spDe2<<4)+spMu2, (spDe4<<4)+spMu4
00000000                            	dc.b (spRS1<<6)+spAR1, (spRS3<<6)+spAR3, (spRS2<<6)+spAR2, (spRS4<<6)+spAR4
00000000                            	dc.b (spAM1<<7)+spSR1, (spAM3<<7)+spsR3, (spAM2<<7)+spSR2, (spAM4<<7)+spSR4
00000000                            	dc.b spDR1,            spDR3,            spDR2,            spDR4
00000000                            	dc.b (spSL1<<4)+spRR1, (spSL3<<4)+spRR3, (spSL2<<4)+spRR2, (spSL4<<4)+spRR4
00000000                            	dc.b spSS1,            spSS3,            spSS2,            spSS4
00000000                            	dc.b spTL1|spTLMask1,  spTL3|spTLMask3,  spTL2|spTLMask2,  spTL4|spTLMask4
00000000                            	if safe=1
00000000                            		dc.b 'NAT'	; align the patch
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; Patches - Total Level (for broken total level masks)
00000000                            spTotalLv2 macro op1,op2,op3,op4
00000000                            spTL1	= op1
00000000                            spTL2	= op2
00000000                            spTL3	= op3
00000000                            spTL4	= op4
00000000                            	dc.b (spFe<<3)+spAl
00000000                            	dc.b (spDe1<<4)+spMu1, (spDe3<<4)+spMu3, (spDe2<<4)+spMu2, (spDe4<<4)+spMu4
00000000                            	dc.b (spRS1<<6)+spAR1, (spRS3<<6)+spAR3, (spRS2<<6)+spAR2, (spRS4<<6)+spAR4
00000000                            	dc.b (spAM1<<7)+spSR1, (spAM3<<7)+spsR3, (spAM2<<7)+spSR2, (spAM4<<7)+spSR4
00000000                            	dc.b spDR1,            spDR3,            spDR2,            spDR4
00000000                            	dc.b (spSL1<<4)+spRR1, (spSL3<<4)+spRR3, (spSL2<<4)+spRR2, (spSL4<<4)+spRR4
00000000                            	dc.b spSS1,            spSS3,            spSS2,            spSS4
00000000                            	dc.b spTL1,	       spTL3,		 spTL2,		   spTL4
00000000                            	if safe=1
00000000                            		dc.b 'NAT'	; align the patch
00000000                            	endif
00000000                                endm
00000000                            ; ---------------------------------------------------------------------------------------------
00000000                            ; SMPS commands
00000000                            
00000000                            ; E0xx - Panning, AMS, FMS (PANAFMS - PAFMS_PAN)
00000000                            sPan		macro pan, ams, fms
00000000                            	if narg=1
00000000                            		dc.b $E0, \pan
00000000                            	elseif narg=2
00000000                            		dc.b $E0, \pan|\ams
00000000                            	else
00000000                            		dc.b $E0, \pan|(\ams<<4)|\fms
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; E1xx - Set channel frequency displacement to xx (DETUNE_SET)
00000000                            ssDetune	macro val
00000000                            	dc.b $E1, \val
00000000                                endm
00000000                            
00000000                            ; E2xx - Add xx to channel frequency displacement (DETUNE)
00000000                            saDetune	macro val
00000000                            	dc.b $E2, \val
00000000                                endm
00000000                            
00000000                            ; E3xx - Set channel pitch to xx (TRANSPOSE - TRNSP_SET)
00000000                            ssTranspose	macro val
00000000                            	dc.b $E3, \val
00000000                                endm
00000000                            
00000000                            ; E4xx - Add xx to channel pitch (TRANSPOSE - TRNSP_ADD)
00000000                            saTranspose	macro val
00000000                            	dc.b $E4, \val
00000000                                endm
00000000                            
00000000                            ; E5xx - Set channel tick multiplier to xx (TICK_MULT - TMULT_CUR)
00000000                            ssTickMulCh	macro val
00000000                            	dc.b $E5, \val-1
00000000                                endm
00000000                            
00000000                            ; E6xx - Set global tick multiplier to xx (TICK_MULT - TMULT_ALL)
00000000                            ssTickMul	macro val
00000000                            	dc.b $E6, \val-1
00000000                                endm
00000000                            
00000000                            ; E7 - Do not attack of next note (HOLD)
00000000 =000000E7                  sHold =		$E7
00000000                            
00000000                            ; E8xx - Set patch/voice/sample to xx (INSTRUMENT - INS_C_FM / INS_C_PSG / INS_C_DAC)
00000000                            sVoice		macro val
00000000                            	dc.b $E8, \val
00000000                                endm
00000000                            
00000000                            ; E9xx - Set music speed shoes tempo to xx (TEMPO - TEMPO_SET_SPEED)
00000000                            ssTempoShoes	macro val
00000000                            	dc.b $E9, \val
00000000                                endm
00000000                            
00000000                            ; EAxx - Set music tempo to xx (TEMPO - TEMPO_SET)
00000000                            ssTempo		macro val
00000000                            	dc.b $EA, \val
00000000                                endm
00000000                            ssTempoS1	macro val
00000000                            	sConvS1Tempo \val
00000000                            	dc.b $EA, s3tempo
00000000                                endm
00000000                            
00000000                            ; EB - Turn on Modulation (MOD_SET - MODS_ON)
00000000                            sModOn		macro
00000000                            	dc.b $EB
00000000                                endm
00000000                            
00000000                            ; EC - Turn off Modulation (MOD_SET - MODS_OFF)
00000000                            sModOff		macro
00000000                            	dc.b $EC
00000000                                endm
00000000                            
00000000                            ; EDxx - Add xx to channel volume (VOLUME - VOL_CN_FM / VOL_CN_PSG / VOL_CN_DAC)
00000000                            saVol		macro vol
00000000                            	dc.b $ED, \vol
00000000                                endm
00000000                            
00000000                            ; EExx - Set channel volume to xx (VOLUME - VOL_CN_ABS)
00000000                            ssVol		macro vol
00000000                            	dc.b $EE, \vol
00000000                                endm
00000000                            
00000000                            ; EFxxyy - Enable/Disable LFO (SET_LFO - LFO_AMSEN)
00000000                            ssLFO		macro reg, ams, fms, pan
00000000                            	if narg=2
00000000                            		dc.b $EF, \reg,\ams
00000000                            	elseif narg=3
00000000                            		dc.b $EF, \reg,(\ams<<4)|\fms
00000000                            	else
00000000                            		dc.b $EF, \reg,(\ams<<4)|\fms|\pan
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; F0wwxxyyzz - Modulation
00000000                            ;  ww: wait time
00000000                            ;  xx: modulation speed
00000000                            ;  yy: change per step
00000000                            ;  zz: number of steps
00000000                            ; (MOD_SETUP)
00000000                            ssMod68k	macro wait, speed, step, count
00000000                            	dc.b $F0, \wait,\speed,\step,\count
00000000                                endm
00000000                            
00000000                            ; F1 - Use sample DAC mode (DAC_MODE - DACM_SAMP)
00000000                            sModeSampDAC	macro
00000000                            	dc.b $F1
00000000                                endm
00000000                            
00000000                            ; F2 - Use pitch DAC mode (DAC_MODE - DACM_NOTE)
00000000                            sModePitchDAC	macro
00000000                            	dc.b $F2
00000000                                endm
00000000                            
00000000                            ; F3xx - PSG4 noise mode xx (PSG_NOISE - PNOIS_AMPS)
00000000                            sNoisePSG	macro val
00000000                            	dc.b $F3, \val
00000000                                endm
00000000                            
00000000                            ; F4xxxx - Keep looping back to xxxx each time the SFX is being played (CONT_SFX)
00000000                            sCont		macro loc
00000000                            	dc.b $F4
00000000                            	dc.w \loc-*-1
00000000                                endm
00000000                            
00000000                            ; F5 - End of channel (TRK_END - TEND_STD)
00000000                            sStop		macro
00000000                            	dc.b $F5
00000000                                endm
00000000                            
00000000                            ; F6xxxx - Jump to xxxx (GOTO)
00000000                            ssJump		macro loc
00000000                            	dc.b $F6
00000000                            	dc.w \loc-*-1
00000000                                endm
00000000                            
00000000                            ; F7xxyyzzzz - Loop back to zzzz yy times, xx being the loop index for loop recursion fixing (LOOP)
00000000                            sLoop		macro index,loops,loc
00000000                            	dc.b $F7, \index
00000000                            	dc.w \loc-*-1
00000000                            	dc.b \loops
00000000                                endm
00000000                            
00000000                            ; F8xxxx - Call pattern at xxxx, saving return point (GOSUB)
00000000                            sCall		macro loc
00000000                            	dc.b $F8
00000000                            	dc.w \loc-*-1
00000000                                endm
00000000                            
00000000                            ; F9 - Return (RETURN)
00000000                            sRet		macro
00000000                            	dc.b $F9
00000000                                endm
00000000                            
00000000                            ; FAyyxx - Set communications byte yy to xx (SET_COMM - SPECIAL)
00000000                            sComm		macro num, val
00000000                            	dc.b $FA, \num,\val
00000000                                endm
00000000                            
00000000                            ; FBxyzz - Get communications byte y, and compare zz with it using condition x (COMM_CONDITION)
00000000                            sCond		macro num, cond, val
00000000                            	dc.b $FB, \num|(\cond<<4),\val
00000000                                endm
00000000                            
00000000                            ; FC - Reset condition (COMM_RESET)
00000000                            sCondOff	macro
00000000                            	dc.b $FC
00000000                                endm
00000000                            
00000000                            ; FDxx - Stop note after xx frames (NOTE_STOP - NSTOP_NORMAL)
00000000                            sNoteTimeOut	macro val
00000000                            	dc.b $FD, \val
00000000                                endm
00000000                            
00000000                            ; FExxyy - YM command yy on register xx (YMCMD)
00000000                            sCmdYM		macro reg, val
00000000                            	dc.b $FE, \reg,\val
00000000                                endm
00000000                            
00000000                            ; FF00xx - Play sample xx on DAC1 (PLAY_DAC - PLAY_DAC1)
00000000                            sPlaySamp1	macro id
00000000                            	dc.b $FF,$00, \id
00000000                                endm
00000000                            
00000000                            ; FF01xx - Play sample xx on DAC1 (PLAY_DAC - PLAY_DAC2)
00000000                            sPlaySamp2	macro id
00000000                            	dc.b $FF,$01, \id
00000000                                endm
00000000                            
00000000                            ; FF02xxxx - Set channel frequency to xxxx (CHFREQ_SET)
00000000                            ssFreq		macro freq
00000000                            	dc.b $FF,$02
00000000                            	dc.w \freq
00000000                                endm
00000000                            
00000000                            ; FF03xx - Set channel frequency to note xx (CHFREQ_SET - CHFREQ_NOTE)
00000000                            ssFreqNote	macro note
00000000                            	dc.b $FF,$03, \note^$80
00000000                                endm
00000000                            
00000000                            ; FF04 - Increment spindash rev counter (SPINDASH_REV - SDREV_INC)
00000000                            sSpinRev	macro
00000000                            	dc.b $FF,$04
00000000                                endm
00000000                            
00000000                            ; FF05 - Reset spindash rev counter (SPINDASH_REV - SDREV_RESET)
00000000                            sSpinReset	macro
00000000                            	dc.b $FF,$05
00000000                                endm
00000000                            
00000000                            ; FF06xx - Add xx to music speed tempo (TEMPO - TEMPO_ADD_SPEED)
00000000                            saTempoSpeed	macro tempo
00000000                            	dc.b $FF,$06, \tempo
00000000                                endm
00000000                            
00000000                            ; FF07xx - Add xx to music tempo (TEMPO - TEMPO_ADD)
00000000                            saTempo		macro tempo
00000000                            	dc.b $FF,$07, \tempo
00000000                                endm
00000000                            
00000000                            ; FF08xyzz - Get RAM address pointer offset by y, compare zz with it using condition x (COMM_CONDITION - COMM_SPEC)
00000000                            sCondReg	macro off, cond, val
00000000                            	dc.b $FF,$08, \off|(\cond<<4),\val
00000000                                endm
00000000                            
00000000                            ; FF09xx - Play another music/sfx (SND_CMD)
00000000                            sPlayMus	macro id
00000000                            	dc.b $FF,$09, \id
00000000                                endm
00000000                            
00000000                            ; FF0A - Enable raw frequency mode (RAW_FREQ)
00000000                            sFreqOn		macro freq
00000000                            	dc.b $FF,$0A
00000000                            	inform 3,"Flag is currently not implemented! Please remove."
00000000                                endm
00000000                            
00000000                            ; FF0B - Disable raw frequency mode (RAW_FREQ - RAW_FREQ_OFF)
00000000                            sFreqOff	macro freq
00000000                            	dc.b $FF,$0B
00000000                            	inform 3,"Flag is currently not implemented! Please remove."
00000000                                endm
00000000                            
00000000                            ; FF0C - Enable FM3 special mode (SPC_FM3)
00000000                            sSpecFM3	macro freq
00000000                            	dc.b $FF,$0C
00000000                            	inform 3,"Flag is currently not implemented! Please remove."
00000000                                endm
00000000                            
00000000                            ; FF0Dxx - Set DAC filter bank address (DAC_FILTER)
00000000                            ssFilter	macro bank
00000000                            	dc.b $FF,$0D, \bank
00000000                                endm
00000000                            
00000000                            ; FF0E - Freeze 68k. Debug flag (DEBUG_STOP_CPU)
00000000                            sFreeze		macro
00000000                            	if safe=1
00000000                            		dc.b $FF,$0E
00000000                            	endif
00000000                                endm
00000000                            
00000000                            ; FF0F - Bring up tracker debugger at end of frame. Debug flag (DEBUG_PRINT_TRACKER)
00000000                            sCheck		macro
00000000                            	if safe=1
00000000                            		dc.b $FF,$0F
00000000                            	endif
00000000                                endm
00000000                            
00000000                            		include	"Config/Constants.asm"		; Constants
00000000                            ; =========================================================================================================================================================
00000000                            ; MegaDrive constants
00000000                            ; =========================================================================================================================================================
00000000 =00000000                  ROM_START		equ	$000000				; ROM area start address
00000000 =00400000                  ROM_END			equ	$3FFFFF+1			; ROM area end address
00000000                            
00000000 =00A00000                  Z80_RAM			equ	$A00000				; Z80 RAM start address
00000000 =00A02000                  Z80_RAM_END		equ	$A02000				; Z80 RAM end address
00000000 =00A11100                  Z80_BUS_REQ		equ	$A11100				; Z80 bus request
00000000 =00A11200                  Z80_RESET		equ	$A11200				; Z80 reset
00000000                            
00000000 =00A04000                  YM2612_A0		equ	$A04000				; M68K YM2612 register port 0
00000000 =00A04001                  YM2612_D0		equ	$A04001				; M68K YM2612 data port 0
00000000 =00A04002                  YM2612_A1		equ	$A04002				; M68K YM2612 register port 1
00000000 =00A04003                  YM2612_D1		equ	$A04003				; M68K YM2612 data port 1
00000000 =00C00011                  PSG_INPUT		equ	$C00011				; M68K PSG input
00000000                            
00000000 =00A10001                  HW_VERSION		equ	$A10001				; Hardware version
00000000 =00A14000                  TMSS_PORT		equ	$A14000				; TMSS port
00000000                            
00000000 =00A10003                  PORT_A_DATA		equ	$A10003				; Port A data
00000000 =00A10005                  PORT_B_DATA		equ	$A10005				; Port B data
00000000 =00A10007                  PORT_C_DATA		equ	$A10007				; Port C data
00000000 =00A10009                  PORT_A_CTRL		equ	$A10009				; Port A control
00000000 =00A1000B                  PORT_B_CTRL		equ	$A1000B				; Port B control
00000000 =00A1000D                  PORT_C_CTRL		equ	$A1000D				; Port C control
00000000 =00A1000F                  PORT_A_TX		equ	$A1000F				; Port A Tx data
00000000 =00A10011                  PORT_A_RX		equ	$A10011				; Port A Rx data
00000000 =00A10013                  PORT_A_SCTRL		equ	$A10013				; Port A S control
00000000 =00A10015                  PORT_B_TX		equ	$A10015				; Port B Tx data
00000000 =00A10017                  PORT_B_RX		equ	$A10017				; Port B Rx data
00000000 =00A10019                  PORT_B_SCTRL		equ	$A10019				; Port B S control
00000000 =00A1001B                  PORT_C_TX		equ	$A1001B				; Port C Tx data
00000000 =00A1001D                  PORT_C_RX		equ	$A1001D				; Port C Rx data
00000000 =00A1001F                  PORT_C_SCTRL		equ	$A1001F				; Port C S control
00000000                            
00000000 =00A130F1                  SRAM_ACCESS		equ	$A130F1				; SRAM access register ($200000 - $3FFFFF)
00000000                            
00000000 =00A130F3                  MAPPER_BANK_1		equ	$A130F3				; Mapper bank 1 register ($080000 - $0FFFFF)
00000000 =00A130F5                  MAPPER_BANK_2		equ	$A130F5				; Mapper bank 2 register ($100000 - $17FFFF)
00000000 =00A130F7                  MAPPER_BANK_3		equ	$A130F7				; Mapper bank 3 register ($180000 - $1FFFFF)
00000000 =00A130F9                  MAPPER_BANK_4		equ	$A130F9				; Mapper bank 4 register ($200000 - $27FFFF)
00000000 =00A130FB                  MAPPER_BANK_5		equ	$A130FB				; Mapper bank 5 register ($280000 - $2FFFFF)
00000000 =00A130FD                  MAPPER_BANK_6		equ	$A130FD				; Mapper bank 6 register ($300000 - $37FFFF)
00000000 =00A130FF                  MAPPER_BANK_7		equ	$A130FF				; Mapper bank 7 register ($380000 - $3FFFFF)
00000000                            
00000000 =00C00000                  VDP_DATA		equ	$C00000				; VDP data port
00000000 =00C00004                  VDP_CTRL		equ	$C00004				; VDP control port
00000000 =00C00008                  VDP_HVCOUNT		equ	$C00008				; VDP H/V counter
00000000 =00C0001C                  VDP_DEBUG		equ	$C0001C				; VDP debug register
00000000                            
00000000 =00FF0000                  RAM_START		equ	$FF0000				; M68K RAM start address
00000000 =01000000                  RAM_END			equ	$FFFFFF+1			; M68K RAM end address
00000000                            
00000000 =FFFF8000                  RAM_WORD_START		equ	$FFFF8000			; Starting address of absolute word addressable M68K RAM
00000000 =00000000                  RAM_WORD_END		equ	$FFFFFFFF+1			; Ending address of absolute word addressable M68K RAM
00000000                            ; =========================================================================================================================================================
00000000                            		include	"Config/Macros.asm"		; Macros
00000000                            ; =========================================================================================================================================================
00000000                            ; MegaDrive macros
00000000                            ; =========================================================================================================================================================
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Align
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	bound	- Size boundary
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            align		macros	bound
00000000                            		cnop	0,\bound
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Pad RS to even address
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------
00000000                            rseven		macros
00000000                            		rs.b	__rs&1
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Push registers to stack (works on either processor)
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	regs	- Registers to push
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            push		macro	regs
00000000                            		if z80prg=0
00000000                            			if instr("\regs","/")|instr("\regs","-")
00000000                            				movem.\0 \regs,-(sp)
00000000                            			else
00000000                            				move.\0	\regs,-(sp)
00000000                            			endif
00000000                            		else
00000000                            			zpush	\regs
00000000                            		endif
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Pop registers from stack (works on either processor)
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	regs	- Registers to pop
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            pop		macro	regs
00000000                            		if z80prg=0
00000000                            			if instr("\regs","/")|instr("\regs","-")
00000000                            				movem.\0 (sp)+,\regs
00000000                            			else
00000000                            				move.\0	(sp)+,\regs
00000000                            			endif
00000000                            		else
00000000                            			zpop	\regs
00000000                            		endif
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Clear memory
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	starta	- Address to start clearing memory at
00000000                            ;	enda	- Address to finish clearing memory at
00000000                            ;		  (not rEQUired if there exists a label that is the same as the starting label, but with "_End" at the end of it)
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            clrRAM		macro	starta, enda
00000000                            		local	endaddr
00000000                            		if narg<2
00000000                            endaddr			EQUS	"\starta\_End"
00000000                            		else
00000000                            endaddr			EQUS	"\enda"
00000000                            		endif
00000000                            
00000000                            		moveq	#0,d0
00000000                            
00000000                            		if ((\starta)&$8000)=0
00000000                            			lea	\starta,a1
00000000                            		else
00000000                            			lea	(\starta).w,a1
00000000                            		endif
00000000                            		if (\starta)&1
00000000                            			move.b	d0,(a1)+
00000000                            		endif
00000000                            
00000000                            		move.w	#(((\endaddr)-(\starta))-((\starta)&1))>>2-1,d1
00000000                            .Clear\@:	move.l	d0,(a1)+
00000000                            		dbf	d1,.Clear\@
00000000                            
00000000                            		if (((\endaddr)-(\starta))-((\starta)&1))&2
00000000                            			move.w	d0,(a1)+
00000000                            		endif
00000000                            		if (((\endaddr)-(\starta))-((\starta)&1))&1
00000000                            			move.b	d0,(a1)+
00000000                            		endif
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Disable SRAM access
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            sramOff		macros
00000000                            		move.b	#0,SRAM_ACCESS
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Enable SRAM access
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            sramOn		macros
00000000                            		move.b	#1,SRAM_ACCESS
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Disable interrupts
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            intsOff		macros
00000000                            		ori	#$700,sr
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Enable interrupts
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            intsOn		macros
00000000                            		andi	#$F8FF,sr
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Stop the Z80
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            doZ80Stop	macros
00000000                            		move.w	#$100,Z80_BUS_REQ
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Wait for the Z80 to stop
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            waitZ80Stop	macro
00000000                            .Wait\@:	btst	#0,Z80_BUS_REQ
00000000                            		bne.s	.Wait\@
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Stop the Z80 and wait for it to
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            stopZ80		macro
00000000                            		doZ80Stop
00000000                          M 	move.w	#$100,z80_bus_req
00000000                            		waitZ80Stop
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Start the Z80
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            startZ80	macros
00000000                            		move.w	#0,Z80_BUS_REQ
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Wait for the Z80 to start
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            waitZ80Start	macro
00000000                            .Wait\@:	btst	#0,Z80_BUS_REQ
00000000                            		beq.s	.Wait\@
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Cancel Z80 reset
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            resetZ80Off	macros
00000000                            		move.w	#$100,Z80_RESET
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Reset the Z80
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            resetZ80	macros
00000000                            		move.w	#0,Z80_RESET
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Wait for the YM2612 to not be busy
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            waitYM		macro
00000000                            		nop
00000000                            		nop
00000000                            		nop
00000000                            @Wait\@:	tst.b	(a0)
00000000                            		bmi.s	@Wait\@
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Wait for DMA finish
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	port	- Something to represent the VDP control port (default is VDP_CTRL_PORT)
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------	
00000000                            waitDMA		macro	port
00000000                            .Wait\@:
00000000                            		if narg>0
00000000                            			move.w	\port,d1
00000000                            		else
00000000                            			move.w	VDP_CTRL,d1
00000000                            		endif
00000000                            		btst	#1,d1
00000000                            		bne.s	.Wait\@
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; VDP command instruction
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	addr	- Address in VDP memory
00000000                            ;	type	- Type of VDP memory
00000000                            ;	rwd	- VDP command
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =00000021                  VRAM		EQU	%100001		; VRAM
00000000 =0000002B                  CRAM		EQU	%101011		; CRAM
00000000 =00000025                  VSRAM		EQU	%100101		; VSRAM
00000000 =0000000C                  READ		EQU	%001100		; VDP read
00000000 =00000007                  WRITE		EQU	%000111		; VDP write
00000000 =00000027                  DMA		EQU	%100111		; VDP DMA
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            vdpCmd		macro	ins, addr, type, rwd, end, end2
00000000                            		if narg=5
00000000                            			\ins	#((((\type&\rwd)&3)<<30)|((\addr&$3FFF)<<16)|(((\type&\rwd)&$FC)<<2)|((\addr&$C000)>>14)), \end
00000000                            		elseif narg>=6
00000000                            			\ins	#((((\type&\rwd)&3)<<30)|((\addr&$3FFF)<<16)|(((\type&\rwd)&$FC)<<2)|((\addr&$C000)>>14))\end, \end2
00000000                            		else
00000000                            			\ins	((((\type&\rwd)&3)<<30)|((\addr&$3FFF)<<16)|(((\type&\rwd)&$FC)<<2)|((\addr&$C000)>>14))
00000000                            		endif
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; VDP DMA from 68000 memory to VDP memory
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	src	- Source address in 68000 memory
00000000                            ;	dest	- Destination address in VDP memory
00000000                            ;	len	- Length of data in bytes
00000000                            ;	type	- Type of VDP memory
00000000                            ;	a6.l	- VDP control port
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            dma68k		macro	src, dest, len, type, port
00000000                            		move.l	#$94009300|((((\len)/2)&$FF00)<<8)|(((\len)/2)&$FF),(a6)
00000000                            		move.l	#$96009500|((((\src)/2)&$FF00)<<8)|(((\src)/2)&$FF),(a6)
00000000                            		move.w	#$9700|(((\src)>>17)&$7F),(a6)
00000000                            		vdpCmd	move.w, \dest, \type, DMA, >>16, (a6)
00000000                            		vdpCmd	move.w, \dest, \type, DMA, &$FFFF, -(sp)
00000000                            		move.w	(sp)+,(a6)
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Fill VRAM with byte
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	byte	- Byte to fill VRAM with
00000000                            ;	addr	- Address in VRAM
00000000                            ;	len	- Length of fill in bytes
00000000                            ;	a6.l	- VDP control port
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            dmaFill		macro	byte, addr, len
00000000                            		move.w	#$8F01,(a6)
00000000                            		move.l	#$94009300|((((\len)-1)&$FF00)<<8)|(((\len)-1)&$FF),(a6)
00000000                            		move.w	#$9780,(a6)
00000000                            		move.l	#$40000080|(((\addr)&$3FFF)<<16)|(((\addr)&$C000)>>14),(a6)
00000000                            		move.w	#(\byte)<<8,-4(a6)
00000000                            		waitDMA	(a6)
00000000                            		move.w	#$8F02,(a6)
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Copy a region of VRAM to a location in VRAM
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	src	- Source address in VRAM
00000000                            ;	dest	- Destination address in VRAM
00000000                            ;	len	- Length of copy in bytes
00000000                            ;	a6.l	- VDP control port
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            dmaCopy		macro	src, dest, len
00000000                            		move.w	#$8F01,(a6)
00000000                            		move.l	#$94009300|((((\len)-1)&$FF00)<<8)|(((\len)-1)&$FF),(a6)
00000000                            		move.l	#$96009500|(((\src)&$FF00)<<8)|((\src)&$FF),(a6)
00000000                            		move.w	#$97C0,(a6)
00000000                            		move.l	#$000000C0|(((\dest)&$3FFF)<<16)|(((\dest)&$C000)>>14),(a6)
00000000                            		waitDMA	(a6)
00000000                            		move.w	#$8F02,(a6)
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Start the lag-o-meter
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            lagOn		macro
00000000                            		if ENABLE_LAGMETER
00000000                            			move.w	#$9193,VDP_CTRL
00000000                            		endif
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Stop the lag-o-meter
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            lagOff		macro
00000000                            		if ENABLE_LAGMETER
00000000                            			move.w	#$9100,VDP_CTRL
00000000                            		endif
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Disable display
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            displayOff	macro
00000000                            		move.w	rVDPReg1.w,d0
00000000                            		andi.b	#%10111111,d0
00000000                            		move.w	d0,VDP_CTRL
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Enable display
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            displayOn	macro
00000000                            		move.w	rVDPReg1.w,d0
00000000                            		ori.b	#%01000000,d0
00000000                            		move.w	d0,VDP_CTRL
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Move the HUD down
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            moveHUDDown	macros
00000000                            		move.l	#-$80000,rHUD_Accel.w		; Set to move HUD down
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Move the HUD up
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            moveHUDUp	macros
00000000                            		move.l	#$8000,rHUD_Accel.w		; Set to move HUD up
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Convert a string to the textbox's format and store as a line
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	str	- The string
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            txtLine		macro	str
00000000                            c		= 1
00000000                            		rept	strlen(\str)
00000000                            ochar			substr c, c, \str
00000000                            char			substr "\ochar"-$1F, "\ochar"-$1F, "skojh`aledisfsg\0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_ABCDEFGHIJKLMNOPQRSTUVWXYZncmb"
00000000                            			dc.w	"\char"+$588
00000000                            c			= c+1
00000000                            		endr
00000000                            		dc.w	$FFFF
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add a line break character to the textbox
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            txtLineBreak	macros
00000000                            		dc.w	$FFFF
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add a message terminator character to the textbox
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            txtLineEnd	macros
00000000                            		dc.w	0
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add an animation change flag to the textbox
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	ani	- New animation script pointer
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            txtNewAni	macro	ani
00000000                            		dc.w	$FFFE
00000000                            		dc.l	\ani
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add an icon change flag to the textbox
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	icon	- New icon art pointer
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            txtNewIcon	macro	icon
00000000                            		dc.w	$FFFD
00000000                            		dc.l	\icon
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add a finished flag to the textbox
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            txtEnd		macros
00000000                            		dc.w	$FFFC
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add an entry to the level art animation script
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	duration	- Global duration
00000000                            ;	artaddr		- Source art
00000000                            ;	tileid		- Destination tile ID
00000000                            ;	numentries	- Number of entries
00000000                            ;	numvramtiles	- Number of tiles per entry
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            lvlAniDat	macro	duration, artaddr, tileid, numentries, numvramtiles
00000000                            		dc.l	(\duration&$FF)<<24|\artaddr
00000000                            		dc.w	((\tileid&$7FF)<<5)
00000000                            		dc.b	\numentries, \numvramtiles
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Get a unique character set from a string
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	string		- String to go throuhg
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	unique_chars	- A string of unique characters found
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            getUniqueChars	macro	string
00000000                            unique_chars	substr 1,1,\string
00000000                            strpos		= 1
00000000                            
00000000                            		while strpos<strlen(\string)
00000000                            found			= 0
00000000                            pos			= 0
00000000                            char			substr strpos+1,strpos+1,\string
00000000                            
00000000                            			while (pos<strlen("\unique_chars"))&(found=0)
00000000                            uchar				substr pos+1,pos+1,"\unique_chars"
00000000                            				if strcmp("\uchar","\char")|strcmp("\char", " ")
00000000                            found					= 1
00000000                            				endif
00000000                            pos				= pos+1
00000000                            			endw
00000000                            
00000000                            			if found=0
00000000                            unique_chars			equs "\unique_chars\\char"
00000000                            			endif
00000000                            strpos			= strpos+1
00000000                            
00000000                            			endw
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Run objects macro
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            runObjects		macro
00000000                            		movea.w	rTailNext.w,a0				; load first object slot into a0
00000000                            		move.l	oAddr(a0),a1				; load its pointer to a1
00000000                            		jsr	(a1)					; jump to its code
00000000                            	endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Next object macro
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            nextObject		macro
00000000                            		movea.w	oNext(a0),a0				; load the next object address to a0
00000000                            		move.l	oAddr(a0),a1				; load its pointer to a1
00000000                            		jmp	(a1)					; jump to its code
00000000                            	endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add sprite to a display list
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	layer	- The destination display layer
00000000                            ;	obj 	- The address register for the source object
00000000                            ;	fre 	- A free-to-user address register
00000000                            ;	chk	- If 1, the code also checks if the object is displayed already
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            displaySprite		macro	layer, obj, fre, chk
00000000                            ;	if layer >= 8
00000000                            ;		inform 2,"Invalid display layer!"
00000000                            ;	endif
00000000                            
00000000                            	if \chk
00000000                            		tst.w	oDrawNext(\obj)					; check if displayed already
00000000                            		bne.s	.no\@						; if yes, skip
00000000                            	endif
00000000                            
00000000                            		move.w	#rDispInput+(\layer*dSize),oDrawNext(\obj)	; put end marker as the next pointer
00000000                            		move.w	rDispInput+dPrev+(\layer*dSize).w,\fre		; copy the pointer from the end marker to dst register
00000000                            		move.w	\fre,oDrawPrev(\obj)				; copy that to prev pointer
00000000                            		move.w	\obj,oDrawNext(\fre)				;
00000000                            		move.w	\obj,rDispInput+dPrev+(\layer*dSize).w		; copy the pointer from the end marker to dst register
00000000                            
00000000                            ;		cmp.w	#rDispInput+(\layer*dSize),rDispInput+dPrev+(\layer*dSize).w	; special case: points to itself
00000000                            ;		bne.s	.no\@								; if no, skip
00000000                            ;		move.w	\obj,rDispInput+dPrev+(\layer*dSize).w				; else, copy over
00000000                            
00000000                            .no\@
00000000                            	endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Add sprite to a display list using an address register
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	reg	- The address regsister containing target
00000000                            ;	obj 	- The address register for the source object
00000000                            ;	fre 	- A free-to-user address register
00000000                            ;	chk	- If 1, the code also checks if the object is displayed already
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            displaySpriteReg		macro	reg, obj, fre, chk
00000000                            	local layer
00000000                            layer EQUR	\reg							; convert register
00000000                            
00000000                            	if \chk
00000000                            		tst.w	oDrawNext(\reg)					; check if displayed already
00000000                            		bne.s	.no\@						; if yes, skip
00000000                            	endif
00000000                            
00000000                            		move.w	layer,oDrawNext(\obj)				; put end marker as the next pointer
00000000                            		move.w	oDrawPrev(layer),\fre				; copy the pointer from the end marker to dst register
00000000                            		move.w	\fre,oDrawPrev(\obj)				; copy that to prev pointer
00000000                            		move.w	\obj,oDrawNext(\fre)				;
00000000                            		move.w	\obj,oDrawPrev(layer)				; copy the pointer from the end marker to dst register
00000000                            
00000000                            ;		cmp.w	oDrawPrev(layer),layer				; special case: points to itself
00000000                            ;		bne.s	.no\@						; if no, skip
00000000                            ;		move.w	\obj,oDrawPrev(layer)				; else, copy over
00000000                            .no\@
00000000                            	endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Remove a sprite from a display list
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	obj 	- The address register for the source object
00000000                            ;	fre 	- A free-to-user address register
00000000                            ;	chk	- If 1, the code also checks if the object is displayed already
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            removeSprite		macro	obj, fre, chk
00000000                            	if \chk
00000000                            		tst.w	oDrawNext(\obj)					; check if displayed already
00000000                            		beq.s	.yes\@						; if not, skip
00000000                            	endif
00000000                            
00000000                            		move.w	oDrawPrev(\obj),\fre				; load the prev pointer to dst
00000000                            		move.w	oDrawNext(\obj),oDrawNext(\fre)			; copy the next object pointer from src to dst
00000000                            		move.w	oDrawNext(\obj),\fre				; load the next pointer to dst
00000000                            		move.w	oDrawPrev(\obj),oDrawPrev(\fre)			; copy the prev object pointer from src to dst
00000000                            
00000000                            ;		cmp.w	oDrawPrev(\obj),\fre				; special case: last object
00000000                            ;		bne.s	.no\@						; if no, skip
00000000                            ;		move.w	\fre,oDrawNext(\fre)				; else, change to point to same address
00000000                            
00000000                            .no\@
00000000                            		clr.l	oDrawNext(\obj)
00000000                            .yes\@
00000000                            	endm
00000000                            ; =========================================================================================================================================================
00000000                            		include	"Config/Offsets.asm"		; Offsets
00000000                            ; =========================================================================================================================================================
00000000                            ; User defined constants
00000000                            ; =========================================================================================================================================================
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Game mode IDs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsreset
00000000 =00000000                  gTitle		rs.l	1				; Title screen game mode
00000000 =00000004                  gLevel		rs.l	1				; Level game mode
00000000 =00000008                  gEnd		rs.l	1				; Ending game mode
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; V-INT routine IDs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsreset
00000000 =00000000                  vLag		rs.w	1				; Lag updates
00000000 =00000002                  vGeneral	rs.w	1				; General updates
00000000 =00000004                  vLevel		rs.w	1				; Level updates
00000000 =00000006                  vLvlLoad	rs.w	1				; Level load updates
00000000 =00000008                  vTitle		rs.w	1				; Title screen updates
00000000 =0000000A                  vFade		rs.w	1				; Fade updates
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Level IDs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsreset
00000000 =00000000                  zWWZ		rs.b	1				; Wacky Workbench
00000000                            
00000000 =00000001                  ZONE_COUNT	equ	__rs				; Number of zones
00000000                            
00000000 =00000000                  lWWZ		equ	zWWZ<<8				; Wacky Workbench
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Music definitions
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset	MusOff
00000000 =0000000A                  mFirst		rs.b	0
00000000 =0000000A                  mSega		rs.b	1				; SEGA jingle
00000000 =0000000B                  mWWZ		rs.b	1				; Wacky Workbench music
00000000 =0000000C                  mBoss		rs.b	1				; Boss music
00000000 =0000000D                  mInvincible	rs.b	1				; Invincibility music
00000000 =0000000E                  mEnd		rs.b	0
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; SFX definitions
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset	SFXoff
00000000 =00000082                  sFirst		rs.b	0
00000000 =00000082                  sLeap		rs.b	1				; Jump sound
00000000 =00000083                  sSkid		rs.b	1				; Skid sound
00000000 =00000084                  sHurt		rs.b	0				; Hurt sound
00000000 =00000084                  sDeath		rs.b	1				; Death sound
00000000 =00000085                  sPush		rs.b	1				; Push sound
00000000 =00000086                  sBubble		rs.b	1				; Bubble sound
00000000 =00000087                  sDrown		rs.b	1				; Drowning sound
00000000 =00000088                  sDrownWarn	rs.b	1				; Drown warning sound
00000000 =00000089                  sDrownCount	rs.b	1				; Drown countdown sound
00000000 =0000008A                  sCheckpoint	rs.b	1				; Checkpoint sound
00000000 =0000008B                  sSpikeMove	rs.b	1				; Spike movement sound
00000000 =0000008C                  sRing		rs.b	1				; Ring sound
00000000 =0000008D                  sRingLoss	rs.b	1				; Ring loss sound
00000000 =0000008E                  sSpring		rs.b	1				; Spring sound
00000000 =0000008F                  sShield		rs.b	1				; Shield sound
00000000 =00000090                  sSplash		rs.b	1				; Water splash sound
00000000 =00000091                  sBumper		rs.b	1				; Bumper sound
00000000 =00000092                  sSwitch		rs.b	1				; Switch sound
00000000 =00000093                  sSignpost	rs.b	1				; Signpost sound
00000000 =00000094                  sCollapse	rs.b	1				; Collapse sound
00000000 =00000095                  sWallSmash	rs.b	1				; Wall smash sound
00000000 =00000096                  sRumble		rs.b	1				; Rumble sound
00000000 =00000097                  sWarp		rs.b	1				; Warp sound
00000000 =00000098                  sBossHit	rs.b	1				; Boss hit sound
00000000 =00000099                  sBomb		rs.b	1				; Bomb sound
00000000 =0000009A                  sBreakItem	rs.b	1				; Break item sound
00000000 =0000009B                  sFloorBounce	rs.b	1				; Floor bounce sound
00000000 =0000009C                  sCharge		rs.b	1				; Charge sound
00000000 =0000009D                  sChargeStop	rs.b	1				; Charge stop sound
00000000 =0000009E                  sChargeRelease	rs.b	1				; Charge release sound
00000000 =0000009F                  sDiamBreak	rs.b	1				; Diamond break sound
00000000 =000000A0                  sEnd		rs.b	0
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Object SSTs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsreset
00000000 =00000000                  oPrevDPLC	rs.b	0				; Previous DPLC ID (only used by a few objects)
00000000 =00000000                  oAddr		rs.l	1				; Pointer to object code
00000000 =00000004                  oNext		rs.w	1				; Pointer to next object in the linked list
00000000 =00000006                  oPrev		rs.w	1				; Pointer to previous object in the linked list
00000000 =00000008                  oDrawNext	rs.w	1				; Pointer to next object to display
00000000 =0000000A                  oDrawPrev	rs.w	1				; Pointer to previous object to display
00000000                            
00000000 =0000000C                  oFlags		rs.b	1				; Object flags
00000000 =0000000D                  oRender		rs.b	1				; Render flags
00000000 =0000000E                  oVRAM		rs.w	1				; Sprite tile properties
00000000 =00000010                  oFrame		rs.b	0				; Mapping frame ID (top byte of the following long)
00000000 =00000010                  oMap		rs.l	1				; Sprite mappings
00000000                            
00000000 =00000014                  oXPos		rs.l	1				; X position
00000000 =00000017                  oDrawW	=	__rs-1					; Sprite width
00000000 =00000018                  oYPos		rs.l	1				; Y position
00000000 =0000001B                  oDrawH	=	__rs-1					; Sprite height
00000000 =0000001C                  oXVel		rs.w	1				; X velocity
00000000 =0000001E                  oYVel		rs.w	1				; Y velocity
00000000                            
00000000 =00000020                  oAni		rs.b	1				; Animation ID
00000000 =00000021                  oPrevAni	rs.b	1				; Saved animation ID
00000000 =00000022                  oAniFrame	rs.b	1				; Animation script frame ID
00000000 =00000023                  oAniTimer	rs.b	1				; Animation timer
00000000                            
00000000 =00000024                  oSubtype	rs.b	1				; Subtype ID (top byte of the following long)
00000000 =00000025                  oRoutine	rs.b	1				; Routine ID
00000000 =00000026                  oRespawn	rs.w	1				; Respawn table entry pointer
00000000 =00000028                  oStatus		rs.b	1				; Status flags
00000000 =00000029                  oShield		rs.b	1				; Shield flags
00000000                            
00000000 =0000002A                  oDynSSTs	rs.b	$60-__rs			; Dynamic SSTs
00000000 =00000060                  oSize		rs.b	0				; Size of the SSTs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Dynamic SSTs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset	oDynSSTs
00000000 =0000002A                  oColType	rs.b	1				; Collision type
00000000 =0000002B                  oColStat	rs.b	1				; Collision status
00000000 =0000002B                  oHitCnt		equ	oColStat			; Boss hit count
00000000 =0000002C                  oColW		rs.b	1				; Collision width
00000000 =0000002D                  oColH		rs.b	1				; Collision height
00000000 =0000002E                  oNextTilt	rs.b	1				; Next tilt value
00000000 =0000002F                  oTilt		rs.b	1				; Tilt value
00000000 =00000030                  oLvlSSTs	rs.b	0				; Beginning of dynamic level SSTs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Sub sprite SSTs
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsreset
00000000 =00000000                  oSubXPos	rs.w	1				; Sub sprite X position
00000000 =00000002                  oSubYPos	rs.w	1				; Sub sprite Y position
00000000                            		rs.b	1				; Unused
00000000 =00000005                  oSubFrame	rs.b	1				; Sub sprite mapping frame
00000000 =00000006                  oSubSize	rs.b	0				; Sub sprite SSTs size
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset	oNextTilt			; Allow some reserved SSTs
00000000 =0000002E                  oSubSSTs	rs.b	0				; Start of sub sprite SSTs
00000000 =0000002E                  oSubCnt		rs.w	1				; Main sprite sub sprite count
00000000 =00000030                  oSubStart	rs.b	0				; Actual sub sprite SSTs start
00000000 =00000000                  ct		=	0
00000000                            	rept	8					; Allow 8 sub sprites per object
00000000                            oSub\$ct\X	rs.w	1				; Sub sprite X position
00000000                            oSub\$ct\Y	rs.w	1				; Sub sprite Y position
00000000                            		rs.b	1				; Unused
00000000                            oSub\$ct\Frame	rs.b	1				; Sub sprite mapping frame position
00000000                            ct		=	ct+1
00000000                            	endr
00000000 =00000030                M osub0x	rs.w	1
00000000 =00000032                M osub0y	rs.w	1
00000000                          M 	rs.b	1
00000000 =00000035                M osub0frame	rs.b	1
00000000 =00000001                M ct	=	ct+1
00000000 =00000036                M osub1x	rs.w	1
00000000 =00000038                M osub1y	rs.w	1
00000000                          M 	rs.b	1
00000000 =0000003B                M osub1frame	rs.b	1
00000000 =00000002                M ct	=	ct+1
00000000 =0000003C                M osub2x	rs.w	1
00000000 =0000003E                M osub2y	rs.w	1
00000000                          M 	rs.b	1
00000000 =00000041                M osub2frame	rs.b	1
00000000 =00000003                M ct	=	ct+1
00000000 =00000042                M osub3x	rs.w	1
00000000 =00000044                M osub3y	rs.w	1
00000000                          M 	rs.b	1
00000000 =00000047                M osub3frame	rs.b	1
00000000 =00000004                M ct	=	ct+1
00000000 =00000048                M osub4x	rs.w	1
00000000 =0000004A                M osub4y	rs.w	1
00000000                          M 	rs.b	1
00000000 =0000004D                M osub4frame	rs.b	1
00000000 =00000005                M ct	=	ct+1
00000000 =0000004E                M osub5x	rs.w	1
00000000 =00000050                M osub5y	rs.w	1
00000000                          M 	rs.b	1
00000000 =00000053                M osub5frame	rs.b	1
00000000 =00000006                M ct	=	ct+1
00000000 =00000054                M osub6x	rs.w	1
00000000 =00000056                M osub6y	rs.w	1
00000000                          M 	rs.b	1
00000000 =00000059                M osub6frame	rs.b	1
00000000 =00000007                M ct	=	ct+1
00000000 =0000005A                M osub7x	rs.w	1
00000000 =0000005C                M osub7y	rs.w	1
00000000                          M 	rs.b	1
00000000 =0000005F                M osub7frame	rs.b	1
00000000 =00000008                M ct	=	ct+1
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Sprite drawing input list definitions
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset oDrawPrev-6			; this awkward thing will make dPrev == oDrawPrev
00000000 =00000004                  dNext		rs.w 1					; pointer to first display object in linked list
00000000 =00000006                  dN2		rs.w 1					; must be 0
00000000 =00000008                  dN1		rs.w 1					; must be 0
00000000 =0000000A                  dPrev		rs.w 1					; pointer to last display object in linked list
00000000 =00000008                  dSize =		__rs-dNext				; size of display layer
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Solid object collision bits
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =00000003                  cStandBit	equ	3
00000000 =00000008                  cStand		equ	1<<cStandBit
00000000                            
00000000 =00000002                  cPushDelta	equ	2
00000000                            
00000000 =00000005                  cPushBit	equ	cStandBit+cPushDelta
00000000 =00000020                  cPush		equ	1<<cPushBit
00000000                            
00000000 =00000000                  cTouchSideBit	equ	0
00000000 =00000001                  cTouchSide	equ	1<<cTouchSideBit
00000000                            
00000000 =00000002                  cTouchBtmBit	equ	cTouchSideBit+cPushDelta
00000000 =00000004                  cTouchBtm	equ	1<<cTouchBtmBit
00000000                            
00000000 =00000004                  cTouchTopBit	equ	cTouchBtmBit+cPushDelta
00000000 =00000010                  cTouchTop	equ	1<<cTouchTopBit
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Macro to calculate the RAM space used by objects without going over the given max size
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	size	- Max size for this object SST space
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =00000000                  curobj		=	0
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            maxObjRAM	macro	size
00000000                            curobj_size	=	0
00000000                            		while curobj_size<(\size)
00000000                            rObj_\$curobj		rs.b	oSize
00000000                            curobj_size		=	curobj_size+oSize
00000000                            curobj			=	curobj+1
00000000                            		endw
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Level drawing variables
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsreset
00000000 =00000000                  cXPos		rs.l	1				; Plane X position
00000000 =00000004                  cXPrev		rs.w	1				; Plane previous X position
00000000 =00000006                  cXPrevR		rs.w	1				; Plane previous X position (rounded)
00000000 =00000008                  cYPos		rs.l	1				; Plane Y position
00000000 =0000000C                  cYPrev		rs.w	1				; Plane previous Y position
00000000 =0000000E                  cYPrevR		rs.w	1				; Plane previous Y position (rounded)
00000000 =00000010                  cRBlks		rs.b	1				; Number of blocks in the first set of tiles in a row
00000000 =00000011                  cCBlks		rs.b	1				; Number of blocks in the first set of tiles in a column
00000000 =00000012                  cVDP		rs.l	1				; VDP command
00000000 =00000016                  cLayout		rs.w	1				; Layout offset
00000000 =00000018                  cUpdate		rs.l	1				; Update routine
00000000 =0000001C                  cRedraw		rs.w	1				; Redraw flag
00000000 =0000001E                  cSize2		rs.b	0				; Variable list size
00000000                            ; =========================================================================================================================================================
00000000                            		include	"Config/Variables.asm"		; Variables
00000000                            ; =========================================================================================================================================================
00000000                            ; User defined RAM addresses
00000000                            ; =========================================================================================================================================================
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Standard variables
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset	RAM_START
00000000                            
00000000                            		; --- BUFFERS ---
00000000                            
00000000 =00FF0000                  rBuffer		rs.b	0				; General buffer
00000000 =00FF0000                  rChunks		rs.b	$8000				; Chunk table (uses same space as general buffer)
00000000 =00FF8000                  rBuffer_End	rs.b	0
00000000                            
00000000                            		rsset	$FF000000|(RAM_START+$8000)
00000000                            
00000000 =FFFF8000                  rKosPBuf	rs.b	$1000				; Kosinski decompression buffer
00000000                            
00000000 =FFFF9000                  rDMAQueue	rs.b	$FC				; DMA queue buffer
00000000 =FFFF90FC                  rDMASlot	rs.w	1				; DMA queue buffer slot
00000000                            
00000000 =FFFF90FE                  rHScroll	rs.b	$380				; HScroll table
00000000 =FFFF947E                  rHScroll_End	rs.b	0				; ''
00000000                            
00000000 =FFFF947E                  rVScroll	rs.b	$50				; VScroll table
00000000 =FFFF94CE                  rVScroll_End	rs.b	0				; ''
00000000 =FFFF947E                  rVScrollFG	EQU	rVScroll			; VScroll foreground value
00000000 =FFFF9480                  rVScrollBG	EQU	rVScroll+2			; VScroll background value
00000000                            
00000000 =FFFF94CE                  rSprites	rs.b	$280				; Sprite table
00000000 =FFFF974E                  rSprites_End	rs.b	0				; ''
00000000                            
00000000                            ; NTP: we won't be able to save ram like this until we switch to SWAP mappings (and we'll need per-piece limit checks on lest we overwrite the water palette)
00000000                            ;rDestWtrPal	equ	rSprites_End-$100		; Target water palette buffer
00000000                            ;rDestPal	equ	rSprites_End-$80		; Target palette buffer
00000000                            
00000000 =FFFF974E                  rDestWtrPal	rs.b	$80				; Target water palette buffer
00000000 =FFFF97CE                  rDestPal	rs.b	$80				; Target palette buffer
00000000 =FFFF984E                  rWaterPal	rs.b	$80				; Water palette buffer
00000000 =FFFF98CE                  rPalette	rs.b	$80				; Palette buffer
00000000                            
00000000 =FFFF994E                  rKosPVars	rs.b	0				; Kosinski decompression queue variables
00000000 =FFFF994E                  rKosPCnt	rs.w	1				; Kosinski decompression queue count
00000000 =FFFF9950                  rKosPRegs	rs.b	$1A				; Kosinski decompression stored registers
00000000 =FFFF996A                  rKosPSR		rs.w	1				; Kosinski decompression stored SR
00000000 =FFFF996C                  rKosPBookmark	rs.l	1				; Kosinski decompression bookmark
00000000 =FFFF9970                  rKosPList	rs.b	$20				; Kosinski decompression queue
00000000 =FFFF9970                  rKosPSrc	equ	rKosPList			; ''
00000000 =FFFF9974                  rKosPDest	equ	rKosPList+4			; ''
00000000 =FFFF9990                  rKosPList_End	rs.b	0				; ''
00000000 =FFFF9990                  rKosPMMods	rs.w	1				; Kosinski moduled decompression modules left
00000000 =FFFF9992                  rKosPMLastSz	rs.w	1				; Kosinski moduled decompression last module size
00000000 =FFFF9994                  rKosPMList	rs.b	$20*6				; Kosinski moduled decompression queue
00000000 =FFFF9994                  rKosPMSrc	equ	rKosPMList			; ''
00000000 =FFFF9998                  rKosPMDest	equ	rKosPMList+4			; ''
00000000 =FFFF9A54                  rKosPMList_End	rs.b	0				; ''
00000000 =FFFF9A54                  rKosPVars_End	rs.b	0				; End of Kosinski decompression queue variables
00000000                            
00000000 =FFFF9A54                  rObjects	rs.b	0				; Object SSTs
00000000                            		maxObjRAM $2400				; ''
00000000 =00000000                M curobj_size	=	0
00000000                          M 	while	curobj_size<($2400)
00000000 =FFFF9A54                M robj_0	rs.b	osize
00000000 =00000060                M curobj_size	=	curobj_size+osize
00000000 =00000001                M curobj	=	curobj+1
00000000 =FFFF9AB4                M robj_1	rs.b	osize
00000000 =000000C0                M curobj_size	=	curobj_size+osize
00000000 =00000002                M curobj	=	curobj+1
00000000 =FFFF9B14                M robj_2	rs.b	osize
00000000 =00000120                M curobj_size	=	curobj_size+osize
00000000 =00000003                M curobj	=	curobj+1
00000000 =FFFF9B74                M robj_3	rs.b	osize
00000000 =00000180                M curobj_size	=	curobj_size+osize
00000000 =00000004                M curobj	=	curobj+1
00000000 =FFFF9BD4                M robj_4	rs.b	osize
00000000 =000001E0                M curobj_size	=	curobj_size+osize
00000000 =00000005                M curobj	=	curobj+1
00000000 =FFFF9C34                M robj_5	rs.b	osize
00000000 =00000240                M curobj_size	=	curobj_size+osize
00000000 =00000006                M curobj	=	curobj+1
00000000 =FFFF9C94                M robj_6	rs.b	osize
00000000 =000002A0                M curobj_size	=	curobj_size+osize
00000000 =00000007                M curobj	=	curobj+1
00000000 =FFFF9CF4                M robj_7	rs.b	osize
00000000 =00000300                M curobj_size	=	curobj_size+osize
00000000 =00000008                M curobj	=	curobj+1
00000000 =FFFF9D54                M robj_8	rs.b	osize
00000000 =00000360                M curobj_size	=	curobj_size+osize
00000000 =00000009                M curobj	=	curobj+1
00000000 =FFFF9DB4                M robj_9	rs.b	osize
00000000 =000003C0                M curobj_size	=	curobj_size+osize
00000000 =0000000A                M curobj	=	curobj+1
00000000 =FFFF9E14                M robj_a	rs.b	osize
00000000 =00000420                M curobj_size	=	curobj_size+osize
00000000 =0000000B                M curobj	=	curobj+1
00000000 =FFFF9E74                M robj_b	rs.b	osize
00000000 =00000480                M curobj_size	=	curobj_size+osize
00000000 =0000000C                M curobj	=	curobj+1
00000000 =FFFF9ED4                M robj_c	rs.b	osize
00000000 =000004E0                M curobj_size	=	curobj_size+osize
00000000 =0000000D                M curobj	=	curobj+1
00000000 =FFFF9F34                M robj_d	rs.b	osize
00000000 =00000540                M curobj_size	=	curobj_size+osize
00000000 =0000000E                M curobj	=	curobj+1
00000000 =FFFF9F94                M robj_e	rs.b	osize
00000000 =000005A0                M curobj_size	=	curobj_size+osize
00000000 =0000000F                M curobj	=	curobj+1
00000000 =FFFF9FF4                M robj_f	rs.b	osize
00000000 =00000600                M curobj_size	=	curobj_size+osize
00000000 =00000010                M curobj	=	curobj+1
00000000 =FFFFA054                M robj_10	rs.b	osize
00000000 =00000660                M curobj_size	=	curobj_size+osize
00000000 =00000011                M curobj	=	curobj+1
00000000 =FFFFA0B4                M robj_11	rs.b	osize
00000000 =000006C0                M curobj_size	=	curobj_size+osize
00000000 =00000012                M curobj	=	curobj+1
00000000 =FFFFA114                M robj_12	rs.b	osize
00000000 =00000720                M curobj_size	=	curobj_size+osize
00000000 =00000013                M curobj	=	curobj+1
00000000 =FFFFA174                M robj_13	rs.b	osize
00000000 =00000780                M curobj_size	=	curobj_size+osize
00000000 =00000014                M curobj	=	curobj+1
00000000 =FFFFA1D4                M robj_14	rs.b	osize
00000000 =000007E0                M curobj_size	=	curobj_size+osize
00000000 =00000015                M curobj	=	curobj+1
00000000 =FFFFA234                M robj_15	rs.b	osize
00000000 =00000840                M curobj_size	=	curobj_size+osize
00000000 =00000016                M curobj	=	curobj+1
00000000 =FFFFA294                M robj_16	rs.b	osize
00000000 =000008A0                M curobj_size	=	curobj_size+osize
00000000 =00000017                M curobj	=	curobj+1
00000000 =FFFFA2F4                M robj_17	rs.b	osize
00000000 =00000900                M curobj_size	=	curobj_size+osize
00000000 =00000018                M curobj	=	curobj+1
00000000 =FFFFA354                M robj_18	rs.b	osize
00000000 =00000960                M curobj_size	=	curobj_size+osize
00000000 =00000019                M curobj	=	curobj+1
00000000 =FFFFA3B4                M robj_19	rs.b	osize
00000000 =000009C0                M curobj_size	=	curobj_size+osize
00000000 =0000001A                M curobj	=	curobj+1
00000000 =FFFFA414                M robj_1a	rs.b	osize
00000000 =00000A20                M curobj_size	=	curobj_size+osize
00000000 =0000001B                M curobj	=	curobj+1
00000000 =FFFFA474                M robj_1b	rs.b	osize
00000000 =00000A80                M curobj_size	=	curobj_size+osize
00000000 =0000001C                M curobj	=	curobj+1
00000000 =FFFFA4D4                M robj_1c	rs.b	osize
00000000 =00000AE0                M curobj_size	=	curobj_size+osize
00000000 =0000001D                M curobj	=	curobj+1
00000000 =FFFFA534                M robj_1d	rs.b	osize
00000000 =00000B40                M curobj_size	=	curobj_size+osize
00000000 =0000001E                M curobj	=	curobj+1
00000000 =FFFFA594                M robj_1e	rs.b	osize
00000000 =00000BA0                M curobj_size	=	curobj_size+osize
00000000 =0000001F                M curobj	=	curobj+1
00000000 =FFFFA5F4                M robj_1f	rs.b	osize
00000000 =00000C00                M curobj_size	=	curobj_size+osize
00000000 =00000020                M curobj	=	curobj+1
00000000 =FFFFA654                M robj_20	rs.b	osize
00000000 =00000C60                M curobj_size	=	curobj_size+osize
00000000 =00000021                M curobj	=	curobj+1
00000000 =FFFFA6B4                M robj_21	rs.b	osize
00000000 =00000CC0                M curobj_size	=	curobj_size+osize
00000000 =00000022                M curobj	=	curobj+1
00000000 =FFFFA714                M robj_22	rs.b	osize
00000000 =00000D20                M curobj_size	=	curobj_size+osize
00000000 =00000023                M curobj	=	curobj+1
00000000 =FFFFA774                M robj_23	rs.b	osize
00000000 =00000D80                M curobj_size	=	curobj_size+osize
00000000 =00000024                M curobj	=	curobj+1
00000000 =FFFFA7D4                M robj_24	rs.b	osize
00000000 =00000DE0                M curobj_size	=	curobj_size+osize
00000000 =00000025                M curobj	=	curobj+1
00000000 =FFFFA834                M robj_25	rs.b	osize
00000000 =00000E40                M curobj_size	=	curobj_size+osize
00000000 =00000026                M curobj	=	curobj+1
00000000 =FFFFA894                M robj_26	rs.b	osize
00000000 =00000EA0                M curobj_size	=	curobj_size+osize
00000000 =00000027                M curobj	=	curobj+1
00000000 =FFFFA8F4                M robj_27	rs.b	osize
00000000 =00000F00                M curobj_size	=	curobj_size+osize
00000000 =00000028                M curobj	=	curobj+1
00000000 =FFFFA954                M robj_28	rs.b	osize
00000000 =00000F60                M curobj_size	=	curobj_size+osize
00000000 =00000029                M curobj	=	curobj+1
00000000 =FFFFA9B4                M robj_29	rs.b	osize
00000000 =00000FC0                M curobj_size	=	curobj_size+osize
00000000 =0000002A                M curobj	=	curobj+1
00000000 =FFFFAA14                M robj_2a	rs.b	osize
00000000 =00001020                M curobj_size	=	curobj_size+osize
00000000 =0000002B                M curobj	=	curobj+1
00000000 =FFFFAA74                M robj_2b	rs.b	osize
00000000 =00001080                M curobj_size	=	curobj_size+osize
00000000 =0000002C                M curobj	=	curobj+1
00000000 =FFFFAAD4                M robj_2c	rs.b	osize
00000000 =000010E0                M curobj_size	=	curobj_size+osize
00000000 =0000002D                M curobj	=	curobj+1
00000000 =FFFFAB34                M robj_2d	rs.b	osize
00000000 =00001140                M curobj_size	=	curobj_size+osize
00000000 =0000002E                M curobj	=	curobj+1
00000000 =FFFFAB94                M robj_2e	rs.b	osize
00000000 =000011A0                M curobj_size	=	curobj_size+osize
00000000 =0000002F                M curobj	=	curobj+1
00000000 =FFFFABF4                M robj_2f	rs.b	osize
00000000 =00001200                M curobj_size	=	curobj_size+osize
00000000 =00000030                M curobj	=	curobj+1
00000000 =FFFFAC54                M robj_30	rs.b	osize
00000000 =00001260                M curobj_size	=	curobj_size+osize
00000000 =00000031                M curobj	=	curobj+1
00000000 =FFFFACB4                M robj_31	rs.b	osize
00000000 =000012C0                M curobj_size	=	curobj_size+osize
00000000 =00000032                M curobj	=	curobj+1
00000000 =FFFFAD14                M robj_32	rs.b	osize
00000000 =00001320                M curobj_size	=	curobj_size+osize
00000000 =00000033                M curobj	=	curobj+1
00000000 =FFFFAD74                M robj_33	rs.b	osize
00000000 =00001380                M curobj_size	=	curobj_size+osize
00000000 =00000034                M curobj	=	curobj+1
00000000 =FFFFADD4                M robj_34	rs.b	osize
00000000 =000013E0                M curobj_size	=	curobj_size+osize
00000000 =00000035                M curobj	=	curobj+1
00000000 =FFFFAE34                M robj_35	rs.b	osize
00000000 =00001440                M curobj_size	=	curobj_size+osize
00000000 =00000036                M curobj	=	curobj+1
00000000 =FFFFAE94                M robj_36	rs.b	osize
00000000 =000014A0                M curobj_size	=	curobj_size+osize
00000000 =00000037                M curobj	=	curobj+1
00000000 =FFFFAEF4                M robj_37	rs.b	osize
00000000 =00001500                M curobj_size	=	curobj_size+osize
00000000 =00000038                M curobj	=	curobj+1
00000000 =FFFFAF54                M robj_38	rs.b	osize
00000000 =00001560                M curobj_size	=	curobj_size+osize
00000000 =00000039                M curobj	=	curobj+1
00000000 =FFFFAFB4                M robj_39	rs.b	osize
00000000 =000015C0                M curobj_size	=	curobj_size+osize
00000000 =0000003A                M curobj	=	curobj+1
00000000 =FFFFB014                M robj_3a	rs.b	osize
00000000 =00001620                M curobj_size	=	curobj_size+osize
00000000 =0000003B                M curobj	=	curobj+1
00000000 =FFFFB074                M robj_3b	rs.b	osize
00000000 =00001680                M curobj_size	=	curobj_size+osize
00000000 =0000003C                M curobj	=	curobj+1
00000000 =FFFFB0D4                M robj_3c	rs.b	osize
00000000 =000016E0                M curobj_size	=	curobj_size+osize
00000000 =0000003D                M curobj	=	curobj+1
00000000 =FFFFB134                M robj_3d	rs.b	osize
00000000 =00001740                M curobj_size	=	curobj_size+osize
00000000 =0000003E                M curobj	=	curobj+1
00000000 =FFFFB194                M robj_3e	rs.b	osize
00000000 =000017A0                M curobj_size	=	curobj_size+osize
00000000 =0000003F                M curobj	=	curobj+1
00000000 =FFFFB1F4                M robj_3f	rs.b	osize
00000000 =00001800                M curobj_size	=	curobj_size+osize
00000000 =00000040                M curobj	=	curobj+1
00000000 =FFFFB254                M robj_40	rs.b	osize
00000000 =00001860                M curobj_size	=	curobj_size+osize
00000000 =00000041                M curobj	=	curobj+1
00000000 =FFFFB2B4                M robj_41	rs.b	osize
00000000 =000018C0                M curobj_size	=	curobj_size+osize
00000000 =00000042                M curobj	=	curobj+1
00000000 =FFFFB314                M robj_42	rs.b	osize
00000000 =00001920                M curobj_size	=	curobj_size+osize
00000000 =00000043                M curobj	=	curobj+1
00000000 =FFFFB374                M robj_43	rs.b	osize
00000000 =00001980                M curobj_size	=	curobj_size+osize
00000000 =00000044                M curobj	=	curobj+1
00000000 =FFFFB3D4                M robj_44	rs.b	osize
00000000 =000019E0                M curobj_size	=	curobj_size+osize
00000000 =00000045                M curobj	=	curobj+1
00000000 =FFFFB434                M robj_45	rs.b	osize
00000000 =00001A40                M curobj_size	=	curobj_size+osize
00000000 =00000046                M curobj	=	curobj+1
00000000 =FFFFB494                M robj_46	rs.b	osize
00000000 =00001AA0                M curobj_size	=	curobj_size+osize
00000000 =00000047                M curobj	=	curobj+1
00000000 =FFFFB4F4                M robj_47	rs.b	osize
00000000 =00001B00                M curobj_size	=	curobj_size+osize
00000000 =00000048                M curobj	=	curobj+1
00000000 =FFFFB554                M robj_48	rs.b	osize
00000000 =00001B60                M curobj_size	=	curobj_size+osize
00000000 =00000049                M curobj	=	curobj+1
00000000 =FFFFB5B4                M robj_49	rs.b	osize
00000000 =00001BC0                M curobj_size	=	curobj_size+osize
00000000 =0000004A                M curobj	=	curobj+1
00000000 =FFFFB614                M robj_4a	rs.b	osize
00000000 =00001C20                M curobj_size	=	curobj_size+osize
00000000 =0000004B                M curobj	=	curobj+1
00000000 =FFFFB674                M robj_4b	rs.b	osize
00000000 =00001C80                M curobj_size	=	curobj_size+osize
00000000 =0000004C                M curobj	=	curobj+1
00000000 =FFFFB6D4                M robj_4c	rs.b	osize
00000000 =00001CE0                M curobj_size	=	curobj_size+osize
00000000 =0000004D                M curobj	=	curobj+1
00000000 =FFFFB734                M robj_4d	rs.b	osize
00000000 =00001D40                M curobj_size	=	curobj_size+osize
00000000 =0000004E                M curobj	=	curobj+1
00000000 =FFFFB794                M robj_4e	rs.b	osize
00000000 =00001DA0                M curobj_size	=	curobj_size+osize
00000000 =0000004F                M curobj	=	curobj+1
00000000 =FFFFB7F4                M robj_4f	rs.b	osize
00000000 =00001E00                M curobj_size	=	curobj_size+osize
00000000 =00000050                M curobj	=	curobj+1
00000000 =FFFFB854                M robj_50	rs.b	osize
00000000 =00001E60                M curobj_size	=	curobj_size+osize
00000000 =00000051                M curobj	=	curobj+1
00000000 =FFFFB8B4                M robj_51	rs.b	osize
00000000 =00001EC0                M curobj_size	=	curobj_size+osize
00000000 =00000052                M curobj	=	curobj+1
00000000 =FFFFB914                M robj_52	rs.b	osize
00000000 =00001F20                M curobj_size	=	curobj_size+osize
00000000 =00000053                M curobj	=	curobj+1
00000000 =FFFFB974                M robj_53	rs.b	osize
00000000 =00001F80                M curobj_size	=	curobj_size+osize
00000000 =00000054                M curobj	=	curobj+1
00000000 =FFFFB9D4                M robj_54	rs.b	osize
00000000 =00001FE0                M curobj_size	=	curobj_size+osize
00000000 =00000055                M curobj	=	curobj+1
00000000 =FFFFBA34                M robj_55	rs.b	osize
00000000 =00002040                M curobj_size	=	curobj_size+osize
00000000 =00000056                M curobj	=	curobj+1
00000000 =FFFFBA94                M robj_56	rs.b	osize
00000000 =000020A0                M curobj_size	=	curobj_size+osize
00000000 =00000057                M curobj	=	curobj+1
00000000 =FFFFBAF4                M robj_57	rs.b	osize
00000000 =00002100                M curobj_size	=	curobj_size+osize
00000000 =00000058                M curobj	=	curobj+1
00000000 =FFFFBB54                M robj_58	rs.b	osize
00000000 =00002160                M curobj_size	=	curobj_size+osize
00000000 =00000059                M curobj	=	curobj+1
00000000 =FFFFBBB4                M robj_59	rs.b	osize
00000000 =000021C0                M curobj_size	=	curobj_size+osize
00000000 =0000005A                M curobj	=	curobj+1
00000000 =FFFFBC14                M robj_5a	rs.b	osize
00000000 =00002220                M curobj_size	=	curobj_size+osize
00000000 =0000005B                M curobj	=	curobj+1
00000000 =FFFFBC74                M robj_5b	rs.b	osize
00000000 =00002280                M curobj_size	=	curobj_size+osize
00000000 =0000005C                M curobj	=	curobj+1
00000000 =FFFFBCD4                M robj_5c	rs.b	osize
00000000 =000022E0                M curobj_size	=	curobj_size+osize
00000000 =0000005D                M curobj	=	curobj+1
00000000 =FFFFBD34                M robj_5d	rs.b	osize
00000000 =00002340                M curobj_size	=	curobj_size+osize
00000000 =0000005E                M curobj	=	curobj+1
00000000 =FFFFBD94                M robj_5e	rs.b	osize
00000000 =000023A0                M curobj_size	=	curobj_size+osize
00000000 =0000005F                M curobj	=	curobj+1
00000000 =FFFFBDF4                M robj_5f	rs.b	osize
00000000 =00002400                M curobj_size	=	curobj_size+osize
00000000 =00000060                M curobj	=	curobj+1
00000000 =FFFFBE54                  rObjects_End	rs.b	0
00000000                            
00000000 =00000060                  OBJECT_COUNT	equ	(rObjects_End-rObjects)/oSize
00000000                            
00000000 =FFFFBE54                  rTailAddr	rs.l	1				; pointer to tail object code
00000000 =FFFFBE58                  rTailNext	rs.w	1				; pointer to the first object in linked list
00000000 =FFFFBE5A                  rTailPrev	rs.w	1				; pointer to the last object in linked list
00000000 =FFFFBE5C                  rFreeHead	rs.w	1				; pointer to the first object that is not loaded
00000000                            
00000000 =FFFFBE5A                  rDispInput	equ __rs-dnext
00000000                            		rs.b	dSize*8				; Sprite display input list (8 priority levels)
00000000 =FFFFBE9E                  rDispInput_End	rs.b	0				; 
00000000                            
00000000 =FFFFBE9E                  rRespawns	rs.b	$300				; Object respawn table
00000000 =FFFFC19E                  rRespawns_End	rs.b	0				; ''
00000000                            
00000000 =FFFFC19E                  rFGRowBuf	rs.b	$102				; Foreground horizontal plane buffer
00000000 =FFFFC2A0                  rFGColBuf	rs.b	$82				; Foreground vertical plane buffer
00000000 =FFFFC322                  rBGRowBuf	rs.b	$102				; Background horizontal plane buffer
00000000 =FFFFC424                  rBGColBuf	rs.b	$82				; Background vertical plane buffer
00000000                            
00000000 =FFFFC4A6                  rAMPS		rs.b	0			; AMPS variables
00000000                            		include	"Sound/amps/code/ram.asm"
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; RAM definitions
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000 =FFFFC4A6                  mFlags		rs.b 1		; various driver flags, see below
00000000 =FFFFC4A7                  mCtrPal		rs.b 1		; frame counter fo 50hz fix
00000000 =FFFFC4A8                  mVctSFX		rs.l 1		; address of voice table for sfx
00000000 =FFFFC4AC                  mComm		rs.b 8		; communications bytes
00000000 =FFFFC4B4                  mMasterVolFM	rs.b 0		; master volume for FM channels
00000000 =FFFFC4B4                  mFadeAddr	rs.l 1		; fading program address
00000000 =FFFFC4B8                  mTempoMain	rs.b 1		; music normal tempo
00000000 =FFFFC4B9                  mTempoSpeed	rs.b 1		; music speed shoes tempo
00000000 =FFFFC4BA                  mTempo		rs.b 1		; current tempo we are using right now
00000000 =FFFFC4BB                  mTempoCur	rs.b 1		; tempo counter/accumulator
00000000 =FFFFC4BC                  mQueue		rs.b 3		; sound queue
00000000 =FFFFC4BF                  mMasterVolPSG	rs.b 1		; master volume for PSG channels
00000000 =FFFFC4C0                  mMasterVolDAC	rs.b 1		; master volume for DAC channels
00000000 =FFFFC4C1                  mSpindash	rs.b 1		; spindash rev counter
00000000 =FFFFC4C2                  mContCtr	rs.b 1		; continous sfx loop counter
00000000 =FFFFC4C3                  mContLast	rs.b 1		; last continous sfx played
00000000                            		rs.w 0		; align channel data
00000000                            
00000000 =FFFFC4C4                  mDAC1		rs.b cSize	; DAC 1 data
00000000 =FFFFC4F0                  mDAC2		rs.b cSize	; DAC 2 data
00000000 =FFFFC51C                  mFM1		rs.b cSize	; FM 1 data
00000000 =FFFFC548                  mFM2		rs.b cSize	; FM 2 data
00000000 =FFFFC574                  mFM3		rs.b cSize	; FM 3 data
00000000 =FFFFC5A0                  mFM4		rs.b cSize	; FM 4 data
00000000 =FFFFC5CC                  mFM5		rs.b cSize	; FM 5 data
00000000 =FFFFC5F8                  mPSG1		rs.b cSize	; PSG 1 data
00000000 =FFFFC624                  mPSG2		rs.b cSize	; PSG 2 data
00000000 =FFFFC650                  mPSG3		rs.b cSize	; PSG 3 data
00000000 =FFFFC67C                  mSFXDAC1	rs.b cSizeSFX	; SFX DAC 1 data
00000000 =FFFFC698                  mSFXFM3		rs.b cSizeSFX	; SFX FM 3 data
00000000 =FFFFC6B4                  mSFXFM4		rs.b cSizeSFX	; SFX FM 4 data
00000000 =FFFFC6D0                  mSFXFM5		rs.b cSizeSFX	; SFX FM 5 data
00000000 =FFFFC6EC                  mSFXPSG1	rs.b cSizeSFX	; SFX PSG 1 data
00000000 =FFFFC708                  mSFXPSG2	rs.b cSizeSFX	; SFX PSG 2 data
00000000 =FFFFC724                  mSFXPSG3	rs.b cSizeSFX	; SFX PSG 3 data
00000000                            
00000000                            		rsEven
00000000                          M 	rs.b	__rs&1
00000000 =FFFFC740                  mSize		rs.w 0		; end of the driver RAM
00000000                            ; ===========================================================================
00000000                            
00000000                            		; --- ENGINE VARIABLES ---
00000000                            
00000000 =FFFFC740                  rP1Data		rs.b	0				; Controller 1 data
00000000 =FFFFC740                  rP1Hold		rs.b	1				; Controller 1 held button data
00000000 =FFFFC741                  rP1Press	rs.b	1				; Controller 1 pressed button data
00000000 =FFFFC742                  rP2Data		rs.b	0				; Controller 2 data
00000000 =FFFFC742                  rP2Hold		rs.b	1				; Controller 2 held button data
00000000 =FFFFC743                  rP2Press	rs.b	1				; Controller 2 pressed button data
00000000                            
00000000 =FFFFC744                  rHWVersion	rs.b	1				; Hardware version
00000000 =FFFFC745                  rVINTFlag	rs.b	0				; V-INT flag
00000000 =FFFFC745                  rVINTRout	rs.b	1				; V-INT routine
00000000                            
00000000 =FFFFC746                  rPalFade	rs.b	0				; Palette fade properties
00000000 =FFFFC746                  rFadeStart	rs.b	1				; Palette fade start index
00000000 =FFFFC747                  rFadeLen	rs.b	1				; Palette fade size
00000000                            
00000000 =FFFFC748                  rLagCount	rs.b	1				; Lag frame counter
00000000                            
00000000 =FFFFC749                  rHIntFlag	rs.b	1				; H-INT run flag
00000000                            
00000000 =FFFFC74A                  rVIntJmp	rs.w	1				; Header will point here for V-INT
00000000 =FFFFC74C                  rVIntAddr	rs.l	1				; V-INT address
00000000 =FFFFC750                  rHIntJmp	rs.w	1				; Header will point here for H-INT
00000000 =FFFFC752                  rHIntAddr	rs.l	1				; H-INT address
00000000                            
00000000 =FFFFC756                  rFrameCnt	rs.l	1				; Frame counter
00000000                            
00000000 =FFFFC75A                  rGameMode	rs.b	1				; Game mode ID
00000000 =FFFFC75B                  rSprCount	rs.b	1				; Sprite count
00000000 =FFFFC75C                  rPauseFlag	rs.b	1				; Pause flag
00000000 =FFFFC75D                  rHIntUpdates	rs.b	1				; Level updates in H-INT flag
00000000                            
00000000 =FFFFC75E                  rHIntReg	rs.b	1				; H-INT counter register
00000000 =FFFFC75F                  rHIntCnt	rs.b	1				; H-INT counter value
00000000                            
00000000 =FFFFC760                  rRNGSeed	rs.l	1				; RNG seed
00000000                            
00000000 =FFFFC764                  rVDPReg1	rs.w	1				; VDP register 1 register ID and value
00000000 =FFFFC766                  rWindowY	rs.w	1				; Window Y position (VDP register)
00000000                            
00000000 =FFFFC768                  rMoveCheat	rs.b	1
00000000 =FFFFC769                  rArtCheat	rs.b	1
00000000                            
00000000 =FFFFC76A                  rOscNums	rs.b	0				; Oscillation numbers
00000000 =FFFFC76A                  rOscCtrl	rs.w	1				; Oscillation control
00000000 =FFFFC76C                  rOscData	rs.w	$20				; Oscialltion data
00000000 =FFFFC7AC                  rOscNums_End	rs.b	0				; ''
00000000                            
00000000                            		; --- GLOBAL VARIABLES ---
00000000                            
00000000 =FFFFC7AC                  rLevel		rs.b	0				; Level ID
00000000 =FFFFC7AC                  rZone		rs.b	1				; Zone ID
00000000 =FFFFC7AD                  rAct		rs.b	1				; Act ID
00000000                            
00000000 =FFFFC7AE                  rChkpoint	rs.b	0				; Checkpoint RAM
00000000 =FFFFC7AE                  rLastChkpoint	rs.b	1				; Last checkpoint hit
00000000                            		rs.b	1
00000000 =FFFFC7B0                  rSavedXPos	rs.w	1				; Saved player X position
00000000 =FFFFC7B2                  rSavedYPos	rs.w	1				; Saved player Y position
00000000 =FFFFC7B4                  rChkpoint_End	rs.b	0				; End of checkpoint RAM
00000000                            
00000000 =FFFFC7B4                  rObjPosAddr	rs.l	1				; Object position data pointer
00000000 =FFFFC7B8                  rObjManInit	rs.b	1				; Object manager initialized flag
00000000                            
00000000 =FFFFC7B9                  rStartFall	rs.b	1				; Start level by falling flag
00000000                            
00000000 =FFFFC7BA                  rObjLoadR	rs.l	1				; Object data address (for going right)
00000000 =FFFFC7BE                  rObjLoadL	rs.l	1				; Object data address (for going left)
00000000 =FFFFC7C2                  rObjRespL	rs.w	1				; Object respawn address (for going right)
00000000 =FFFFC7C4                  rObjRespR	rs.w	1				; Object respawn address (for going left)
00000000 =FFFFC7C6                  rObjXCoarse	rs.w	1				; Object manager's coarse X position
00000000 =FFFFC7C8                  rObjYCoarse	rs.w	1				; Object manager's coarse Y position
00000000 =FFFFC7CA                  rObjManX	rs.w	1				; Object manager's camera X position
00000000 =FFFFC7CC                  rObjManY	rs.w	1				; Object manager's camera Y position
00000000                            
00000000 =FFFFC7CE                  rPalCycTimer	rs.b	1				; Palette cycle timer
00000000 =FFFFC7CF                  rPalCycIndex	rs.b	1				; Palette cycle index
00000000                            
00000000                            		; --- LOCAL VARIABLES ---
00000000                            
00000000 =FFFFC7D0                  rGameVars	rs.b	0				; Start of local game variables
00000000                            		rs.b	((-__rs)&$FFFF)-$100		; You have the rest of RAM here for local variables
00000000 =FFFFFF00                  rGameVars_End	rs.b	0				; End of local game variables
00000000                            
00000000                            		; --- STACK SPACE ---
00000000                            
00000000 =FFFFFF00                  rStackSpace	rs.b	$100				; Stack space
00000000 =00000000                  rStackBase	rs.b	0				; ''
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Title screen variables
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset	rGameVars
00000000                            
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Level variables
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		rsset	rGameVars
00000000 =FFFFC7D0                  rBlocks		rs.b	$1800				; Block table
00000000                            
00000000 =FFFFDFD0                  rLayout		rs.b	$1000				; Level layout
00000000                            
00000000 =FFFFEFD0                  rScrlSecs	rs.b	$384				; Scroll sections
00000000 =FFFFF354                  rScrlSecs_End	rs.b	0				; ''
00000000                            
00000000 =FFFFF354                  rColList	rs.b	$80				; Collision response list
00000000 =FFFFF3D4                  rColList_End	rs.b	0				; ''
00000000                            
00000000 =FFFFF3D4                  rRings		rs.w	1				; Ring count
00000000                            
00000000 =FFFFF3D6                  rRingManRout	rs.b	1				; Ring manager routine
00000000 =FFFFF3D7                  rRingFrame	rs.b	1				; Ring animation frame
00000000                            
00000000 =FFFFF3D8                  rRingAniTime	rs.b	1				; Ring animation timer
00000000 =FFFFF3D9                  rRLossAniT	rs.b	1
00000000 =FFFFF3DA                  rRLossAniA	rs.w	1
00000000 =FFFFF3DC                  rRLossAniF	rs.b	1
00000000                            
00000000 =FFFFF3DD                  rBossDefeat	rs.b	1
00000000                            
00000000 =FFFFF3DE                  rRingStat	rs.b	$400				; Ring status table
00000000 =FFFFF7DE                  rRingStat_End	rs.b	0				; ''
00000000                            
00000000 =FFFFF7DE                  rRingCol	rs.b	0				; Ring collection table
00000000 =FFFFF7DE                  rRingColCnt	rs.w	1				; Ring collection count
00000000 =FFFFF7E0                  rRingColList	rs.b	$7E				; Ring collection list
00000000 =FFFFF85E                  rRingCol_End	rs.b	0				; ''
00000000                            
00000000 =FFFFF85E                  rRingPosAddr	rs.l	1				; Ring position data pointer
00000000 =FFFFF862                  rRingLoadL	rs.l	1				; Ring data address for the left side of the screen
00000000 =FFFFF866                  rRingLoadR	rs.l	1				; Ring data address for the right side of the screen
00000000 =FFFFF86A                  rRingStatPtr	rs.w	1				; Ring status address
00000000                            
00000000 =FFFFF86C                  rPlayer1Addr	rs.w	1				; Player 1 object address
00000000 =FFFFF86E                  rShield1Addr	rs.w	1				; Player 1 shield address
00000000 =FFFFF870                  rInvinc1Addr	rs.w	1				; Player 1 invincibility address
00000000 =FFFFF872                  rAftImg1Addr	rs.w	1				; Player 1 after image address
00000000                            
00000000 =FFFFF874                  rPlayer2Addr	rs.w	1				; Player 2 object address
00000000 =FFFFF876                  rShield2Addr	rs.w	1				; Player 2 shield address
00000000 =FFFFF878                  rInvinc2Addr	rs.w	1				; Player 2 invincibility address
00000000 =FFFFF87A                  rAftImg2Addr	rs.w	1				; Player 2 after image address
00000000                            
00000000 =FFFFF87C                  rWater1Addr	rs.w	1				; Water surface 1 address
00000000 =FFFFF87E                  rWater2Addr	rs.w	1				; Water surface 2 address
00000000                            
00000000 =FFFFF880                  rCamera		rs.b	0				; Camera RAM
00000000                            
00000000 =FFFFF880                  rFGCam		rs.b	cSize2				; Foreground variables
00000000 =FFFFF89E                  rBGCam		rs.b	cSize2				; Background variables
00000000                            
00000000 =FFFFF8BC                  rDestMaxCam	rs.b	0				; Target maximum camera positions
00000000 =FFFFF8BC                  rDestMaxX	rs.w	1				; Target maximum camera X position
00000000 =FFFFF8BE                  rDestMaxY	rs.w	1				; Target maximum camera Y position
00000000 =FFFFF8C0                  rMaxCam		rs.b	0				; Maximum camera positions
00000000 =FFFFF8C0                  rMaxCamX	rs.w	1				; Maximum camera X position
00000000 =FFFFF8C2                  rMaxCamY	rs.w	1				; Maximum camera Y position
00000000 =FFFFF8C4                  rDestMinCam	rs.b	0				; Target minimum camera positions
00000000 =FFFFF8C4                  rDestMinX	rs.w	1				; Target minimum camera X position
00000000 =FFFFF8C6                  rDestMinY	rs.w	1				; Target minimum camera Y position
00000000 =FFFFF8C8                  rMinCam		rs.b	0				; Minimum camera positions
00000000 =FFFFF8C8                  rMinCamX	rs.w	1				; Minimum camera X position
00000000 =FFFFF8CA                  rMinCamY	rs.w	1				; Minimum camera Y position
00000000 =FFFFF8CC                  rCamYPosDist	rs.w	1				; Distance from the player's Y position and the camera's
00000000 =FFFFF8CE                  rCamLocked	rs.b	0				; Camera locked flags
00000000 =FFFFF8CE                  rCamLockX	rs.b	1				; Camera locked horizontally flag
00000000 =FFFFF8CF                  rCamLockY	rs.b	1				; Camera locked vertically flag
00000000 =FFFFF8D0                  rCamMaxChg	rs.b	1				; Camera max Y position changing flag
00000000                            
00000000 =FFFFF8D1                  rCamera_End	rs.b	0				; End of camera RAM
00000000                            
00000000 =FFFFF8D1                  rDebugMode	rs.b	1				; Debug placement mode
00000000                            
00000000 =FFFFF8D2                  rCamXPosCenter	rs.w	1				; Camera X center
00000000                            
00000000 =FFFFF8D4                  rCtrl		rs.b	0				; Player control data
00000000 =FFFFF8D4                  rCtrlHold	rs.b	1				; Player control held button data
00000000 =FFFFF8D5                  rCtrlPress	rs.b	1				; Player control pressed button data
00000000                            
00000000 =FFFFF8D6                  rLevelMusic	rs.b	1				; Level music ID
00000000 =FFFFF8D7                  rBossMusic	rs.b	1				; Boss music ID
00000000                            
00000000 =FFFFF8D8                  r1stCol		rs.l	1				; Primary level collision data pointer
00000000 =FFFFF8DC                  r2ndCol		rs.l	1				; Secondary level collision data pointer
00000000                            
00000000 =FFFFF8E0                  rColAddr	rs.l	1				; Current collsion address
00000000                            
00000000 =FFFFF8E4                  rLayerPos	rs.w	1				; Fake layer position
00000000                            
00000000 =FFFFF8E6                  rAngleVals	rs.l	1				; Angle value array pointer
00000000 =FFFFF8EA                  rColArrayN	rs.l	1				; Normal height map array pointer
00000000 =FFFFF8EE                  rColArrayR	rs.l	1				; Rotated height map array pointer
00000000                            
00000000 =FFFFF8F2                  rNextLevel	rs.b	1				; Flag to go to the next level
00000000                            
00000000 =FFFFF8F3                  rUpdateRings	rs.b	1				; Update Ring counter in the HUD flag
00000000                            
00000000 =FFFFF8F4                  rWaterFlag	rs.b	1				; Water in level flag
00000000 =FFFFF8F5                  rWaterFullscr	rs.b	1				; Water fullscreen flag
00000000 =FFFFF8F6                  rWaterLvl	rs.w	1				; Water height
00000000 =FFFFF8F8                  rDestWtrLvl	rs.w	1				; Target water height
00000000                            
00000000 =FFFFF8FA                  rLvlFrames	rs.w	1				; Level frame counter
00000000 =FFFFF8FC                  rLvlReload	rs.b	1				; Level reload flag
00000000 =FFFFF8FD                  rTimeOver	rs.b	1				; Time over flag
00000000                            
00000000 =FFFFF8FE                  rDynEvRout	rs.b	1				; Dynamic event routine ID
00000000                            
00000000 =FFFFF8FF                  rFloorActive	rs.b	1				; Floor active flag
00000000 =FFFFF900                  rFloorTimer	rs.w	1				; Floor timer
00000000                            
00000000 =FFFFF902                  rAnimCnts	rs.b	$10				; Level art animation counters
00000000                            
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Camera variables
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =FFFFF880                  rCamXPos		equ	rFGCam+cXPos			; Camera X position
00000000 =FFFFF888                  rCamYPos		equ	rFGCam+cYPos			; Camera Y position
00000000 =FFFFF89E                  rCamBGXPos		equ	rBGCam+cXPos			; Background camera X position
00000000 =FFFFF8A6                  rCamBGYPos		equ	rBGCam+cYPos			; Background camera Y position
00000000 =FFFFF89C                  rFGRedraw	equ	rFGCam+cRedraw		; Foreground redraw flag
00000000 =FFFFF8BA                  rBGRedraw	equ	rBGCam+cRedraw		; Background redraw flag
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Variables for the vector table
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 =FFFFC74A                  vInterrupt	equ	rVIntJmp			; V-INT
00000000 =FFFFC750                  hInterrupt	equ	rHIntJmp			; H-INT
00000000                            ; =========================================================================================================================================================
00000000                            
00000000                            		include	"Config/Error/debugger.asm"	; Debugger macro set
00000000                            ; ===============================================================
00000000                            ; ---------------------------------------------------------------
00000000                            ; Error handling and debugging modules
00000000                            ; 2016-2017, Vladikcomper
00000000                            ; ---------------------------------------------------------------
00000000                            ; Debugging macros definitions file
00000000                            ; ---------------------------------------------------------------
00000000                            
00000000 =00000001                  isAMPS =		1		; Set to 1
00000000                            ; ===============================================================
00000000                            ; ---------------------------------------------------------------
00000000                            ; Constants
00000000                            ; ---------------------------------------------------------------
00000000                            
00000000                            ; ----------------------------
00000000                            ; Arguments formatting flags
00000000                            ; ----------------------------
00000000                            
00000000                            ; General arguments format flags
00000000 =00000080                  hex		equ		$80				; flag to display as hexadecimal number
00000000 =00000090                  dem		equ		$90				; flag to display as decimal number
00000000 =000000A0                  bin		equ		$A0				; flag to display as binary number
00000000 =000000B0                  sym		equ		$B0				; flag to display as symbol (treat as offset, decode into symbol +displacement, if present)
00000000 =000000C0                  fsymdisp	equ		$C0				; flag to display as symbol's displacement alone (DO NOT USE, unless complex formatting is required, see notes below)
00000000 =000000DF                  fstr		equ		$DF				; flag to display as string (treat as offset, insert string from that offset)
00000000 =000000D0                  fasm		equ		$D0				; flag to display as code (treat as offset, decode from that offset)
00000000                            
00000000                            ; NOTES:
00000000                            ;	* By default, the "sym" flag displays both symbol and displacement (e.g.: "Map_Sonic+$2E")
00000000                            ;		In case, you need a different formatting for the displacement part (different text color and such),
00000000                            ;		use "sym|split", so the displacement won't be displayed until symdisp is met
00000000                            ;	* The "symdisp" can only be used after the "sym|split" instance, which decodes offset, otherwise, it'll
00000000                            ;		display a garbage offset.
00000000                            ;	* No other argument format flags (hex, dec, bin, str) are allowed between "sym|split" and "symdisp",
00000000                            ;		otherwise, the "symdisp" results are undefined.
00000000                            ;	* When using "str" flag, the argument should point to string offset that will be inserted.
00000000                            ;		Arguments format flags CAN NOT be used in the string (as no arguments are meant to be here),
00000000                            ;		only console control flags (see below).
00000000                            ;	* The "asm" flag will use "setpat" flag to switch text color, and will reset pattern to normal again.
00000000                            ;		you must reapply any pattern you used before yourself.
00000000                            ;	* The "asm" flag will overwrite $FF0000-$FF0080, so be careful when viewing RAM.
00000000                            
00000000                            
00000000                            ; Additional flags ...
00000000                            ; ... for number formatters (hex, dec, bin)
00000000 =00000008                  signed	equ		8				; treat number as signed (display + or - before the number depending on sign)
00000000                            
00000000                            ; ... for symbol formatter (sym)
00000000 =00000008                  fsplit	equ		8				; DO NOT write displacement (if present), skip and wait for "symdisp" flag to write it later (optional)
00000000 =00000004                  forced	equ		4				; display "<unknown>" if symbol was not found, otherwise, plain offset is displayed by the displacement formatter
00000000                            
00000000                            ; ... for symbol displacement formatter (symdisp)
00000000 =00000008                  weak	equ		8				; DO NOT write plain offset if symbol is displayed as "<unknown>"
00000000                            
00000000                            ; Argument type flags:
00000000                            ; - DO NOT USE in formatted strings processed by macros, as these are included automatically
00000000                            ; - ONLY USE when writting down strings manually with DC.B
00000000 =00000000                  byte	equ		0
00000000 =00000001                  word	equ		1
00000000 =00000003                  long	equ		3
00000000                            
00000000                            ; -----------------------
00000000                            ; Console control flags
00000000                            ; -----------------------
00000000                            
00000000                            ; Plain control flags: no arguments following
00000000 =000000E0                  fendl	equ		$E0				; "End of line": flag for line break
00000000 =000000E6                  cr	equ		$E6				; "Carriage return": jump to the beginning of the line
00000000 =000000E8                  fpal0	equ		$E8				; use palette line #0
00000000 =000000EA                  fpal1	equ		$EA				; use palette line #1
00000000 =000000EC                  fpal2	equ		$EC				; use palette line #2
00000000 =000000EE                  fpal3	equ		$EE				; use palette line #3
00000000                            
00000000                            ; Parametrized control flags: followed by 1-byte argument
00000000 =000000F0                  setw	equ		$F0				; set line width: number of characters before automatic line break
00000000 =000000F4                  setoff	equ		$F4				; set tile offset: lower byte of base pattern, which points to tile index of ASCII character 00
00000000 =000000F8                  setpat	equ		$F8				; set tile pattern: high byte of base pattern, which determines palette flags and $100-tile section id
00000000 =000000FA                  setx	equ		$FA				; set x-position
00000000                            ; ---------------------------------------------------------------
00000000                            ; Macros
00000000                            ; ---------------------------------------------------------------
00000000                            
00000000                            RaiseError &
00000000                            	pea		*(pc)
00000000                            	RaiseError2 \_
00000000                            	endm
00000000                            
00000000                            RaiseError2 &
00000000                            	move.w	sr, -(sp)
00000000                            	__FSTRING_GenerateArgumentsCode \string
00000000                            	jsr		ErrorHandler
00000000                            	__FSTRING_GenerateDecodedString \string
00000000                            	if strlen("\console_program")			; if console program offset is specified ...
00000000                            		dc.b	\opts+_eh_enter_console|(((*&1)^1)*_eh_align_offset)	; add flag "_eh_align_offset" if the next byte is at odd offset ...
00000000                            		even															; ... to tell Error handler to skip this byte, so it'll jump to ...
00000000                            		jmp		\console_program										; ... an aligned "jmp" instruction that calls console program itself
00000000                            	else
00000000                            		dc.b	\opts+0						; otherwise, just specify \opts for error handler, +0 will generate dc.b 0 ...
00000000                            		even								; ... in case \opts argument is empty or skipped
00000000                            	endc
00000000                            	even
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------
00000000                            Console &
00000000                            	if strcmp("\0","write")|strcmp("\0","writeline")
00000000                            		move.w	sr, -(sp)
00000000                            		__FSTRING_GenerateArgumentsCode \1
00000000                            		movem.l	a0-a2/d7, -(sp)
00000000                            		if (__sp>0)
00000000                            			lea	4*4(sp), a2
00000000                            		endc
00000000                            		lea	.str\@(pc), a1
00000000                            		jsr	ErrorHandler.__global__console_\0\_formatted
00000000                            		movem.l	(sp)+, a0-a2/d7
00000000                            		if (__sp>8)
00000000                            			lea	__sp(sp), sp
00000000                            		elseif (__sp>0)
00000000                            			addq.w	#__sp, sp
00000000                            		endc
00000000                            		move.w	(sp)+, sr
00000000                            		bra.w	.instr_end\@
00000000                            	.str\@:
00000000                            		__FSTRING_GenerateDecodedString \1
00000000                            		even
00000000                            	.instr_end\@:
00000000                            	elseif strcmp("\0","run")
00000000                            		jsr	ErrorHandler.__extern__console_only
00000000                            		jsr	\1
00000000                            		if narg<=1		; HACK
00000000                            			bra.s	*
00000000                            		endif
00000000                            	elseif strcmp("\0","setxy")
00000000                            		move.w	sr, -(sp)
00000000                            		movem.l	d0-d1, -(sp)
00000000                            		move.w	\2, -(sp)
00000000                            		move.w	\1, -(sp)
00000000                            		jsr	ErrorHandler.__global__console_setposasxy_stack
00000000                            		addq.w	#4, sp
00000000                            		movem.l	(sp)+, d0-d1
00000000                            		move.w	(sp)+, sr
00000000                            	elseif strcmp("\0","breakline")
00000000                            		move.w	sr, -(sp)
00000000                            		jsr	ErrorHandler.__global__console_startnewline
00000000                            		move.w	(sp)+, sr
00000000                            	else
00000000                            		inform	2,"""\0"" isn't a member of ""Console"""
00000000                            	endc
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------
00000000                            __ErrorMessage &
00000000                            		__FSTRING_GenerateArgumentsCode \string
00000000                            		jsr	ErrorHandler
00000000                            		__FSTRING_GenerateDecodedString \string
00000000                            		dc.b	\opts+0
00000000                            		even
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------
00000000                            __FSTRING_GenerateArgumentsCode &
00000000                            	__pos:	set 	instr(\string,'%<')		; token position
00000000                            	__stack:set		0						; size of actual stack
00000000                            	__sp:	set		0						; stack displacement
00000000                            	; Parse string itself
00000000                            	while (__pos)
00000000                            		; Retrive expression in brackets following % char
00000000                                	__endpos:	set		instr(__pos+1,\string,'>')
00000000                                	__midpos:	set		instr(__pos+5,\string,' ')
00000000                                	if (__midpos<1)|(__midpos>__endpos)
00000000                            			__midpos: = __endpos
00000000                                	endc
00000000                            		__substr:	substr	__pos+1+1,__endpos-1,\string			; .type ea param
00000000                            		__type:		substr	__pos+1+1,__pos+1+1+1,\string			; .type
00000000                            		; Expression is an effective address (e.g. %(.w d0 hex) )
00000000                            		if "\__type">>8="."
00000000                            			__operand:	substr	__pos+1+1,__midpos-1,\string			; .type ea
00000000                            			__param:	substr	__midpos+1,__endpos-1,\string			; param
00000000                            			if "\__type"=".b"
00000000                            				pushp	"move\__operand\,1(sp)"
00000000                            				pushp	"subq.w	#2, sp"
00000000                            				__stack: = __stack+2
00000000                            				__sp: = __sp+2
00000000                            			elseif "\__type"=".w"
00000000                            				pushp	"move\__operand\,-(sp)"
00000000                            				__stack: = __stack+1
00000000                            				__sp: = __sp+2
00000000                            			elseif "\__type"=".l"
00000000                            				pushp	"move\__operand\,-(sp)"
00000000                            				__stack: = __stack+1
00000000                            				__sp: = __sp+4
00000000                            			else
00000000                            				fatal 'Unrecognized type in string operand: %<\__substr>'
00000000                            			endc
00000000                            		endc
00000000                            		__pos:	set		instr(__pos+1,\string,'%<')
00000000                            	endw
00000000                            	; Generate stack code
00000000                            	rept __stack
00000000                            		popp	__command
00000000                            		\__command
00000000                            	endr
00000000                            	endm
00000000                            
00000000                            ; ---------------------------------------------------------------
00000000                            __FSTRING_GenerateDecodedString &
00000000                            	__lpos:	set		1						; start position
00000000                            	__pos:	set 	instr(\string,'%<')		; token position
00000000                            	while (__pos)
00000000                            		; Write part of string before % token
00000000                            		__substr:	substr	__lpos,__pos-1,\string
00000000                            		dc.b	"\__substr"
00000000                            		; Retrive expression in brakets following % char
00000000                                	__endpos:	set		instr(__pos+1,\string,'>')
00000000                                	__midpos:	set		instr(__pos+5,\string,' ')
00000000                                	if (__midpos<1)|(__midpos>__endpos)
00000000                            			__midpos: = __endpos
00000000                                	endc
00000000                            		__type:		substr	__pos+1+1,__pos+1+1+1,\string			; .type
00000000                            		; Expression is an effective address (e.g. %<.w d0 hex> )
00000000                            		if "\__type">>8="."
00000000                            			__param:	substr	__midpos+1,__endpos-1,\string			; param
00000000                            			if strlen("\__param")<1
00000000                            				__param: substr ,,"hex"			; if param is ommited, set it to "hex"
00000000                            			endc
00000000                            			if "\__type"=".b"
00000000                            				dc.b	\__param
00000000                            			elseif "\__type"=".w"
00000000                            				dc.b	\__param|1
00000000                            			else
00000000                            				dc.b	\__param|3
00000000                            			endc
00000000                            		; Expression is an inline constant (e.g. %<endl> )
00000000                            		else
00000000                            			__substr:	substr	__pos+1+1,__endpos-1,\string
00000000                            			dc.b	\__substr
00000000                            		endc
00000000                            		__lpos:	set		__endpos+1
00000000                            		__pos:	set		instr(__pos+1,\string,'%<')
00000000                            	endw
00000000                            	; Write part of string before the end
00000000                            	__substr:	substr	__lpos,,\string
00000000                            	dc.b	"\__substr"
00000000                            	dc.b	0
00000000                            	endm
00000000                            		
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Header
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		include	"Config/Header.asm"
00000000                            ; =========================================================================================================================================================
00000000                            ; MegaDrive Header
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Based on MarkeyJester's shortened header and initialization
00000000                            ; =========================================================================================================================================================
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Store a string in memory with a character limit (also pads to that limit if it doesn't exceed it)
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; PARAMETERS:
00000000                            ;	string	- The string
00000000                            ;	limit	- Character limit
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; RETURNS:
00000000                            ;	Nothing
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            headStr		macro	string, limit
00000000                            		local	p
00000000                            p =		*
00000000                            		dcb.b	\limit, " "
00000000                            		org	p
00000000                            		dc.b	\string
00000000                            		org	p+\limit
00000000                            		endm
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            		org	0
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000                            ; Vector table
00000000                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000000 F0A1 000C                  		dc.l	($F0<<24)|PORT_C_CTRL-1		; Stack pointer (set like so for initialization routine) (also manufacture lineF exception)
00000004                            
00000004 0000 0000                  		dc.l	.PrgInit			; Entry pointer
00000008                            
00000008 0000 0000                  		dc.l	exBus				; Bus error
0000000C 0000 0000                  		dc.l	exAddr				; Address error
00000010 0000 0000                  		dc.l	exIll				; Illegal instruction error
00000014 0000 0000                  		dc.l	exDiv				; Division by zero error
00000018 0000 0000                  		dc.l	exChk				; CHK out of bounds error
0000001C 0000 0000                  		dc.l	Trapv				; TRAPV interrupt
00000020 0000 0000                  		dc.l	exPriv				; Privilege violation error
00000024 0000 0000                  		dc.l	exTrace				; TRACE interrupt
00000028 0000 0000                  		dc.l	exLineA				; Line A emulation
0000002C 0000 0000                  		dc.l	exLineF				; Line F emulation
00000030                            
00000030 0017                       .InitVals:	dc.w	$18-1				; Number of registers to set up
00000032 8004                       		dc.w	$8004				; VDP register base (preset for register 0 - H-INT disabled)
00000034 0100                       		dc.w	$100				; Register increment (also used for Z80 later)
00000036                            
00000036 34                         		dc.b	$34				; DMA enabled, V-INT enabled
00000037 30                         		dc.b	$C000/$400			; Plane A at $C000
00000038 34                         		dc.b	$D000/$400			; Plane W at $D000
00000039 07                         		dc.b	$E000/$2000			; Plane B at $E000
0000003A 7C                         		dc.b	$F800/$200			; Sprite table at $F800
0000003B 00                         		dc.b	$00				; Unused
0000003C 00                         		dc.b	$00				; BG color line 0 entry 0
0000003D 00                         		dc.b	$00				; Unused
0000003E 00                         		dc.b	$00				; Unused
0000003F FF                         		dc.b	$FF				; H-INT every 255th line
00000040 00                         		dc.b	$00				; EXT-INT off, VScroll by screen, HScroll by screen
00000041 81                         		dc.b	$81				; H40 width, interalce disabled, S/H disabled
00000042 3F                         		dc.b	$FC00/$400			; HScroll table at $FC00
00000043 00                         		dc.b	$00				; Unused
00000044 02                         		dc.b	$02				; Autoincrement by 2
00000045 01                         		dc.b	$01				; Plane size 64x32
00000046 00                         		dc.b	$00				; Disable window
00000047 00                         		dc.b	$00				; ''
00000048 FF                         		dc.b	$FF				; DMA length $FFFF
00000049 FF                         		dc.b	$FF				; ''
0000004A 00                         		dc.b	$00				; DMA source 0
0000004B 00                         		dc.b	$00				; ''
0000004C 80                         		dc.b	$80				; '' + VRAM fill mode
0000004D                            
0000004D 40                         		dc.b	$40				; Port initialization value
0000004E                            
0000004E                            		vdpCmd	dc.l,0,VRAM,DMA			; VDP DMA at $0000
0000004E 4000 0080                M 	dc.l	((((vram&dma)&3)<<30)|((0&$3fff)<<16)|(((vram&dma)&$fc)<<2)|((0&$c000)>>14))
00000052                            
00000052 000E 1FFD                  		dc.w	$E, $2000-2-1			; Checksum error color, amount of Z80 to clear
00000056 00A0 0000                  		dc.l	Z80_RAM				; Z80 RAM
0000005A 00A1 1100                  		dc.l	Z80_BUS_REQ			; Z80 bus request
0000005E 00A1 1200                  		dc.l	Z80_RESET			; Z80 reset
00000062                            
00000062                            		vdpCmd	dc.l,0,CRAM,WRITE		; CRAM WRITE at $0000
00000062 C000 0000                M 	dc.l	((((cram&write)&3)<<30)|((0&$3fff)<<16)|(((cram&write)&$fc)<<2)|((0&$c000)>>14))
00000066                            		vdpCmd	dc.l,0,VSRAM,WRITE		; VSRAM WRITE at $0000
00000066 4000 0010                M 	dc.l	((((vsram&write)&3)<<30)|((0&$3fff)<<16)|(((vsram&write)&$fc)<<2)|((0&$c000)>>14))
0000006A                            
0000006A 9FBF DFFF                  		dc.b	$9F, $BF, $DF, $FF		; PSG mute values
0000006E                            
0000006E F3C3                       		dc.b	$F3, $C3			; di and jp instructions for Z80
00000070                            
00000070 FFFF C750                  		dc.l	hInterrupt			; Horizontal interrupt
00000074 00C0 0000                  .VDPDPort:	dc.l	VDP_DATA			; Interrupt level 5
00000078 FFFF C74A                  		dc.l	vInterrupt			; Vertical interrupt
0000007C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000007C                            ; Program initialization
0000007C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000007C                            ICD_BLK		EQU	.PrgInit
0000007C                            .PrgInit:
0000007C                            		intsOff
0000007C 007C 0700                M 	ori	#$700,sr
00000080                            
00000080                            		; --- CHECK WARM BOOT ---
00000080                            
00000080 4A57                       		tst.w	(sp)				; Has port C been initialized already?
00000082 6600 0000                  		bne.w	.WarmBoot			; If so, branch
00000086                            
00000086 7800                       		moveq	#0,d4				; Register that holds 0
00000088 7C00                       		moveq	#0,d6				; Checksum value
0000008A                            
0000008A                            		; --- CHECK TMSS ---
0000008A                            
0000008A 162F FFF5                  		move.b	-$B(sp),d3			; Get hardware version
0000008E E903                       		asl.b	#4,d3				; ''
00000090 6700                       		beq.s	.NoTMSS				; If this is a non-TMSS system, branch
00000092 2F78 0100 3FF4             		move.l	$100.w,$3FF4(sp)		; Satisfy the TMSS
00000098                            
00000098                            .NoTMSS:
00000098                            
00000098                            		; --- SET UP VDP REGISTERS ---
00000098                            
00000098 2A78 0074                  		movea.l	.VDPDPort.w,a5			; VDP data port
0000009C 4DED 0004                  		lea	4(a5),a6			; VDP control port
000000A0                            
000000A0                            .WaitDMA:
000000A0 44D6                       		move.w	(a6),ccr			; Load status
000000A2 69FC                       		bvs.s	.WaitDMA			; If there's a DMA, wait
000000A4                            
000000A4 41F8 0030                  		lea	.InitVals.w,a0			; VDP registers
000000A8 4C98 0026                  		movem.w	(a0)+,d1/d2/d5			; Get number of entries, register base, and register increment
000000AC                            
000000AC                            .InitVDPRegs:
000000AC 3C82                       		move.w	d2,(a6)				; Set register data
000000AE D445                       		add.w	d5,d2				; Next register
000000B0 1418                       		move.b	(a0)+,d2			; Get register data
000000B2 51C9 FFF8                  		dbf	d1,.InitVDPRegs			; Loop
000000B6                            
000000B6                            		; --- CLEAR VRAM ---
000000B6                            
000000B6 2C98                       		move.l	(a0)+,(a6)			; Set DMA fill destination
000000B8 3C84                       		move.w	d4,(a6)				; Set DMA fill value
000000BA                            
000000BA                            		; --- CLEAR RAM ---
000000BA                            
000000BA 2444                       		movea.l	d4,a2				; End of RAM
000000BC 323C 3FFF                  		move.w	#(RAM_END-RAM_START)>>2-1,d1	; Longwords to clear
000000C0                            
000000C0                            .ClearRAM:
000000C0 2504                       		move.l	d4,-(a2)			; Clear RAM
000000C2 51C9 FFFC                  		dbf	d1,.ClearRAM			; Loop
000000C6                            
000000C6                            		; --- SET UP FOR Z80 ---
000000C6                            
000000C6 4CD8 1A01                  		movem.l	(a0)+,d0/a1/a3/a4		; Load Z80 addresses and values
000000CA 3685                       		move.w	d5,(a3)				; Request Z80 stop
000000CC                            
000000CC                            		; --- CLEAR CRAM AND VSRAM AND INITIALIZE JOYPADS ---
000000CC                            
000000CC 4441                       		neg.w	d1				; Run the next bit 2 times
000000CE                            
000000CE                            .InitVDPJoypads:
000000CE 2C98                       		move.l	(a0)+,(a6)			; Set VDP command
000000D0 761F                       		moveq	#$80>>2-1,d3			; Longwords to clear
000000D2                            
000000D2                            .ClearVDPMem:
000000D2 2A84                       		move.l	d4,(a5)				; Clear memory
000000D4 51CB FFFC                  		dbf	d3,.ClearVDPMem			; Loop
000000D8 3F02                       		move.w	d2,-(sp)			; Initialize port
000000DA 51C9 FFF2                  		dbf	d1,.InitVDPJoypads		; Loop
000000DE                            
000000DE 3885                       		move.w	d5,(a4)				; Cancel Z80 reset
000000E0                            
000000E0                            		; --- MUTE PSG ---
000000E0                            
000000E0 7603                       		moveq	#4-1,d3				; Number of PSG channels
000000E2                            
000000E2                            .MutePSG:
000000E2 1D58 000D                  		move.b	(a0)+,$D(a6)			; Mute channel
000000E6 51CB FFFA                  		dbf	d3,.MutePSG			; Loop
000000EA                            
000000EA                            		; --- INITIALIZE Z80 ---
000000EA                            
000000EA 12D8                       		move.b	(a0)+,(a1)+			; Write di (disable Z80 interrupts)
000000EC 12D8                       		move.b	(a0)+,(a1)+			; Write jp (Will end up just looping forever at the beginning)
000000EE                            
000000EE                            .ClearZ80:
000000EE 12C4                       		move.b	d4,(a1)+			; Clear Z80
000000F0 51C8 FFFC                  		dbf	d0,.ClearZ80			; Loop
000000F4                            
000000F4 3884                       		move.w	d4,(a4)				; Reset the Z80
000000F6                            
000000F6                            		; --- CHECK THE CHECKSUM ---
000000F6                            
000000F6 41F8 0200                  		lea	$200.w,a0			; Start reading data at the end of the header
000000FA 2238 01A4                  		move.l	$1A4.w,d1			; Get ROM end address
000000FE                            
000000FE 6000                       		bra.s	.ChkChecksum			; Continue
00000100                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000100                            ; Header
00000100                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000100 5345 4741                  		dc.b	"SEGA"				; Hardware system ID
00000104                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000104                            ; Program initialization (part 2)
00000104                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000104                            .ChkChecksum:
00000104 DC58                       		add.w	(a0)+,d6			; Add ROM data to the checksum value
00000106 B288                       		cmp.l	a0,d1				; Are we at the end of the ROM?
00000108 64FA                       		bcc.s	.ChkChecksum			; If not, keep adding
0000010A BC78 018E                  		cmp.w	$18E.w,d6			; Is the checksum correct?
0000010E 6700                       		beq.s	.ChksumPassed			; If not, branch
00000110                            
00000110                            .ChksumError:
00000110                            		vdpCmd	move.l,0,CRAM,WRITE,(a6)	; Set background to red
00000110 2CBC C000 0000           M 	move.l	#((((cram&write)&3)<<30)|((0&$3fff)<<16)|(((cram&write)&$fc)<<2)|((0&$c000)>>14)),(a6)
00000116 2A80                       		move.l	d0,(a5)				; ''
00000118 60F6                       		bra.s	.ChksumError			; Loop here forever
0000011A                            
0000011A                            .ChksumPassed:
0000011A 3885                       		move.w	d5,(a4)				; Cancel Z80 reset
0000011C 3684                       		move.w	d4,(a3)				; Start the Z80
0000011E                            
0000011E                            		; --- FINISH I/O INITIALIZATION ---
0000011E                            
0000011E 3F42 0004                  		move.w	d2,4(sp)			; Initialize port C
00000122                            
00000122                            .WarmBoot:
00000122 4FF8 0000                  		lea	rStackBase.w,sp		; Set the stack pointer
00000126 4CD4 7FFF                  		movem.l	(a4),d0-a6			; Clear registers
0000012A                            
0000012A 4EF9 0000 0000             		jmp	GameInit			; Go to the game initialization
00000130                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000130                            ; Header (part 2)
00000130                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000130                            		headStr	"\NOTES", $20			; Notes
00000130                          M 	local	p
00000130 =00000130                M p	=	*
00000130 2020 2020 2020 2020 2020+M 	dcb.b	$20," "
00000150                          M 	org	p
00000130                          M 	dc.b	""
00000130                          M 	org	p+$20
00000150                            		headStr	"\GAME_NAME", $30		; International game name
00000150                          M 	local	p
00000150 =00000150                M p	=	*
00000150 2020 2020 2020 2020 2020+M 	dcb.b	$30," "
00000180                          M 	org	p
00000150 4865 6467 6562 7265 7720+M 	dc.b	"Hedgebrew Engine Project                        "
00000180                          M 	org	p+$30
00000180 474D 2030 3030 3030 3030+  		dc.b	"GM 00000000-00"		; Version
0000018E 0000                       		dc.w	0				; Checksum value (replaced by external program)
00000190                            		headStr	"\IO_SUPPORT", $10		; I/O support
00000190                          M 	local	p
00000190 =00000190                M p	=	*
00000190 2020 2020 2020 2020 2020+M 	dcb.b	$10," "
000001A0                          M 	org	p
00000190 4A                       M 	dc.b	"J"
00000191                          M 	org	p+$10
000001A0 0000 0000 003F FFFF        		dc.l	ROM_START, ROM_END-1		; ROM start and end addresses (replaced by external program)
000001A8 00FF 0000 00FF FFFF        		dc.l	RAM_START, RAM_END-1		; RAM start and end addresses
000001B0 2020 2020                  		dc.l	SRAM_SUPPORT			; SRAM support
000001B4 2020 2020 2020 2020        		dc.l	SRAM_START, SRAM_END		; SRAM start and end addresses
000001BC                            ; =========================================================================================================================================================
000001BC                            
000001BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000001BC                            ; Entry point
000001BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000001BC                            GameInit:
000001BC                            		intsOff						; Disable interrupts
000001BC 007C 0700                M 	ori	#$700,sr
000001C0                            		
000001C0                            		clrRAM	RAM_START, RAM_END			; Clear RAM
000001C0                          M 	local	endaddr
000001C0                          M endaddr	equs	"ram_end"
000001C0 7000                     M 	moveq	#0,d0
000001C2 43F9 00FF 0000           M 	lea	ram_start,a1
000001C8 323C 3FFF                M 	move.w	#(((ram_end)-(ram_start))-((ram_start)&1))>>2-1,d1
000001CC 22C0                     M .clear_22:	move.l	d0,(a1)+
000001CE 51C9 FFFC                M 	dbf	d1,.clear_22
000001D2                            		
000001D2 6100 0000                  		bsr.w	InitDMAQueue				; Initialize the DMA queue
000001D6 6100 0000                  		bsr.w	InitVDP					; Initialize the VDP
000001DA 4EB9 0000 0000             		jsr	LoadDualPCM				; Load Dual PCM
000001E0                            		
000001E0 1039 00A1 0001             		move.b	HW_VERSION,d0				; Get hardware version
000001E6 0200 00C0                  		andi.b	#$C0,d0					; Just get region bits
000001EA 11C0 C744                  		move.b	d0,rHWVersion.w				; Store in RAM
000001EE                            
000001EE 303C 4EF9                  		move.w	#$4EF9,d0				; JMP opcode
000001F2 31C0 C74A                  		move.w	d0,rVIntJmp.w				; Set the "JMP" command for V-INT
000001F6 31C0 C750                  		move.w	d0,rHIntJmp.w				; Set the "JMP" command for H-INT
000001FA 21FC 0000 0000 C74C        		move.l	#VInt_Standard,rVIntAddr.w		; Set the V-INT pointer to the standard V-INT routine
00000202 21FC 0000 0000 C752        		move.l	#HInt_Water,rHIntAddr.w			; Set the H-INT pointer to the standard V-INT routine
0000020A                            
0000020A 4278 9000                  		clr.w	rDMAQueue.w				; Set stop token at the beginning of the DMA queue
0000020E 31FC 9000 90FC             		move.w	#rDMAQueue,rDMASlot.w			; Reset the DMA queue slot
00000214                            
00000214 11FC 0004 C75A             		move.b	#gLevel,rGameMode.w			; Set game mode to "title"
0000021A 4EF9 0000 0000             		jmp	Level					; Go to the title screen
00000220                            
00000220                            ; =========================================================================================================================================================
00000220                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000220                            ; Go to the correct game mode
00000220                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000220                            GotoGameMode:
00000220 7000                       		moveq	#0,d0
00000222 1038 C75A                  		move.b	rGameMode.w,d0				; Get game mode ID
00000226 207B 0000                  		movea.l	.GameModes(pc,d0.w),a0			; Get pointer
0000022A 4ED0                       		jmp	(a0)					; Jump to it
0000022C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000022C                            .GameModes:
0000022C 0000 0000                  		dc.l	TitleScreen				; Title screen
00000230 0000 0000                  		dc.l	Level					; Level mode
00000234 0000 0000                  		dc.l	Ending					; Ending
00000238                            
00000238                            ; =========================================================================================================================================================
00000238                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000238                            ; Function libraries
00000238                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000238                            		include	"Libraries/VDP.asm"		; VDP functions
00000238                            ; =========================================================================================================================================================
00000238                            ; VDP functions
00000238                            ; =========================================================================================================================================================
00000238                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000238                            ; Initialize the VDP
00000238                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000238                            ; PARAMETERS:
00000238                            ;	Nothing
00000238                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000238                            ; RETURNS:
00000238                            ;	Nothing
00000238                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000238                            InitVDP:
00000238 31FC 8134 C764             		move.w	#$8134,rVDPReg1.w		; Save VDP register 1 in RAM
0000023E 31FC 8AFF C75E             		move.w	#$8AFF,rHIntReg.w		; Save H-INT counter register in RAM
00000244                            
00000244 6000 0000                  		bra.w	InitSpriteTable			; Initialize the sprite table
00000248                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000248                            ; Clear the screen and other VDP data (64 tile width)
00000248                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000248                            ; PARAMETERS:
00000248                            ;	Nothing
00000248                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000248                            ; RETURNS:
00000248                            ;	Nothing
00000248                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000248                            ClearScreen:
00000248 4DF9 00C0 0004             		lea	VDP_CTRL,a6			; VDP control port
0000024E                            		dmaFill	0,$C000,$3000			; Clear planes
0000024E 3CBC 8F01                M 	move.w	#$8f01,(a6)
00000252 2CBC 942F 93FF           M 	move.l	#$94009300|(((($3000)-1)&$ff00)<<8)|((($3000)-1)&$ff),(a6)
00000258 3CBC 9780                M 	move.w	#$9780,(a6)
0000025C 2CBC 4000 0083           M 	move.l	#$40000080|((($c000)&$3fff)<<16)|((($c000)&$c000)>>14),(a6)
00000262 3D7C 0000 FFFC           M 	move.w	#(0)<<8,-4(a6)
00000268                          M 	waitdma	(a6)
00000268                          M .wait_24:
00000268 3216                     M 	move.w	(a6),d1
0000026A 0801 0001                M 	btst	#1,d1
0000026E 66F8                     M 	bne.s	.wait_24
00000270 3CBC 8F02                M 	move.w	#$8f02,(a6)
00000274                            
00000274                            		clrRAM	rHScroll, rVScroll_End	; Clear scroll tables
00000274                          M 	local	endaddr
00000274                          M endaddr	equs	"rvscroll_end"
00000274 7000                     M 	moveq	#0,d0
00000276 43F8 90FE                M 	lea	(rhscroll).w,a1
0000027A 323C 00F3                M 	move.w	#(((rvscroll_end)-(rhscroll))-((rhscroll)&1))>>2-1,d1
0000027E 22C0                     M .clear_25:	move.l	d0,(a1)+
00000280 51C9 FFFC                M 	dbf	d1,.clear_25
00000284                            		
00000284 6000 0000                  		bra.w	InitSpriteTable			; Initialize the sprite table
00000288                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000288                            ; Load a plane map
00000288                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000288                            ; PARAMETERS:
00000288                            ;	d0.l	- VDP command for writing the data to VRAM
00000288                            ;	d1.w	- Width in tiles (minus 1)
00000288                            ;	d2.w	- Height in tiles (minus 1)
00000288                            ;	d3.w	- Base tile properties for each tile
00000288                            ;	d6.l	- Delta value for drawing to the next row (only required for just LoadPlaneMap_Custom)
00000288                            ;	a1.l	- Plane map address
00000288                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000288                            ; RETURNS:
00000288                            ;	Nothing
00000288                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000288                            LoadPlaneMap:
00000288                            LoadPlaneMap_H64:
00000288 2C3C 0080 0000             		move.l	#$800000,d6			; For planes with 64 tile width
0000028E 6000                       		bra.s	LoadPlaneMap_Custom		; Load the map
00000290                            
00000290                            LoadPlaneMap_H32:
00000290 2C3C 0040 0000             		move.l	#$400000,d6			; For planes with 32 tile width
00000296 6000                       		bra.s	LoadPlaneMap_Custom		; Load the map
00000298                            
00000298                            LoadPlaneMap_H128:
00000298 2C3C 0100 0000             		move.l	#$1000000,d6			; For planes with 128 tile width
0000029E                            
0000029E                            LoadPlaneMap_Custom:
0000029E                            .RowLoop:
0000029E 23C0 00C0 0004             		move.l	d0,VDP_CTRL			; Set VDP command
000002A4 3801                       		move.w	d1,d4				; Store width
000002A6                            
000002A6                            .TileLoop:
000002A6 3A19                       		move.w	(a1)+,d5			; Get tile ID and properties
000002A8 DA43                       		add.w	d3,d5				; Add base tile properties
000002AA 33C5 00C0 0000             		move.w	d5,VDP_DATA			; Save in VRAM
000002B0 51CC FFF4                  		dbf	d4,.TileLoop			; Loop until the row has been drawn
000002B4 D086                       		add.l	d6,d0				; Next row
000002B6 51CA FFE6                  		dbf	d2,.RowLoop			; Loop until the plane has been drawn
000002BA 4E75                       		rts
000002BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000002BC                            ; Load a plane map into RAM
000002BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000002BC                            ; PARAMETERS:
000002BC                            ;	d1.w	- Width in tiles (minus 1)
000002BC                            ;	d2.w	- Height in tiles (minus 1)
000002BC                            ;	d3.w	- Base tile properties for each tile
000002BC                            ;	d6.l	- Delta value for drawing to the next row (only required for just LoadPlaneMap_Custom)
000002BC                            ;	a0.l	- Buffer to load into
000002BC                            ;	a1.l	- Plane map address
000002BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000002BC                            ; RETURNS:
000002BC                            ;	Nothing
000002BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000002BC                            LoadPlaneMap_RAM:
000002BC                            .RowLoop:
000002BC 2448                       		movea.l	a0,a2				; Copy buffer address
000002BE 3801                       		move.w	d1,d4				; Store width
000002C0                            
000002C0                            .TileLoop:
000002C0 3A19                       		move.w	(a1)+,d5			; Get tile ID and properties
000002C2 DA43                       		add.w	d3,d5				; Add base tile properties
000002C4 34C5                       		move.w	d5,(a2)+			; Save in RAM
000002C6 51CC FFF8                  		dbf	d4,.TileLoop			; Loop until the row has been drawn
000002CA D0FC 0080                  		adda.w	#$80,a0				; Next row
000002CE 51CA FFEC                  		dbf	d2,.RowLoop			; Loop until the plane has been drawn
000002D2 4E75                       		rts
000002D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000002D4                            ; Fill the plane map with a value in a specific region
000002D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000002D4                            ; PARAMETERS:
000002D4                            ;	d0.l	- VDP command for writing the data to VRAM
000002D4                            ;	d1.w	- Width in tiles (minus 1)
000002D4                            ;	d2.w	- Height in tiles (minus 1)
000002D4                            ;	d3.w	- Value to fill plane map with
000002D4                            ;	d6.l	- Delta value for drawing to the next row
000002D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000002D4                            ; RETURNS:
000002D4                            ;	Nothing
000002D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000002D4                            FillPlaneMap:
000002D4                            FillPlaneMap_H64:
000002D4 2C3C 0080 0000             		move.l	#$800000,d6			; For planes with 64 tile width
000002DA 6000                       		bra.s	FillPlaneMap_Custom		; Fill the map
000002DC                            
000002DC                            FillPlaneMap_H32:
000002DC 2C3C 0040 0000             		move.l	#$400000,d6			; For planes with 32 tile width
000002E2 6000                       		bra.s	FillPlaneMap_Custom		; Fill the map
000002E4                            
000002E4                            FillPlaneMap_H128:
000002E4 2C3C 0100 0000             		move.l	#$1000000,d6			; For planes with 128 tile width
000002EA                            
000002EA                            FillPlaneMap_Custom:
000002EA                            .RowLoop:
000002EA 23C0 00C0 0004             		move.l	d0,VDP_CTRL			; Set VDP command
000002F0 3801                       		move.w	d1,d4				; Store width
000002F2                            
000002F2                            .TileLoop:
000002F2 33C3 00C0 0000             		move.w	d3,VDP_DATA			; Save value in VRAM
000002F8 51CC FFF8                  		dbf	d4,.TileLoop			; Loop until the row has been drawn
000002FC D086                       		add.l	d6,d0				; Next row
000002FE 51CA FFEA                  		dbf	d2,.RowLoop			; Loop until the plane has been drawn
00000302 4E75                       		rts
00000304                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000304                            ; Queue a VDP DMA command to VRAM, to be issued the next time ProcessDMAQueue is called. Can be called a maximum of 18 times before the queue needs
00000304                            ; to be cleared by issuing the commands (this checks for overflow)
00000304                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000304                            ; PARAMETERS:
00000304                            ; 	d1.l	- Source address
00000304                            ; 	d2.w	- Destination address
00000304                            ; 	d3.w	- Transfer length
00000304                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000304                            ; RETURNS:
00000304                            ;	Nothing
00000304                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000304                            ; This option breaks DMA transfers that crosses a 128kB block into two. It is disabled by default because you can simply align the art in ROM
00000304                            ; and avoid the issue altogether. It is here so that you have a high-performance routine to do the job in situations where you can't align it in ROM.
00000304 =00000001                  Use128kbSafeDMA		= 1
00000304                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000304                            ; Option to mask interrupts while updating the DMA queue. This fixes many race conditions in the DMA funcion, but it costs 46(6/1) cycles. The
00000304                            ; better way to handle these race conditions would be to make unsafe callers (such as S3&K's KosM decoder) prevent these by masking off interrupts
00000304                            ; before calling and then restore interrupts after.
00000304 =00000000                  UseVIntSafeDMA		= 0
00000304                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000304                            ; Option to assume that transfer length is always less than $7FFF. Only makes sense if Use128kbSafeDMA is 1. Moreover, setting this to 1 will
00000304                            ; cause trouble on a 64kB DMA, so make sure you never do one if you set it to 1! Enabling this saves 4(1/0) cycles on the case where a DMA is
00000304                            ; broken in two and both transfers are properly queued, and nothing at all otherwise.
00000304 =00000000                  AssumeMax7FFFXfer	= 0&Use128kbSafeDMA
00000304                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000304                            ; Convenience macros, for increased maintainability of the code.
00000304                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000304                            ; Like vdpComm, but starting from an address contained in a register
00000304 =00000001                  vdpCommReg_defined = 1
00000304                            vdpCommReg	macro	reg, type, rwd, clr
00000304                            		local	cd
00000304                            cd		= \type&\rwd
00000304                            		lsl.l	#2,\reg				; Move high bits into (word-swapped) position, accidentally moving everything else
00000304                            		if ((cd)&3)<>0
00000304                            			addq.w	#((cd)&3),\reg		; Add upper access type bits
00000304                            		endif
00000304                            		ror.w	#2,\reg				; Put upper access type bits into place, also moving all other bits into their correct
00000304                            							; (word-swapped) places
00000304                            		swap	\reg				; Put all bits in proper places
00000304                            		if \clr<>0
00000304                            			andi.w	#3,\reg			; Strip whatever junk was in upper word of reg
00000304                            		endif
00000304                            		if ((cd)&$FC)=$20
00000304                            			tas.b	\reg			; Add in the DMA flag -- tas fails on memory, but works on registers
00000304                            		elseif ((cd)&$FC)<>0
00000304                            			ori.w	#(((cd)&$FC)*4),\reg	; Add in missing access type bits
00000304                            		endif
00000304                            		endm
00000304                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000304                            QueueDMATransfer:
00000304                            
00000304 3278 90FC                  		movea.w	rDMASlot.w,a1
00000308 B2FC 90FC                  		cmpa.w	#rDMASlot,a1
0000030C 6700                       		beq.s	.Done				; Return if there's no more room in the queue
0000030E                            
0000030E E289                       		lsr.l	#1,d1				; Source address is in words for the VDP registers
00000310                            
00000310 3003                       			move.w  d3,d0			; d0 = length of transfer in words
00000312                            			; Compute position of last transferred word. This handles 2 cases:
00000312                            			; (1) zero length DMAs transfer length actually transfer $10000 words
00000312                            			; (2) (source+length)&$FFFF = 0
00000312 5340                       			subq.w  #1,d0
00000314 D041                       			add.w   d1,d0			; d0 = ((src_address >> 1) & $FFFF) + ((xferlen >> 1) - 1)
00000316 6500                       			bcs.s   .DoubleTransfer		; Carry set = ($10000 << 1) = $20000, or new 128kB block
00000318                            
00000318                            		; Store VDP commands for specifying DMA into the queue
00000318 4841                       		swap	d1				; Want the high byte first
0000031A 303C 977F                  		move.w	#$977F,d0			; Command to specify source address & $FE0000, plus bitmask for the given byte
0000031E C001                       		and.b	d1,d0				; Mask in source address & $FE0000, stripping high bit in the process
00000320 32C0                       		move.w	d0,(a1)+			; Store command
00000322 3203                       		move.w	d3,d1				; Put length together with (source address & $01FFFE) >> 1...
00000324 03C9 0001                  		movep.l	d1,1(a1)			; ... and stuff them all into RAM in their proper places (movep for the win)
00000328 43E9 0008                  		lea	8(a1),a1			; Skip past all of these commands
0000032C                            
0000032C                            		vdpCommReg d2,VRAM,DMA,1		; Make DMA destination command
0000032C                          M 	local	cd
0000032C =00000021                M cd	=	vram&dma
0000032C E58A                     M 	lsl.l	#2,d2
0000032E 5242                     M 	addq.w	#((cd)&3),d2
00000330 E45A                     M 	ror.w	#2,d2
00000332 4842                     M 	swap	d2
00000334 0242 0003                M 	andi.w	#3,d2
00000338 4AC2                     M 	tas.b	d2
0000033A 22C2                       		move.l	d2,(a1)+			; Store command
0000033C                            
0000033C 4251                       		clr.w	(a1)				; Put a stop token at the end of the used part of the queue
0000033E 31C9 90FC                  		move.w	a1,rDMASlot.w			; Set the next free slot address, potentially undoing the above clr (this is intentional!)
00000342                            
00000342                            .Done:
00000342 4E75                       		rts
00000344                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000344                            .DoubleTransfer:
00000344                            			; Hand-coded version to break the DMA transfer into two smaller transfers
00000344                            			; that do not cross a 128kB boundary. This is done much faster (at the cost
00000344                            			; of space) than by the method of saving parameters and calling the normal
00000344                            			; DMA function twice, as Sonic3_Complete does.
00000344                            			; d0 is the number of words-1 that got over the end of the 128kB boundary
00000344 5240                       			addq.w	#1,d0			; Make d0 the number of words past the 128kB boundary
00000346 9640                       			sub.w	d0,d3			; First transfer will use only up to the end of the 128kB boundary
00000348                            
00000348                            			; Store VDP commands for specifying DMA into the queue
00000348 4841                       			swap	d1			; Want the high byte first
0000034A                            
0000034A                            			; Sadly, all registers we can spare are in use right now, so we can't use
0000034A                            			; no-cost RAM source safety.
0000034A 0241 007F                  			andi.w	#$7F,d1			; Strip high bit
0000034E 0041 9700                  			ori.w	#$9700,d1		; Command to specify source address & $FE0000
00000352 32C1                       			move.w	d1,(a1)+		; Store command
00000354 5201                       			addq.b	#1,d1			; Advance to next 128kB boundary (**)
00000356 3341 000C                  			move.w	d1,12(a1)		; Store it now (safe to do in all cases, as we will overwrite later if queue got filled) (**)
0000035A 3203                       			move.w	d3,d1			; Put length together with (source address & $01FFFE) >> 1...
0000035C 03C9 0001                  			movep.l	d1,1(a1)		; ... and stuff them all into RAM in their proper places (movep for the win)
00000360 43E9 0008                  			lea	8(a1),a1		; Skip past all of these commands
00000364                            
00000364 3602                       			move.w	d2,d3			; Save for later
00000366                            			vdpCommReg d2,VRAM,DMA,1	; Make DMA destination command
00000366                          M 	local	cd
00000366 =00000021                M cd	=	vram&dma
00000366 E58A                     M 	lsl.l	#2,d2
00000368 5242                     M 	addq.w	#((cd)&3),d2
0000036A E45A                     M 	ror.w	#2,d2
0000036C 4842                     M 	swap	d2
0000036E 0242 0003                M 	andi.w	#3,d2
00000372 4AC2                     M 	tas.b	d2
00000374 22C2                       			move.l	d2,(a1)+		; Store command
00000376                            
00000376 B2FC 90FC                  			cmpa.w	#rDMASlot,a1		; Did this command fill the queue?
0000037A 6700                       			beq.s	.SkipSecondTransfer	; Branch if so
0000037C                            
0000037C                            			; Store VDP commands for specifying DMA into the queue
0000037C                            			; The source address high byte was done above already in the comments marked
0000037C                            			; with (**)
0000037C 7400                       				moveq	#0,d2		; Need a zero for a 128kB block start
0000037E 3400                       				move.w	d0,d2		; Copy number of words on this new block...
00000380 05C9 0003                  				movep.l	d2,3(a1)	; ... and stuff it all into RAM at the proper places (movep for the win)
00000384 43E9 000A                  			lea	10(a1),a1		; Skip past all of these commands
00000388                            
00000388                            			; d1 contains length up to the end of the 128kB boundary
00000388 D241                       			add.w	d1,d1			; Convert it into byte length...
0000038A D243                       			add.w	d3,d1			; ... and offset destination by the correct amount
0000038C                            			vdpCommReg d1,VRAM,DMA,1	; Make DMA destination command
0000038C                          M 	local	cd
0000038C =00000021                M cd	=	vram&dma
0000038C E589                     M 	lsl.l	#2,d1
0000038E 5241                     M 	addq.w	#((cd)&3),d1
00000390 E459                     M 	ror.w	#2,d1
00000392 4841                     M 	swap	d1
00000394 0241 0003                M 	andi.w	#3,d1
00000398 4AC1                     M 	tas.b	d1
0000039A 22C1                       			move.l	d1,(a1)+		; Store command
0000039C                            
0000039C 4251                       			clr.w	(a1)			; Put a stop token at the end of the used part of the queue
0000039E 31C9 90FC                  			move.w	a1,rDMASlot.w		; Set the next free slot address, potentially undoing the above clr (this is intentional!)
000003A2                            
000003A2 4E75                       			rts
000003A4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000003A4                            .SkipSecondTransfer:
000003A4 3289                       			move.w	a1,(a1)			; Set the next free slot address, overwriting what the second (**) instruction did
000003A6                            	
000003A6 4E75                       			rts
000003A8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000003A8                            ; Issue all the queued VDP DMA commands from QueueDMATransfer, resets the queue when it's done
000003A8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000003A8                            ; PARAMETERS:
000003A8                            ;	a6.l	- VDP control port
000003A8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000003A8                            ; RETURNS:
000003A8                            ;	Nothing
000003A8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000003A8                            ProcessDMAQueue:
000003A8 43F8 9000                  		lea	rDMAQueue.w,a1
000003AC 31C9 90FC                  		move.w	a1,rDMASlot.w
000003B0                            
000003B0                            		rept (rDMASlot-rDMAQueue)/(7*2)
000003B0                            			move.w	(a1)+,d0
000003B0                            			beq.w	.Done			; Branch if we reached a stop token
000003B0                            			
000003B0                            			move.w	d0,(a6)			; Issue a set of VDP commands...
000003B0                            			move.l	(a1)+,(a6)
000003B0                            			move.l	(a1)+,(a6)
000003B0                            			move.w	(a1)+,(a6)
000003B0                            			move.w	(a1)+,(a6)
000003B0                            		endr
000003B0 3019                     M 	move.w	(a1)+,d0
000003B2 6700 0000                M 	beq.w	.done
000003B6 3C80                     M 	move.w	d0,(a6)
000003B8 2C99                     M 	move.l	(a1)+,(a6)
000003BA 2C99                     M 	move.l	(a1)+,(a6)
000003BC 3C99                     M 	move.w	(a1)+,(a6)
000003BE 3C99                     M 	move.w	(a1)+,(a6)
000003C0 3019                     M 	move.w	(a1)+,d0
000003C2 6700 0000                M 	beq.w	.done
000003C6 3C80                     M 	move.w	d0,(a6)
000003C8 2C99                     M 	move.l	(a1)+,(a6)
000003CA 2C99                     M 	move.l	(a1)+,(a6)
000003CC 3C99                     M 	move.w	(a1)+,(a6)
000003CE 3C99                     M 	move.w	(a1)+,(a6)
000003D0 3019                     M 	move.w	(a1)+,d0
000003D2 6700 0000                M 	beq.w	.done
000003D6 3C80                     M 	move.w	d0,(a6)
000003D8 2C99                     M 	move.l	(a1)+,(a6)
000003DA 2C99                     M 	move.l	(a1)+,(a6)
000003DC 3C99                     M 	move.w	(a1)+,(a6)
000003DE 3C99                     M 	move.w	(a1)+,(a6)
000003E0 3019                     M 	move.w	(a1)+,d0
000003E2 6700 0000                M 	beq.w	.done
000003E6 3C80                     M 	move.w	d0,(a6)
000003E8 2C99                     M 	move.l	(a1)+,(a6)
000003EA 2C99                     M 	move.l	(a1)+,(a6)
000003EC 3C99                     M 	move.w	(a1)+,(a6)
000003EE 3C99                     M 	move.w	(a1)+,(a6)
000003F0 3019                     M 	move.w	(a1)+,d0
000003F2 6700 0000                M 	beq.w	.done
000003F6 3C80                     M 	move.w	d0,(a6)
000003F8 2C99                     M 	move.l	(a1)+,(a6)
000003FA 2C99                     M 	move.l	(a1)+,(a6)
000003FC 3C99                     M 	move.w	(a1)+,(a6)
000003FE 3C99                     M 	move.w	(a1)+,(a6)
00000400 3019                     M 	move.w	(a1)+,d0
00000402 6700 0000                M 	beq.w	.done
00000406 3C80                     M 	move.w	d0,(a6)
00000408 2C99                     M 	move.l	(a1)+,(a6)
0000040A 2C99                     M 	move.l	(a1)+,(a6)
0000040C 3C99                     M 	move.w	(a1)+,(a6)
0000040E 3C99                     M 	move.w	(a1)+,(a6)
00000410 3019                     M 	move.w	(a1)+,d0
00000412 6700 0000                M 	beq.w	.done
00000416 3C80                     M 	move.w	d0,(a6)
00000418 2C99                     M 	move.l	(a1)+,(a6)
0000041A 2C99                     M 	move.l	(a1)+,(a6)
0000041C 3C99                     M 	move.w	(a1)+,(a6)
0000041E 3C99                     M 	move.w	(a1)+,(a6)
00000420 3019                     M 	move.w	(a1)+,d0
00000422 6700 0000                M 	beq.w	.done
00000426 3C80                     M 	move.w	d0,(a6)
00000428 2C99                     M 	move.l	(a1)+,(a6)
0000042A 2C99                     M 	move.l	(a1)+,(a6)
0000042C 3C99                     M 	move.w	(a1)+,(a6)
0000042E 3C99                     M 	move.w	(a1)+,(a6)
00000430 3019                     M 	move.w	(a1)+,d0
00000432 6700 0000                M 	beq.w	.done
00000436 3C80                     M 	move.w	d0,(a6)
00000438 2C99                     M 	move.l	(a1)+,(a6)
0000043A 2C99                     M 	move.l	(a1)+,(a6)
0000043C 3C99                     M 	move.w	(a1)+,(a6)
0000043E 3C99                     M 	move.w	(a1)+,(a6)
00000440 3019                     M 	move.w	(a1)+,d0
00000442 6700 0000                M 	beq.w	.done
00000446 3C80                     M 	move.w	d0,(a6)
00000448 2C99                     M 	move.l	(a1)+,(a6)
0000044A 2C99                     M 	move.l	(a1)+,(a6)
0000044C 3C99                     M 	move.w	(a1)+,(a6)
0000044E 3C99                     M 	move.w	(a1)+,(a6)
00000450 3019                     M 	move.w	(a1)+,d0
00000452 6700 0000                M 	beq.w	.done
00000456 3C80                     M 	move.w	d0,(a6)
00000458 2C99                     M 	move.l	(a1)+,(a6)
0000045A 2C99                     M 	move.l	(a1)+,(a6)
0000045C 3C99                     M 	move.w	(a1)+,(a6)
0000045E 3C99                     M 	move.w	(a1)+,(a6)
00000460 3019                     M 	move.w	(a1)+,d0
00000462 6700 0000                M 	beq.w	.done
00000466 3C80                     M 	move.w	d0,(a6)
00000468 2C99                     M 	move.l	(a1)+,(a6)
0000046A 2C99                     M 	move.l	(a1)+,(a6)
0000046C 3C99                     M 	move.w	(a1)+,(a6)
0000046E 3C99                     M 	move.w	(a1)+,(a6)
00000470 3019                     M 	move.w	(a1)+,d0
00000472 6700 0000                M 	beq.w	.done
00000476 3C80                     M 	move.w	d0,(a6)
00000478 2C99                     M 	move.l	(a1)+,(a6)
0000047A 2C99                     M 	move.l	(a1)+,(a6)
0000047C 3C99                     M 	move.w	(a1)+,(a6)
0000047E 3C99                     M 	move.w	(a1)+,(a6)
00000480 3019                     M 	move.w	(a1)+,d0
00000482 6700 0000                M 	beq.w	.done
00000486 3C80                     M 	move.w	d0,(a6)
00000488 2C99                     M 	move.l	(a1)+,(a6)
0000048A 2C99                     M 	move.l	(a1)+,(a6)
0000048C 3C99                     M 	move.w	(a1)+,(a6)
0000048E 3C99                     M 	move.w	(a1)+,(a6)
00000490 3019                     M 	move.w	(a1)+,d0
00000492 6700 0000                M 	beq.w	.done
00000496 3C80                     M 	move.w	d0,(a6)
00000498 2C99                     M 	move.l	(a1)+,(a6)
0000049A 2C99                     M 	move.l	(a1)+,(a6)
0000049C 3C99                     M 	move.w	(a1)+,(a6)
0000049E 3C99                     M 	move.w	(a1)+,(a6)
000004A0 3019                     M 	move.w	(a1)+,d0
000004A2 6700 0000                M 	beq.w	.done
000004A6 3C80                     M 	move.w	d0,(a6)
000004A8 2C99                     M 	move.l	(a1)+,(a6)
000004AA 2C99                     M 	move.l	(a1)+,(a6)
000004AC 3C99                     M 	move.w	(a1)+,(a6)
000004AE 3C99                     M 	move.w	(a1)+,(a6)
000004B0 3019                     M 	move.w	(a1)+,d0
000004B2 6700 0000                M 	beq.w	.done
000004B6 3C80                     M 	move.w	d0,(a6)
000004B8 2C99                     M 	move.l	(a1)+,(a6)
000004BA 2C99                     M 	move.l	(a1)+,(a6)
000004BC 3C99                     M 	move.w	(a1)+,(a6)
000004BE 3C99                     M 	move.w	(a1)+,(a6)
000004C0 3019                     M 	move.w	(a1)+,d0
000004C2 6700 0000                M 	beq.w	.done
000004C6 3C80                     M 	move.w	d0,(a6)
000004C8 2C99                     M 	move.l	(a1)+,(a6)
000004CA 2C99                     M 	move.l	(a1)+,(a6)
000004CC 3C99                     M 	move.w	(a1)+,(a6)
000004CE 3C99                     M 	move.w	(a1)+,(a6)
000004D0 7000                       		moveq	#0,d0
000004D2                            
000004D2                            .Done:
000004D2 31C0 9000                  		move.w	d0,rDMAQueue.w
000004D6 4E75                       		rts
000004D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004D8                            ; Initialize the DMA queue
000004D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004D8                            ; PARAMETERS:
000004D8                            ;	Nothing
000004D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004D8                            ; RETURNS:
000004D8                            ;	Nothing
000004D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000004D8                            InitDMAQueue:
000004D8 43F8 9000                  		lea	rDMAQueue.w,a1
000004DC 32BC 0000                  		move.w	#0,(a1)
000004E0 31C9 90FC                  		move.w	a1,rDMASlot.w
000004E4 223C 9695 9493             		move.l	#$96959493,d1
000004EA =00000000                  c		= 0
000004EA                            		rept (rDMASlot-rDMAQueue)/(7*2)
000004EA                            			movep.l	d1,2+c(a1)
000004EA                            c			= c+14
000004EA                            		endr
000004EA 03C9 0002                M 	movep.l	d1,2+c(a1)
000004EE =0000000E                M c	=	c+14
000004EE 03C9 0010                M 	movep.l	d1,2+c(a1)
000004F2 =0000001C                M c	=	c+14
000004F2 03C9 001E                M 	movep.l	d1,2+c(a1)
000004F6 =0000002A                M c	=	c+14
000004F6 03C9 002C                M 	movep.l	d1,2+c(a1)
000004FA =00000038                M c	=	c+14
000004FA 03C9 003A                M 	movep.l	d1,2+c(a1)
000004FE =00000046                M c	=	c+14
000004FE 03C9 0048                M 	movep.l	d1,2+c(a1)
00000502 =00000054                M c	=	c+14
00000502 03C9 0056                M 	movep.l	d1,2+c(a1)
00000506 =00000062                M c	=	c+14
00000506 03C9 0064                M 	movep.l	d1,2+c(a1)
0000050A =00000070                M c	=	c+14
0000050A 03C9 0072                M 	movep.l	d1,2+c(a1)
0000050E =0000007E                M c	=	c+14
0000050E 03C9 0080                M 	movep.l	d1,2+c(a1)
00000512 =0000008C                M c	=	c+14
00000512 03C9 008E                M 	movep.l	d1,2+c(a1)
00000516 =0000009A                M c	=	c+14
00000516 03C9 009C                M 	movep.l	d1,2+c(a1)
0000051A =000000A8                M c	=	c+14
0000051A 03C9 00AA                M 	movep.l	d1,2+c(a1)
0000051E =000000B6                M c	=	c+14
0000051E 03C9 00B8                M 	movep.l	d1,2+c(a1)
00000522 =000000C4                M c	=	c+14
00000522 03C9 00C6                M 	movep.l	d1,2+c(a1)
00000526 =000000D2                M c	=	c+14
00000526 03C9 00D4                M 	movep.l	d1,2+c(a1)
0000052A =000000E0                M c	=	c+14
0000052A 03C9 00E2                M 	movep.l	d1,2+c(a1)
0000052E =000000EE                M c	=	c+14
0000052E 03C9 00F0                M 	movep.l	d1,2+c(a1)
00000532 =000000FC                M c	=	c+14
00000532 4E75                       		rts
00000534                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000534                            ; Load a palette into the main palette buffer
00000534                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000534                            ; PARAMETERS:
00000534                            ;	d0.w	- Size of palette (divided by 2 minus 1)
00000534                            ;	a0.l	- Pointer to palette data
00000534                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000534                            LoadPalette:
00000534 43F8 98CE                  		lea	rPalette.w,a1			; Main palette buffer
00000538 6000                       		bra.s	LoadPalToBuf			; Load the palette
0000053A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000053A                            ; Load a palette into the target palette buffer
0000053A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000053A                            ; PARAMETERS:
0000053A                            ;	d0.w	- Size of palette (divided by 2 minus 1)
0000053A                            ;	a0.l	- Pointer to palette data
0000053A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000053A                            LoadTargetPal:
0000053A 43F8 97CE                  		lea	rDestPal.w,a1			; Target palette buffer
0000053E 6000                       		bra.s	LoadPalToBuf			; Load the palette
00000540                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000540                            ; Load a palette into the main water palette buffer
00000540                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000540                            ; PARAMETERS:
00000540                            ;	d0.w	- Size of palette (divided by 2 minus 1)
00000540                            ;	a0.l	- Pointer to palette data
00000540                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000540                            LoadWaterPal:
00000540 43F8 984E                  		lea	rWaterPal.w,a1		; Main water palette buffer
00000544 6000                       		bra.s	LoadPalToBuf			; Load the palette
00000546                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000546                            ; Load a palette into the target water palette buffer
00000546                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000546                            ; PARAMETERS:
00000546                            ;	d0.w	- Size of palette (divided by 2 minus 1)
00000546                            ;	a0.l	- Pointer to palette data
00000546                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000546                            LoadTargetWaterPal:
00000546 43F8 974E                  		lea	rDestWtrPal.w,a1		; Target water palette buffer
0000054A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000054A                            ; Load a palette into a palette buffer
0000054A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000054A                            ; PARAMETERS:
0000054A                            ;	d0.w	- Size of palette (divided by 2 minus 1)
0000054A                            ;	a0.l	- Pointer to palette data
0000054A                            ;	a1.l	- Pointer to destination buffer
0000054A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000054A                            LoadPalToBuf:
0000054A 32D8                       		move.w	(a0)+,(a1)+			; Copy palette data
0000054C 51C8 FFFC                  		dbf	d0,LoadPalToBuf			; Loop
00000550 4E75                       		rts
00000552                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000552                            ; Fade the palette to black
00000552                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000552                            ; PARAMETERS:
00000552                            ;	Nothing
00000552                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000552                            ; RETURNS:
00000552                            ;	Nothing
00000552                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000552                            FadeToBlack:
00000552 31FC 003F C746             		move.w	#$003F,rPalFade.w		; Set to fade everything
00000558                            
00000558                            FadeToBlack_Custom:
00000558 7807                       		moveq	#7,d4				; Set repeat times
0000055A                            		
0000055A                            .FadeLoop:
0000055A                            		rept	2
0000055A                            			move.b	#vFade,rVINTRout.w	; Set V-INT routine
0000055A                            			bsr.w	VSync_Routine		; Do V-SYNC
0000055A                            		endr
0000055A 11FC 000A C745           M 	move.b	#vfade,rvintrout.w
00000560 6100 0000                M 	bsr.w	vsync_routine
00000564 11FC 000A C745           M 	move.b	#vfade,rvintrout.w
0000056A 6100 0000                M 	bsr.w	vsync_routine
0000056E 6100                       		bsr.s	FadeToBlack_Once		; Fade the colors once
00000570 51CC FFE8                  		dbf	d4,.FadeLoop			; Loop until we are done
00000574 4E75                       		rts
00000576                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000576                            FadeToBlack_Once:
00000576 7000                       		moveq	#0,d0
00000578 41F8 98CE                  		lea	rPalette.w,a0			; Palette buffer
0000057C 1038 C746                  		move.b	rFadeStart.w,d0		; Add starting index offset
00000580 D0C0                       		adda.w	d0,a0				; ''
00000582 1038 C747                  		move.b	rFadeLen.w,d0			; Get fade size
00000586                            
00000586                            .FadeLoop:
00000586 6100                       		bsr.s	.FadeColor			; Fade a color			
00000588 51C8 FFFC                  		dbf	d0,.FadeLoop			; Loop
0000058C                            
0000058C 7000                       		moveq	#0,d0
0000058E 41F8 984E                  		lea	rWaterPal.w,a0		; Water palette buffer
00000592 1038 C746                  		move.b	rFadeStart.w,d0		; Add starting index offset
00000596 D0C0                       		adda.w	d0,a0				; ''
00000598 1038 C747                  		move.b	rFadeLen.w,d0			; Get fade size
0000059C                            
0000059C                            .FadeLoopWater:
0000059C 6100                       		bsr.s	.FadeColor			; Fade a color			
0000059E 51C8 FFFC                  		dbf	d0,.FadeLoopWater		; Loop
000005A2 4E75                       		rts
000005A4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000005A4                            .FadeColor:
000005A4 3A10                       		move.w	(a0),d5				; Load color
000005A6 6700                       		beq.s	.NoRed				; If the color is already black, branch
000005A8 3205                       		move.w	d5,d1				; Copy color
000005AA 1401                       		move.b	d1,d2				; Load green and red
000005AC 1601                       		move.b	d1,d3				; Load only red
000005AE                            
000005AE 0241 0E00                  		andi.w	#$E00,d1			; Get only blue
000005B2 6700                       		beq.s	.NoBlue				; If blue is finished, branch
000005B4 0445 0200                  		subi.w	#$200,d5			; Decrease blue
000005B8                            
000005B8                            .NoBlue:
000005B8 0202 00E0                  		andi.b	#$E0,d2				; Get only green
000005BC 6700                       		beq.s	.NoGreen			; If green is finished, branch
000005BE 0445 0020                  		subi.w	#$20,d5				; Decrease green
000005C2                            
000005C2                            .NoGreen:
000005C2 0203 000E                  		andi.b	#$E,d3				; Get only red
000005C6 6700                       		beq.s	.NoRed				; If red is finished, branch
000005C8 5545                       		subq.w	#2,d5				; Decrease red
000005CA                            
000005CA                            .NoRed:
000005CA 30C5                       		move.w	d5,(a0)+			; Save the color
000005CC 4E75                       		rts
000005CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000005CE                            ; Fade the palette from black to the target palette
000005CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000005CE                            ; PARAMETERS:
000005CE                            ;	Nothing
000005CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000005CE                            ; RETURNS:
000005CE                            ;	Nothing
000005CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000005CE                            FadeFromBlack:
000005CE 31FC 003F C746             		move.w	#$003F,rPalFade.w		; Set to fade everything
000005D4                            
000005D4                            FadeFromBlack_Custom:
000005D4 780E                       		moveq	#$E,d4				; Maximum color check
000005D6                            
000005D6                            .FadeLoop:
000005D6                            		rept	2
000005D6                            			move.b	#vFade,rVINTRout.w	; Set V-INT routine
000005D6                            			bsr.w	VSync_Routine		; Do V-SYNC
000005D6                            		endr
000005D6 11FC 000A C745           M 	move.b	#vfade,rvintrout.w
000005DC 6100 0000                M 	bsr.w	vsync_routine
000005E0 11FC 000A C745           M 	move.b	#vfade,rvintrout.w
000005E6 6100 0000                M 	bsr.w	vsync_routine
000005EA 6100                       		bsr.s	FadeFromBlack_Once		; Fade the colors once
000005EC 5504                       		subq.b	#2,d4				; Decrement color check
000005EE 66E6                       		bne.s	.FadeLoop			; If we are not done, branch
000005F0                            
000005F0 11FC 000A C745             		move.b	#vFade,rVINTRout.w		; Set V-INT routine
000005F6 6000 0000                  		bra.w	VSync_Routine			; Do V-SYNC so that the colors transfer
000005FA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000005FA                            FadeFromBlack_Once:
000005FA 7000                       		moveq	#0,d0
000005FC 41F8 98CE                  		lea	rPalette.w,a0			; Palette buffer
00000600 43F8 97CE                  		lea	rDestPal.w,a1			; Target palette buffer
00000604 1038 C746                  		move.b	rFadeStart.w,d0		; Add starting index offset
00000608 D0C0                       		adda.w	d0,a0				; ''
0000060A D2C0                       		adda.w	d0,a1				; ''
0000060C 1038 C747                  		move.b	rFadeLen.w,d0			; Get fade size
00000610                            
00000610                            .FadeLoop:
00000610 6100                       		bsr.s	.FadeColor			; Fade a color			
00000612 51C8 FFFC                  		dbf	d0,.FadeLoop			; Loop
00000616                            
00000616 7000                       		moveq	#0,d0
00000618 41F8 984E                  		lea	rWaterPal.w,a0		; Water palette buffer
0000061C 43F8 974E                  		lea	rDestWtrPal.w,a1		; Target water palette buffer
00000620 1038 C746                  		move.b	rFadeStart.w,d0		; Add starting index offset
00000624 D0C0                       		adda.w	d0,a0				; ''
00000626 D2C0                       		adda.w	d0,a1				; ''
00000628 1038 C747                  		move.b	rFadeLen.w,d0			; Get fade size
0000062C                            
0000062C                            .FadeLoopWater:
0000062C 6100                       		bsr.s	.FadeColor			; Fade a color			
0000062E 51C8 FFFC                  		dbf	d0,.FadeLoopWater		; Loop
00000632 4E75                       		rts
00000634                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000634                            .FadeColor:
00000634 1A11                       		move.b	(a1),d5				; Load blue
00000636 3219                       		move.w	(a1)+,d1			; Load green and red
00000638 1401                       		move.b	d1,d2				; Load red
0000063A E809                       		lsr.b	#4,d1				; Get only green
0000063C 0202 000E                  		andi.b	#$E,d2				; Get only red
00000640                            
00000640 3610                       		move.w	(a0),d3				; Load current color
00000642 B805                       		cmp.b	d5,d4				; Should the blue fade?
00000644 6200                       		bhi.s	.NoBlue				; If not, branch
00000646 0643 0200                  		addi.w	#$200,d3			; Increase blue
0000064A                            
0000064A                            .NoBlue:
0000064A B801                       		cmp.b	d1,d4				; Should the green fade?
0000064C 6200                       		bhi.s	.NoGreen			; If not, branch
0000064E 0643 0020                  		addi.w	#$20,d3				; Increase green
00000652                            
00000652                            .NoGreen:
00000652 B802                       		cmp.b	d2,d4				; Should the red fade?
00000654 6200                       		bhi.s	.NoRed				; If not, branch
00000656 5443                       		addq.w	#2,d3				; Increase red
00000658                            
00000658                            .NoRed:
00000658 30C3                       		move.w	d3,(a0)+			; Save the color
0000065A 4E75                       		rts
0000065C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000065C                            ; Fade the palette to white
0000065C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000065C                            ; PARAMETERS:
0000065C                            ;	Nothing
0000065C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000065C                            ; RETURNS:
0000065C                            ;	Nothing
0000065C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000065C                            FadeToWhite:
0000065C 31FC 003F C746             		move.w	#$003F,rPalFade.w		; Set to fade everything
00000662                            
00000662                            FadeToWhite_Custom:
00000662 7807                       		moveq	#7,d4				; Set repeat times
00000664                            
00000664                            .FadeLoop:
00000664                            		rept	2
00000664                            			move.b	#vFade,rVINTRout.w	; Set V-INT routine
00000664                            			bsr.w	VSync_Routine		; Do V-SYNC
00000664                            		endr
00000664 11FC 000A C745           M 	move.b	#vfade,rvintrout.w
0000066A 6100 0000                M 	bsr.w	vsync_routine
0000066E 11FC 000A C745           M 	move.b	#vfade,rvintrout.w
00000674 6100 0000                M 	bsr.w	vsync_routine
00000678 6100                       		bsr.s	FadeToWhite_Once		; Fade the colors once
0000067A 51CC FFE8                  		dbf	d4,.FadeLoop			; Loop until we are done
0000067E 4E75                       		rts
00000680                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000680                            FadeToWhite_Once:
00000680 7000                       		moveq	#0,d0
00000682 41F8 98CE                  		lea	rPalette.w,a0			; Palette buffer
00000686 1038 C746                  		move.b	rFadeStart.w,d0		; Add starting index offset
0000068A D0C0                       		adda.w	d0,a0				; ''
0000068C 1038 C747                  		move.b	rFadeLen.w,d0			; Get fade size
00000690                            
00000690                            .FadeLoop:
00000690 6100                       		bsr.s	.FadeColor			; Fade a color			
00000692 51C8 FFFC                  		dbf	d0,.FadeLoop			; Loop
00000696                            
00000696 7000                       		moveq	#0,d0
00000698 41F8 984E                  		lea	rWaterPal.w,a0		; Water palette buffer
0000069C 1038 C746                  		move.b	rFadeStart.w,d0		; Add starting index offset
000006A0 D0C0                       		adda.w	d0,a0				; ''
000006A2 1038 C747                  		move.b	rFadeLen.w,d0			; Get fade size
000006A6                            
000006A6                            .FadeLoopWater:
000006A6 6100                       		bsr.s	.FadeColor			; Fade a color			
000006A8 51C8 FFFC                  		dbf	d0,.FadeLoopWater		; Loop
000006AC 4E75                       		rts
000006AE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000006AE                            .FadeColor:
000006AE 3A10                       		move.w	(a0),d5				; Load color
000006B0 0C45 0EEE                  		cmpi.w	#$EEE,d5			; Is it already white?
000006B4 6700                       		beq.s	.NoRed				; If so, branch
000006B6 3205                       		move.w	d5,d1				; Copy color
000006B8 1401                       		move.b	d1,d2				; Load green and red
000006BA 1601                       		move.b	d1,d3				; Load only red
000006BC                            
000006BC 0241 0E00                  		andi.w	#$E00,d1			; Get only blue
000006C0 0C41 0E00                  		cmpi.w	#$E00,d1			; Is blue finished?
000006C4 6700                       		beq.s	.NoBlue				; If do, branch
000006C6 0645 0200                  		addi.w	#$200,d5			; Increase blue
000006CA                            
000006CA                            .NoBlue:
000006CA 0202 00E0                  		andi.b	#$E0,d2				; Get only green
000006CE 0C02 00E0                  		cmpi.b	#$E0,d2				; Is green finished?
000006D2 6700                       		beq.s	.NoGreen			; If so, branch
000006D4 0645 0020                  		addi.w	#$20,d5				; Increase green
000006D8                            
000006D8                            .NoGreen:
000006D8 0203 000E                  		andi.b	#$E,d3				; Get only red
000006DC 0C03 000E                  		cmpi.b	#$E,d3				; Is red finished?
000006E0 6700                       		beq.s	.NoRed				; If so, branch
000006E2 5445                       		addq.w	#2,d5				; Increase red
000006E4                            
000006E4                            .NoRed:
000006E4 30C5                       		move.w	d5,(a0)+			; Save the color
000006E6 4E75                       		rts
000006E8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000006E8                            ; Fade the palette from white to the target palette
000006E8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000006E8                            ; PARAMETERS:
000006E8                            ;	Nothing
000006E8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000006E8                            ; RETURNS:
000006E8                            ;	Nothing
000006E8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000006E8                            FadeFromWhite:
000006E8 31FC 003F C746             		move.w	#$003F,rPalFade.w		; Set to fade everything
000006EE                            
000006EE                            FadeFromWhite_Custom:
000006EE 7800                       		moveq	#0,d4				; Minimum color check
000006F0                            		
000006F0                            .FadeLoop:
000006F0                            		rept	2
000006F0                            			move.b	#vFade,rVINTRout.w	; Set V-INT routine
000006F0                            			bsr.w	VSync_Routine		; Do V-SYNC
000006F0                            		endr
000006F0 11FC 000A C745           M 	move.b	#vfade,rvintrout.w
000006F6 6100 0000                M 	bsr.w	vsync_routine
000006FA 11FC 000A C745           M 	move.b	#vfade,rvintrout.w
00000700 6100 0000                M 	bsr.w	vsync_routine
00000704 6100                       		bsr.s	FadeFromWhite_Once		; Fade the colors once
00000706 5404                       		addq.b	#2,d4				; Decrement color check
00000708 0C04 000E                  		cmpi.b	#$E,d4				; Are we done?
0000070C 66E2                       		bne.s	.FadeLoop			; If not, branch
0000070E                            
0000070E 11FC 000A C745             		move.b	#vFade,rVINTRout.w		; Set V-INT routine
00000714 6000 0000                  		bra.w	VSync_Routine			; Do V-SYNC so that the colors transfer
00000718                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000718                            FadeFromWhite_Once:
00000718 7000                       		moveq	#0,d0
0000071A 41F8 98CE                  		lea	rPalette.w,a0			; Palette buffer
0000071E 43F8 97CE                  		lea	rDestPal.w,a1			; Target palette buffer
00000722 1038 C746                  		move.b	rFadeStart.w,d0		; Add starting index offset
00000726 D0C0                       		adda.w	d0,a0				; ''
00000728 D2C0                       		adda.w	d0,a1				; ''
0000072A 1038 C747                  		move.b	rFadeLen.w,d0			; Get fade size
0000072E                            
0000072E                            .FadeLoop:
0000072E 6100                       		bsr.s	.FadeColor			; Fade a color			
00000730 51C8 FFFC                  		dbf	d0,.FadeLoop			; Loop
00000734                            
00000734 7000                       		moveq	#0,d0
00000736 41F8 984E                  		lea	rWaterPal.w,a0		; Water palette buffer
0000073A 43F8 974E                  		lea	rDestWtrPal.w,a1		; Target water palette buffer
0000073E 1038 C746                  		move.b	rFadeStart.w,d0		; Add starting index offset
00000742 D0C0                       		adda.w	d0,a0				; ''
00000744 D2C0                       		adda.w	d0,a1				; ''
00000746 1038 C747                  		move.b	rFadeLen.w,d0			; Get fade size
0000074A                            
0000074A                            .FadeLoopWater:
0000074A 6100                       		bsr.s	.FadeColor			; Fade a color			
0000074C 51C8 FFFC                  		dbf	d0,.FadeLoopWater		; Loop
00000750 4E75                       		rts
00000752                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000752                            .FadeColor:
00000752 1A11                       		move.b	(a1),d5				; Load blue
00000754 3219                       		move.w	(a1)+,d1			; Load green and red
00000756 1401                       		move.b	d1,d2				; Load red
00000758 E809                       		lsr.b	#4,d1				; Get only green
0000075A 0202 000E                  		andi.b	#$E,d2				; Get only red
0000075E                            
0000075E 3610                       		move.w	(a0),d3				; Load current color
00000760 B805                       		cmp.b	d5,d4				; Should the blue fade?
00000762 6500                       		bcs.s	.NoBlue				; If not, branch
00000764 0443 0200                  		subi.w	#$200,d3			; Decrease blue
00000768                            
00000768                            .NoBlue:
00000768 B801                       		cmp.b	d1,d4				; Should the green fade?
0000076A 6500                       		bcs.s	.NoGreen			; If not, branch
0000076C 0443 0020                  		subi.w	#$20,d3				; Decrease green
00000770                            
00000770                            .NoGreen:
00000770 B802                       		cmp.b	d2,d4				; Should the red fade?
00000772 6500                       		bcs.s	.NoRed				; If not, branch
00000774 5543                       		subq.w	#2,d3				; Decrease red
00000776                            
00000776                            .NoRed:
00000776 30C3                       		move.w	d3,(a0)+			; Save the color
00000778 4E75                       		rts
0000077A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000077A                            ; Fade the palette from the current palette to the target palette
0000077A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000077A                            ; PARAMETERS:
0000077A                            ;	Nothing
0000077A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000077A                            ; RETURNS:
0000077A                            ;	Nothing
0000077A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000077A                            FadeToPalette:
0000077A 31FC 003F C746             		move.w	#$003F,rPalFade.w		; Set to fade everything
00000780                            
00000780                            FadeToPalette_Custom:
00000780 7000                       		moveq	#0,d0
00000782 41F8 98CE                  		lea	rPalette.w,a0			; Palette buffer
00000786 1038 C746                  		move.b	rFadeStart.w,d0		; Add starting index offset
0000078A D0C0                       		adda.w	d0,a0				; ''
0000078C                            
0000078C 7807                       		moveq	#7,d4				; Set repeat times
0000078E                            
0000078E                            .FadeLoop:
0000078E                            		rept	2
0000078E                            			move.b	#vFade,rVINTRout.w	; Set V-INT routine
0000078E                            			bsr.w	VSync_Routine		; Do V-SYNC
0000078E                            		endr
0000078E 11FC 000A C745           M 	move.b	#vfade,rvintrout.w
00000794 6100 0000                M 	bsr.w	vsync_routine
00000798 11FC 000A C745           M 	move.b	#vfade,rvintrout.w
0000079E 6100 0000                M 	bsr.w	vsync_routine
000007A2 6100                       		bsr.s	FadeToPalette_Once		; Fade the colors once
000007A4 51CC FFE8                  		dbf	d4,.FadeLoop			; Loop until we are done
000007A8 4E75                       		rts
000007AA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000007AA                            FadeToPalette_Once:
000007AA 7000                       		moveq	#0,d0
000007AC 41F8 98CE                  		lea	rPalette.w,a0			; Palette buffer
000007B0 43F8 97CE                  		lea	rDestPal.w,a1			; Target palette buffer
000007B4 1038 C746                  		move.b	rFadeStart.w,d0		; Add starting index offset
000007B8 D0C0                       		adda.w	d0,a0				; ''
000007BA D2C0                       		adda.w	d0,a1				; ''
000007BC 1038 C747                  		move.b	rFadeLen.w,d0			; Get fade size
000007C0                            
000007C0                            .FadeLoop:
000007C0 6100                       		bsr.s	.FadeColor			; Fade a color			
000007C2 51C8 FFFC                  		dbf	d0,.FadeLoop			; Loop
000007C6                            
000007C6 7000                       		moveq	#0,d0
000007C8 41F8 984E                  		lea	rWaterPal.w,a0		; Water palette buffer
000007CC 43F8 974E                  		lea	rDestWtrPal.w,a1		; Target water palette buffer
000007D0 1038 C746                  		move.b	rFadeStart.w,d0		; Add starting index offset
000007D4 D0C0                       		adda.w	d0,a0				; ''
000007D6 D2C0                       		adda.w	d0,a1				; ''
000007D8 1038 C747                  		move.b	rFadeLen.w,d0			; Get fade size
000007DC                            
000007DC                            .FadeLoopWater:
000007DC 6100                       		bsr.s	.FadeColor			; Fade a color			
000007DE 51C8 FFFC                  		dbf	d0,.FadeLoopWater		; Loop
000007E2 4E75                       		rts
000007E4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000007E4                            .FadeColor:
000007E4 3610                       		move.w	(a0),d3				; Get color
000007E6 B659                       		cmp.w	(a1)+,d3			; Has the color already reached the target color?
000007E8 6700                       		beq.s	.NoRed				; If so, branch
000007EA                            		
000007EA 3229 FFFE                  		move.w	-2(a1),d1			; Get green and red
000007EE 1401                       		move.b	d1,d2				; Get red only
000007F0 0202 000E                  		andi.b	#$E,d2				; ''
000007F4 E809                       		lsr.b	#4,d1				; Get green only
000007F6                            
000007F6 1A29 FFFE                  		move.b	-2(a1),d5			; Get blue
000007FA BA10                       		cmp.b	(a0),d5				; Does blue need to fade?
000007FC 6700                       		beq.s	.NoBlue				; If not, branch
000007FE 6500                       		bcs.s	.DecBlue			; If it needs to be decreased, branch
00000800 0643 0200                  		addi.w	#$200,d3			; Increase blue
00000804 6000                       		bra.s	.NoBlue				; Continue
00000806                            
00000806                            .DecBlue:
00000806 0443 0200                  		subi.w	#$200,d3			; Decrease blue
0000080A                            
0000080A                            .NoBlue:
0000080A 3A10                       		move.w	(a0),d5				; Get green
0000080C E80D                       		lsr.b	#4,d5				; ''
0000080E B205                       		cmp.b	d5,d1				; Does green need to fade?
00000810 6700                       		beq.s	.NoGreen			; If not, branch
00000812 6500                       		bcs.s	.DecGreen			; If it needs to be decreased, branch
00000814 0603 0020                  		addi.b	#$20,d3				; Increase green
00000818 6000                       		bra.s	.NoGreen			; Continue
0000081A                            
0000081A                            .DecGreen:
0000081A 0403 0020                  		subi.b	#$20,d3				; Decrease green
0000081E                            
0000081E                            .NoGreen:
0000081E 3A10                       		move.w	(a0),d5				; Get red
00000820 0205 000E                  		andi.b	#$E,d5				; ''
00000824 B405                       		cmp.b	d5,d2				; Does red need to fade?
00000826 6700                       		beq.s	.NoRed				; If not, branch
00000828 6500                       		bcs.s	.DecRed				; If it needs to be decreased, branch
0000082A 5403                       		addq.b	#2,d3				; Increase red
0000082C 6000                       		bra.s	.NoRed				; Continue
0000082E                            
0000082E                            .DecRed:
0000082E 5503                       		subq.b	#2,d3				; Decrease red
00000830                            
00000830                            .NoRed:
00000830 30C3                       		move.w	d3,(a0)+			; Save new color
00000832 4E75                       		rts
00000834                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000834                            ; Initialize the sprite table
00000834                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000834                            InitSpriteTable:
00000834 7000                       		moveq	#0,d0
00000836 41F8 94CE                  		lea	rSprites.w,a0			; Sprite table buffer
0000083A 7201                       		moveq	#1,d1				; Link value
0000083C 7E4F                       		moveq	#($280/8)-1,d7			; Number of sprites
0000083E                            
0000083E                            .Loop:
0000083E 3080                       		move.w	d0,(a0)				; Move off screen
00000840 1141 0003                  		move.b	d1,3(a0)			; Set link value
00000844 5241                       		addq.w	#1,d1				; Increment link value
00000846 5048                       		addq.w	#8,a0				; Next sprite
00000848 51CF FFF4                  		dbf	d7,.Loop			; Loop
0000084C 1140 FFFB                  		move.b	d0,-5(a0)			; Set final link value to 0
00000850 4E75                       		rts
00000852                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000852                            ; Draw the sprites from mappings
00000852                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000852                            ; PARAMETERS:
00000852                            ;	d0.w	- X position
00000852                            ;	d1.w	- Y position
00000852                            ;	d4.w	- Number of sprites to draw
00000852                            ;	d5.w	- Sprite tile properties
00000852                            ;	d6.b	- Render flags
00000852                            ;	d7.w	- Max number of sprites left to draw
00000852                            ;	a1.l	- Mappings frame data
00000852                            ;	a6.l	- Sprite table buffer
00000852                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000852                            ; RETURNS:
00000852                            ;	Nothing
00000852                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000852                            DrawSprite:
00000852 E20E                       		lsr.b	#1,d6				; Is this sprite flipped horizontally?
00000854 6500                       		bcs.s	DrawSprite_FlipX		; If so, branch
00000856 E20E                       		lsr.b	#1,d6				; Is this sprite flipped vertically?
00000858 6500 0000                  		bcs.w	DrawSprite_FlipY		; If so, branch
0000085C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000085C                            ; Draw the sprites from mappings with no flip checks
0000085C                            ; (Parameters inherited from DrawSprite, minus d6, a.k.a. render flags)
0000085C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000085C                            DrawSprite_Loop:
0000085C 1419                       		move.b	(a1)+,d2			; Get Y offset
0000085E 4882                       		ext.w	d2				; ''
00000860 D441                       		add.w	d1,d2				; Add onto Y position
00000862 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000864 1CD9                       		move.b	(a1)+,(a6)+			; Store sprite size
00000866 524E                       		addq.w	#1,a6				; Skip link data
00000868 3419                       		move.w	(a1)+,d2			; Get tile properties
0000086A D445                       		add.w	d5,d2				; Add base tile properties
0000086C 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
0000086E 3419                       		move.w	(a1)+,d2			; Get X offset
00000870 D440                       		add.w	d0,d2				; Add onto X position
00000872 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000874 5347                       		subq.w	#1,d7				; Decrement sprite count
00000876 5BCC FFE4                  		dbmi	d4,DrawSprite_Loop		; Loop if there are still enough sprites left
0000087A                            		
0000087A                            DrawSprite_End:
0000087A 4E75                       		rts
0000087C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000087C                            ; Draw the sprites from mappings, horizontally flipped
0000087C                            ; (Parameters inherited from DrawSprite)
0000087C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000087C                            DrawSprite_FlipX:
0000087C E20E                       		lsr.b	#1,d6				; Is this sprite flipped vertically?
0000087E 6500                       		bcs.s	DrawSprite_FlipXY		; If so, branch
00000880                            
00000880                            .Loop:
00000880 1419                       		move.b	(a1)+,d2			; Get Y offset
00000882 4882                       		ext.w	d2				; ''
00000884 D441                       		add.w	d1,d2				; Add onto Y position
00000886 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000888 1C19                       		move.b	(a1)+,d6			; Get sprite size
0000088A 1CC6                       		move.b	d6,(a6)+			; Store in sprite table
0000088C 524E                       		addq.w	#1,a6				; Skip link data
0000088E 3419                       		move.w	(a1)+,d2			; Get tile properties
00000890 D445                       		add.w	d5,d2				; Add base tile properties
00000892 0A42 0800                  		eori.w	#$800,d2			; Flip horizontally
00000896 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000898 3419                       		move.w	(a1)+,d2			; Get X offset
0000089A 4442                       		neg.w	d2				; Negate it
0000089C 1C3B 6000                  		move.b	DrawSprite_XFlipOff(pc,d6.w),d6	; Get the X offset to apply
000008A0 9446                       		sub.w	d6,d2				; Subtract the new X offset
000008A2 D440                       		add.w	d0,d2				; Add onto X position
000008A4 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000008A6 5347                       		subq.w	#1,d7				; Decrement sprite count
000008A8 5BCC FFD6                  		dbmi	d4,.Loop			; Loop if there are still enough sprites left
000008AC 4E75                       		rts
000008AE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000008AE                            DrawSprite_XFlipOff:
000008AE 0808 0808                  		dc.b	8, 8, 8, 8
000008B2 1010 1010                  		dc.b	$10, $10, $10, $10
000008B6 1818 1818                  		dc.b	$18, $18, $18, $18
000008BA 2020 2020                  		dc.b	$20, $20, $20, $20
000008BE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000008BE                            ; Draw the sprites from mappings, horizontally and vertically flipped
000008BE                            ; (Parameters inherited from DrawSprite, minus d6, a.k.a. render flags)
000008BE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000008BE                            DrawSprite_FlipXY:
000008BE 1419                       		move.b	(a1)+,d2			; Get Y offset
000008C0 4882                       		ext.w	d2				; ''
000008C2 4442                       		neg.w	d2				; Negate it
000008C4 1C11                       		move.b	(a1),d6				; Get sprite sizes
000008C6 1C3B 6000                  		move.b	DrawSprite_YFlipOff(pc,d6.w),d6	; Get the Y offset to apply
000008CA 9446                       		sub.w	d6,d2				; Subtract from the Y offset
000008CC D441                       		add.w	d1,d2				; Add onto Y position
000008CE 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000008D0 1C19                       		move.b	(a1)+,d6			; Get sprite size
000008D2 1CC6                       		move.b	d6,(a6)+			; Store in sprite table
000008D4 524E                       		addq.w	#1,a6				; Skip link data
000008D6 3419                       		move.w	(a1)+,d2			; Get tile properties
000008D8 D445                       		add.w	d5,d2				; Add base tile properties
000008DA 0A42 1800                  		eori.w	#$1800,d2			; Flip horizontally and vertically
000008DE 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000008E0 3419                       		move.w	(a1)+,d2			; Get X offset
000008E2 4442                       		neg.w	d2				; Negate it
000008E4 1C3B 60C8                  		move.b	DrawSprite_XFlipOff(pc,d6.w),d6	; Get the X offset to apply
000008E8 9446                       		sub.w	d6,d2				; Subtract the new X offset
000008EA D440                       		add.w	d0,d2				; Add onto X position
000008EC 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000008EE 5347                       		subq.w	#1,d7				; Decrement sprite count
000008F0 5BCC FFCC                  		dbmi	d4,DrawSprite_FlipXY		; Loop if there are still enough sprites left
000008F4 4E75                       		rts
000008F6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000008F6                            DrawSprite_YFlipOff:
000008F6 0810 1820                  		dc.b	8, $10, $18, $20
000008FA 0810 1820                  		dc.b	8, $10, $18, $20
000008FE 0810 1820                  		dc.b	8, $10, $18, $20
00000902 0810 1820                  		dc.b	8, $10, $18, $20
00000906                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000906                            ; Draw the sprites from mappings, vertically flipped
00000906                            ; (Parameters inherited from DrawSprite)
00000906                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000906                            DrawSprite_FlipY:
00000906 1419                       		move.b	(a1)+,d2			; Get Y offset
00000908 4882                       		ext.w	d2				; ''
0000090A 4442                       		neg.w	d2				; Negate it
0000090C 1C19                       		move.b	(a1)+,d6			; Get sprite sizes
0000090E 1D46 0002                  		move.b	d6,2(a6)			; Store in sprite table
00000912 1C3B 60E2                  		move.b	DrawSprite_YFlipOff(pc,d6.w),d6	; Get the Y offset to apply
00000916 9446                       		sub.w	d6,d2				; Subtract from the Y offset
00000918 D441                       		add.w	d1,d2				; Add onto Y position
0000091A 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
0000091C 544E                       		addq.w	#2,a6				; Skip link data
0000091E 3419                       		move.w	(a1)+,d2			; Get tile properties
00000920 D445                       		add.w	d5,d2				; Add base tile properties
00000922 0A42 1000                  		eori.w	#$1000,d2			; Flip vertically
00000926 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000928 3419                       		move.w	(a1)+,d2			; Get X offset
0000092A D440                       		add.w	d0,d2				; Add onto X position
0000092C 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
0000092E 5347                       		subq.w	#1,d7				; Decrement sprite count
00000930 5BCC FFD4                  		dbmi	d4,DrawSprite_FlipY		; Loop if there are still enough sprites left
00000934 4E75                       		rts
00000936                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000936                            ; Draw the sprites from mappings (with boundary checks)
00000936                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000936                            ; PARAMETERS:
00000936                            ;	d0.w	- X position
00000936                            ;	d1.w	- Y position
00000936                            ;	d4.w	- Number of sprites to draw
00000936                            ;	d5.w	- Sprite tile properties
00000936                            ;	d6.b	- Render flags
00000936                            ;	d7.w	- Max number of sprites left to draw
00000936                            ;	a1.l	- Mappings frame data
00000936                            ;	a6.l	- Sprite table buffer
00000936                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000936                            ; RETURNS:
00000936                            ;	Nothing
00000936                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000936                            DrawSprite_BoundChk:
00000936 E20E                       		lsr.b	#1,d6				; Is this sprite flipped horizontally?
00000938 6500                       		bcs.s	DrawSprite_BndChk_FlipX		; If so, branch
0000093A E20E                       		lsr.b	#1,d6				; Is this sprite flipped vertically?
0000093C 6500 0000                  		bcs.w	DrawSprite_BndChk_FlipY		; If so, branch
00000940                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000940                            ; Draw the sprites from mappings (with boundary checks) with no flip checks
00000940                            ; (Parameters inherited from DrawSprite_BoundChk, minus d6, a.k.a. render flags)
00000940                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000940                            DrawSprBndChk_Loop:
00000940 1419                       		move.b	(a1)+,d2			; Get Y offset
00000942 4882                       		ext.w	d2				; ''
00000944 D441                       		add.w	d1,d2				; Add onto Y position
00000946 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it above the screen?
0000094A 6300                       		bls.s	.Next_YOffScr			; If so, branch
0000094C 0C42 0160                  		cmpi.w	#224+128,d2			; Is it below the screen?
00000950 6400                       		bhs.s	.Next_YOffScr			; If so, branch
00000952 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000954 1CD9                       		move.b	(a1)+,(a6)+			; Store sprite size
00000956 524E                       		addq.w	#1,a6				; Skip link data
00000958 3419                       		move.w	(a1)+,d2			; Get tile properties
0000095A D445                       		add.w	d5,d2				; Add base tile properties
0000095C 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
0000095E 3419                       		move.w	(a1)+,d2			; Get X offset
00000960 D440                       		add.w	d0,d2				; Add onto X position
00000962 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it left of the screen?
00000966 6300                       		bls.s	.Next_XOffScr			; If so, branch
00000968 0C42 01C0                  		cmpi.w	#320+128,d2			; Is it right of the screen?
0000096C 6400                       		bhs.s	.Next_XOffScr			; If so, branch
0000096E 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000970 5347                       		subq.w	#1,d7				; Decrement sprite count
00000972 5BCC FFCC                  		dbmi	d4,DrawSprBndChk_Loop		; Loop if there are still enough sprites left
00000976 4E75                       		rts
00000978                            
00000978                            .Next_XOffScr:
00000978 5D4E                       		subq.w	#6,a6				; Go back to the start of the current sprite entry
0000097A 51CC FFC4                  		dbf	d4,DrawSprBndChk_Loop		; Loop if there are still enough sprites left
0000097E 4E75                       		rts
00000980                            
00000980                            .Next_YOffScr:
00000980 5A49                       		addq.w	#5,a1				; Go to the next sprite in the mappings in the mappings
00000982 51CC FFBC                  		dbf	d4,DrawSprBndChk_Loop		; Loop if there are still enough sprites left
00000986 4E75                       		rts
00000988                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000988                            ; Draw the sprites from mappings (with boundary checks), horizontally flipped
00000988                            ; (Parameters inherited from DrawSprite_BoundChk)
00000988                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000988                            DrawSprite_BndChk_FlipX:
00000988 E20E                       		lsr.b	#1,d6				; Is this sprite flipped vertically?
0000098A 6500                       		bcs.s	DrawSprite_BndChk_FlipXY	; If so, branch
0000098C                            
0000098C                            .Loop:
0000098C 1419                       		move.b	(a1)+,d2			; Get Y offset
0000098E 4882                       		ext.w	d2				; ''
00000990 D441                       		add.w	d1,d2				; Add onto Y position
00000992 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it above the screen?
00000996 6300                       		bls.s	.Next_YOffScr			; If so, branch
00000998 0C42 0160                  		cmpi.w	#224+128,d2			; Is it below the screen?
0000099C 6400                       		bhs.s	.Next_YOffScr			; If so, branch
0000099E 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000009A0 1C19                       		move.b	(a1)+,d6			; Get sprite size
000009A2 1CC6                       		move.b	d6,(a6)+			; Store in sprite table
000009A4 524E                       		addq.w	#1,a6				; Skip link data
000009A6 3419                       		move.w	(a1)+,d2			; Get tile properties
000009A8 D445                       		add.w	d5,d2				; Add base tile properties
000009AA 0A42 0800                  		eori.w	#$800,d2			; Flip horizontally
000009AE 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000009B0 3419                       		move.w	(a1)+,d2			; Get X offset
000009B2 4442                       		neg.w	d2				; Negate it
000009B4 1C3B 6000                  		move.b	DrwSprBndChk_XFlips(pc,d6.w),d6; Get the X offset to apply
000009B8 9446                       		sub.w	d6,d2				; Subtract the new X offset
000009BA D440                       		add.w	d0,d2				; Add onto X position
000009BC 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it left of the screen?
000009C0 6300                       		bls.s	.Next_XOffScr			; If so, branch
000009C2 0C42 01C0                  		cmpi.w	#320+128,d2			; Is it right of the screen?
000009C6 6400                       		bhs.s	.Next_XOffScr			; If so, branch
000009C8 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
000009CA 5347                       		subq.w	#1,d7				; Decrement sprite count
000009CC 5BCC FFBE                  		dbmi	d4,.Loop			; Loop if there are still enough sprites left
000009D0 4E75                       		rts
000009D2                            
000009D2                            .Next_XOffScr:
000009D2 5D4E                       		subq.w	#6,a6				; Go back to the start of the current sprite entry
000009D4 51CC FFB6                  		dbf	d4,.Loop			; Loop if there are still enough sprites left
000009D8 4E75                       		rts
000009DA                            
000009DA                            .Next_YOffScr:
000009DA 5A49                       		addq.w	#5,a1				; Go to the next sprite in the mappings
000009DC 51CC FFAE                  		dbf	d4,.Loop			; Loop if there are still enough sprites left
000009E0 4E75                       		rts
000009E2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000009E2                            DrwSprBndChk_XFlips:
000009E2 0808 0808                  		dc.b	8, 8, 8, 8
000009E6 1010 1010                  		dc.b	$10, $10, $10, $10
000009EA 1818 1818                  		dc.b	$18, $18, $18, $18
000009EE 2020 2020                  		dc.b	$20, $20, $20, $20
000009F2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000009F2                            ; Draw the sprites from mappings (with boundary checks), horizontally and vertically flipped
000009F2                            ; (Parameters inherited from DrawSprite, minus d6, a.k.a. render flags)
000009F2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000009F2                            DrawSprite_BndChk_FlipXY:
000009F2 1419                       		move.b	(a1)+,d2			; Get Y offset
000009F4 4882                       		ext.w	d2				; ''
000009F6 4442                       		neg.w	d2				; Negate it
000009F8 1C11                       		move.b	(a1),d6				; Get sprite sizes
000009FA 1C3B 6000                  		move.b	DrwSprBndChk_YFlips(pc,d6.w),d6; Get the Y offset to apply
000009FE 9446                       		sub.w	d6,d2				; Subtract from the Y offset
00000A00 D441                       		add.w	d1,d2				; Add onto Y position
00000A02 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it above the screen?
00000A06 6300                       		bls.s	.Next_YOffScr			; If so, branch
00000A08 0C42 0160                  		cmpi.w	#224+128,d2			; Is it below the screen?
00000A0C 6400                       		bhs.s	.Next_YOffScr			; If so, branch
00000A0E 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000A10 1C19                       		move.b	(a1)+,d6			; Get sprite size
00000A12 1CC6                       		move.b	d6,(a6)+			; Store in sprite table
00000A14 524E                       		addq.w	#1,a6				; Skip link data
00000A16 3419                       		move.w	(a1)+,d2			; Get tile properties
00000A18 D445                       		add.w	d5,d2				; Add base tile properties
00000A1A 0A42 1800                  		eori.w	#$1800,d2			; Flip horizontally and vertically
00000A1E 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000A20 3419                       		move.w	(a1)+,d2			; Get X offset
00000A22 4442                       		neg.w	d2				; Negate it
00000A24 1C3B 60BC                  		move.b	DrwSprBndChk_XFlips(pc,d6.w),d6; Get the X offset to apply
00000A28 9446                       		sub.w	d6,d2				; Subtract the new X offset
00000A2A D440                       		add.w	d0,d2				; Add onto X position
00000A2C 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it left of the screen?
00000A30 6300                       		bls.s	.Next_XOffScr			; If so, branch
00000A32 0C42 01C0                  		cmpi.w	#320+128,d2			; Is it right of the screen?
00000A36 6400                       		bhs.s	.Next_XOffScr			; If so, branch
00000A38 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000A3A 5347                       		subq.w	#1,d7				; Decrement sprite count
00000A3C 5BCC FFB4                  		dbmi	d4,DrawSprite_BndChk_FlipXY	; Loop if there are still enough sprites left
00000A40 4E75                       		rts
00000A42                            
00000A42                            .Next_XOffScr:
00000A42 5D4E                       		subq.w	#6,a6				; Go back to the start of the current sprite entry
00000A44 51CC FFAC                  		dbf	d4,DrawSprite_BndChk_FlipXY	; Loop if there are still enough sprites left
00000A48 4E75                       		rts
00000A4A                            
00000A4A                            .Next_YOffScr:
00000A4A 5A49                       		addq.w	#5,a1				; Go to the next sprite in the mappings
00000A4C 51CC FFA4                  		dbf	d4,DrawSprite_BndChk_FlipXY	; Loop if there are still enough sprites left
00000A50 4E75                       		rts
00000A52                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A52                            DrwSprBndChk_YFlips:
00000A52 0810 1820                  		dc.b	8, $10, $18, $20
00000A56 0810 1820                  		dc.b	8, $10, $18, $20
00000A5A 0810 1820                  		dc.b	8, $10, $18, $20
00000A5E 0810 1820                  		dc.b	8, $10, $18, $20
00000A62                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A62                            ; Draw the sprites from mappings (with boundary checks), vertically flipped
00000A62                            ; (Parameters inherited from DrawSprite_BoundChk)
00000A62                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000A62                            DrawSprite_BndChk_FlipY:
00000A62 1419                       		move.b	(a1)+,d2			; Get Y offset
00000A64 4882                       		ext.w	d2				; ''
00000A66 4442                       		neg.w	d2				; Negate it
00000A68 1C19                       		move.b	(a1)+,d6			; Get sprite sizes
00000A6A 1D46 0002                  		move.b	d6,2(a6)			; Store in sprite table
00000A6E 1C3B 60E2                  		move.b	DrwSprBndChk_YFlips(pc,d6.w),d6; Get the Y offset to apply
00000A72 9446                       		sub.w	d6,d2				; Subtract from the Y offset
00000A74 D441                       		add.w	d1,d2				; Add onto Y position
00000A76 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it above the screen?
00000A7A 6300                       		bls.s	.Next_YOffScr			; If so, branch
00000A7C 0C42 0160                  		cmpi.w	#224+128,d2			; Is it below the screen?
00000A80 6400                       		bhs.s	.Next_YOffScr			; If so, branch
00000A82 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000A84 544E                       		addq.w	#2,a6				; Skip link data
00000A86 3419                       		move.w	(a1)+,d2			; Get tile properties
00000A88 D445                       		add.w	d5,d2				; Add base tile properties
00000A8A 0A42 1000                  		eori.w	#$1000,d2			; Flip vertically
00000A8E 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000A90 3419                       		move.w	(a1)+,d2			; Get X offset
00000A92 D440                       		add.w	d0,d2				; Add onto X position
00000A94 0C42 0060                  		cmpi.w	#-32+128,d2			; Is it left of the screen?
00000A98 6300                       		bls.s	.Next_XOffScr			; If so, branch
00000A9A 0C42 01C0                  		cmpi.w	#320+128,d2			; Is it right of the screen?
00000A9E 6400                       		bhs.s	.Next_XOffScr			; If so, branch
00000AA0 3CC2                       		move.w	d2,(a6)+			; Store in sprite table
00000AA2 5347                       		subq.w	#1,d7				; Decrement sprite count
00000AA4 5BCC FFBC                  		dbmi	d4,DrawSprite_BndChk_FlipY	; Loop if there are still enough sprites left
00000AA8 4E75                       		rts
00000AAA                            
00000AAA                            .Next_XOffScr:
00000AAA 5D4E                       		subq.w	#6,a6				; Go back to the start of the current sprite entry
00000AAC 51CC FFB4                  		dbf	d4,DrawSprite_BndChk_FlipY	; Loop if there are still enough sprites left
00000AB0 4E75                       		rts
00000AB2                            
00000AB2                            .Next_YOffScr:
00000AB2 5A49                       		addq.w	#5,a1				; Go to the next sprite in the mappings
00000AB4 51CC FFAC                  		dbf	d4,DrawSprite_BndChk_FlipY	; Loop if there are still enough sprites left
00000AB8 4E75                       		rts
00000ABA                            ; =========================================================================================================================================================
00000ABA                            		include	"Libraries/Joypad.asm"		; Joypad functions
00000ABA                            ; =========================================================================================================================================================
00000ABA                            ; Joypad functions
00000ABA                            ; =========================================================================================================================================================
00000ABA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000ABA                            ; Read joypad input
00000ABA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000ABA                            ; PARAMETERS:
00000ABA                            ;	Nothing
00000ABA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000ABA                            ; RETURNS:
00000ABA                            ;	Nothing
00000ABA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000ABA                            ReadJoypads:
00000ABA 41F8 C740                  	lea	rP1Data.w,a0			; 8	; load RAM space for joypad data
00000ABE 43F9 00A1 0002             	lea	PORT_A_DATA-1,a1		; 12	; load I/O data port A
00000AC4 7000                       	moveq	#%00000000,d0			; 4	; prepare TH = 0 request value
00000AC6 7240                       	moveq	#%01000000,d1			; 4	; prepare TH = 1 request value
00000AC8                            
00000AC8                            	; Repeat the following twice to
00000AC8                            	; collect input from both pads
00000AC8                            	rept	2
00000AC8                            		move.w	d0,(a1)			; 8	; set TH = 0 (burn 8 cycles to wait for returned data by setting up bitmasks below)
00000AC8                            		moveq	#%00110000,d2		; 4	; button bitmask mask for TH = 0
00000AC8                            		moveq	#%00111111,d3		; 4	; button bitmask for TH = 1
00000AC8                            		and.w	(a1),d2			; 8	; collect current button data for TH = 0 (A and Start)
00000AC8                            		move.w	d1,(a1)			; 8	; set TH = 1 (burn 8 cycles again below to wait)
00000AC8                            		add.b	d2,d2			; 4	; shift TH = 0 button bits to the left by two
00000AC8                            		add.b	d2,d2			; 4	; (A and start will be bits $6 and $7 in saved data)
00000AC8                            		and.w	(a1)+,d3		; 8	; collect current button data for TH = 1 (Up, Down, Left, Right, B, and C)
00000AC8                            		or.b	d3,d2			; 4	; combine collected button bits
00000AC8                            		not.b	d2			; 4	; flip bits (now pressed = 1 and not pressed = 0)
00000AC8                            		move.b	(a0),d3			; 8	; d3 = last collected button data
00000AC8                            		eor.b	d2,d3			; 4	; remove any currently pressed buttons from d3
00000AC8                            		move.b	d2,(a0)+		; 8	; save d2 (current button presses) as current held buttons
00000AC8                            		and.b	d2,d3			; 4	; limit d3 (pressed buttons) to only include current buttons
00000AC8                            		move.b	d3,(a0)+		; 8	; save all pressed buttons for this frame
00000AC8                            	endr
00000AC8 3280                     M 	move.w	d0,(a1)
00000ACA 7430                     M 	moveq	#%00110000,d2
00000ACC 763F                     M 	moveq	#%00111111,d3
00000ACE C451                     M 	and.w	(a1),d2
00000AD0 3281                     M 	move.w	d1,(a1)
00000AD2 D402                     M 	add.b	d2,d2
00000AD4 D402                     M 	add.b	d2,d2
00000AD6 C659                     M 	and.w	(a1)+,d3
00000AD8 8403                     M 	or.b	d3,d2
00000ADA 4602                     M 	not.b	d2
00000ADC 1610                     M 	move.b	(a0),d3
00000ADE B503                     M 	eor.b	d2,d3
00000AE0 10C2                     M 	move.b	d2,(a0)+
00000AE2 C602                     M 	and.b	d2,d3
00000AE4 10C3                     M 	move.b	d3,(a0)+
00000AE6 3280                     M 	move.w	d0,(a1)
00000AE8 7430                     M 	moveq	#%00110000,d2
00000AEA 763F                     M 	moveq	#%00111111,d3
00000AEC C451                     M 	and.w	(a1),d2
00000AEE 3281                     M 	move.w	d1,(a1)
00000AF0 D402                     M 	add.b	d2,d2
00000AF2 D402                     M 	add.b	d2,d2
00000AF4 C659                     M 	and.w	(a1)+,d3
00000AF6 8403                     M 	or.b	d3,d2
00000AF8 4602                     M 	not.b	d2
00000AFA 1610                     M 	move.b	(a0),d3
00000AFC B503                     M 	eor.b	d2,d3
00000AFE 10C2                     M 	move.b	d2,(a0)+
00000B00 C602                     M 	and.b	d2,d3
00000B02 10C3                     M 	move.b	d3,(a0)+
00000B04                            
00000B04 4E75                       	rts					; 16	; return
00000B06                            
00000B06                            ; =========================================================================================================================================================
00000B06                            		include	"Libraries/Decompression.asm"	; Decompression functions
00000B06                            ; =========================================================================================================================================================
00000B06                            ; Decompression functions
00000B06                            ; =========================================================================================================================================================
00000B06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000B06                            ; Kosinski decompression (General purpose)
00000B06                            ; New faster version by written by vladikcomper, with additional improvements by MarkeyJester and Flamewing
00000B06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000B06                            ; PARAMETERS:
00000B06                            ;	a0.l	- Source address
00000B06                            ;	a1.l	- Destination address
00000B06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000B06                            ; RETURNS:
00000B06                            ;	a1.l	- End of decompressed data address
00000B06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000B06 =00000001                  _Kos_UseLUT			equ	1
00000B06 =00000003                  _Kos_LoopUnroll			equ	3
00000B06 =00000001                  _Kos_ExtremeUnrolling		equ	1
00000B06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000B06                            _Kos_RunBitStream macro
00000B06                            		dbra	d2,.skip\@
00000B06                            		moveq	#7,d2				; Set repeat count to 8.
00000B06                            		move.b	d1,d0				; Use the remaining 8 bits.
00000B06                            		not.w	d3				; Have all 16 bits been used up?
00000B06                            		bne.s	.skip\@				; Branch if not.
00000B06                            		move.b	(a0)+,d0			; Get desc field low-byte.
00000B06                            		move.b	(a0)+,d1			; Get desc field hi-byte.
00000B06                            	if _Kos_UseLUT=1
00000B06                            		move.b	(a4,d0.w),d0			; Invert bit order...
00000B06                            		move.b	(a4,d1.w),d1			; ... for both bytes.
00000B06                            	endif
00000B06                            .skip\@:
00000B06                            		endm
00000B06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000B06                            _Kos_ReadBit macro
00000B06                            	if _Kos_UseLUT=1
00000B06                            		add.b	d0,d0				; Get a bit from the bitstream.
00000B06                            	else
00000B06                            		lsr.b	#1,d0				; Get a bit from the bitstream.
00000B06                            	endif
00000B06                            		endm
00000B06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000B06                            KosDec:
00000B06 7E07                       		moveq	#(1<<_Kos_LoopUnroll)-1,d7
00000B08 7000                       		moveq	#0,d0
00000B0A 7200                       		moveq	#0,d1
00000B0C 49FA 0000                  		lea	KosDec_ByteMap(pc),a4		; Load LUT pointer.
00000B10 1018                       		move.b	(a0)+,d0			; Get desc field low-byte.
00000B12 1218                       		move.b	(a0)+,d1			; Get desc field hi-byte.
00000B14 1034 0000                  		move.b	(a4,d0.w),d0			; Invert bit order...
00000B18 1234 1000                  		move.b	(a4,d1.w),d1			; ... for both bytes.
00000B1C 7407                       		moveq	#7,d2				; Set repeat count to 8.
00000B1E 7600                       		moveq	#0,d3				; d3 will be desc field switcher.
00000B20 6000                       		bra.s	.FetchNewCode
00000B22                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000B22                            .FetchCodeLoop:
00000B22                            		; Code 1 (Uncompressed byte).
00000B22                            		_Kos_RunBitStream
00000B22 51CA 0000                M 	dbra	d2,.skip_30
00000B26 7407                     M 	moveq	#7,d2
00000B28 1001                     M 	move.b	d1,d0
00000B2A 4643                     M 	not.w	d3
00000B2C 6600                     M 	bne.s	.skip_30
00000B2E 1018                     M 	move.b	(a0)+,d0
00000B30 1218                     M 	move.b	(a0)+,d1
00000B32 1034 0000                M 	move.b	(a4,d0.w),d0
00000B36 1234 1000                M 	move.b	(a4,d1.w),d1
00000B3A                          M .skip_30:
00000B3A 12D8                       		move.b	(a0)+,(a1)+
00000B3C                             
00000B3C                            .FetchNewCode:
00000B3C                            		_Kos_ReadBit
00000B3C D000                     M 	add.b	d0,d0
00000B3E 65E2                       		bcs.s	.FetchCodeLoop			; If code = 1, branch.
00000B40                             
00000B40                            		; Codes 00 and 01.
00000B40 7AFF                       		moveq	#-1,d5
00000B42 4BD1                       		lea	(a1),a5
00000B44                            		_Kos_RunBitStream
00000B44 51CA 0000                M 	dbra	d2,.skip_32
00000B48 7407                     M 	moveq	#7,d2
00000B4A 1001                     M 	move.b	d1,d0
00000B4C 4643                     M 	not.w	d3
00000B4E 6600                     M 	bne.s	.skip_32
00000B50 1018                     M 	move.b	(a0)+,d0
00000B52 1218                     M 	move.b	(a0)+,d1
00000B54 1034 0000                M 	move.b	(a4,d0.w),d0
00000B58 1234 1000                M 	move.b	(a4,d1.w),d1
00000B5C                          M .skip_32:
00000B5C                            		_Kos_ReadBit
00000B5C D000                     M 	add.b	d0,d0
00000B5E 6500 0000                  		bcs.w	.Code_01
00000B62                             
00000B62                            		; Code 00 (Dictionary ref. short).
00000B62                            		_Kos_RunBitStream
00000B62 51CA 0000                M 	dbra	d2,.skip_34
00000B66 7407                     M 	moveq	#7,d2
00000B68 1001                     M 	move.b	d1,d0
00000B6A 4643                     M 	not.w	d3
00000B6C 6600                     M 	bne.s	.skip_34
00000B6E 1018                     M 	move.b	(a0)+,d0
00000B70 1218                     M 	move.b	(a0)+,d1
00000B72 1034 0000                M 	move.b	(a4,d0.w),d0
00000B76 1234 1000                M 	move.b	(a4,d1.w),d1
00000B7A                          M .skip_34:
00000B7A                            		_Kos_ReadBit
00000B7A D000                     M 	add.b	d0,d0
00000B7C 6500                       		bcs.s	.Copy45
00000B7E                            		_Kos_RunBitStream
00000B7E 51CA 0000                M 	dbra	d2,.skip_36
00000B82 7407                     M 	moveq	#7,d2
00000B84 1001                     M 	move.b	d1,d0
00000B86 4643                     M 	not.w	d3
00000B88 6600                     M 	bne.s	.skip_36
00000B8A 1018                     M 	move.b	(a0)+,d0
00000B8C 1218                     M 	move.b	(a0)+,d1
00000B8E 1034 0000                M 	move.b	(a4,d0.w),d0
00000B92 1234 1000                M 	move.b	(a4,d1.w),d1
00000B96                          M .skip_36:
00000B96                            		_Kos_ReadBit
00000B96 D000                     M 	add.b	d0,d0
00000B98 6500                       		bcs.s	.Copy3
00000B9A                            		_Kos_RunBitStream
00000B9A 51CA 0000                M 	dbra	d2,.skip_38
00000B9E 7407                     M 	moveq	#7,d2
00000BA0 1001                     M 	move.b	d1,d0
00000BA2 4643                     M 	not.w	d3
00000BA4 6600                     M 	bne.s	.skip_38
00000BA6 1018                     M 	move.b	(a0)+,d0
00000BA8 1218                     M 	move.b	(a0)+,d1
00000BAA 1034 0000                M 	move.b	(a4,d0.w),d0
00000BAE 1234 1000                M 	move.b	(a4,d1.w),d1
00000BB2                          M .skip_38:
00000BB2 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
00000BB4 DAC5                       		adda.w	d5,a5
00000BB6 12DD                       		move.b	(a5)+,(a1)+
00000BB8 12DD                       		move.b	(a5)+,(a1)+
00000BBA 6080                       		bra.s	.FetchNewCode
00000BBC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000BBC                            .Copy3:
00000BBC                            		_Kos_RunBitStream
00000BBC 51CA 0000                M 	dbra	d2,.skip_39
00000BC0 7407                     M 	moveq	#7,d2
00000BC2 1001                     M 	move.b	d1,d0
00000BC4 4643                     M 	not.w	d3
00000BC6 6600                     M 	bne.s	.skip_39
00000BC8 1018                     M 	move.b	(a0)+,d0
00000BCA 1218                     M 	move.b	(a0)+,d1
00000BCC 1034 0000                M 	move.b	(a4,d0.w),d0
00000BD0 1234 1000                M 	move.b	(a4,d1.w),d1
00000BD4                          M .skip_39:
00000BD4 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
00000BD6 DAC5                       		adda.w	d5,a5
00000BD8 12DD                       		move.b	(a5)+,(a1)+
00000BDA 12DD                       		move.b	(a5)+,(a1)+
00000BDC 12DD                       		move.b	(a5)+,(a1)+
00000BDE 6000 FF5C                  		bra.w	.FetchNewCode
00000BE2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000BE2                            .Copy45:
00000BE2                            		_Kos_RunBitStream
00000BE2 51CA 0000                M 	dbra	d2,.skip_40
00000BE6 7407                     M 	moveq	#7,d2
00000BE8 1001                     M 	move.b	d1,d0
00000BEA 4643                     M 	not.w	d3
00000BEC 6600                     M 	bne.s	.skip_40
00000BEE 1018                     M 	move.b	(a0)+,d0
00000BF0 1218                     M 	move.b	(a0)+,d1
00000BF2 1034 0000                M 	move.b	(a4,d0.w),d0
00000BF6 1234 1000                M 	move.b	(a4,d1.w),d1
00000BFA                          M .skip_40:
00000BFA                            		_Kos_ReadBit
00000BFA D000                     M 	add.b	d0,d0
00000BFC 6500                       		bcs.s	.Copy5
00000BFE                            		_Kos_RunBitStream
00000BFE 51CA 0000                M 	dbra	d2,.skip_42
00000C02 7407                     M 	moveq	#7,d2
00000C04 1001                     M 	move.b	d1,d0
00000C06 4643                     M 	not.w	d3
00000C08 6600                     M 	bne.s	.skip_42
00000C0A 1018                     M 	move.b	(a0)+,d0
00000C0C 1218                     M 	move.b	(a0)+,d1
00000C0E 1034 0000                M 	move.b	(a4,d0.w),d0
00000C12 1234 1000                M 	move.b	(a4,d1.w),d1
00000C16                          M .skip_42:
00000C16 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
00000C18 DAC5                       		adda.w	d5,a5
00000C1A 12DD                       		move.b	(a5)+,(a1)+
00000C1C 12DD                       		move.b	(a5)+,(a1)+
00000C1E 12DD                       		move.b	(a5)+,(a1)+
00000C20 12DD                       		move.b	(a5)+,(a1)+
00000C22 6000 FF18                  		bra.w	.FetchNewCode
00000C26                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000C26                            .Copy5:
00000C26                            		_Kos_RunBitStream
00000C26 51CA 0000                M 	dbra	d2,.skip_43
00000C2A 7407                     M 	moveq	#7,d2
00000C2C 1001                     M 	move.b	d1,d0
00000C2E 4643                     M 	not.w	d3
00000C30 6600                     M 	bne.s	.skip_43
00000C32 1018                     M 	move.b	(a0)+,d0
00000C34 1218                     M 	move.b	(a0)+,d1
00000C36 1034 0000                M 	move.b	(a4,d0.w),d0
00000C3A 1234 1000                M 	move.b	(a4,d1.w),d1
00000C3E                          M .skip_43:
00000C3E 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
00000C40 DAC5                       		adda.w	d5,a5
00000C42 12DD                       		move.b	(a5)+,(a1)+
00000C44 12DD                       		move.b	(a5)+,(a1)+
00000C46 12DD                       		move.b	(a5)+,(a1)+
00000C48 12DD                       		move.b	(a5)+,(a1)+
00000C4A 12DD                       		move.b	(a5)+,(a1)+
00000C4C 6000 FEEE                  		bra.w	.FetchNewCode
00000C50                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000C50                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000C50                            .Code_01:
00000C50 7800                       		moveq	#0,d4				; d4 will contain copy count.
00000C52                            		; Code 01 (Dictionary ref. long / special).
00000C52                            		_Kos_RunBitStream
00000C52 51CA 0000                M 	dbra	d2,.skip_44
00000C56 7407                     M 	moveq	#7,d2
00000C58 1001                     M 	move.b	d1,d0
00000C5A 4643                     M 	not.w	d3
00000C5C 6600                     M 	bne.s	.skip_44
00000C5E 1018                     M 	move.b	(a0)+,d0
00000C60 1218                     M 	move.b	(a0)+,d1
00000C62 1034 0000                M 	move.b	(a4,d0.w),d0
00000C66 1234 1000                M 	move.b	(a4,d1.w),d1
00000C6A                          M .skip_44:
00000C6A 1C18                       		move.b	(a0)+,d6			; d6 = %LLLLLLLL.
00000C6C 1818                       		move.b	(a0)+,d4			; d4 = %HHHHHCCC.
00000C6E 1A04                       		move.b	d4,d5				; d5 = %11111111 HHHHHCCC.
00000C70 EB4D                       		lsl.w	#5,d5				; d5 = %111HHHHH CCC00000.
00000C72 1A06                       		move.b	d6,d5				; d5 = %111HHHHH LLLLLLLL.
00000C74 C847                       		and.w	d7,d4				; d4 = %00000CCC.
00000C76 6600                       		bne.s	.StreamCopy			; if CCC=0, branch.
00000C78                             
00000C78                            		; special mode (extended counter)
00000C78 1818                       		move.b	(a0)+,d4			; Read cnt
00000C7A 6700                       		beq.s	.Quit				; If cnt=0, quit decompression.
00000C7C 5304                       		subq.b	#1,d4
00000C7E 6700 FEBC                  		beq.w	.FetchNewCode			; If cnt=1, fetch a new code.
00000C82                             
00000C82 DAC5                       		adda.w	d5,a5
00000C84 12DD                       		move.b	(a5)+,(a1)+			; Do 1 extra copy (to compensate +1 to copy counter).
00000C86 3C04                       		move.w	d4,d6
00000C88 4646                       		not.w	d6
00000C8A CC47                       		and.w	d7,d6
00000C8C DC46                       		add.w	d6,d6
00000C8E E64C                       		lsr.w	#_Kos_LoopUnroll,d4
00000C90 4EFB 6000                  		jmp	.LargeCopy(pc,d6.w)
00000C94                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000C94                            .LargeCopy:
00000C94                            	rept (1<<_Kos_LoopUnroll)
00000C94                            		move.b	(a5)+,(a1)+
00000C94                            	endr
00000C94 12DD                     M 	move.b	(a5)+,(a1)+
00000C96 12DD                     M 	move.b	(a5)+,(a1)+
00000C98 12DD                     M 	move.b	(a5)+,(a1)+
00000C9A 12DD                     M 	move.b	(a5)+,(a1)+
00000C9C 12DD                     M 	move.b	(a5)+,(a1)+
00000C9E 12DD                     M 	move.b	(a5)+,(a1)+
00000CA0 12DD                     M 	move.b	(a5)+,(a1)+
00000CA2 12DD                     M 	move.b	(a5)+,(a1)+
00000CA4 51CC FFEE                  		dbra	d4,.LargeCopy
00000CA8 6000 FE92                  		bra.w	.FetchNewCode
00000CAC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000CAC                            .StreamCopy:
00000CAC DAC5                       		adda.w	d5,a5
00000CAE 12DD                       		move.b	(a5)+,(a1)+			; Do 1 extra copy (to compensate +1 to copy counter).
00000CB0 BF44                       		eor.w	d7,d4
00000CB2 D844                       		add.w	d4,d4
00000CB4 4EFB 4000                  		jmp	.MediumCopy(pc,d4.w)
00000CB8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000CB8                            .MediumCopy:
00000CB8                            	rept 8
00000CB8                            		move.b	(a5)+,(a1)+
00000CB8                            	endr
00000CB8 12DD                     M 	move.b	(a5)+,(a1)+
00000CBA 12DD                     M 	move.b	(a5)+,(a1)+
00000CBC 12DD                     M 	move.b	(a5)+,(a1)+
00000CBE 12DD                     M 	move.b	(a5)+,(a1)+
00000CC0 12DD                     M 	move.b	(a5)+,(a1)+
00000CC2 12DD                     M 	move.b	(a5)+,(a1)+
00000CC4 12DD                     M 	move.b	(a5)+,(a1)+
00000CC6 12DD                     M 	move.b	(a5)+,(a1)+
00000CC8 6000 FE72                  		bra.w	.FetchNewCode
00000CCC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000CCC                            .Quit:
00000CCC 4E75                       		rts
00000CCE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000CCE                            KosDec_ByteMap:
00000CCE 0080 40C0 20A0 60E0 1090+  		dc.b	$00,$80,$40,$C0,$20,$A0,$60,$E0,$10,$90,$50,$D0,$30,$B0,$70,$F0
00000CDE 0888 48C8 28A8 68E8 1898+  		dc.b	$08,$88,$48,$C8,$28,$A8,$68,$E8,$18,$98,$58,$D8,$38,$B8,$78,$F8
00000CEE 0484 44C4 24A4 64E4 1494+  		dc.b	$04,$84,$44,$C4,$24,$A4,$64,$E4,$14,$94,$54,$D4,$34,$B4,$74,$F4
00000CFE 0C8C 4CCC 2CAC 6CEC 1C9C+  		dc.b	$0C,$8C,$4C,$CC,$2C,$AC,$6C,$EC,$1C,$9C,$5C,$DC,$3C,$BC,$7C,$FC
00000D0E 0282 42C2 22A2 62E2 1292+  		dc.b	$02,$82,$42,$C2,$22,$A2,$62,$E2,$12,$92,$52,$D2,$32,$B2,$72,$F2
00000D1E 0A8A 4ACA 2AAA 6AEA 1A9A+  		dc.b	$0A,$8A,$4A,$CA,$2A,$AA,$6A,$EA,$1A,$9A,$5A,$DA,$3A,$BA,$7A,$FA
00000D2E 0686 46C6 26A6 66E6 1696+  		dc.b	$06,$86,$46,$C6,$26,$A6,$66,$E6,$16,$96,$56,$D6,$36,$B6,$76,$F6
00000D3E 0E8E 4ECE 2EAE 6EEE 1E9E+  		dc.b	$0E,$8E,$4E,$CE,$2E,$AE,$6E,$EE,$1E,$9E,$5E,$DE,$3E,$BE,$7E,$FE
00000D4E 0181 41C1 21A1 61E1 1191+  		dc.b	$01,$81,$41,$C1,$21,$A1,$61,$E1,$11,$91,$51,$D1,$31,$B1,$71,$F1
00000D5E 0989 49C9 29A9 69E9 1999+  		dc.b	$09,$89,$49,$C9,$29,$A9,$69,$E9,$19,$99,$59,$D9,$39,$B9,$79,$F9
00000D6E 0585 45C5 25A5 65E5 1595+  		dc.b	$05,$85,$45,$C5,$25,$A5,$65,$E5,$15,$95,$55,$D5,$35,$B5,$75,$F5
00000D7E 0D8D 4DCD 2DAD 6DED 1D9D+  		dc.b	$0D,$8D,$4D,$CD,$2D,$AD,$6D,$ED,$1D,$9D,$5D,$DD,$3D,$BD,$7D,$FD
00000D8E 0383 43C3 23A3 63E3 1393+  		dc.b	$03,$83,$43,$C3,$23,$A3,$63,$E3,$13,$93,$53,$D3,$33,$B3,$73,$F3
00000D9E 0B8B 4BCB 2BAB 6BEB 1B9B+  		dc.b	$0B,$8B,$4B,$CB,$2B,$AB,$6B,$EB,$1B,$9B,$5B,$DB,$3B,$BB,$7B,$FB
00000DAE 0787 47C7 27A7 67E7 1797+  		dc.b	$07,$87,$47,$C7,$27,$A7,$67,$E7,$17,$97,$57,$D7,$37,$B7,$77,$F7
00000DBE 0F8F 4FCF 2FAF 6FEF 1F9F+  		dc.b	$0F,$8F,$4F,$CF,$2F,$AF,$6F,$EF,$1F,$9F,$5F,$DF,$3F,$BF,$7F,$FF
00000DCE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000DCE                            ; Enigma decompression (Mainly for plane mappings)
00000DCE                            ; New faster version by written by vladikcomper, with additional improvements by MarkeyJester and Flamewing
00000DCE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000DCE                            ; PARAMETERS:
00000DCE                            ;	d0.w	- Base tile properties (tile ID, flags, etc.)
00000DCE                            ;	a0.l	- Source address
00000DCE                            ;	a1.l	- Destination address
00000DCE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000DCE                            ; RETURNS:
00000DCE                            ;	a1.l	- End of decompressed data address
00000DCE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000DCE                            EniDec:
00000DCE                            		push.l d0-d7/a1-a5
00000DCE 48E7 FF7C                M 	movem.l	d0-d7/a1-a5,-(sp)
00000DD2 3640                       		movea.w d0,a3				; Store base tile properties
00000DD4 1018                       		move.b	(a0)+,d0
00000DD6 4880                       		ext.w	d0
00000DD8 3A40                       		movea.w d0,a5				; Store first byte, extended to word
00000DDA 1818                       		move.b	(a0)+,d4			; Store second byte
00000DDC E70C                       		lsl.b	#3,d4				; Multiply by 8
00000DDE 3458                       		movea.w (a0)+,a2			; Store third and fourth byte
00000DE0 D4CB                       		adda.w	a3,a2				; Add base tile properties
00000DE2 3858                       		movea.w (a0)+,a4			; Store fifth and sixth byte
00000DE4 D8CB                       		adda.w	a3,a4				; Add base tile properties
00000DE6 1A18                       		move.b	(a0)+,d5			; Store seventh byte
00000DE8 E145                       		asl.w	#8,d5				; Shift up by a byte
00000DEA 1A18                       		move.b	(a0)+,d5			; Store eigth byte in lower register byte
00000DEC 7C10                       		moveq	#$10,d6				; 16 bits = 2 bytes
00000DEE                            
00000DEE                            EniDec_Loop:
00000DEE 7007                       		moveq	#7,d0				; Process 7 bits at a time
00000DF0 3E06                       		move.w	d6,d7
00000DF2 9E40                       		sub.w	d0,d7
00000DF4 3205                       		move.w	d5,d1
00000DF6 EE69                       		lsr.w	d7,d1
00000DF8 0241 007F                  		andi.w	#$7F,d1				; Keep only lower 7 bits
00000DFC 3401                       		move.w	d1,d2
00000DFE 0C41 0040                  		cmpi.w	#$40,d1				; Is Bit 6 set?
00000E02 6400                       		bcc.s	.getnext			; If so, branch
00000E04 7006                       		moveq	#6,d0				; If not, process 6 bits instead of 7
00000E06 E24A                       		lsr.w	#1,d2				; Bitfield now becomes TTSSSS isntead of TTTSSSS
00000E08                            
00000E08                            .getnext:
00000E08 6100 0000                  		bsr.w	EniDec_ChkGetNextByte
00000E0C 0242 000F                  		andi.w	#$F,d2				; Keep only lower nibble
00000E10 E849                       		lsr.w	#4,d1				; Store upper nibble (max value = 7)
00000E12 D241                       		add.w	d1,d1
00000E14 4EFB 1000                  		jmp	EniDec_JmpTable(pc,d1.w)
00000E18                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E18                            EniDec_Sub0:
00000E18 32CA                       		move.w	a2,(a1)+			; Write to destination
00000E1A 524A                       		addq.w	#1,a2				; Increment
00000E1C 51CA FFFA                  		dbf	d2,EniDec_Sub0			; Repeat
00000E20 60CC                       		bra.s	EniDec_Loop
00000E22                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E22                            EniDec_Sub4:
00000E22 32CC                       		move.w	a4,(a1)+			; Write to destination
00000E24 51CA FFFC                  		dbf	d2,EniDec_Sub4			; Repeat
00000E28 60C4                       		bra.s	EniDec_Loop
00000E2A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E2A                            EniDec_Sub8:
00000E2A 6100 0000                  		bsr.w	EniDec_GetInlineCopyVal
00000E2E                            
00000E2E                            .loop1:
00000E2E 32C1                       		move.w	d1,(a1)+
00000E30 51CA FFFC                  		dbf	d2,.loop1
00000E34 60B8                       		bra.s	EniDec_Loop
00000E36                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E36                            EniDec_SubA:
00000E36 6100 0000                  		bsr.w	EniDec_GetInlineCopyVal
00000E3A                            
00000E3A                            .loop2:
00000E3A 32C1                       		move.w	d1,(a1)+
00000E3C 5241                       		addq.w	#1,d1
00000E3E 51CA FFFA                  		dbf	d2,.loop2
00000E42 60AA                       		bra.s	EniDec_Loop
00000E44                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E44                            EniDec_SubC:
00000E44 6100 0000                  		bsr.w	EniDec_GetInlineCopyVal
00000E48                            
00000E48                            .loop3:
00000E48 32C1                       		move.w	d1,(a1)+
00000E4A 5341                       		subq.w	#1,d1
00000E4C 51CA FFFA                  		dbf	d2,.loop3
00000E50 609C                       		bra.s	EniDec_Loop
00000E52                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E52                            EniDec_SubE:
00000E52 0C42 000F                  		cmpi.w	#$F,d2
00000E56 6700                       		beq.s	EniDec_End
00000E58                            
00000E58                            .loop4:
00000E58 6100 0000                  		bsr.w	EniDec_GetInlineCopyVal
00000E5C 32C1                       		move.w	d1,(a1)+
00000E5E 51CA FFF8                  		dbf	d2,.loop4
00000E62 608A                       		bra.s	EniDec_Loop
00000E64                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E64                            EniDec_JmpTable:
00000E64 60B2                       		bra.s	EniDec_Sub0
00000E66 60B0                       		bra.s	EniDec_Sub0
00000E68 60B8                       		bra.s	EniDec_Sub4
00000E6A 60B6                       		bra.s	EniDec_Sub4
00000E6C 60BC                       		bra.s	EniDec_Sub8
00000E6E 60C6                       		bra.s	EniDec_SubA
00000E70 60D2                       		bra.s	EniDec_SubC
00000E72 60DE                       		bra.s	EniDec_SubE
00000E74                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E74                            EniDec_End:
00000E74 5348                       		subq.w	#1,a0
00000E76 0C46 0010                  		cmpi.w	#16,d6				; Were we going to start on a completely new byte?
00000E7A 6600                       		bne.s	.norollback			; If not, branch
00000E7C 5348                       		subq.w	#1,a0
00000E7E                            
00000E7E                            .norollback:
00000E7E 3008                       		move.w	a0,d0
00000E80 E248                       		lsr.w	#1,d0				; Are we on an odd byte?
00000E82 6400                       		bcc.s	.evendest			; If not, branch
00000E84 5248                       		addq.w	#1,a0				; Ensure we're on an even byte
00000E86                            
00000E86                            .evendest:
00000E86                            		pop.l	d0-d7/a1-a5
00000E86 4CDF 3EFF                M 	movem.l	(sp)+,d0-d7/a1-a5
00000E8A 4E75                       		rts
00000E8C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000E8C                            EniDec_GetInlineCopyVal:
00000E8C 360B                       		move.w	a3,d3				; Store base tile properties
00000E8E 1204                       		move.b	d4,d1
00000E90 D201                       		add.b	d1,d1
00000E92 6400                       		bcc.s	.nopriority			; If d4 was < $80
00000E94 5346                       		subq.w	#1,d6				; Get next bit number
00000E96 0D05                       		btst	d6,d5				; Is the bit set?
00000E98 6700                       		beq.s	.nopriority			; If not, branch
00000E9A 0043 8000                  		ori.w	#(1<<15),d3			; Set high priority bit
00000E9E                            
00000E9E                            .nopriority:
00000E9E D201                       		add.b	d1,d1
00000EA0 6400                       		bcc.s	.nopal1				; If d4 < $40
00000EA2 5346                       		subq.w	#1,d6				; Get next bit number
00000EA4 0D05                       		btst	d6,d5				; Is the bit set?
00000EA6 6700                       		beq.s	.nopal1				; If not, branch
00000EA8 0643 4000                  		addi.w	#(2<<13),d3			; Set the second palette bit
00000EAC                            
00000EAC                            .nopal1:
00000EAC D201                       		add.b	d1,d1
00000EAE 6400                       		bcc.s	.nopal0				; If d4 was < $20
00000EB0 5346                       		subq.w	#1,d6				; Get next bit number
00000EB2 0D05                       		btst	d6,d5				; Is the bit set?
00000EB4 6700                       		beq.s	.nopal0				; If not, branch
00000EB6 0643 2000                  		addi.w	#(1<<13),d3			; Set the first palette bit
00000EBA                            
00000EBA                            .nopal0:
00000EBA D201                       		add.b	d1,d1
00000EBC 6400                       		bcc.s	.noyflip			; If d4 was < $10
00000EBE 5346                       		subq.w	#1,d6				; Get next bit number
00000EC0 0D05                       		btst	d6,d5				; Is the bit set?
00000EC2 6700                       		beq.s	.noyflip			; If not, branch
00000EC4 0043 1000                  		ori.w	#(1<<12),d3			; Set the Y flip bit
00000EC8                            
00000EC8                            .noyflip:
00000EC8 D201                       		add.b	d1,d1
00000ECA 6400                       		bcc.s	.noxflip			; If d4 was < 8
00000ECC 5346                       		subq.w	#1,d6				; Get next bit number
00000ECE 0D05                       		btst	d6,d5				; Is the bit set?
00000ED0 6700                       		beq.s	.noxflip			; If not, branch
00000ED2 0043 0800                  		ori.w	#(1<<11),d3			; Set the X flip bit
00000ED6                            
00000ED6                            .noxflip:
00000ED6 3205                       		move.w	d5,d1
00000ED8 3E06                       		move.w	d6,d7				; Get remaining bits
00000EDA 9E4D                       		sub.w	a5,d7				; Subtract minimum bit number
00000EDC 6400                       		bcc.s	.GotEnoughBits			; If we're beyond that, branch
00000EDE 3C07                       		move.w	d7,d6
00000EE0 0646 0010                  		addi.w	#16,d6				; 16 bits = 2 bytes
00000EE4 4447                       		neg.w	d7				; Calculate bit deficit
00000EE6 EF69                       		lsl.w	d7,d1				; Make space for this many bits
00000EE8 1A10                       		move.b	(a0),d5				; Get next byte
00000EEA EF3D                       		rol.b	d7,d5				; Make the upper X bits the lower X bits
00000EEC DE47                       		add.w	d7,d7
00000EEE CA7B 7000                  		and.w	EniDec_AndVals-2(pc,d7.w),d5	; Only keep X lower bits
00000EF2 D245                       		add.w	d5,d1				; Compensate for the bit deficit
00000EF4                            
00000EF4                            .AddBits:
00000EF4 300D                       		move.w	a5,d0
00000EF6 D040                       		add.w	d0,d0
00000EF8 C27B 0000                  		and.w	EniDec_AndVals-2(pc,d0.w),d1	; Only keep as many bits as required
00000EFC D243                       		add.w	d3,d1				; Add base tile properties
00000EFE 1A18                       		move.b	(a0)+,d5			; Get current byte, move onto next byte
00000F00 E14D                       		lsl.w	#8,d5				; Shift up by a byte
00000F02 1A18                       		move.b	(a0)+,d5			; Store next byte in lower register byte
00000F04 4E75                       		rts
00000F06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F06                            .GotEnoughBits:
00000F06 6700                       		beq.s	.GotExactCount			; If the exact number of bits are leftover, branch
00000F08 EE69                       		lsr.w	d7,d1				; Remove unneeded bits
00000F0A 300D                       		move.w	a5,d0
00000F0C D040                       		add.w	d0,d0
00000F0E C27B 0000                  		and.w	EniDec_AndVals-2(pc,d0.w),d1	; Only keep as many bits as required
00000F12 D243                       		add.w	d3,d1				; Add base tile properties
00000F14 300D                       		move.w	a5,d0				; Store number of bits used up by inline copy
00000F16 6000                       		bra.s	EniDec_ChkGetNextByte		; Move onto next byte
00000F18                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F18                            .GotExactCount:
00000F18 7C10                       		moveq	#16,d6				; 16 bits = 2 bytes
00000F1A 60D8                       		bra.s	.AddBits
00000F1C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F1C                            EniDec_AndVals:
00000F1C 0001 0003 0007 000F        		dc.w	1, 3, 7, $F
00000F24 001F 003F 007F 00FF        		dc.w	$1F, $3F, $7F, $FF
00000F2C 01FF 03FF 07FF 0FFF        		dc.w	$1FF, $3FF, $7FF, $FFF
00000F34 1FFF 3FFF 7FFF FFFF        		dc.w	$1FFF, $3FFF, $7FFF, $FFFF
00000F3C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F3C                            EniDec_ChkGetNextByte:
00000F3C 9C40                       		sub.w	d0,d6
00000F3E 0C46 0009                  		cmpi.w	#9,d6
00000F42 6400                       		bcc.s	.Done
00000F44 5046                       		addq.w	#8,d6				; 8 bits = 1 byte
00000F46 E145                       		asl.w	#8,d5				; Shift up by a byte
00000F48 1A18                       		move.b	(a0)+,d5			; Store next byte in lower register byte
00000F4A                            
00000F4A                            .Done:
00000F4A 4E75                       		rts
00000F4C                            ; --------------------------------------------------------------------------------------------------------------------------------------
00000F4C                            ; Load a Kosinski Moduled Queue
00000F4C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F4C                            ; PARAMETERS:
00000F4C                            ;	a3.l	- Queue pointer
00000F4C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F4C                            ; RETURNS:
00000F4C                            ;	Nothing
00000F4C                            ; --------------------------------------------------------------------------------------------------------------------------------------
00000F4C                            LoadKosMQueue:
00000F4C 3C1B                       		move.w	(a3)+,d6			; Get number of entries
00000F4E 6B00                       		bmi.s	.End				; If it's negative, branch
00000F50                            
00000F50                            .Queue:
00000F50 225B                       		movea.l	(a3)+,a1			; Get art pointer
00000F52 341B                       		move.w	(a3)+,d2			; Get VRAM address
00000F54 6100                       		bsr.s	QueueKosMData			; Queue
00000F56 51CE FFF8                  		dbf	d6,.Queue			; Loop
00000F5A                            
00000F5A                            .End:
00000F5A 4E75                       		rts
00000F5C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F5C                            ; Adds a Kosinski Moduled archive to the module queue
00000F5C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F5C                            ; PARAMETERS:
00000F5C                            ;	d2.w	- Destination in VRAM
00000F5C                            ;	a1.l	- Address of the archive
00000F5C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F5C                            ; RETURNS:
00000F5C                            ;	Nothing
00000F5C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F5C                            QueueKosMData:
00000F5C 45F8 9994                  		lea	rKosPMList.w,a2
00000F60 4A92                       		tst.l	(a2)				; Is the first slot free?
00000F62 6700                       		beq.s	ProcessKosM_Init		; If it is, branch
00000F64                            		
00000F64                            .FindFreeSlot:
00000F64 5C4A                       		addq.w	#6,a2				; Otherwise, check next slot
00000F66 4A92                       		tst.l	(a2)
00000F68 66FA                       		bne.s	.FindFreeSlot
00000F6A 24C9                       		move.l	a1,(a2)+			; Store source address
00000F6C 34C2                       		move.w	d2,(a2)+			; Store destination VRAM address
00000F6E 4E75                       		rts
00000F70                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F70                            ; Initializes processing of the first module on the queue
00000F70                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F70                            ; PARAMETERS:
00000F70                            ;	Nothing
00000F70                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F70                            ; RETURNS:
00000F70                            ;	Nothing
00000F70                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000F70                            ProcessKosM_Init:
00000F70 3619                       		move.w	(a1)+,d3			; Get uncompressed size
00000F72 0C43 A000                  		cmpi.w	#$A000,d3
00000F76 6600                       		bne.s	.GotSize
00000F78 363C 8000                  		move.w	#$8000,d3			; $A000 means $8000 for some reason
00000F7C                            
00000F7C                            .GotSize:
00000F7C E24B                       		lsr.w	#1,d3
00000F7E 3003                       		move.w	d3,d0
00000F80 EB58                       		rol.w	#5,d0
00000F82 0240 001F                  		andi.w	#$1F,d0				; Get number of complete modules
00000F86 11C0 9990                  		move.b	d0,rKosPMMods.w
00000F8A 0283 0000 07FF             		andi.l	#$7FF,d3			; Get size of last module in words
00000F90 6600                       		bne.s	.GotLeftover			; Branch if it's non-zero
00000F92 5338 9990                  		subq.b	#1,rKosPMMods.w		; Otherwise decrement the number of modules
00000F96 263C 0000 0800             		move.l	#$800,d3			; And take the size of the last module to be $800 words
00000F9C                            
00000F9C                            .GotLeftover:
00000F9C 31C3 9992                  		move.w	d3,rKosPMLastSz.w
00000FA0 31C2 9998                  		move.w	d2,rKosPMDest.w
00000FA4 21C9 9994                  		move.l	a1,rKosPMSrc.w
00000FA8 5238 9990                  		addq.b	#1,rKosPMMods.w		; Store total number of modules
00000FAC 4E75                       		rts
00000FAE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000FAE                            ; Processes the first module on the queue
00000FAE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000FAE                            ; PARAMETERS:
00000FAE                            ;	Nothing
00000FAE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000FAE                            ; RETURNS:
00000FAE                            ;	Nothing
00000FAE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000FAE                            ProcessKosM:
00000FAE 4A38 9990                  		tst.b	rKosPMMods.w
00000FB2 6600                       		bne.s	.ModulesLeft
00000FB4                            
00000FB4                            .Done:
00000FB4 4E75                       		rts
00000FB6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000FB6                            .ModulesLeft:
00000FB6 6B00                       		bmi.s	.DecompressionStarted
00000FB8 0C78 0004 994E             		cmpi.w	#(rKosPList_End-rKosPList)/8,rKosPCnt.w
00000FBE 64F4                       		bhs.s	.Done				; Branch if the Kosinski decompression queue is full
00000FC0 2278 9994                  		movea.l	rKosPMList.w,a1
00000FC4 45F8 8000                  		lea	rKosPBuf.w,a2
00000FC8 6100 0000                  		bsr.w	QueueKosData			; Add current module to decompression queue
00000FCC 0038 0080 9990             		ori.b	#$80,rKosPMMods.w		; And set bit to signify decompression in progress
00000FD2 4E75                       		rts
00000FD4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00000FD4                            .DecompressionStarted:
00000FD4 4A78 994E                  		tst.w	rKosPCnt.w
00000FD8 66DA                       		bne.s	.Done				; Branch if the decompression isn't complete
00000FDA                            
00000FDA                            		; Otherwise, DMA the decompressed data to VRAM
00000FDA 0238 007F 9990             		andi.b	#$7F,rKosPMMods.w
00000FE0 263C 0000 0800             		move.l	#$1000/2,d3
00000FE6 5338 9990                  		subq.b	#1,rKosPMMods.w
00000FEA 6600                       		bne.s	.Skip				; Branch if it isn't the last module
00000FEC 3638 9992                  		move.w	rKosPMLastSz.w,d3
00000FF0                            
00000FF0                            .Skip:
00000FF0 3438 9998                  		move.w	rKosPMDest.w,d2
00000FF4 3002                       		move.w	d2,d0
00000FF6 D043                       		add.w	d3,d0
00000FF8 D043                       		add.w	d3,d0
00000FFA 31C0 9998                  		move.w	d0,rKosPMDest.w		; Set new destination
00000FFE 2038 9994                  		move.l	rKosPMList.w,d0
00001002 2238 9970                  		move.l	rKosPList.w,d1
00001006 9081                       		sub.l	d1,d0
00001008 0280 0000 000F             		andi.l	#$F,d0
0000100E D280                       		add.l	d0,d1				; Round to the nearest $10 boundary
00001010 21C1 9994                  		move.l	d1,rKosPMList.w		; And set new source
00001014 223C FFFF 8000             		move.l	#rKosPBuf,d1
0000101A 6100 F2E8                  		bsr.w	QueueDMATransfer
0000101E 4A38 9990                  		tst.b	rKosPMMods.w
00001022 6600 0000                  		bne.w	.Exit				; Return if this wasn't the last module
00001026 41F8 9994                  		lea	rKosPMList.w,a0
0000102A 43F8 999A                  		lea	(rKosPMList+6).w,a1
0000102E                            	rept (rKosPMList_End-rKosPMList)/6-1
0000102E                            		move.l	(a1)+,(a0)+			; Otherwise, shift all entries up
0000102E                            		move.w	(a1)+,(a0)+
0000102E                            	endr
0000102E 20D9                     M 	move.l	(a1)+,(a0)+
00001030 30D9                     M 	move.w	(a1)+,(a0)+
00001032 20D9                     M 	move.l	(a1)+,(a0)+
00001034 30D9                     M 	move.w	(a1)+,(a0)+
00001036 20D9                     M 	move.l	(a1)+,(a0)+
00001038 30D9                     M 	move.w	(a1)+,(a0)+
0000103A 20D9                     M 	move.l	(a1)+,(a0)+
0000103C 30D9                     M 	move.w	(a1)+,(a0)+
0000103E 20D9                     M 	move.l	(a1)+,(a0)+
00001040 30D9                     M 	move.w	(a1)+,(a0)+
00001042 20D9                     M 	move.l	(a1)+,(a0)+
00001044 30D9                     M 	move.w	(a1)+,(a0)+
00001046 20D9                     M 	move.l	(a1)+,(a0)+
00001048 30D9                     M 	move.w	(a1)+,(a0)+
0000104A 20D9                     M 	move.l	(a1)+,(a0)+
0000104C 30D9                     M 	move.w	(a1)+,(a0)+
0000104E 20D9                     M 	move.l	(a1)+,(a0)+
00001050 30D9                     M 	move.w	(a1)+,(a0)+
00001052 20D9                     M 	move.l	(a1)+,(a0)+
00001054 30D9                     M 	move.w	(a1)+,(a0)+
00001056 20D9                     M 	move.l	(a1)+,(a0)+
00001058 30D9                     M 	move.w	(a1)+,(a0)+
0000105A 20D9                     M 	move.l	(a1)+,(a0)+
0000105C 30D9                     M 	move.w	(a1)+,(a0)+
0000105E 20D9                     M 	move.l	(a1)+,(a0)+
00001060 30D9                     M 	move.w	(a1)+,(a0)+
00001062 20D9                     M 	move.l	(a1)+,(a0)+
00001064 30D9                     M 	move.w	(a1)+,(a0)+
00001066 20D9                     M 	move.l	(a1)+,(a0)+
00001068 30D9                     M 	move.w	(a1)+,(a0)+
0000106A 20D9                     M 	move.l	(a1)+,(a0)+
0000106C 30D9                     M 	move.w	(a1)+,(a0)+
0000106E 20D9                     M 	move.l	(a1)+,(a0)+
00001070 30D9                     M 	move.w	(a1)+,(a0)+
00001072 20D9                     M 	move.l	(a1)+,(a0)+
00001074 30D9                     M 	move.w	(a1)+,(a0)+
00001076 20D9                     M 	move.l	(a1)+,(a0)+
00001078 30D9                     M 	move.w	(a1)+,(a0)+
0000107A 20D9                     M 	move.l	(a1)+,(a0)+
0000107C 30D9                     M 	move.w	(a1)+,(a0)+
0000107E 20D9                     M 	move.l	(a1)+,(a0)+
00001080 30D9                     M 	move.w	(a1)+,(a0)+
00001082 20D9                     M 	move.l	(a1)+,(a0)+
00001084 30D9                     M 	move.w	(a1)+,(a0)+
00001086 20D9                     M 	move.l	(a1)+,(a0)+
00001088 30D9                     M 	move.w	(a1)+,(a0)+
0000108A 20D9                     M 	move.l	(a1)+,(a0)+
0000108C 30D9                     M 	move.w	(a1)+,(a0)+
0000108E 20D9                     M 	move.l	(a1)+,(a0)+
00001090 30D9                     M 	move.w	(a1)+,(a0)+
00001092 20D9                     M 	move.l	(a1)+,(a0)+
00001094 30D9                     M 	move.w	(a1)+,(a0)+
00001096 20D9                     M 	move.l	(a1)+,(a0)+
00001098 30D9                     M 	move.w	(a1)+,(a0)+
0000109A 20D9                     M 	move.l	(a1)+,(a0)+
0000109C 30D9                     M 	move.w	(a1)+,(a0)+
0000109E 20D9                     M 	move.l	(a1)+,(a0)+
000010A0 30D9                     M 	move.w	(a1)+,(a0)+
000010A2 20D9                     M 	move.l	(a1)+,(a0)+
000010A4 30D9                     M 	move.w	(a1)+,(a0)+
000010A6 20D9                     M 	move.l	(a1)+,(a0)+
000010A8 30D9                     M 	move.w	(a1)+,(a0)+
000010AA 4298                       		clr.l	(a0)+				; And mark the last slot as free
000010AC 4258                       		clr.w	(a0)+
000010AE 2038 9994                  		move.l	rKosPMList.w,d0
000010B2 6700                       		beq.s	.Exit				; Return if the queue is now empty
000010B4 2240                       		movea.l	d0,a1
000010B6 3438 9998                  		move.w	rKosPMDest.w,d2
000010BA 6000 FEB4                  		bra.w	ProcessKosM_Init
000010BE                            
000010BE                            .Exit:
000010BE 4E75                       		rts
000010C0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000010C0                            ; Adds Kosinski-compressed data to the decompression queue
000010C0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000010C0                            ; PARAMETERS:
000010C0                            ;	a1.l	- Compressed data address
000010C0                            ;	a2.l	- Decompression destination in RAM
000010C0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000010C0                            ; RETURNS:
000010C0                            ;	Nothing
000010C0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000010C0                            QueueKosData:
000010C0 3038 994E                  		move.w	rKosPCnt.w,d0
000010C4 E748                       		lsl.w	#3,d0
000010C6 47F8 9970                  		lea	rKosPList.w,a3
000010CA 2789 0000                  		move.l	a1,(a3,d0.w)			; Store source
000010CE 278A 0004                  		move.l	a2,4(a3,d0.w)			; Store destination
000010D2 5278 994E                  		addq.w	#1,rKosPCnt.w
000010D6 4E75                       		rts
000010D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000010D8                            ; Checks if V-INT occured in the middle of Kosinski queue processing and stores the location from which processing is to resume if it did
000010D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000010D8                            ; PARAMETERS:
000010D8                            ;	Nothing
000010D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000010D8                            ; RETURNS:
000010D8                            ;	Nothing
000010D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000010D8                            SetKosBookmark:
000010D8 4A78 994E                  		tst.w	rKosPCnt.w
000010DC 6A00                       		bpl.s	.Done				; Branch if a decompression wasn't in progress
000010DE 202F 0042                  		move.l	$42(sp),d0			; Check address V-INT is supposed to rte to
000010E2 0C80 0000 0000             		cmpi.l	#ProcessKos_Main,d0
000010E8 6500                       		bcs.s	.Done
000010EA 0C80 0000 0000             		cmpi.l	#ProcessKos_Done,d0
000010F0 6400                       		bcc.s	.Done
000010F2 21EF 0042 996C             		move.l	$42(sp),rKosPBookmark.w
000010F8 2F7C 0000 0000 0042        		move.l	#BackupKosRegs,$42(sp)		; Force V-INT to rte here instead if needed
00001100                            
00001100                            .Done:
00001100 4E75                       		rts
00001102                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001102                            ; Processes the first entry in the Kosinski decompression queue
00001102                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001102                            ; PARAMETERS:
00001102                            ;	Nothing
00001102                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001102                            ; RETURNS:
00001102                            ;	Nothing
00001102                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001102                            ProcessKos:
00001102 4A78 994E                  		tst.w	rKosPCnt.w
00001106 6700 0000                  		beq.w	ProcessKos_Done
0000110A 6B00 0000                  		bmi.w	RestoreKosBookmark		; Branch if a decompression was interrupted by V-int
0000110E                            
0000110E                            ProcessKos_Main:
0000110E 0078 8000 994E             		ori.w	#$8000,rKosPCnt.w	; Set sign bit to signify decompression in progress
00001114 2078 9970                  		movea.l	rKosPList.w,a0
00001118 2278 9974                  		movea.l	rKosPDest.w,a1
0000111C                            		
0000111C                            		; What follows is identical to the normal Kosinski decompressor
0000111C 7E07                       		moveq	#(1<<_Kos_LoopUnroll)-1,d7
0000111E 7000                       		moveq	#0,d0
00001120 7200                       		moveq	#0,d1
00001122 49FA FBAA                  		lea	KosDec_ByteMap(pc),a4		; Load LUT pointer.
00001126 1018                       		move.b	(a0)+,d0			; Get desc field low-byte.
00001128 1218                       		move.b	(a0)+,d1			; Get desc field hi-byte.
0000112A 1034 0000                  		move.b	(a4,d0.w),d0			; Invert bit order...
0000112E 1234 1000                  		move.b	(a4,d1.w),d1			; ... for both bytes.
00001132 7407                       		moveq	#7,d2				; Set repeat count to 8.
00001134 7600                       		moveq	#0,d3				; d3 will be desc field switcher.
00001136 6000                       		bra.s	.FetchNewCode
00001138                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001138                            .FetchCodeLoop:
00001138                            		; Code 1 (Uncompressed byte).
00001138                            		_Kos_RunBitStream
00001138 51CA 0000                M 	dbra	d2,.skip_47
0000113C 7407                     M 	moveq	#7,d2
0000113E 1001                     M 	move.b	d1,d0
00001140 4643                     M 	not.w	d3
00001142 6600                     M 	bne.s	.skip_47
00001144 1018                     M 	move.b	(a0)+,d0
00001146 1218                     M 	move.b	(a0)+,d1
00001148 1034 0000                M 	move.b	(a4,d0.w),d0
0000114C 1234 1000                M 	move.b	(a4,d1.w),d1
00001150                          M .skip_47:
00001150 12D8                       		move.b	(a0)+,(a1)+
00001152                            
00001152                            .FetchNewCode:
00001152                            		_Kos_ReadBit
00001152 D000                     M 	add.b	d0,d0
00001154 65E2                       		bcs.s	.FetchCodeLoop			; If code = 1, branch.
00001156                            
00001156                            		; Codes 00 and 01.
00001156 7AFF                       		moveq	#-1,d5
00001158 4BD1                       		lea	(a1),a5
0000115A                            		_Kos_RunBitStream
0000115A 51CA 0000                M 	dbra	d2,.skip_49
0000115E 7407                     M 	moveq	#7,d2
00001160 1001                     M 	move.b	d1,d0
00001162 4643                     M 	not.w	d3
00001164 6600                     M 	bne.s	.skip_49
00001166 1018                     M 	move.b	(a0)+,d0
00001168 1218                     M 	move.b	(a0)+,d1
0000116A 1034 0000                M 	move.b	(a4,d0.w),d0
0000116E 1234 1000                M 	move.b	(a4,d1.w),d1
00001172                          M .skip_49:
00001172                            		_Kos_ReadBit
00001172 D000                     M 	add.b	d0,d0
00001174 6500 0000                  		bcs.w	.Code_01
00001178                            
00001178                            		; Code 00 (Dictionary ref. short).
00001178                            		_Kos_RunBitStream
00001178 51CA 0000                M 	dbra	d2,.skip_51
0000117C 7407                     M 	moveq	#7,d2
0000117E 1001                     M 	move.b	d1,d0
00001180 4643                     M 	not.w	d3
00001182 6600                     M 	bne.s	.skip_51
00001184 1018                     M 	move.b	(a0)+,d0
00001186 1218                     M 	move.b	(a0)+,d1
00001188 1034 0000                M 	move.b	(a4,d0.w),d0
0000118C 1234 1000                M 	move.b	(a4,d1.w),d1
00001190                          M .skip_51:
00001190                            		_Kos_ReadBit
00001190 D000                     M 	add.b	d0,d0
00001192 6500                       		bcs.s	.Copy45
00001194                            		_Kos_RunBitStream
00001194 51CA 0000                M 	dbra	d2,.skip_53
00001198 7407                     M 	moveq	#7,d2
0000119A 1001                     M 	move.b	d1,d0
0000119C 4643                     M 	not.w	d3
0000119E 6600                     M 	bne.s	.skip_53
000011A0 1018                     M 	move.b	(a0)+,d0
000011A2 1218                     M 	move.b	(a0)+,d1
000011A4 1034 0000                M 	move.b	(a4,d0.w),d0
000011A8 1234 1000                M 	move.b	(a4,d1.w),d1
000011AC                          M .skip_53:
000011AC                            		_Kos_ReadBit
000011AC D000                     M 	add.b	d0,d0
000011AE 6500                       		bcs.s	.Copy3
000011B0                            		_Kos_RunBitStream
000011B0 51CA 0000                M 	dbra	d2,.skip_55
000011B4 7407                     M 	moveq	#7,d2
000011B6 1001                     M 	move.b	d1,d0
000011B8 4643                     M 	not.w	d3
000011BA 6600                     M 	bne.s	.skip_55
000011BC 1018                     M 	move.b	(a0)+,d0
000011BE 1218                     M 	move.b	(a0)+,d1
000011C0 1034 0000                M 	move.b	(a4,d0.w),d0
000011C4 1234 1000                M 	move.b	(a4,d1.w),d1
000011C8                          M .skip_55:
000011C8 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
000011CA DAC5                       		adda.w	d5,a5
000011CC 12DD                       		move.b	(a5)+,(a1)+
000011CE 12DD                       		move.b	(a5)+,(a1)+
000011D0 6080                       		bra.s	.FetchNewCode
000011D2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000011D2                            .Copy3:
000011D2                            		_Kos_RunBitStream
000011D2 51CA 0000                M 	dbra	d2,.skip_56
000011D6 7407                     M 	moveq	#7,d2
000011D8 1001                     M 	move.b	d1,d0
000011DA 4643                     M 	not.w	d3
000011DC 6600                     M 	bne.s	.skip_56
000011DE 1018                     M 	move.b	(a0)+,d0
000011E0 1218                     M 	move.b	(a0)+,d1
000011E2 1034 0000                M 	move.b	(a4,d0.w),d0
000011E6 1234 1000                M 	move.b	(a4,d1.w),d1
000011EA                          M .skip_56:
000011EA 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
000011EC DAC5                       		adda.w	d5,a5
000011EE 12DD                       		move.b	(a5)+,(a1)+
000011F0 12DD                       		move.b	(a5)+,(a1)+
000011F2 12DD                       		move.b	(a5)+,(a1)+
000011F4 6000 FF5C                  		bra.w	.FetchNewCode
000011F8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000011F8                            .Copy45:
000011F8                            		_Kos_RunBitStream
000011F8 51CA 0000                M 	dbra	d2,.skip_57
000011FC 7407                     M 	moveq	#7,d2
000011FE 1001                     M 	move.b	d1,d0
00001200 4643                     M 	not.w	d3
00001202 6600                     M 	bne.s	.skip_57
00001204 1018                     M 	move.b	(a0)+,d0
00001206 1218                     M 	move.b	(a0)+,d1
00001208 1034 0000                M 	move.b	(a4,d0.w),d0
0000120C 1234 1000                M 	move.b	(a4,d1.w),d1
00001210                          M .skip_57:
00001210                            		_Kos_ReadBit
00001210 D000                     M 	add.b	d0,d0
00001212 6500                       		bcs.s	.Copy5
00001214                            		_Kos_RunBitStream
00001214 51CA 0000                M 	dbra	d2,.skip_59
00001218 7407                     M 	moveq	#7,d2
0000121A 1001                     M 	move.b	d1,d0
0000121C 4643                     M 	not.w	d3
0000121E 6600                     M 	bne.s	.skip_59
00001220 1018                     M 	move.b	(a0)+,d0
00001222 1218                     M 	move.b	(a0)+,d1
00001224 1034 0000                M 	move.b	(a4,d0.w),d0
00001228 1234 1000                M 	move.b	(a4,d1.w),d1
0000122C                          M .skip_59:
0000122C 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
0000122E DAC5                       		adda.w	d5,a5
00001230 12DD                       		move.b	(a5)+,(a1)+
00001232 12DD                       		move.b	(a5)+,(a1)+
00001234 12DD                       		move.b	(a5)+,(a1)+
00001236 12DD                       		move.b	(a5)+,(a1)+
00001238 6000 FF18                  		bra.w	.FetchNewCode
0000123C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000123C                            .Copy5:
0000123C                            		_Kos_RunBitStream
0000123C 51CA 0000                M 	dbra	d2,.skip_60
00001240 7407                     M 	moveq	#7,d2
00001242 1001                     M 	move.b	d1,d0
00001244 4643                     M 	not.w	d3
00001246 6600                     M 	bne.s	.skip_60
00001248 1018                     M 	move.b	(a0)+,d0
0000124A 1218                     M 	move.b	(a0)+,d1
0000124C 1034 0000                M 	move.b	(a4,d0.w),d0
00001250 1234 1000                M 	move.b	(a4,d1.w),d1
00001254                          M .skip_60:
00001254 1A18                       		move.b	(a0)+,d5			; d5 = displacement.
00001256 DAC5                       		adda.w	d5,a5
00001258 12DD                       		move.b	(a5)+,(a1)+
0000125A 12DD                       		move.b	(a5)+,(a1)+
0000125C 12DD                       		move.b	(a5)+,(a1)+
0000125E 12DD                       		move.b	(a5)+,(a1)+
00001260 12DD                       		move.b	(a5)+,(a1)+
00001262 6000 FEEE                  		bra.w	.FetchNewCode
00001266                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001266                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001266                            .Code_01:
00001266 7800                       		moveq	#0,d4				; d4 will contain copy count.
00001268                            		; Code 01 (Dictionary ref. long / special).
00001268                            		_Kos_RunBitStream
00001268 51CA 0000                M 	dbra	d2,.skip_61
0000126C 7407                     M 	moveq	#7,d2
0000126E 1001                     M 	move.b	d1,d0
00001270 4643                     M 	not.w	d3
00001272 6600                     M 	bne.s	.skip_61
00001274 1018                     M 	move.b	(a0)+,d0
00001276 1218                     M 	move.b	(a0)+,d1
00001278 1034 0000                M 	move.b	(a4,d0.w),d0
0000127C 1234 1000                M 	move.b	(a4,d1.w),d1
00001280                          M .skip_61:
00001280 1C18                       		move.b	(a0)+,d6			; d6 = %LLLLLLLL.
00001282 1818                       		move.b	(a0)+,d4			; d4 = %HHHHHCCC.
00001284 1A04                       		move.b	d4,d5				; d5 = %11111111 HHHHHCCC.
00001286 EB4D                       		lsl.w	#5,d5				; d5 = %111HHHHH CCC00000.
00001288 1A06                       		move.b	d6,d5				; d5 = %111HHHHH LLLLLLLL.
0000128A C847                       		and.w	d7,d4				; d4 = %00000CCC.
0000128C 6600                       		bne.s	.StreamCopy			; if CCC=0, branch.
0000128E                            
0000128E                            		; special mode (extended counter)
0000128E 1818                       		move.b	(a0)+,d4			; Read cnt
00001290 6700                       		beq.s	.Quit				; If cnt=0, quit decompression.
00001292 5304                       		subq.b	#1,d4
00001294 6700 FEBC                  		beq.w	.FetchNewCode			; If cnt=1, fetch a new code.
00001298                            
00001298 DAC5                       		adda.w	d5,a5
0000129A 12DD                       		move.b	(a5)+,(a1)+			; Do 1 extra copy (to compensate +1 to copy counter).
0000129C 3C04                       		move.w	d4,d6
0000129E 4646                       		not.w	d6
000012A0 CC47                       		and.w	d7,d6
000012A2 DC46                       		add.w	d6,d6
000012A4 E64C                       		lsr.w	#_Kos_LoopUnroll,d4
000012A6 4EFB 6000                  		jmp	.LargeCopy(pc,d6.w)
000012AA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000012AA                            .LargeCopy:
000012AA                            	rept (1<<_Kos_LoopUnroll)
000012AA                            		move.b	(a5)+,(a1)+
000012AA                            	endr
000012AA 12DD                     M 	move.b	(a5)+,(a1)+
000012AC 12DD                     M 	move.b	(a5)+,(a1)+
000012AE 12DD                     M 	move.b	(a5)+,(a1)+
000012B0 12DD                     M 	move.b	(a5)+,(a1)+
000012B2 12DD                     M 	move.b	(a5)+,(a1)+
000012B4 12DD                     M 	move.b	(a5)+,(a1)+
000012B6 12DD                     M 	move.b	(a5)+,(a1)+
000012B8 12DD                     M 	move.b	(a5)+,(a1)+
000012BA 51CC FFEE                  		dbra	d4,.LargeCopy
000012BE 6000 FE92                  		bra.w	.FetchNewCode
000012C2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000012C2                            .StreamCopy:
000012C2 DAC5                       		adda.w	d5,a5
000012C4 12DD                       		move.b	(a5)+,(a1)+			; Do 1 extra copy (to compensate +1 to copy counter).
000012C6 BF44                       		eor.w	d7,d4
000012C8 D844                       		add.w	d4,d4
000012CA 4EFB 4000                  		jmp	.MediumCopy(pc,d4.w)
000012CE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000012CE                            .MediumCopy:
000012CE                            	rept 8
000012CE                            		move.b	(a5)+,(a1)+
000012CE                            	endr
000012CE 12DD                     M 	move.b	(a5)+,(a1)+
000012D0 12DD                     M 	move.b	(a5)+,(a1)+
000012D2 12DD                     M 	move.b	(a5)+,(a1)+
000012D4 12DD                     M 	move.b	(a5)+,(a1)+
000012D6 12DD                     M 	move.b	(a5)+,(a1)+
000012D8 12DD                     M 	move.b	(a5)+,(a1)+
000012DA 12DD                     M 	move.b	(a5)+,(a1)+
000012DC 12DD                     M 	move.b	(a5)+,(a1)+
000012DE 6000 FE72                  		bra.w	.FetchNewCode
000012E2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000012E2                            .Quit:	
000012E2 21C8 9970                  		move.l	a0,rKosPList.w
000012E6 21C9 9974                  		move.l	a1,rKosPDest.w
000012EA 0278 7FFF 994E             		andi.w	#$7FFF,rKosPCnt.w		; Clear decompression in progress bit
000012F0 5378 994E                  		subq.w	#1,rKosPCnt.w
000012F4 6700                       		beq.s	ProcessKos_Done			; Branch if there aren't any entries remaining in the queue
000012F6 41F8 9970                  		lea	rKosPList.w,a0
000012FA 43F8 9978                  		lea	(rKosPList+8).w,a1		; Otherwise, shift all entries up
000012FE                            	rept (rKosPList_End-rKosPList)/8-1
000012FE                            		move.l	(a1)+,(a0)+
000012FE                            		move.l	(a1)+,(a0)+
000012FE                            	endr
000012FE 20D9                     M 	move.l	(a1)+,(a0)+
00001300 20D9                     M 	move.l	(a1)+,(a0)+
00001302 20D9                     M 	move.l	(a1)+,(a0)+
00001304 20D9                     M 	move.l	(a1)+,(a0)+
00001306 20D9                     M 	move.l	(a1)+,(a0)+
00001308 20D9                     M 	move.l	(a1)+,(a0)+
0000130A                            
0000130A                            ProcessKos_Done:
0000130A 4E75                       		rts
0000130C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000130C                            RestoreKosBookmark:
0000130C 4CB8 007F 9950             		movem.w	rKosPRegs.w,d0-d6
00001312 4CF8 2300 995E             		movem.l	(rKosPRegs+2*7).w,a0-a1/a5
00001318 2F38 996C                  		move.l	rKosPBookmark.w,-(sp)
0000131C 3F38 996A                  		move.w	rKosPSR.w,-(sp)
00001320 7E07                       		moveq	#(1<<_Kos_LoopUnroll)-1,d7
00001322 49FA F9AA                  		lea	KosDec_ByteMap(pc),a4		; Load LUT poiner
00001326 4E73                       		rte
00001328                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001328                            BackupKosRegs:
00001328 40F8 996A                  		move	sr,rKosPSR.w
0000132C 48B8 007F 9950             		movem.w	d0-d6,rKosPRegs.w
00001332 48F8 2300 995E             		movem.l	a0-a1/a5,(rKosPRegs+2*7).w
00001338 4E75                       		rts
0000133A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000133A                            ; Load Kosinski compressed art into VRAM
0000133A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000133A                            ; PARAMETERS:
0000133A                            ;	a0.l	- Source address
0000133A                            ;	a1.l	- Destination address
0000133A                            ;	a2.w	- VRAM address
0000133A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000133A                            ; RETURNS:
0000133A                            ;	Nothing
0000133A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000133A                            LoadKosArt:
0000133A 2649                       		movea.l	a1,a3				; Save destination address
0000133C 6100 F7C8                  		bsr.w	KosDec				; Decompress the art
00001340                            
00001340 93CB                       		suba.l	a3,a1				; Get size of decompressed art
00001342 3609                       		move.w	a1,d3				; ''
00001344 E24B                       		lsr.w	#1,d3				; Divide by 2 for DMA
00001346 220B                       		move.l	a3,d1				; Use destination address for DMA source
00001348 340A                       		move.w	a2,d2				; Get destination VRAM address
0000134A 6000 EFB8                  		bra.w	QueueDMATransfer		; Queue a DMA transfer
0000134E                            ; =========================================================================================================================================================
0000134E                            		include	"Libraries/Math.asm"		; Math functions
0000134E                            ; =========================================================================================================================================================
0000134E                            ; Math functions
0000134E                            ; =========================================================================================================================================================
0000134E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000134E                            ; Get a pseudo random number
0000134E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000134E                            ; PARAMETERS:
0000134E                            ;	Nothing
0000134E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000134E                            ; RETURNS:
0000134E                            ;	d0.l	- Random number
0000134E                            ;	d1.l	- New seed
0000134E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000134E                            RandomNumber:
0000134E 2238 C760                  		move.l	rRNGSeed.w,d1			; Get seed
00001352 6600                       		bne.s	.Generate			; If it's already initialized, branch
00001354 223C 2A6D 365B             		move.l	#$2A6D365B,d1			; Initialize the seed
0000135A                            
0000135A                            .Generate:
0000135A 2001                       		move.l	d1,d0				; Do a bunch of calculations to get a "random" number
0000135C E581                       		asl.l	#2,d1				; ''
0000135E D280                       		add.l	d0,d1				; ''
00001360 E781                       		asl.l	#3,d1				; ''
00001362 D280                       		add.l	d0,d1				; ''
00001364 3001                       		move.w	d1,d0				; ''
00001366 4841                       		swap	d1				; ''
00001368 D041                       		add.w	d1,d0				; ''
0000136A 3200                       		move.w	d0,d1				; ''
0000136C 4841                       		swap	d1				; ''
0000136E 21C1 C760                  		move.l	d1,rRNGSeed.w			; Set new seed
00001372 4E75                       		rts
00001374                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001374                            ; Calculate the sine and cosine of an angle
00001374                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001374                            ; PARAMETERS:
00001374                            ;	d0.b	- Angle
00001374                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001374                            ; RETURNS:
00001374                            ;	d0.w	- Sine value
00001374                            ;	d1.w	- Cosine value	
00001374                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001374                            CalcSine:
00001374 0240 00FF                  		andi.w	#$FF,d0				; Only allow angles 0-$FF
00001378 5040                       		addq.w	#8,d0				; Turn into offset
0000137A D040                       		add.w	d0,d0				; ''
0000137C 323B 0000                  		move.w	SineTable-$10+$80(pc,d0.w),d1	; Get cosine value
00001380 303B 0000                  		move.w	SineTable-$10(pc,d0.w),d0	; Get sine value
00001384 4E75                       		rts
00001386                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001386                            SineTable:
00001386 0000 0006 000C 0012 0019+  		dc.w	$0000, $0006, $000C, $0012, $0019, $001F, $0025, $002B, $0031, $0038, $003E, $0044, $004A, $0050, $0056, $005C
000013A6 0061 0067 006D 0073 0078+  		dc.w	$0061, $0067, $006D, $0073, $0078, $007E, $0083, $0088, $008E, $0093, $0098, $009D, $00A2, $00A7, $00AB, $00B0
000013C6 00B5 00B9 00BD 00C1 00C5+  		dc.w	$00B5, $00B9, $00BD, $00C1, $00C5, $00C9, $00CD, $00D1, $00D4, $00D8, $00DB, $00DE, $00E1, $00E4, $00E7, $00EA
000013E6 00EC 00EE 00F1 00F3 00F4+  		dc.w	$00EC, $00EE, $00F1, $00F3, $00F4, $00F6, $00F8, $00F9, $00FB, $00FC, $00FD, $00FE, $00FE, $00FF, $00FF, $00FF
00001406 0100 00FF 00FF 00FF 00FE+  		dc.w	$0100, $00FF, $00FF, $00FF, $00FE, $00FE, $00FD, $00FC, $00FB, $00F9, $00F8, $00F6, $00F4, $00F3, $00F1, $00EE
00001426 00EC 00EA 00E7 00E4 00E1+  		dc.w	$00EC, $00EA, $00E7, $00E4, $00E1, $00DE, $00DB, $00D8, $00D4, $00D1, $00CD, $00C9, $00C5, $00C1, $00BD, $00B9
00001446 00B5 00B0 00AB 00A7 00A2+  		dc.w	$00B5, $00B0, $00AB, $00A7, $00A2, $009D, $0098, $0093, $008E, $0088, $0083, $007E, $0078, $0073, $006D, $0067
00001466 0061 005C 0056 0050 004A+  		dc.w	$0061, $005C, $0056, $0050, $004A, $0044, $003E, $0038, $0031, $002B, $0025, $001F, $0019, $0012, $000C, $0006
00001486 0000 FFFA FFF4 FFEE FFE7+  		dc.w	$0000, $FFFA, $FFF4, $FFEE, $FFE7, $FFE1, $FFDB, $FFD5, $FFCF, $FFC8, $FFC2, $FFBC, $FFB6, $FFB0, $FFAA, $FFA4
000014A6 FF9F FF99 FF93 FF8B FF88+  		dc.w	$FF9F, $FF99, $FF93, $FF8B, $FF88, $FF82, $FF7D, $FF78, $FF72, $FF6D, $FF68, $FF63, $FF5E, $FF59, $FF55, $FF50
000014C6 FF4B FF47 FF43 FF3F FF3B+  		dc.w	$FF4B, $FF47, $FF43, $FF3F, $FF3B, $FF37, $FF33, $FF2F, $FF2C, $FF28, $FF25, $FF22, $FF1F, $FF1C, $FF19, $FF16
000014E6 FF14 FF12 FF0F FF0D FF0C+  		dc.w	$FF14, $FF12, $FF0F, $FF0D, $FF0C, $FF0A, $FF08, $FF07, $FF05, $FF04, $FF03, $FF02, $FF02, $FF01, $FF01, $FF01
00001506 FF00 FF01 FF01 FF01 FF02+  		dc.w	$FF00, $FF01, $FF01, $FF01, $FF02, $FF02, $FF03, $FF04, $FF05, $FF07, $FF08, $FF0A, $FF0C, $FF0D, $FF0F, $FF12
00001526 FF14 FF16 FF19 FF1C FF1F+  		dc.w	$FF14, $FF16, $FF19, $FF1C, $FF1F, $FF22, $FF25, $FF28, $FF2C, $FF2F, $FF33, $FF37, $FF3B, $FF3F, $FF43, $FF47
00001546 FF4B FF50 FF55 FF59 FF5E+  		dc.w	$FF4B, $FF50, $FF55, $FF59, $FF5E, $FF63, $FF68, $FF6D, $FF72, $FF78, $FF7D, $FF82, $FF88, $FF8B, $FF93, $FF99
00001566 FF9F FFA4 FFAA FFB0 FFB6+  		dc.w	$FF9F, $FFA4, $FFAA, $FFB0, $FFB6, $FFBC, $FFC2, $FFC8, $FFCF, $FFD5, $FFDB, $FFE1, $FFE7, $FFEE, $FFF4, $FFFA
00001586 0000 0006 000C 0012 0019+  		dc.w	$0000, $0006, $000C, $0012, $0019, $001F, $0025, $002B, $0031, $0038, $003E, $0044, $004A, $0050, $0056, $005C
000015A6 0061 0067 006D 0073 0078+  		dc.w	$0061, $0067, $006D, $0073, $0078, $007E, $0083, $0088, $008E, $0093, $0098, $009D, $00A2, $00A7, $00AB, $00B0
000015C6 00B5 00B9 00BD 00C1 00C5+  		dc.w	$00B5, $00B9, $00BD, $00C1, $00C5, $00C9, $00CD, $00D1, $00D4, $00D8, $00DB, $00DE, $00E1, $00E4, $00E7, $00EA
000015E6 00EC 00EE 00F1 00F3 00F4+  		dc.w	$00EC, $00EE, $00F1, $00F3, $00F4, $00F6, $00F8, $00F9, $00FB, $00FC, $00FD, $00FE, $00FE, $00FF, $00FF, $00FF
00001606 0100 00FF 00FF 00FF 00FE+  		dc.w	$0100, $00FF, $00FF, $00FF, $00FE, $00FE, $00FD, $00FC, $00FB, $00F9, $00F8, $00F6, $00F4, $00F3, $00F1, $00EE
00001626 00EC 00EA 00E7 00E4 00E1+  		dc.w	$00EC, $00EA, $00E7, $00E4, $00E1, $00DE, $00DB, $00D8, $00D4, $00D1, $00CD, $00C9, $00C5, $00C1, $00BD, $00B9
00001646 00B5 00B0 00AB 00A7 00A2+  		dc.w	$00B5, $00B0, $00AB, $00A7, $00A2, $009D, $0098, $0093, $008E, $0088, $0083, $007E, $0078, $0073, $006D, $0067
00001666 0061 005C 0056 0050 004A+  		dc.w	$0061, $005C, $0056, $0050, $004A, $0044, $003E, $0038, $0031, $002B, $0025, $001F, $0019, $0012, $000C, $0006
00001686 0000 FFFA FFF4 FFEE FFE7+  		dc.w	$0000, $FFFA, $FFF4, $FFEE, $FFE7, $FFE1, $FFDB, $FFD5, $FFCF, $FFC8, $FFC2, $FFBC, $FFB6, $FFB0, $FFAA, $FFA4
000016A6 FF9F FF99 FF93 FF8B FF88+  		dc.w	$FF9F, $FF99, $FF93, $FF8B, $FF88, $FF82, $FF7D, $FF78, $FF72, $FF6D, $FF68, $FF63, $FF5E, $FF59, $FF55, $FF50
000016C6 FF4B FF47 FF43 FF3F FF3B+  		dc.w	$FF4B, $FF47, $FF43, $FF3F, $FF3B, $FF37, $FF33, $FF2F, $FF2C, $FF28, $FF25, $FF22, $FF1F, $FF1C, $FF19, $FF16
000016E6 FF14 FF12 FF0F FF0D FF0C+  		dc.w	$FF14, $FF12, $FF0F, $FF0D, $FF0C, $FF0A, $FF08, $FF07, $FF05, $FF04, $FF03, $FF02, $FF02, $FF01, $FF01, $FF01
00001706 FF00 FF01 FF01 FF01 FF02+  		dc.w	$FF00, $FF01, $FF01, $FF01, $FF02, $FF02, $FF03, $FF04, $FF05, $FF07, $FF08, $FF0A, $FF0C, $FF0D, $FF0F, $FF12
00001726 FF14 FF16 FF19 FF1C FF1F+  		dc.w	$FF14, $FF16, $FF19, $FF1C, $FF1F, $FF22, $FF25, $FF28, $FF2C, $FF2F, $FF33, $FF37, $FF3B, $FF3F, $FF43, $FF47
00001746 FF4B FF50 FF55 FF59 FF5E+  		dc.w	$FF4B, $FF50, $FF55, $FF59, $FF5E, $FF63, $FF68, $FF6D, $FF72, $FF78, $FF7D, $FF82, $FF88, $FF8B, $FF93, $FF99
00001766 FF9F FFA4 FFAA FFB0 FFB6+  		dc.w	$FF9F, $FFA4, $FFAA, $FFB0, $FFB6, $FFBC, $FFC2, $FFC8, $FFCF, $FFD5, $FFDB, $FFE1, $FFE7, $FFEE, $FFF4, $FFFA
00001786                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001786                            ; Calculate the arctangent of y/x
00001786                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001786                            ; PARAMETERS:
00001786                            ;	d1.w	- X position
00001786                            ;	d2.w	- Y position
00001786                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001786                            ; RETURNS:
00001786                            ;	d0.w	- The angle
00001786                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001786                            CalcArcTan:
00001786                            		push.l	d3-d4
00001786 48E7 1800                M 	movem.l	d3-d4,-(sp)
0000178A 7600                       		moveq	#0,d3
0000178C 7800                       		moveq	#0,d4
0000178E 3601                       		move.w	d1,d3
00001790 3802                       		move.w	d2,d4
00001792 8843                       		or.w	d3,d4
00001794 6700                       		beq.s	GetArcTan_Zero			; Special case when both x and y are zero
00001796 3802                       		move.w	d2,d4
00001798                            		
00001798 4A43                       		tst.w	d3
0000179A 6A00                       		bpl.s	.NotNeg
0000179C 4443                       		neg.w	d3
0000179E                            
0000179E                            .NotNeg:
0000179E 4A44                       		tst.w	d4
000017A0 6A00                       		bpl.s	.NotNeg2
000017A2 4444                       		neg.w	d4
000017A4                            
000017A4                            .NotNeg2:
000017A4 B843                       		cmp.w	d3,d4
000017A6 6400                       		bhs.s	.NotGreater			; If |y| >= |x|
000017A8 E18C                       		lsl.l	#8,d4
000017AA 88C3                       		divu.w	d3,d4
000017AC 7000                       		moveq	#0,d0
000017AE 103B 4000                  		move.b	ArcTanTable(pc,d4.w),d0
000017B2 6000                       		bra.s	.Skip
000017B4                            
000017B4                            .NotGreater:
000017B4 E18B                       		lsl.l	#8,d3
000017B6 86C4                       		divu.w	d4,d3
000017B8 7040                       		moveq	#$40,d0
000017BA 903B 3000                  		sub.b	ArcTanTable(pc,d3.w),d0		; arctan(y/x) = 90 - arctan(x/y)
000017BE                            
000017BE                            .Skip:
000017BE 4A41                       		tst.w	d1
000017C0 6A00                       		bpl.s	.Skip2
000017C2 4440                       		neg.w	d0
000017C4 0640 0080                  		addi.w	#$80,d0				; Place angle in appropriate quadrant
000017C8                            
000017C8                            .Skip2:
000017C8 4A42                       		tst.w	d2
000017CA 6A00                       		bpl.s	.Skip3
000017CC 4440                       		neg.w	d0
000017CE 0640 0100                  		addi.w	#$100,d0			; Place angle in appropriate quadrant
000017D2                            
000017D2                            .Skip3:
000017D2                            		pop.l	d3-d4
000017D2 4CDF 0018                M 	movem.l	(sp)+,d3-d4
000017D6 4E75                       		rts
000017D8                            
000017D8                            GetArcTan_Zero:
000017D8 303C 0040                  		move.w	#$40,d0				; Angle = 90 degrees
000017DC                            		pop.l	d3-d4
000017DC 4CDF 0018                M 	movem.l	(sp)+,d3-d4
000017E0 4E75                       		rts
000017E2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000017E2                            ArcTanTable:
000017E2 0000 0000 0101             		dc.b	$00, $00, $00, $00, $01, $01
000017E8 0101 0101 0202             		dc.b	$01, $01, $01, $01, $02, $02
000017EE 0202 0202 0303             		dc.b	$02, $02, $02, $02, $03, $03
000017F4 0303 0303 0304             		dc.b	$03, $03, $03, $03, $03, $04
000017FA 0404 0404 0405             		dc.b	$04, $04, $04, $04, $04, $05
00001800 0505 0505 0506             		dc.b	$05, $05, $05, $05, $05, $06
00001806 0606 0606 0606             		dc.b	$06, $06, $06, $06, $06, $06
0000180C 0707 0707 0707             		dc.b	$07, $07, $07, $07, $07, $07
00001812 0808 0808 0808             		dc.b	$08, $08, $08, $08, $08, $08
00001818 0809 0909 0909             		dc.b	$08, $09, $09, $09, $09, $09
0000181E 090A 0A0A 0A0A             		dc.b	$09, $0A, $0A, $0A, $0A, $0A
00001824 0A0A 0B0B 0B0B             		dc.b	$0A, $0A, $0B, $0B, $0B, $0B
0000182A 0B0B 0B0C 0C0C             		dc.b	$0B, $0B, $0B, $0C, $0C, $0C
00001830 0C0C 0C0C 0D0D             		dc.b	$0C, $0C, $0C, $0C, $0D, $0D
00001836 0D0D 0D0D 0D0E             		dc.b	$0D, $0D, $0D, $0D, $0D, $0E
0000183C 0E0E 0E0E 0E0E             		dc.b	$0E, $0E, $0E, $0E, $0E, $0E
00001842 0F0F 0F0F 0F0F             		dc.b	$0F, $0F, $0F, $0F, $0F, $0F
00001848 0F10 1010 1010             		dc.b	$0F, $10, $10, $10, $10, $10
0000184E 1010 1111 1111             		dc.b	$10, $10, $11, $11, $11, $11
00001854 1111 1111 1212             		dc.b	$11, $11, $11, $11, $12, $12
0000185A 1212 1212 1213             		dc.b	$12, $12, $12, $12, $12, $13
00001860 1313 1313 1313             		dc.b	$13, $13, $13, $13, $13, $13
00001866 1314 1414 1414             		dc.b	$13, $14, $14, $14, $14, $14
0000186C 1414 1415 1515             		dc.b	$14, $14, $14, $15, $15, $15
00001872 1515 1515 1515             		dc.b	$15, $15, $15, $15, $15, $15
00001878 1616 1616 1616             		dc.b	$16, $16, $16, $16, $16, $16
0000187E 1616 1717 1717             		dc.b	$16, $16, $17, $17, $17, $17
00001884 1717 1717 1718             		dc.b	$17, $17, $17, $17, $17, $18
0000188A 1818 1818 1818             		dc.b	$18, $18, $18, $18, $18, $18
00001890 1818 1919 1919             		dc.b	$18, $18, $19, $19, $19, $19
00001896 1919 1919 1919             		dc.b	$19, $19, $19, $19, $19, $19
0000189C 1A1A 1A1A 1A1A             		dc.b	$1A, $1A, $1A, $1A, $1A, $1A
000018A2 1A1A 1A1B 1B1B             		dc.b	$1A, $1A, $1A, $1B, $1B, $1B
000018A8 1B1B 1B1B 1B1B             		dc.b	$1B, $1B, $1B, $1B, $1B, $1B
000018AE 1B1C 1C1C 1C1C             		dc.b	$1B, $1C, $1C, $1C, $1C, $1C
000018B4 1C1C 1C1C 1C1C             		dc.b	$1C, $1C, $1C, $1C, $1C, $1C
000018BA 1D1D 1D1D 1D1D             		dc.b	$1D, $1D, $1D, $1D, $1D, $1D
000018C0 1D1D 1D1D 1D1E             		dc.b	$1D, $1D, $1D, $1D, $1D, $1E
000018C6 1E1E 1E1E 1E1E             		dc.b	$1E, $1E, $1E, $1E, $1E, $1E
000018CC 1E1E 1E1E 1F1F             		dc.b	$1E, $1E, $1E, $1E, $1F, $1F
000018D2 1F1F 1F1F 1F1F             		dc.b	$1F, $1F, $1F, $1F, $1F, $1F
000018D8 1F1F 1F1F 2020             		dc.b	$1F, $1F, $1F, $1F, $20, $20
000018DE 2020 2020 2000             		dc.b	$20, $20, $20, $20, $20, $00
000018E4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000018E4                            ; Initialize oscillation
000018E4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000018E4                            InitOscillation:
000018E4 43F8 C76A                  		lea	rOscNums.w,a1
000018E8 45FA 0000                  		lea	OscInitData(pc),a2
000018EC 7200                       		moveq	#(OscInitData_End-OscInitData)>>1-1,d1
000018EE                            
000018EE                            .LoadData:
000018EE 32DA                       		move.w	(a2)+,(a1)+
000018F0 51C9 FFFC                  		dbf	d1,.LoadData
000018F4 4E75                       		rts
000018F6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000018F6                            OscInitData:
000018F6 007D                       		dc.w	%0000000001111101
000018F8 0080 0000                  		dc.w	$0080, $0000
000018FC 0080 0000                  		dc.w	$0080, $0000
00001900 0080 0000                  		dc.w	$0080, $0000
00001904 0080 0000                  		dc.w	$0080, $0000
00001908 0080 0000                  		dc.w	$0080, $0000
0000190C 0080 0000                  		dc.w	$0080, $0000
00001910 0080 0000                  		dc.w	$0080, $0000
00001914 0080 0000                  		dc.w	$0080, $0000
00001918 0080 0000                  		dc.w	$0080, $0000
0000191C 3848 00EE                  		dc.w	$3848, $00EE
00001920 2080 00B4                  		dc.w	$2080, $00B4
00001924 3080 010E                  		dc.w	$3080, $010E
00001928 5080 01C2                  		dc.w	$5080, $01C2
0000192C 7080 0276                  		dc.w	$7080, $0276
00001930 0080 0000                  		dc.w	$0080, $0000
00001934 4000 00FE                  		dc.w	$4000, $00FE
00001938                            OscInitData_End:
00001938                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001938                            ; Update oscillation
00001938                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001938                            UpdateOscillation:
00001938 43F8 C76A                  		lea	rOscNums.w,a1
0000193C 45FA 0000                  		lea	OscUpdateData(pc),a2
00001940 3619                       		move.w	(a1)+,d3
00001942 7200                       		moveq	#(OscUpdateData_End-OscUpdateData)>>2-1,d1
00001944                            
00001944                            .OscLoop:
00001944 341A                       		move.w	(a2)+,d2
00001946 381A                       		move.w	(a2)+,d4
00001948 0303                       		btst	d1,d3
0000194A 6600                       		bne.s	.Sub
0000194C 3029 0002                  		move.w	2(a1),d0
00001950 D042                       		add.w	d2,d0
00001952 3340 0002                  		move.w	d0,2(a1)
00001956 D151                       		add.w	d0,(a1)
00001958 B811                       		cmp.b	(a1),d4
0000195A 6200                       		bhi.s	.DoLoop
0000195C 03C3                       		bset	d1,d3
0000195E 6000                       		bra.s	.DoLoop
00001960                            
00001960                            .Sub:
00001960 3029 0002                  		move.w	2(a1),d0
00001964 9042                       		sub.w	d2,d0
00001966 3340 0002                  		move.w	d0,2(a1)
0000196A D151                       		add.w	d0,(a1)
0000196C B811                       		cmp.b	(a1),d4
0000196E 6300                       		bls.s	.DoLoop
00001970 0383                       		bclr	d1,d3
00001972                            
00001972                            .DoLoop:
00001972 5849                       		addq.w	#4,a1
00001974 51C9 FFCE                  		dbf	d1,.OscLoop
00001978                            
00001978 31C3 C76A                  		move.w	d3,rOscCtrl.w
0000197C                            
0000197C                            .End:
0000197C 4E75                       		rts
0000197E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000197E                            OscUpdateData:
0000197E 0002 0010                  		dc.w	$02, $10
00001982 0002 0018                  		dc.w	$02, $18
00001986 0002 0020                  		dc.w	$02, $20
0000198A 0002 0030                  		dc.w	$02, $30
0000198E 0004 0020                  		dc.w	$04, $20
00001992 0008 0008                  		dc.w	$08, $08
00001996 0008 0040                  		dc.w	$08, $40
0000199A 0004 0040                  		dc.w	$04, $40
0000199E 0002 0038                  		dc.w	$02, $38
000019A2 0002 0038                  		dc.w	$02, $38
000019A6 0002 0020                  		dc.w	$02, $20
000019AA 0003 0030                  		dc.w	$03, $30
000019AE 0005 0050                  		dc.w	$05, $50
000019B2 0007 0070                  		dc.w	$07, $70
000019B6 0002 0040                  		dc.w	$02, $40
000019BA 0002 0040                  		dc.w	$02, $40
000019BE                            OscUpdateData_End:
000019BE                            ; =========================================================================================================================================================
000019BE                            		include	"Libraries/Object.asm"		; Object functions
000019BE                            ; =========================================================================================================================================================
000019BE                            ; Object functions
000019BE                            ; =========================================================================================================================================================
000019BE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000019BE                            ; Initialize object lists
000019BE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000019BE                            ; PARAMETERS:
000019BE                            ;	Nothing
000019BE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000019BE                            ; RETURNS:
000019BE                            ;	Nothing
000019BE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000019BE                            InitObjectList:
000019BE                            		clrRAM	rRespawns			; Clear object respawn table
000019BE                          M 	local	endaddr
000019BE                          M endaddr	equs	"rrespawns_End"
000019BE 7000                     M 	moveq	#0,d0
000019C0 43F8 BE9E                M 	lea	(rrespawns).w,a1
000019C4 323C 00BF                M 	move.w	#(((rrespawns_end)-(rrespawns))-((rrespawns)&1))>>2-1,d1
000019C8 22C0                     M .clear_65:	move.l	d0,(a1)+
000019CA 51C9 FFFC                M 	dbf	d1,.clear_65
000019CE                            
000019CE                            	; setup tail object
000019CE 31FC BE54 BE58             		move.w	#rTailAddr,rTailNext.w		; set the first object as the tail object
000019D4 31FC BE54 BE5A             		move.w	#rTailAddr,rTailPrev.w		; set the last object as the tail object
000019DA 21FC 0000 0000 BE54        		move.l	#.rts,rTailAddr.w		; set the next rts as the tail object pointer
000019E2                            
000019E2                            	; setup free object list
000019E2 41F8 9A54                  		lea	rObjects.w,a0			; load the objects list into a0
000019E6 31C8 BE5C                  		move.w	a0,rFreeHead.w			; set the first object as the first free object
000019EA 705E                       		moveq	#OBJECT_COUNT-2,d0		; load object count to d0
000019EC 7260                       		moveq	#oSize,d1			; load object size to d1
000019EE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000019EE                            
000019EE                            .load
000019EE D0C1                       		add.w	d1,a0				; go to the next object now
000019F0 3148 FFA6                  		move.w	a0,oPrev-oSize(a0)		; save new previous pointer
000019F4 42A8 0008                  		clr.l	oDrawNext(a0)			; clear the display link values
000019F8 51C8 FFF4                  		dbf	d0,.load			; loop for every object
000019FC                            
000019FC 4268 0006                  		clr.w	oPrev(a0)			; set the last previous pointer to 0
00001A00                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A00                            
00001A00                            	; reset display table
00001A00 43F8 BE56                  		lea	rDispInput-dNext.w,a1		; get display table address to a1
00001A04 7207                       		moveq	#8-1,d1				; loop for all the layers
00001A06                            
00001A06                            .dsp
00001A06 3349 000E                  		move.w	a1,dPrev+dNext(a1)		; update prev pointer
00001A0A 5849                       		addq.w	#dNext,a1			; advance to the actual address
00001A0C 3349 0004                  		move.w	a1,dNext(a1)			; update next pointer
00001A10                            
00001A10 42A9 0006                  		clr.l	dN2(a1)				; clear the list end pointers
00001A14 5849                       		addq.w	#dSize-dNext,a1			; go to the next layer
00001A16 51C9 FFEE                  		dbf	d1,.dsp				; loop for all layers
00001A1A                            
00001A1A                            .rts
00001A1A 4E75                       		rts
00001A1C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A1C                            ; Find the first free object space available
00001A1C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A1C                            ; PARAMETERS:
00001A1C                            ;	Nothing
00001A1C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A1C                            ; RETURNS:
00001A1C                            ;	a1.l	- Pointer to the SST space in the free object space
00001A1C                            ;	a2.l	- Trashed
00001A1C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A1C                            FindFreeObj:
00001A1C 3038 BE5C                  		move.w	rFreeHead.w,d0			; get pointer to the next free object
00001A20 6700                       		beq.s	.rts				; if it's a null pointer (z=1), return
00001A22 3240                       		movea.w	d0,a1				; load to a1
00001A24 31E9 0006 BE5C             		move.w	oPrev(a1),rFreeHead.w		; copy the next free object pointer to list start
00001A2A                            ; --------------------------------------------------------------
00001A2A                            
00001A2A                            	; clear object memory
00001A2A 45E9 000A                  		lea	oDrawPrev(a1),a2		; load the first byte to clear to a2
00001A2E 425A                       		clr.w	(a2)+				; clear a word of data
00001A30                            
00001A30                            	rept (oSize-oDrawPrev) / 4			; repeat for every object property
00001A30                            		clr.l	(a2)+				; clear a longword of data
00001A30                            	endr
00001A30 429A                     M 	clr.l	(a2)+
00001A32 429A                     M 	clr.l	(a2)+
00001A34 429A                     M 	clr.l	(a2)+
00001A36 429A                     M 	clr.l	(a2)+
00001A38 429A                     M 	clr.l	(a2)+
00001A3A 429A                     M 	clr.l	(a2)+
00001A3C 429A                     M 	clr.l	(a2)+
00001A3E 429A                     M 	clr.l	(a2)+
00001A40 429A                     M 	clr.l	(a2)+
00001A42 429A                     M 	clr.l	(a2)+
00001A44 429A                     M 	clr.l	(a2)+
00001A46 429A                     M 	clr.l	(a2)+
00001A48 429A                     M 	clr.l	(a2)+
00001A4A 429A                     M 	clr.l	(a2)+
00001A4C 429A                     M 	clr.l	(a2)+
00001A4E 429A                     M 	clr.l	(a2)+
00001A50 429A                     M 	clr.l	(a2)+
00001A52 429A                     M 	clr.l	(a2)+
00001A54 429A                     M 	clr.l	(a2)+
00001A56 429A                     M 	clr.l	(a2)+
00001A58 429A                     M 	clr.l	(a2)+
00001A5A                            ; --------------------------------------------------------------
00001A5A                            
00001A5A 3478 BE5A                  		move.w	rTailPrev.w,a2			; load last object to a2
00001A5E 31C9 BE5A                  		move.w	a1,rTailPrev.w			; save as the new last object
00001A62 336A 0004 0004             		move.w	oNext(a2),oNext(a1)		; copy the next pointer from old tail to new object
00001A68 3549 0004                  		move.w	a1,oNext(a2)			; save new object as next pointer for old tail
00001A6C 334A 0006                  		move.w	a2,oPrev(a1)			; save old tail as prev pointer for new object
00001A70                            
00001A70                            .rts:
00001A70 4E75                       		rts
00001A72                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A72                            ; Delete the current object
00001A72                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A72                            ; PARAMETERS:
00001A72                            ;	Nothing
00001A72                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A72                            ; RETURNS:
00001A72                            ;	a1.l	- Trashed
00001A72                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001A72                            DeleteObject:
00001A72                            	removeSprite	a0, a1, 1			; remove object display
00001A72 4A68 0008                M 	tst.w	odrawnext(a0)
00001A76 6700                     M 	beq.s	.yes_66
00001A78 3268 000A                M 	move.w	odrawprev(a0),a1
00001A7C 3368 0008 0008           M 	move.w	odrawnext(a0),odrawnext(a1)
00001A82 3268 0008                M 	move.w	odrawnext(a0),a1
00001A86 3368 000A 000A           M 	move.w	odrawprev(a0),odrawprev(a1)
00001A8C                          M .no_66
00001A8C 42A8 0008                M 	clr.l	odrawnext(a0)
00001A90                          M .yes_66
00001A90 3268 0006                  		move.w	oPrev(a0),a1			; copy previous pointer to a1
00001A94 3368 0004 0004             		move.w	oNext(a0),oNext(a1)		; copy next pointer to previous object
00001A9A 3268 0004                  		move.w	oNext(a0),a1			; get next object to a1
00001A9E 3368 0006 0006             		move.w	oPrev(a0),oPrev(a1)		; copy previous pointer
00001AA4                            
00001AA4 3178 BE5C 0006             		move.w	rFreeHead.w,oPrev(a0)		; get the head of the free list to previous pointer of this object
00001AAA 31C8 BE5C                  		move.w	a0,rFreeHead.w			; save as the new head of free list
00001AAE 4E75                       		rts
00001AB0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001AB0                            ; Delete an object
00001AB0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001AB0                            ; PARAMETERS:
00001AB0                            ;	a1.l	- Pointer to object space to clear
00001AB0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001AB0                            ; RETURNS:
00001AB0                            ;	a1.l	- Trashed
00001AB0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001AB0                            DeleteOtherObj:
00001AB0                            		push.l	a0
00001AB0 2F08                     M 	move.l	a0,-(sp)
00001AB2 2049                       		move.l	a1,a0
00001AB4 61BC                       		bsr.s	DeleteObject
00001AB6                            		pop.l	a0
00001AB6 205F                     M 	move.l	(sp)+,a0
00001AB8 4E75                       		rts
00001ABA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001ABA                            ; Render object sprites
00001ABA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001ABA                            ; PARAMETERS:
00001ABA                            ;	Nothing
00001ABA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001ABA                            ; RETURNS:
00001ABA                            ;	Nothing
00001ABA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001ABA                            RenderObjects:
00001ABA 7E4F                       		moveq	#($280/8)-1,d7			; Max sprite count
00001ABC 7C00                       		moveq	#0,d6				; Render flags
00001ABE                            
00001ABE 47F8 F880                  		lea	rFGCam.w,a3			; Foreground camera variables
00001AC2 4BF8 BE5E                  		lea	rDispInput+dNext.w,a5	; Sprite input table
00001AC6 4DF8 94CE                  		lea	rSprites.w,a6			; Sprite table buffer
00001ACA                            
00001ACA 0C38 0004 C75A             		cmpi.b	#gLevel,rGameMode.w		; Are we in level mode?
00001AD0 6600                       		bne.s	.PrioLvlLoop			; If not, branch
00001AD2 4EB9 0000 0000             		jsr	Level_RenderHUDAndRings		; Render the HUD & Rings (in that order)
00001AD8                            
00001AD8                            .PrioLvlLoop:
00001AD8 3055                       		move.w	(a5),a0				; Load priority level address to a0
00001ADA 504D                       		add.w	#dSize,a5			; Skip bunch of shit
00001ADC 4A68 0008                  		tst.w	oDrawNext(a0)			; Is the next pointer for a valid object?
00001AE0 6700 0000                  		beq.w	.NextPrioLvl			; If not, branch
00001AE4                            
00001AE4                            .ObjectLoop:
00001AE4                            	;	movea.w	(a4)+,a0			; Get object SST address
00001AE4 4A90                       		tst.l	oAddr(a0)			; Is this object slot used?
00001AE6 6700 0000                  		beq.w	.NextObject			; If not, branch
00001AEA                            
00001AEA 0228 007F 000D             		andi.b	#$7F,oRender(a0)		; Clear on-screen flag
00001AF0 1C28 000D                  		move.b	oRender(a0),d6			; Store render flags
00001AF4 3028 0014                  		move.w	oXPos(a0),d0			; Get X position
00001AF8 3228 0018                  		move.w	oYPos(a0),d1			; Get Y position
00001AFC                            
00001AFC 0806 0006                  		btst	#6,d6				; Is the multi sprite flag set?
00001B00 6600 0000                  		bne.w	.MultiDraw			; If so, branch
00001B04 0806 0002                  		btst	#2,d6				; Is the sprite to be drawn via screen space?
00001B08 6700                       		beq.s	.Render				; If not, branch
00001B0A                            
00001B0A 9053                       		sub.w	cXPos(a3),d0			; Subtract the camera's X position from the sprite's
00001B0C 926B 0008                  		sub.w	cYPos(a3),d1			; Subtract the camera's Y position from the sprite's
00001B10                            
00001B10                            .Render:
00001B10 7400                       		moveq	#0,d2
00001B12 1428 0017                  		move.b	oDrawW(a0),d2			; Get sprite width
00001B16 3600                       		move.w	d0,d3				; Get sprite X position
00001B18 D642                       		add.w	d2,d3				; Add width
00001B1A 6B00                       		bmi.s	.NextObject			; If it's off screen on the left, branch
00001B1C 3600                       		move.w	d0,d3				; Get sprite X position
00001B1E 9642                       		sub.w	d2,d3				; Subtract width
00001B20 0C43 0140                  		cmpi.w	#320,d3				; Is it off screen on the right?
00001B24 6C00                       		bge.s	.NextObject			; If so, branch
00001B26 0640 0080                  		addi.w	#128,d0				; Move sprite on screen
00001B2A                            
00001B2A 7400                       		moveq	#0,d2
00001B2C 1428 001B                  		move.b	oDrawH(a0),d2			; Get sprite height
00001B30 3601                       		move.w	d1,d3				; Get sprite Y position
00001B32 D642                       		add.w	d2,d3				; Add height
00001B34 6B00                       		bmi.s	.NextObject			; If it's off screen on the top, branch
00001B36 3601                       		move.w	d1,d3				; Get sprite Y position
00001B38 9642                       		sub.w	d2,d3				; Subtract height
00001B3A 0C43 00E0                  		cmpi.w	#224,d3				; Is it off screen on the bottom?
00001B3E 6C00                       		bge.s	.NextObject			; If so, branch
00001B40 0641 0080                  		addi.w	#128,d1				; Move sprite on screen
00001B44                            
00001B44 0028 0080 000D             		ori.b	#$80,oRender(a0)		; Set on-screen flag
00001B4A 4A47                       		tst.w	d7				; Do we still have some sprite space left?
00001B4C 6B00                       		bmi.s	.NextObject			; If not, branch
00001B4E                            
00001B4E 2828 0010                  		move.l	oMap(a0),d4			; Get mappings pointer
00001B52 6700                       		beq.s	.NextObject			; If blank, branch
00001B54 2244                       		movea.l	d4,a1				; Store it
00001B56 7800                       		moveq	#0,d4
00001B58 0806 0005                  		btst	#5,d6				; Is the static sprite flag set
00001B5C 6600                       		bne.s	.Static				; If so, branch
00001B5E 1828 0010                  		move.b	oFrame(a0),d4			; Get mapping frame
00001B62 D844                       		add.w	d4,d4				; Turn into offset
00001B64 D2F1 4000                  		adda.w	(a1,d4.w),a1			; Get mapping frame data pointer
00001B68 3819                       		move.w	(a1)+,d4			; Get mapping frame sprite count
00001B6A 5344                       		subq.w	#1,d4				; Subtract 1 from sprite count
00001B6C 6B00                       		bmi.s	.NextObject			; If there are no sprites to draw, branch
00001B6E                            
00001B6E                            .Static:
00001B6E 3A28 000E                  		move.w	oVRAM(a0),d5			; Get sprite tile properties
00001B72 6100 ECDE                  		bsr.w	DrawSprite			; Draw the sprites
00001B76                            
00001B76                            .NextObject:	
00001B76 3068 0008                  		move.w	oDrawNext(a0),a0		; Load next object to a0
00001B7A 4A68 0008                  		tst.w	oDrawNext(a0)			; Check the next pointer for valid object
00001B7E 6600 FF64                  		bne.w	.ObjectLoop			; If there are still some sprites to draw in this priority level, branch
00001B82                            
00001B82                            .NextPrioLvl:
00001B82 BAFC BE9E                  		cmpa.w	#rDispInput_End,a5		; Are we at the end of the input table?
00001B86 6500 FF50                  		blo.w	.PrioLvlLoop			; If not, branch
00001B8A                            
00001B8A 3C07                       		move.w	d7,d6				; Get remaining sprite count
00001B8C 6B00                       		bmi.s	.SetDrawnSprites		; If we have filled the entire sprite table, branch
00001B8E 7000                       		moveq	#0,d0
00001B90                            
00001B90                            .FillRest:
00001B90 3C80                       		move.w	d0,(a6)				; Move sprite off screen
00001B92 504E                       		addq.w	#8,a6				; Next sprite
00001B94 51CF FFFA                  		dbf	d7,.FillRest			; Loop
00001B98                            
00001B98                            .SetDrawnSprites:
00001B98 0446 004F                  		subi.w	#($280/8)-1,d6			; Get number of sprites drawn
00001B9C 4446                       		neg.w	d6				; ''
00001B9E 11C6 C75B                  		move.b	d6,rSprCount.w		; Store it
00001BA2                            
00001BA2 4E75                       		rts
00001BA4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001BA4                            .MultiDraw:
00001BA4 0806 0002                  		btst	#2,d6				; Is the sprite to be drawn via screen space?
00001BA8 6700                       		beq.s	.RenderMain			; If not, branch
00001BAA                            
00001BAA 9053                       		sub.w	cXPos(a3),d0			; Subtract the camera's X position from the sprite's
00001BAC 926B 0008                  		sub.w	cYPos(a3),d1			; Subtract the camera's Y position from the sprite's
00001BB0                            
00001BB0                            .RenderMain:
00001BB0 7400                       		moveq	#0,d2
00001BB2 1428 0017                  		move.b	oDrawW(a0),d2			; Get main sprite width
00001BB6 3600                       		move.w	d0,d3				; Get main sprite X position
00001BB8 D642                       		add.w	d2,d3				; Add width
00001BBA 6BBA                       		bmi.s	.NextObject			; If it's off screen on the left, branch
00001BBC 3600                       		move.w	d0,d3				; Get main sprite X position
00001BBE 9642                       		sub.w	d2,d3				; Subtract width
00001BC0 0C43 0140                  		cmpi.w	#320,d3				; Is it off screen on the right?
00001BC4 6CB0                       		bge.s	.NextObject			; If so, branch
00001BC6 0640 0080                  		addi.w	#128,d0				; Move sprite on screen
00001BCA                            
00001BCA 1428 001B                  		move.b	oDrawH(a0),d2			; Get main sprite height
00001BCE 3601                       		move.w	d1,d3				; Get main sprite Y position
00001BD0 D642                       		add.w	d2,d3				; Add height
00001BD2 6BA2                       		bmi.s	.NextObject			; If it's off screen on the top, branch
00001BD4 3601                       		move.w	d1,d3				; Get main sprite Y position
00001BD6 9642                       		sub.w	d2,d3				; Subtract height
00001BD8 0C43 00E0                  		cmpi.w	#224,d3				; Is it off screen on the bottom?
00001BDC 6C98                       		bge.s	.NextObject			; If so, branch
00001BDE 0641 0080                  		addi.w	#128,d1				; Move sprite on screen
00001BE2                            
00001BE2 0028 0080 000D             		ori.b	#$80,oRender(a0)		; Set on-screen flag
00001BE8 4A47                       		tst.w	d7				; Do we still have some sprite space left?
00001BEA 6B00 FF8A                  		bmi.w	.NextObject			; If not, branch
00001BEE                            
00001BEE 3A28 000E                  		move.w	oVRAM(a0),d5			; Get sprite tile properties
00001BF2 2828 0010                  		move.l	oMap(a0),d4			; Get mappings pointer
00001BF6 6700 FF7E                  		beq.w	.NextObject			; If blank, branch
00001BFA 2444                       		movea.l	d4,a2				; Store it
00001BFC 7800                       		moveq	#0,d4
00001BFE 1828 0010                  		move.b	oFrame(a0),d4			; Get mapping frame
00001C02 D844                       		add.w	d4,d4				; Turn into offset
00001C04 43D2                       		lea	(a2),a1				; Copy mappings data pointer
00001C06 D2F1 4000                  		adda.w	(a1,d4.w),a1			; Get mapping frame data pointer
00001C0A 3819                       		move.w	(a1)+,d4			; Get mapping frame sprite count
00001C0C 5344                       		subq.w	#1,d4				; Subtract 1 from sprite count
00001C0E 6B00                       		bmi.s	.RenderSubSprites		; If there are no sprites to draw, branch
00001C10 3606                       		move.w	d6,d3				; Store render flags
00001C12 6100 ED22                  		bsr.w	DrawSprite_BoundChk		; Draw the sprites
00001C16 3C03                       		move.w	d3,d6				; Restore render flags
00001C18                            
00001C18 4A47                       		tst.w	d7				; Do we still have some sprite space left?
00001C1A 6B00 FF5A                  		bmi.w	.NextObject			; If not, branch
00001C1E                            
00001C1E                            .RenderSubSprites:
00001C1E 3628 002E                  		move.w	oSubCnt(a0),d3			; Get sub sprite count
00001C22 5343                       		subq.w	#1,d3				; Subtract 1
00001C24 6B00 FF50                  		bmi.w	.NextObject			; If there are no sprites to draw, branch
00001C28 41E8 0030                  		lea	oSubStart(a0),a0		; Get sub sprite SSTs start
00001C2C                            
00001C2C                            .RenderSubSprs_Loop:
00001C2C 3018                       		move.w	(a0)+,d0			; Get X position
00001C2E 0640 0080                  		addi.w	#128,d0				; Move on screen
00001C32 3218                       		move.w	(a0)+,d1			; Get Y position
00001C34 0641 0080                  		addi.w	#128,d1				; Move on screen
00001C38                            
00001C38 0806 0002                  		btst	#2,d6				; Is the sprite to be drawn via screen space?
00001C3C 6700                       		beq.s	.RenderSub			; If not, branch
00001C3E                            
00001C3E 9053                       		sub.w	cXPos(a3),d0			; Subtract the camera's X position from the sprite's
00001C40 926B 0008                  		sub.w	cYPos(a3),d1			; Subtract the camera's Y position from the sprite's
00001C44                            
00001C44                            .RenderSub:
00001C44 3818                       		move.w	(a0)+,d4			; Get mapping frame
00001C46 D844                       		add.w	d4,d4				; Turn into offset
00001C48 43D2                       		lea	(a2),a1				; Copy mappings data pointer
00001C4A D2F1 4000                  		adda.w	(a1,d4.w),a1			; Get mapping frame data pointer
00001C4E 3819                       		move.w	(a1)+,d4			; Get mapping frame sprite count
00001C50 5344                       		subq.w	#1,d4				; Subtract 1 from sprite count
00001C52 6B00                       		bmi.s	.RenderSubSprs_ChkLoop		; If there are no sprites to draw, branch
00001C54                            		push.w	d6				; Store render flags
00001C54 3F06                     M 	move.w	d6,-(sp)
00001C56 6100 ECDE                  		bsr.w	DrawSprite_BoundChk		; Draw the sprites
00001C5A                            		pop.w	d6				; Restore render flags
00001C5A 3C1F                     M 	move.w	(sp)+,d6
00001C5C                            
00001C5C                            .RenderSubSprs_ChkLoop:
00001C5C 4A47                       		tst.w	d7				; Do we still have some sprite space left?
00001C5E 5BCB FFCC                  		dbmi	d3,.RenderSubSprs_Loop		; If so, loop
00001C62 6000 FF12                  		bra.w	.NextObject			; Continue on rendering other sprites
00001C66                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001C66                            ; Animate an object's sprite
00001C66                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001C66                            ; PARAMETERS:
00001C66                            ;	a0.l	- Object space pointer
00001C66                            ;	a1.l	- Animation script pointer
00001C66                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001C66                            ; RETURNS:
00001C66                            ;	Nothing
00001C66                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001C66                            AnimateObject:
00001C66 7000                       		moveq	#0,d0
00001C68 1028 0020                  		move.b	oAni(a0),d0			; Get animation ID
00001C6C B028 0021                  		cmp.b	oPrevAni(a0),d0			; Has it changed?
00001C70 6700                       		beq.s	.Run				; If not, branch
00001C72 1140 0021                  		move.b	d0,oPrevAni(a0)			; Save the new ID
00001C76 4228 0022                  		clr.b	oAniFrame(a0)			; Reset animation
00001C7A 4228 0023                  		clr.b	oAniTimer(a0)			; Reset animation timer
00001C7E                            
00001C7E                            .Run:
00001C7E 5328 0023                  		subq.b	#1,oAniTimer(a0)		; Decrement animation timer
00001C82 6A00                       		bpl.s	.Wait				; If it hasn't run out, branch
00001C84 D040                       		add.w	d0,d0				; Turn ID into offset
00001C86 D2F1 0000                  		adda.w	(a1,d0.w),a1			; Get pointer to current animation script
00001C8A 1151 0023                  		move.b	(a1),oAniTimer(a0)		; Set new animation timer
00001C8E                            
00001C8E 7200                       		moveq	#0,d1
00001C90 1228 0022                  		move.b	oAniFrame(a0),d1		; Get current value in the script
00001C94 1031 1001                  		move.b	1(a1,d1.w),d0			; ''
00001C98 0C00 00FA                  		cmpi.b	#$FA,d0				; Is it a command value?
00001C9C 6400                       		bhs.s	.CmdReset			; If so, branch
00001C9E                            
00001C9E                            .Next:
00001C9E 1140 0010                  		move.b	d0,oFrame(a0)			; Set mapping frame ID
00001CA2 1028 0028                  		move.b	oStatus(a0),d0			; Get status
00001CA6 0200 0003                  		andi.b	#3,d0				; Only get flip bits
00001CAA 0228 00FC 000D             		andi.b	#$FC,oRender(a0)		; Mask out flip bits in render flags
00001CB0 8128 000D                  		or.b	d0,oRender(a0)			; Set flip bits
00001CB4 5228 0022                  		addq.b	#1,oAniFrame(a0)		; Advance into the animation script
00001CB8                            
00001CB8                            .Wait:
00001CB8 4E75                       		rts
00001CBA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CBA                            .CmdReset:
00001CBA 5200                       		addq.b	#1,d0				; Is this flag $FF (reset)?
00001CBC 6600                       		bne.s	.CmdJump			; If not, branch
00001CBE 4228 0022                  		clr.b	oAniFrame(a0)			; Reset animation
00001CC2 1029 0001                  		move.b	1(a1),d0			; Get first frame ID
00001CC6 60D6                       		bra.s	.Next				; Continue
00001CC8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CC8                            .CmdJump:
00001CC8 5200                       		addq.b	#1,d0				; Is this flag $FE (jump)?
00001CCA 6600                       		bne.s	.CmdSetAnim			; If not, branch
00001CCC 1031 1002                  		move.b	2(a1,d1.w),d0			; Get jump offset
00001CD0 9128 0022                  		sub.b	d0,oAniFrame(a0)		; Go back
00001CD4 9200                       		sub.b	d0,d1				; ''
00001CD6 1031 1001                  		move.b	1(a1,d1.w),d0			; Get new frame ID
00001CDA 60C2                       		bra.s	.Next				; Continue
00001CDC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CDC                            .CmdSetAnim:
00001CDC 5200                       		addq.b	#1,d0				; Is this flag $FD (set animation ID)?
00001CDE 6600                       		bne.s	.CmdNextRout			; If not, branch
00001CE0 1171 1002 0020             		move.b	2(a1,d1.w),oAni(a0)		; Set new animation ID
00001CE6 4E75                       		rts
00001CE8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CE8                            .CmdNextRout:
00001CE8 5200                       		addq.b	#1,d0				; Is this flag $FC (next routine)?
00001CEA 6600                       		bne.s	.CmdReset2ndRout		; If not, branch
00001CEC 5428 0025                  		addq.b	#2,oRoutine(a0)			; Next routine
00001CF0 4228 0023                  		clr.b	oAniTimer(a0)			; Reset animation timer
00001CF4 5228 0022                  		addq.b	#1,oAniFrame(a0)		; Next animation frame
00001CF8 4E75                       		rts
00001CFA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001CFA                            .CmdReset2ndRout:
00001CFA 5200                       		addq.b	#1,d0				; Is this flag $FB (reset secondary routine)?
00001CFC 6600                       		bne.s	.CmdNext2ndRout			; If not, branch
00001CFE 4228 0023                  		clr.b	oAniTimer(a0)			; Reset animation timer
00001D02                            ;		clr.b	oWFZRout(a0)			; Reset routine
00001D02 4E75                       		rts
00001D04                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D04                            .CmdNext2ndRout:
00001D04 5200                       		addq.b	#1,d0				; Is this flag $FA (next secondary routine)?
00001D06 6600                       		bne.s	.CmdEnd				; If not, branch
00001D08                            ;		addq.b	#2,oWFZRout(a0)			; Next routine
00001D08 4E75                       		rts
00001D0A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D0A                            .CmdEnd:
00001D0A 4E75                       		rts
00001D0C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D0C                            ; Load object DPLCs
00001D0C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D0C                            ; PARAMETERS:
00001D0C                            ;	d4.w	- Target VRAM address
00001D0C                            ;	d6.l	- Pointer to uncompressed art
00001D0C                            ;	a2.l	- Pointer to DPLCs
00001D0C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D0C                            ; RETURNS:
00001D0C                            ;	Nothing
00001D0C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D0C                            LoadObjDPLCs:
00001D0C 7000                       		moveq	#0,d0
00001D0E 1028 0010                  		move.b	oFrame(a0),d0			; Get mapping frame
00001D12 B010                       		cmp.b	oPrevDPLC(a0),d0		; Do we need to update the art?
00001D14 6700                       		beq.s	.End				; If not, branch
00001D16 1080                       		move.b	d0,oPrevDPLC(a0)		; Save the frame ID so we don't constantly load the art
00001D18 D040                       		add.w	d0,d0				; Turn ID into offset
00001D1A D4F2 0000                  		adda.w	(a2,d0.w),a2			; Get pointer to DPLC data for the frame
00001D1E 3A1A                       		move.w	(a2)+,d5			; Get DPLC entry count
00001D20 5345                       		subq.w	#1,d5				; Subtract 1
00001D22 6B00                       		bmi.s	.End				; If there are no more entires left, branch
00001D24                            
00001D24                            .ReadEntries:
00001D24 7200                       		moveq	#0,d1
00001D26 321A                       		move.w	(a2)+,d1			; Get DPLC entry data
00001D28 3601                       		move.w	d1,d3				; Copy that
00001D2A E04B                       		lsr.w	#8,d3				; Get tile count
00001D2C 0243 00F0                  		andi.w	#$F0,d3				; ''
00001D30 0643 0010                  		addi.w	#$10,d3				; ''
00001D34 0241 0FFF                  		andi.w	#$FFF,d1			; Get offset in art data
00001D38 EB89                       		lsl.l	#5,d1				; ''
00001D3A D286                       		add.l	d6,d1				; Get pointer in art data
00001D3C 3404                       		move.w	d4,d2				; Copy VRAM address
00001D3E D843                       		add.w	d3,d4				; Add tile count to VRAM address
00001D40 D843                       		add.w	d3,d4				; ''
00001D42 4EB8 0304                  		jsr	QueueDMATransfer.w		; Queue the art
00001D46 51CD FFDC                  		dbf	d5,.ReadEntries			; Loop
00001D4A                            
00001D4A                            .End:
00001D4A 4E75                       		rts
00001D4C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D4C                            ; Move an object by it's velocity values
00001D4C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D4C                            ; PARAMETERS:
00001D4C                            ;	a0.l	- Object space pointer
00001D4C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D4C                            ; RETURNS:
00001D4C                            ;	Nothing
00001D4C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D4C                            ObjectMove:
00001D4C 3028 001C                  		move.w	oXVel(a0),d0			; Get X velocity
00001D50 48C0                       		ext.l	d0				; ''
00001D52 E188                       		lsl.l	#8,d0				; Shift
00001D54 D1A8 0014                  		add.l	d0,oXPos(a0)			; Add to the X position
00001D58 3028 001E                  		move.w	oYVel(a0),d0			; Get Y velocity
00001D5C 48C0                       		ext.l	d0				; ''
00001D5E E188                       		lsl.l	#8,d0				; Shift
00001D60 D1A8 0018                  		add.l	d0,oYPos(a0)			; Add to the Y position
00001D64 4E75                       		rts
00001D66                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D66                            ; Move an object by it's velocity values (with gravity)
00001D66                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D66                            ; PARAMETERS:
00001D66                            ;	a0.l	- Object space pointer
00001D66                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D66                            ; RETURNS:
00001D66                            ;	Nothing
00001D66                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D66                            ObjectMoveAndFall:
00001D66 3028 001C                  		move.w	oXVel(a0),d0			; Get X velocity
00001D6A 48C0                       		ext.l	d0				; ''
00001D6C E188                       		lsl.l	#8,d0				; Shift
00001D6E D1A8 0014                  		add.l	d0,oXPos(a0)			; Add to the X position
00001D72 3028 001E                  		move.w	oYVel(a0),d0			; Get Y velocity
00001D76 0668 0038 001E             		addi.w	#$38,oYVel(a0)			; Apply gravity
00001D7C 48C0                       		ext.l	d0				; ''
00001D7E E188                       		lsl.l	#8,d0				; Shift
00001D80 D1A8 0018                  		add.l	d0,oYPos(a0)			; Add to the Y position
00001D84 4E75                       		rts
00001D86                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D86                            ; Check if a specific object is nearby
00001D86                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D86                            ; PARAMETERS:
00001D86                            ;	a0.l	- Current object space pointer
00001D86                            ;	a1.l	- Range data pointer
00001D86                            ;	a2.l	- Object to check's space pointer
00001D86                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D86                            ; RETURNS:
00001D86                            ;	d0.w	- Return status (0 if not in range, other object's space pointer if in range)
00001D86                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001D86                            CheckObjInRange:
00001D86 7000                       		moveq	#0,d0
00001D88 322A 0014                  		move.w	oXPos(a2),d1			; Get other object's position
00001D8C 342A 0018                  		move.w	oYPos(a2),d2			; ''
00001D90 3628 0014                  		move.w	oXPos(a0),d3			; Get current object's position
00001D94 3828 0018                  		move.w	oYPos(a0),d4			; ''
00001D98 D659                       		add.w	(a1)+,d3			; Get left boundary
00001D9A 3A03                       		move.w	d3,d5				; Copy
00001D9C DA59                       		add.w	(a1)+,d5			; Get right boundary
00001D9E D859                       		add.w	(a1)+,d4			; Get top boundary
00001DA0 3C04                       		move.w	d4,d6				; Copy
00001DA2 DC59                       		add.w	(a1)+,d6			; Get bottom boundary
00001DA4 B243                       		cmp.w	d3,d1				; Is the object past the left boundary?
00001DA6 6500                       		blo.s	.End				; If not, branch
00001DA8 B245                       		cmp.w	d5,d1				; Is the object within the horizontal range?
00001DAA 6400                       		bhs.s	.End				; If not, branch
00001DAC B444                       		cmp.w	d4,d2				; Is the object past the top boundary?
00001DAE 6500                       		blo.s	.End				; If not, branch
00001DB0 B446                       		cmp.w	d6,d2				; Is the object within the vertical range?
00001DB2 6400                       		bhs.s	.End				; If not, branch
00001DB4 300A                       		move.w	a2,d0				; Copy other object's RAM space pointer as the return status
00001DB6                            
00001DB6                            .End:
00001DB6 4E75                       		rts
00001DB8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001DB8                            ; Object manager
00001DB8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001DB8                            ObjectManager:
00001DB8 4A38 C7B8                  		tst.b	rObjManInit.w
00001DBC 6600                       		bne.s	ObjectManagerMain
00001DBE                            
00001DBE                            ObjectManagerInit:
00001DBE 50F8 C7B8                  		st	rObjManInit.w			; Set the init flag
00001DC2                            
00001DC2 2078 C7B4                  		movea.l	rObjPosAddr.w,a0		; Get object data pointer
00001DC6 21C8 C7BA                  		move.l	a0,rObjLoadR.w
00001DCA 21C8 C7BE                  		move.l	a0,rObjLoadL.w			; Store address of object layout
00001DCE                            
00001DCE 47F8 BE9E                  		lea	rRespawns.w,a3			; Object respawn table
00001DD2                            
00001DD2 3C38 F880                  		move.w	rCamXPos.w,d6			; Camera's X position
00001DD6 0446 0080                  		subi.w	#$80,d6				; Subtract 128
00001DDA 6400                       		bhs.s	.NoReset			; Branch if it doesn't go past the left boundary
00001DDC 7C00                       		moveq	#0,d6				; Cap at left boundary
00001DDE                            
00001DDE                            .NoReset:
00001DDE 0246 FF80                  		andi.w	#$FF80,d6			; Keep in chunks of 128 pixels
00001DE2                            
00001DE2 2078 C7BA                  		movea.l	rObjLoadR.w,a0			; Get address of the object loader for the right side of the screen
00001DE6                            
00001DE6                            .ChkObjsLeft:
00001DE6 BC50                       		cmp.w	(a0),d6				; Compare object position
00001DE8 6300                       		bls.s	.ChkDone			; If higher than d6, branch
00001DEA 5C48                       		addq.w	#6,a0				; Next object
00001DEC 524B                       		addq.w	#1,a3				; Next respawn table index
00001DEE 60F6                       		bra.s	.ChkObjsLeft			; Loop
00001DF0                            
00001DF0                            .ChkDone:
00001DF0 21C8 C7BA                  		move.l	a0,rObjLoadR.w			; Store new addresses
00001DF4 31CB C7C4                  		move.w	a3,rObjRespR.w			; ''
00001DF8                            
00001DF8 47F8 BE9E                  		lea	rRespawns.w,a3			; Object respawn table
00001DFC                            
00001DFC 2078 C7BE                  		movea.l	rObjLoadL.w,a0
00001E00 0446 0080                  		subi.w	#$80,d6				; Subtract from camera's X position again
00001E04 6500                       		bcs.s	.ChkDone2			; But is done to account for the object loader later on
00001E06                            
00001E06                            .ChkObjsRight:
00001E06 BC50                       		cmp.w	(a0),d6				; Compate object position
00001E08 6300                       		bls.s	.ChkDone2			; If higher than d6, branch
00001E0A 5C48                       		addq.w	#6,a0				; Next object
00001E0C 524B                       		addq.w	#1,a3				; Next respawn table index
00001E0E 60F6                       		bra.s	.ChkObjsRight			; Loop
00001E10                            
00001E10                            .ChkDone2:
00001E10 21C8 C7BE                  		move.l	a0,rObjLoadL.w		; Store new addresses
00001E14 31CB C7C2                  		move.w	a3,rObjRespL.w		; ''
00001E18                            
00001E18 31FC FFFF C7CA             		move.w	#-1,rObjManX.w		; Reset manager's camera X position
00001E1E 3038 F888                  		move.w	rCamYPos.w,d0			; Get camera's Y position
00001E22 0240 FF80                  		andi.w	#$FF80,d0			; Keep in range
00001E26 31C0 C7CC                  		move.w	d0,rObjManY.w		; Store it so unnecessary Y checks shouldn't be done
00001E2A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001E2A                            ObjectManagerMain:
00001E2A 3238 F888                  		move.w	rCamYPos.w,d1			; Get camera's Y position
00001E2E 0441 0080                  		subi.w	#$80,d1				; Subtract 128 pixels
00001E32 0241 FF80                  		andi.w	#$FF80,d1			; Keep in range
00001E36 31C1 C7C8                  		move.w	d1,rObjYCoarse.w		; Store this
00001E3A                            
00001E3A 3238 F880                  		move.w	rCamXPos.w,d1			; Get camera's X position
00001E3E 0441 0080                  		subi.w	#$80,d1				; Subtract 128 pixels
00001E42 0241 FF80                  		andi.w	#$FF80,d1			; Keep in range
00001E46 31C1 C7C6                  		move.w	d1,rObjXCoarse.w		; Store this
00001E4A                            		
00001E4A 49F9 0000 0000             		lea	Level_ObjIndex,a4		; Level object index
00001E50                            
00001E50 3638 F888                  		move.w	rCamYPos.w,d3			; Get camera's Y position
00001E54 0243 FF80                  		andi.w	#$FF80,d3			; Keep in range
00001E58 3803                       		move.w	d3,d4				; Copy
00001E5A 0644 0200                  		addi.w	#$200,d4			; Lower Y boundary
00001E5E 0443 0080                  		subi.w	#$80,d3				; Upper Y boundary
00001E62 6A00                       		bpl.s	.SetNoWrap			; If still positive, branch
00001E64 7600                       		moveq	#0,d3				; Cap at upper level boundary
00001E66                            
00001E66                            .SetNoWrap:
00001E66 3A3C 0FFF                  		move.w	#$FFF,d5
00001E6A 3C38 F880                  		move.w	rCamXPos.w,d6			; Get camera's X position
00001E6E 0246 FF80                  		andi.w	#$FF80,d6			; Keep in range
00001E72 BC78 C7CA                  		cmp.w	rObjManX.w,d6		; Check against last range
00001E76 6700 0000                  		beq.w	Level_LoadObjs_SameXRange	; Branch if they are the same
00001E7A 6C00                       		bge.s	Level_LoadObjs_Forward		; If new range is greater than the last, branch
00001E7C                            
00001E7C 31C6 C7CA                  		move.w	d6,rObjManX.w		; Set new range
00001E80                            
00001E80 2078 C7BE                  		movea.l	rObjLoadL.w,a0		; Get current objects on the left side of the screen
00001E84 3678 C7C2                  		movea.w	rObjRespL.w,a3		; And the appropriate respawn list
00001E88                            
00001E88 0446 0080                  		subi.w	#$80,d6				; Subtract 128 from the X position
00001E8C 6500                       		blo.s	.EndLoad			; If outside of the level boundary, branch
00001E8E                            
00001E8E 4EB8 1A1C                  		jsr	FindFreeObj.w			; Attempt to load a new object
00001E92 6700                       		beq.s	.EndLoad			; Branch if it failed
00001E94                            
00001E94                            .LoadLoop:
00001E94 BC68 FFFA                  		cmp.w	-6(a0),d6			; Check if the last object is in range
00001E98 6C00                       		bge.s	.EndLoadRst			; If not, branch
00001E9A 5D88                       		subq.l	#6,a0				; Get actual object address
00001E9C 534B                       		subq.w	#1,a3				; Get acutal respawn table address
00001E9E                            
00001E9E 6100 0000                  		bsr.w	Level_LoadObject		; Attempt to spawn the object
00001EA2 6700                       		beq.s	.LoadFail			; Branch if it could not be loaded
00001EA4 5D88                       		subq.l	#6,a0
00001EA6 60EC                       		bra.s	.LoadLoop			; Attempt to load another object
00001EA8                            
00001EA8                            .LoadFail:
00001EA8 5C88                       		addq.l	#6,a0				; Undo object loading
00001EAA 524B                       		addq.w	#1,a3
00001EAC 6000                       		bra.s	.EndLoad
00001EAE                            .EndLoadRst:
00001EAE 4EB8 1AB0                  		jsr	DeleteOtherObj.w
00001EB2                            
00001EB2                            .EndLoad:
00001EB2 21C8 C7BE                  		move.l	a0,rObjLoadL.w		; Store new addresses
00001EB6 31CB C7C2                  		move.w	a3,rObjRespL.w
00001EBA                            
00001EBA 2078 C7BA                  		movea.l	rObjLoadR.w,a0		; Get current objects on the right side of the screen
00001EBE 3678 C7C4                  		movea.w	rObjRespR.w,a3		; And the appropriate respawn list
00001EC2                            
00001EC2 0646 0300                  		addi.w	#$300,d6			; Load 2 chunks forward
00001EC6                            
00001EC6                            .ChkLoop:
00001EC6 BC68 FFFA                  		cmp.w	-6(a0),d6			; Check if the last object is out of range
00001ECA 6E00                       		bgt.s	.ChkDone			; If so, branch
00001ECC 5D88                       		subq.l	#6,a0				; Get the object before this
00001ECE 534B                       		subq.w	#1,a3				; And its respawn index
00001ED0 60F4                       		bra.s	.ChkLoop			; Check next object
00001ED2                            
00001ED2                            .ChkDone:
00001ED2 21C8 C7BA                  		move.l	a0,rObjLoadR.w		; Store new addresses
00001ED6 31CB C7C4                  		move.w	a3,rObjRespR.w
00001EDA 6000                       		bra.s	Level_LoadObjs_SameXRange	; Continue
00001EDC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001EDC                            Level_LoadObjs_Forward:
00001EDC 31C6 C7CA                  		move.w	d6,rObjManX.w		; Set new range
00001EE0                            
00001EE0 2078 C7BA                  		movea.l	rObjLoadR.w,a0		; Get current objects on the right side of the screen
00001EE4 3678 C7C4                  		movea.w	rObjRespR.w,a3		; And the appropriate respawn list
00001EE8                            
00001EE8 0646 0280                  		addi.w	#$280,d6			; Load 2 chunks forward
00001EEC                            
00001EEC 4EB8 1A1C                  		jsr	FindFreeObj.w			; Attempt to load a new object
00001EF0 6700                       		beq.s	.EndLoad			; Branch if it failed
00001EF2                            
00001EF2                            .LoadLoop:
00001EF2 BC50                       		cmp.w	(a0),d6				; Check if the last obhect is in range
00001EF4 6300                       		bls.s	.EndLoadRst			; If not, branch
00001EF6 6100 0000                  		bsr.w	Level_LoadObject		; Attempt to spawn the object
00001EFA 6700                       		beq.s	.EndLoad			; If it failed to, branch
00001EFC 524B                       		addq.w	#1,a3				; Get acutal respawn table address
00001EFE 60F2                       		bra.s	.LoadLoop
00001F00                            
00001F00                            .EndLoadRst:
00001F00 4EB8 1AB0                  		jsr	DeleteOtherObj.w
00001F04                            
00001F04                            .EndLoad:
00001F04 21C8 C7BA                  		move.l	a0,rObjLoadR.w		; Store new addresses
00001F08 31CB C7C4                  		move.w	a3,rObjRespR.w
00001F0C                            
00001F0C 2078 C7BE                  		movea.l	rObjLoadL.w,a0		; Get current objects on the left side of the screen
00001F10 3678 C7C2                  		movea.w	rObjRespL.w,a3		; And the appropriate respawn list
00001F14                            
00001F14 0446 0300                  		subi.w	#$300,d6			; Check 1 chunk backwards
00001F18 6500                       		blo.s	.ChkDone			; If outside of level, branch
00001F1A                            
00001F1A                            .ChkLoop:
00001F1A BC50                       		cmp.w	(a0),d6				; Check if the last object is out of range
00001F1C 6300                       		bls.s	.ChkDone			; If so, branch
00001F1E 5C88                       		addq.l	#6,a0				; Get the object before this
00001F20 524B                       		addq.w	#1,a3				; And its respawn index
00001F22 60F6                       		bra.s	.ChkLoop			; Check next object
00001F24                            
00001F24                            .ChkDone:
00001F24 21C8 C7BE                  		move.l	a0,rObjLoadL.w		; Store new addresses
00001F28 31CB C7C2                  		move.w	a3,rObjRespL.w
00001F2C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001F2C                            Level_LoadObjs_SameXRange:
00001F2C 3C38 F888                  		move.w	rCamYPos.w,d6			; Get camera's X position
00001F30 0246 FF80                  		andi.w	#$FF80,d6			; Keep in range
00001F34 3606                       		move.w	d6,d3				; Copy
00001F36 BC78 C7CC                  		cmp.w	rObjManY.w,d6		; Check against last range
00001F3A 6700 0000                  		beq.w	.LoadEnd			; Branch if they are the same
00001F3E 6C00                       		bge.s	.MovingDown			; If the new raqnge is greater than the last, branch
00001F40                            
00001F40 0443 0080                  		subi.w	#$80,d3				; Loop 1 chunk up
00001F44 6B00 0000                  		bmi.w	.LoadEnd
00001F48 6000                       		bra.s	.YCheck
00001F4A                            
00001F4A                            .MovingDown:
00001F4A 0643 0180                  		addi.w	#$180,d3			; Look 1 chunk down
00001F4E                            
00001F4E                            .YCheck:
00001F4E 4EB8 1A1C                  		jsr	FindFreeObj.w			; Attempt to load a new object
00001F52 6700                       		beq.s	.LoadEnd			; If failed, branch
00001F54                            		
00001F54 3803                       		move.w	d3,d4				; Copy Y position
00001F56 0644 0080                  		addi.w	#$80,d4				; Look one chunk down
00001F5A 3A3C 0FFF                  		move.w	#$FFF,d5
00001F5E                            
00001F5E 2078 C7BE                  		movea.l	rObjLoadL.w,a0		; Get current objects on the left side of the screen
00001F62 3678 C7C2                  		movea.w	rObjRespL.w,a3		; And the appropriate respawn list
00001F66 2E38 C7BA                  		move.l	rObjLoadR.w,d7		; Get current objects on the right side of the screen
00001F6A 9E88                       		sub.l	a0,d7				; Subtract the left position from the right
00001F6C 6700                       		beq.s	.LoadEndRst			; Branch if no objects
00001F6E 5488                       		addq.l	#2,a0				; Align to object's Y position
00001F70                            
00001F70                            .LoadNext:
00001F70 4A13                       		tst.b	(a3)				; Has the object been loaded?
00001F72 6B00                       		bmi.s	.LoadFail			; If so, branch
00001F74                            
00001F74 3210                       		move.w	(a0),d1				; Get object's Y position
00001F76 C245                       		and.w	d5,d1				; Keep in range of 0-$FFF
00001F78 B243                       		cmp.w	d3,d1
00001F7A 6500                       		blo.s	.LoadFail			; Branch if out of range in the top
00001F7C B244                       		cmp.w	d4,d1
00001F7E 6200                       		bhi.s	.LoadFail			; Branch if out of range in the botoom
00001F80                            
00001F80 08D3 0007                  		bset	#7,(a3)				; Mark as loaded
00001F84 3368 FFFE 0014             		move.w	-2(a0),oXPos(a1)			; Set X position
00001F8A 3210                       		move.w	(a0),d1				; Get object's Y position
00001F8C 3401                       		move.w	d1,d2				; Copy it
00001F8E C245                       		and.w	d5,d1				; Keep in range of 0-$FFF
00001F90 3341 0018                  		move.w	d1,oYPos(a1)			; Set Y position
00001F94                            
00001F94 E75A                       		rol.w	#3,d2				; Get X and Y flip bits
00001F96 0242 0003                  		andi.w	#3,d2				; ''
00001F9A 1342 000D                  		move.b	d2,oRender(a1)			; Set render flags
00001F9E 1342 0028                  		move.b	d2,oStatus(a1)			; Set status
00001FA2                            
00001FA2 1428 0002                  		move.b	2(a0),d2			; Get ID
00001FA6 D442                       		add.w	d2,d2				; Make it an index in the level object index list
00001FA8 D442                       		add.w	d2,d2
00001FAA 22B4 2000                  		move.l	(a4,d2.w),oAddr(a1)		; Set address
00001FAE                            
00001FAE 1368 0003 0024             		move.b	3(a0),oSubtype(a1)		; Set subtype
00001FB4 334B 0026                  		move.w	a3,oRespawn(a1)			; Set respawn address
00001FB8                            
00001FB8 4EB8 1A1C                  		jsr	FindFreeObj.w			; Find a free object slot
00001FBC 6700                       		beq.s	.LoadEnd			; If none could be loaded, branch
00001FBE                            
00001FBE                            .LoadFail:
00001FBE 5C88                       		addq.l	#6,a0				; Next object
00001FC0 524B                       		addq.w	#1,a3				; ''
00001FC2 5D87                       		subq.l	#6,d7				; Subtract the size of the entry
00001FC4 66AA                       		bne.s	.LoadNext			; If there are some objects remaining, branch
00001FC6                            
00001FC6                            .LoadEndRst:
00001FC6 4EB8 1AB0                  		jsr	DeleteOtherObj.w
00001FCA                            
00001FCA                            .LoadEnd:
00001FCA 31C6 C7CC                  		move.w	d6,rObjManY.w		; Store manager's camera Y position
00001FCE 4E75                       		rts
00001FD0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001FD0                            ; Load an object from the object layout
00001FD0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001FD0                            ; PARAMETERS:
00001FD0                            ;	d3.w	- Upper boundary
00001FD0                            ;	d4.w	- Lower boundary
00001FD0                            ;	d5.w	- Y position limit
00001FD0                            ;	a0.l	- Index of object layout
00001FD0                            ;	a1.l	- Target object
00001FD0                            ;	a3.l	- Respawn table address
00001FD0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00001FD0                            Level_LoadObject:
00001FD0 4A13                       		tst.b	(a3)				; Has the object been loaded?
00001FD2 6A00                       		bpl.s	.NotLoaded			; If not, branch
00001FD4 5C88                       		addq.l	#6,a0				; Next object
00001FD6 7201                       		moveq	#1,d1				; Ensure that upstream code knows to continue loading
00001FD8 4E75                       		rts
00001FDA                            
00001FDA                            .NotLoaded:
00001FDA 3E18                       		move.w	(a0)+,d7			; X position
00001FDC 3218                       		move.w	(a0)+,d1			; Y position
00001FDE 3401                       		move.w	d1,d2				; Copy
00001FE0 6B00                       		bmi.s	.LoadNoY			; If the object is set to ignore Y checks, branch
00001FE2 C245                       		and.w	d5,d1				; Keey Y in range
00001FE4 B243                       		cmp.w	d3,d1
00001FE6 6500                       		bcs.s	.End				; Branch if in range
00001FE8 B244                       		cmp.w	d4,d1
00001FEA 6300                       		bls.s	.Spawn				; Branch if in range
00001FEC                            
00001FEC                            .End:
00001FEC 5448                       		addq.w	#2,a0				; Next objeect
00001FEE 7201                       		moveq	#1,d1				; Ensure that upstream code knows to continue loading
00001FF0 4E75                       		rts
00001FF2                            
00001FF2                            .LoadNoY:
00001FF2 C245                       		and.w	d5,d1				; Keey Y in range
00001FF4                            
00001FF4                            .Spawn:
00001FF4 08D3 0007                  		bset	#7,(a3)				; Mark as loaded
00001FF8 3347 0014                  		move.w	d7,oXPos(a1)			; Store X position
00001FFC 3341 0018                  		move.w	d1,oYPos(a1)			; Store Y position
00002000                            
00002000 E75A                       		rol.w	#3,d2				; Get X and Y flip bits
00002002 0242 0003                  		andi.w	#3,d2				; ''
00002006 1342 000D                  		move.b	d2,oRender(a1)			; Set render flags
0000200A 1342 0028                  		move.b	d2,oStatus(a1)			; Set status
0000200E                            
0000200E 1418                       		move.b	(a0)+,d2			; Get ID
00002010 D442                       		add.w	d2,d2				; Make it an index in the level object index list
00002012 D442                       		add.w	d2,d2
00002014 22B4 2000                  		move.l	(a4,d2.w),oAddr(a1)		; Set address
00002018                            
00002018 1358 0024                  		move.b	(a0)+,oSubtype(a1)		; Set subtype
0000201C 334B 0026                  		move.w	a3,oRespawn(a1)			; Set respawn address
00002020                            		
00002020 6000 F9FA                  		bra.w	FindFreeObj			; Find a free object slot
00002024                            		
00002024                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002024                            ; Check if the object is in range on the camera. If it isn't, delete it
00002024                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002024                            ; PARAMETERS:
00002024                            ;	a0.l	- Object space pointer
00002024                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002024                            ; RETURNS:
00002024                            ;	Nothing
00002024                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002024                            CheckObjActive:
00002024 3028 0014                  		move.w	oXPos(a0),d0			; Get X position
00002028                            
00002028                            CheckObjActive2:
00002028 0240 FF80                  		andi.w	#$FF80,d0			; Only allow multiples of $80
0000202C 9078 C7C6                  		sub.w	rObjXCoarse.w,d0		; Subtract the camera's coarse X position
00002030 0C40 0280                  		cmpi.w	#$280,d0			; Has it gone offscreen?
00002034 6200                       		bhi.s	.Delete				; If so, branch
00002036 4E75                       		rts
00002038                            
00002038                            .Delete:
00002038 3028 0026                  		move.w	oRespawn(a0),d0			; Get respawn table entry address
0000203C 6700                       		beq.s	.DoDelete			; If 0, branch
0000203E 3440                       		movea.w	d0,a2
00002040 0892 0007                  		bclr	#7,(a2)				; Mark as gone
00002044                            
00002044                            .DoDelete:
00002044 4EF8 1A72                  		jmp	DeleteObject.w			; Delete the object
00002048                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002048                            ; Get orientation to player
00002048                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002048                            ; PARAMETERS:
00002048                            ;	a0.l	- Object space pointer
00002048                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002048                            ; RETURNS:
00002048                            ;	a1.l	- Player object
00002048                            ;	d0.w	- 0 if player is left from object, 2 if right
00002048                            ;	d1.w	- 0 if player is above object, 2 if below
00002048                            ;	d2.w	- Player's horizontal distance to object
00002048                            ;	d3.w	- Player's vertical distance to object
00002048                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002048                            GetOrientToPlayer:
00002048 7000                       		moveq	#0,d0
0000204A 7200                       		moveq	#0,d1
0000204C                            
0000204C 3278 F86C                  		movea.w	rPlayer1Addr.w,a1		; Get player object
00002050                            
00002050 3428 0014                  		move.w	oXPos(a0),d2			; Get horizonal distance
00002054 9469 0014                  		sub.w	oXPos(a1),d2			; ''
00002058 6A00                       		bpl.s	.GetY				; Branch if the player is left from the object
0000205A 5440                       		addq.w	#2,d0				; Set flag to indicate that the player is right from the object
0000205C                            
0000205C                            .GetY:
0000205C 3628 0018                  		move.w	oYPos(a0),d3			; Get vertical distance
00002060 9669 0018                  		sub.w	oYPos(a1),d3			; ''
00002064 6400                       		bhs.s	.End				; Branch if the player is above the object
00002066 5441                       		addq.w	#2,d1				; Set flag to indicate that the player is below the object
00002068                            
00002068                            .End:
00002068 4E75                       		rts
0000206A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000206A                            ; Cap an object's speed
0000206A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000206A                            ; PARAMETERS:
0000206A                            ;	a0.l	- Object space pointer
0000206A                            ;	d0.w	- Max X speed
0000206A                            ;	d1.w	- Max Y speed
0000206A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000206A                            ; RETURNS:
0000206A                            ;	Nothing
0000206A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000206A                            CapObjSpeed:
0000206A 3428 001C                  		move.w	oXVel(a0),d2			; Get X velocity
0000206E 6A00                       		bpl.s	.ChkRight			; If we are going right, branch
00002070 4440                       		neg.w	d0				; Get absolute speed
00002072 B440                       		cmp.w	d0,d2				; Has it gone over the limit?
00002074 6400                       		bhs.s	.ChkUp				; If not, branch
00002076 3400                       		move.w	d0,d2				; Cap the speed
00002078 6000                       		bra.s	.ChkUp				; Continue
0000207A                            
0000207A                            .ChkRight:
0000207A B440                       		cmp.w	d0,d2				; Has it gone over the limit?
0000207C 6300                       		bls.s	.ChkUp				; If not, branch
0000207E 3400                       		move.w	d0,d2				; Cap the speed
00002080                            
00002080                            .ChkUp:
00002080 3628 001E                  		move.w	oYVel(a0),d3			; Get Y velocity
00002084 6A00                       		bpl.s	.ChkDown			; If we are going right, branch
00002086 4441                       		neg.w	d1				; Get absolute speed
00002088 B641                       		cmp.w	d1,d3				; Has it gone over the limit?
0000208A 6400                       		bhs.s	.UpdateVel			; If not, branch
0000208C 3601                       		move.w	d1,d3				; Cap the speed
0000208E 6000                       		bra.s	.UpdateVel			; Continue
00002090                            
00002090                            .ChkDown:
00002090 B641                       		cmp.w	d1,d3				; Has it gone over the limit?
00002092 6300                       		bls.s	.UpdateVel			; If not, branch
00002094 3601                       		move.w	d1,d3				; Cap the speed
00002096                            
00002096                            .UpdateVel:
00002096 3142 001C                  		move.w	d2,oXVel(a0)			; Set X velocity
0000209A 3142 001E                  		move.w	d2,oYVel(a0)			; Set Y velocity
0000209E 4E75                       		rts
000020A0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000020A0                            ; Load a child object	NTP: no idea wtf to do about this one. do we even need it since all objects are kinda linked anyway? we'll have to see
000020A0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000020A0                            ; PARAMETERS:
000020A0                            ;	a2.l	- Object data
000020A0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000020A0                            ; RETURNS:
000020A0                            ;	Nothing
000020A0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000020A0                            ; LoadChildObject:
000020A0 6100 F97A                  		bsr.w	FindFreeObj			; Find a free object slot
000020A4 6600                       		bne.s	.End				; If there is non, branch
000020A6 301A                       		move.w	(a2)+,d0			; Get parent object SST
000020A8 3388 0000                  		move.w	a0,(a1,d0.w)			; Store parent object
000020AC 301A                       		move.w	(a2)+,d0			; Get child object SST
000020AE 3189 0000                  		move.w	a1,(a0,d0.w)			; Store child object
000020B2 229A                       		move.l	(a2)+,oAddr(a1)			; Set object pointer
000020B4 135A 0024                  		move.b	(a2)+,oSubtype(a1)		; Set subtype
000020B8 3368 0014 0014             		move.w	oXPos(a0),oXPos(a1)			; Set X
000020BE 3368 0018 0018             		move.w	oYPos(a0),oYPos(a1)			; Set Y
000020C4                            
000020C4                            .End:
000020C4 4E75                       		rts
000020C6                            ; =========================================================================================================================================================
000020C6                            		include	"Libraries/Interrupt.asm"	; Interrupt functions
000020C6                            ; =========================================================================================================================================================
000020C6                            ; Interrupt functions
000020C6                            ; =========================================================================================================================================================
000020C6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000020C6                            ; Vertical Interrupts
000020C6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000020C6                            VInt_Standard:
000020C6                            		intsOff					; Turn interrupts off
000020C6 007C 0700                M 	ori	#$700,sr
000020CA                            		push.l	d0-a6				; Save registers
000020CA 48E7 FFFE                M 	movem.l	d0-a6,-(sp)
000020CE                            		
000020CE 4DF9 00C0 0004             		lea	VDP_CTRL,a6			; VDP control port
000020D4 4BEE FFFC                  		lea	-4(a6),a5			; VDP data port
000020D8                            
000020D8                            .WaitForVBLANK:
000020D8 3016                       		move.w	(a6),d0				; Get VDP status
000020DA 0240 0008                  		andi.w	#8,d0				; Are we in a VBLANK period?
000020DE 67F8                       		beq.s	.WaitForVBLANK			; If not, wait
000020E0                            
000020E0 0838 0006 C744             		btst	#6,rHWVersion.w		; Is this a PAL system?
000020E6 6700                       		beq.s	.SetVScroll			; If not, branch
000020E8 303C 0700                  		move.w	#$700,d0			; Do a delay
000020EC 51C8 FFFE                  		dbf	d0,*				; ''
000020F0                            
000020F0                            .SetVScroll:
000020F0                            		dma68k	rVScroll,0,$50,VSRAM		; Load VScroll buffer into VSRAM
000020F0 2CBC 9400 9328           M 	move.l	#$94009300|(((($50)/2)&$ff00)<<8)|((($50)/2)&$ff),(a6)
000020F6 2CBC 96CA 953F           M 	move.l	#$96009500|((((rvscroll)/2)&$ff00)<<8)|(((rvscroll)/2)&$ff),(a6)
000020FC 3CBC 977F                M 	move.w	#$9700|(((rvscroll)>>17)&$7f),(a6)
00002100                          M 	vdpcmd	move.w,0,vsram,dma,>>16,(a6)
00002100 3CBC 4000                M 	move.w	#((((vsram&dma)&3)<<30)|((0&$3fff)<<16)|(((vsram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
00002104                          M 	vdpcmd	move.w,0,vsram,dma,&$ffff,-(sp)
00002104 3F3C 0090                M 	move.w	#((((vsram&dma)&3)<<30)|((0&$3fff)<<16)|(((vsram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
00002108 3C9F                     M 	move.w	(sp)+,(a6)
0000210A                            
0000210A 4A38 C745                  		tst.b	rVINTRout.w			; Is the game lagging?
0000210E 6700 0000                  		beq.w	VInt_Lag_Main			; If so, branch
00002112 4238 C748                  		clr.b	rLagCount.w			; Clear lag frame counter
00002116                            
00002116 7000                       		moveq	#0,d0
00002118 1038 C745                  		move.b	rVINTRout.w,d0		; Get V-INT routine ID
0000211C 4238 C745                  		clr.b	rVINTRout.w			; Clear V-INT routine ID
00002120 50F8 C749                  		st	rHIntFlag.w			; Allow the H-INT to run
00002124 303B 0000                  		move.w	VInt_Routines(pc,d0.w),d0	; Get V-INT routine offset
00002128 4EBB 0000                  		jsr	VInt_Routines(pc,d0.w)		; Jump to the routine
0000212C                            
0000212C                            VInt_FinishUpdates:
0000212C 4EB9 0000 0000             		jsr	UpdateAMPS			; Run the AMPS driver
00002132                            
00002132                            VInt_End:
00002132 52B8 C756                  		addq.l	#1,rFrameCnt.w		; Increment frame count
00002136 6100 F216                  		bsr.w	RandomNumber			; Generate a random number
0000213A                            		
0000213A                            		pop.l	d0-a6				; Restore registers
0000213A 4CDF 7FFF                M 	movem.l	(sp)+,d0-a6
0000213E                            		intsOn					; Turn interrupts on
0000213E 027C F8FF                M 	andi	#$f8ff,sr
00002142                            		lagOn					; Turn on the lag-o-meter
00002142 4E73                       		rte
00002144                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002144                            ; V-INT routines
00002144                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002144                            VInt_Routines:
00002144 0000                       		dc.w	VInt_Lag-VInt_Routines		; Lag routine
00002146 0000                       		dc.w	VInt_General-VInt_Routines	; General routine
00002148 0000                       		dc.w	VInt_Level-VInt_Routines	; Level routine
0000214A 0000                       		dc.w	VInt_LevelLoad-VInt_Routines	; Level load routine
0000214C 0000                       		dc.w	VInt_Title-VInt_Routines	; Title screen routine
0000214E 0000                       		dc.w	VInt_Fade-VInt_Routines		; Fade routine
00002150                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002150                            ; V-INT lag routine
00002150                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002150                            VInt_Lag:
00002150 584F                       		addq.w	#4,sp				; Don't return to caller
00002152                            
00002152                            VInt_Lag_Main:
00002152 4A38 F8F5                  		tst.b	rWaterFullscr.w		; Is water fullscreen?
00002156 6600                       		bne.s	.WaterPal			; If so, branch
00002158                            		dma68k	rPalette,0,$80,CRAM		; Load palette into CRAM
00002158 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
0000215E 2CBC 96CC 9567           M 	move.l	#$96009500|((((rpalette)/2)&$ff00)<<8)|(((rpalette)/2)&$ff),(a6)
00002164 3CBC 977F                M 	move.w	#$9700|(((rpalette)>>17)&$7f),(a6)
00002168                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
00002168 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
0000216C                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
0000216C 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
00002170 3C9F                     M 	move.w	(sp)+,(a6)
00002172 6000                       		bra.s	.Cont				; Continue
00002174                            
00002174                            .WaterPal:
00002174                            		dma68k	rWaterPal,0,$80,CRAM		; Load water palette into CRAM
00002174 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
0000217A 2CBC 96CC 9527           M 	move.l	#$96009500|((((rwaterpal)/2)&$ff00)<<8)|(((rwaterpal)/2)&$ff),(a6)
00002180 3CBC 977F                M 	move.w	#$9700|(((rwaterpal)>>17)&$7f),(a6)
00002184                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
00002184 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
00002188                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
00002188 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
0000218C 3C9F                     M 	move.w	(sp)+,(a6)
0000218E                            
0000218E                            .Cont:	
0000218E 3CB8 C75E                  		move.w	rHIntReg.w,(a6)		; Set H-INT counter
00002192                            
00002192 5238 C748                  		addq.b	#1,rLagCount.w		; Increment lag counter
00002196 6000 FF94                  		bra.w	VInt_FinishUpdates		; Go update SMPS
0000219A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000219A                            ; V-INT general routine
0000219A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000219A                            VInt_General:
0000219A 6100 0000                  		bsr.w	VInt_Update			; Do updates
0000219E 6000 EF38                  		bra.w	SetKosBookmark			; Set Kosinski decompression bookmark
000021A2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000021A2                            ; V-INT level load routine
000021A2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000021A2                            VInt_LevelLoad:
000021A2 6100 E916                  		bsr.w	ReadJoypads			; Read joypads
000021A6                            
000021A6 4A38 F8F5                  		tst.b	rWaterFullscr.w		; Is water fullscreen?
000021AA 6600                       		bne.s	.WaterPal			; If so, branch
000021AC                            		dma68k	rPalette,0,$80,CRAM		; Load palette into CRAM
000021AC 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
000021B2 2CBC 96CC 9567           M 	move.l	#$96009500|((((rpalette)/2)&$ff00)<<8)|(((rpalette)/2)&$ff),(a6)
000021B8 3CBC 977F                M 	move.w	#$9700|(((rpalette)>>17)&$7f),(a6)
000021BC                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
000021BC 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
000021C0                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
000021C0 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
000021C4 3C9F                     M 	move.w	(sp)+,(a6)
000021C6 6000                       		bra.s	.Cont				; Continue
000021C8                            
000021C8                            .WaterPal:
000021C8                            		dma68k	rWaterPal,0,$80,CRAM		; Load water palette into CRAM
000021C8 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
000021CE 2CBC 96CC 9527           M 	move.l	#$96009500|((((rwaterpal)/2)&$ff00)<<8)|(((rwaterpal)/2)&$ff),(a6)
000021D4 3CBC 977F                M 	move.w	#$9700|(((rwaterpal)>>17)&$7f),(a6)
000021D8                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
000021D8 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
000021DC                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
000021DC 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
000021E0 3C9F                     M 	move.w	(sp)+,(a6)
000021E2                            
000021E2                            .Cont:
000021E2 3CB8 C75E                  		move.w	rHIntReg.w,(a6)		; Set H-INT counter
000021E6                            		
000021E6                            		dma68k	rSprites,$F800,$280,VRAM	; Load sprite table into VRAM
000021E6 2CBC 9401 9340           M 	move.l	#$94009300|(((($280)/2)&$ff00)<<8)|((($280)/2)&$ff),(a6)
000021EC 2CBC 96CA 9567           M 	move.l	#$96009500|((((rsprites)/2)&$ff00)<<8)|(((rsprites)/2)&$ff),(a6)
000021F2 3CBC 977F                M 	move.w	#$9700|(((rsprites)>>17)&$7f),(a6)
000021F6                          M 	vdpcmd	move.w,$f800,vram,dma,>>16,(a6)
000021F6 3CBC 7800                M 	move.w	#((((vram&dma)&3)<<30)|(($f800&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($f800&$c000)>>14))>>16,(a6)
000021FA                          M 	vdpcmd	move.w,$f800,vram,dma,&$ffff,-(sp)
000021FA 3F3C 0083                M 	move.w	#((((vram&dma)&3)<<30)|(($f800&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($f800&$c000)>>14))&$ffff,-(sp)
000021FE 3C9F                     M 	move.w	(sp)+,(a6)
00002200                            		dma68k	rHScroll,$FC00,$380,VRAM	; Load H-Scroll table into VRAM
00002200 2CBC 9401 93C0           M 	move.l	#$94009300|(((($380)/2)&$ff00)<<8)|((($380)/2)&$ff),(a6)
00002206 2CBC 96C8 957F           M 	move.l	#$96009500|((((rhscroll)/2)&$ff00)<<8)|(((rhscroll)/2)&$ff),(a6)
0000220C 3CBC 977F                M 	move.w	#$9700|(((rhscroll)>>17)&$7f),(a6)
00002210                          M 	vdpcmd	move.w,$fc00,vram,dma,>>16,(a6)
00002210 3CBC 7C00                M 	move.w	#((((vram&dma)&3)<<30)|(($fc00&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($fc00&$c000)>>14))>>16,(a6)
00002214                          M 	vdpcmd	move.w,$fc00,vram,dma,&$ffff,-(sp)
00002214 3F3C 0083                M 	move.w	#((((vram&dma)&3)<<30)|(($fc00&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($fc00&$c000)>>14))&$ffff,-(sp)
00002218 3C9F                     M 	move.w	(sp)+,(a6)
0000221A 6100 E18C                  		bsr.w	ProcessDMAQueue			; Process DMA queue
0000221E                            		
0000221E 6000 EEB8                  		bra.w	SetKosBookmark			; Set Kosinski decompression bookmark
00002222                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002222                            ; V-INT level routine
00002222                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002222                            VInt_Level:
00002222 43F8 F880                  		lea	rFGCam.w,a1			; Foreground level drawing variables
00002226 47F8 C2A0                  		lea	rFGColBuf.w,a3		; Foreground column plane buffer
0000222A 49F8 C19E                  		lea	rFGRowBuf.w,a4		; Foreground row plane buffer
0000222E 4EB9 0000 0000             		jsr	VInt_DrawLevel			; Update the foreground plane
00002234 43F8 F89E                  		lea	rBGCam.w,a1			; Background level drawing variables
00002238 47F8 C424                  		lea	rBGColBuf.w,a3		; Background column plane buffer
0000223C 49F8 C322                  		lea	rBGRowBuf.w,a4		; Background row plane buffer
00002240 4EB9 0000 0000             		jsr	VInt_DrawLevel			; Update the background plane
00002246                            
00002246 6100 E872                  		bsr.w	ReadJoypads			; Read joypads
0000224A                            
0000224A 4A38 F8F5                  		tst.b	rWaterFullscr.w		; Is water fullscreen?
0000224E 6600                       		bne.s	.WaterPal			; If so, branch
00002250                            		dma68k	rPalette,0,$80,CRAM		; Load palette into CRAM
00002250 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
00002256 2CBC 96CC 9567           M 	move.l	#$96009500|((((rpalette)/2)&$ff00)<<8)|(((rpalette)/2)&$ff),(a6)
0000225C 3CBC 977F                M 	move.w	#$9700|(((rpalette)>>17)&$7f),(a6)
00002260                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
00002260 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
00002264                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
00002264 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
00002268 3C9F                     M 	move.w	(sp)+,(a6)
0000226A 6000                       		bra.s	.Cont				; Continue
0000226C                            
0000226C                            .WaterPal:
0000226C                            		dma68k	rWaterPal,0,$80,CRAM		; Load water palette into CRAM
0000226C 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
00002272 2CBC 96CC 9527           M 	move.l	#$96009500|((((rwaterpal)/2)&$ff00)<<8)|(((rwaterpal)/2)&$ff),(a6)
00002278 3CBC 977F                M 	move.w	#$9700|(((rwaterpal)>>17)&$7f),(a6)
0000227C                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
0000227C 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
00002280                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
00002280 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
00002284 3C9F                     M 	move.w	(sp)+,(a6)
00002286                            
00002286                            .Cont:
00002286 3CB8 C75E                  		move.w	rHIntReg.w,(a6)		; Set H-INT counter
0000228A                            
0000228A                            		dma68k	rSprites,$F800,$280,VRAM	; Load sprite table into VRAM
0000228A 2CBC 9401 9340           M 	move.l	#$94009300|(((($280)/2)&$ff00)<<8)|((($280)/2)&$ff),(a6)
00002290 2CBC 96CA 9567           M 	move.l	#$96009500|((((rsprites)/2)&$ff00)<<8)|(((rsprites)/2)&$ff),(a6)
00002296 3CBC 977F                M 	move.w	#$9700|(((rsprites)>>17)&$7f),(a6)
0000229A                          M 	vdpcmd	move.w,$f800,vram,dma,>>16,(a6)
0000229A 3CBC 7800                M 	move.w	#((((vram&dma)&3)<<30)|(($f800&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($f800&$c000)>>14))>>16,(a6)
0000229E                          M 	vdpcmd	move.w,$f800,vram,dma,&$ffff,-(sp)
0000229E 3F3C 0083                M 	move.w	#((((vram&dma)&3)<<30)|(($f800&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($f800&$c000)>>14))&$ffff,-(sp)
000022A2 3C9F                     M 	move.w	(sp)+,(a6)
000022A4                            		dma68k	rHScroll,$FC00,$380,VRAM	; Load H-Scroll table into VRAM
000022A4 2CBC 9401 93C0           M 	move.l	#$94009300|(((($380)/2)&$ff00)<<8)|((($380)/2)&$ff),(a6)
000022AA 2CBC 96C8 957F           M 	move.l	#$96009500|((((rhscroll)/2)&$ff00)<<8)|(((rhscroll)/2)&$ff),(a6)
000022B0 3CBC 977F                M 	move.w	#$9700|(((rhscroll)>>17)&$7f),(a6)
000022B4                          M 	vdpcmd	move.w,$fc00,vram,dma,>>16,(a6)
000022B4 3CBC 7C00                M 	move.w	#((((vram&dma)&3)<<30)|(($fc00&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($fc00&$c000)>>14))>>16,(a6)
000022B8                          M 	vdpcmd	move.w,$fc00,vram,dma,&$ffff,-(sp)
000022B8 3F3C 0083                M 	move.w	#((((vram&dma)&3)<<30)|(($fc00&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($fc00&$c000)>>14))&$ffff,-(sp)
000022BC 3C9F                     M 	move.w	(sp)+,(a6)
000022BE 6100 E0E8                  		bsr.w	ProcessDMAQueue			; Process DMA queue
000022C2                            		
000022C2 0C38 005C C75F             		cmpi.b	#92,rHIntCnt.w		; Would V-INT be unable to do updates in the next frame?
000022C8 6400                       		bhs.s	.DoUpdates			; If not, branch
000022CA 50F8 C75D                  		st	rHIntUpdates.W		; Set updates in H-INT flag
000022CE 584F                       		addq.w	#4,sp				; Skip SMPS update routine afterwards
000022D0 6100 EE06                  		bsr.w	SetKosBookmark			; Set Kosinski decompression bookmark
000022D4 6000 FE5C                  		bra.w	VInt_End			; Continue
000022D8                            
000022D8                            .DoUpdates:
000022D8 4EB9 0000 0000             		jsr	Level_UpdateHUD			; Update the HUD
000022DE 6000 EDF8                  		bra.w	SetKosBookmark			; Set Kosinski decompression bookmark
000022E2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000022E2                            ; V-INT title screen update routine
000022E2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000022E2                            VInt_Title:
000022E2 4E75                       		rts
000022E4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000022E4                            ;		bsr.w	ReadJoypads			; Read joypads
000022E4                            ;
000022E4                            ;		move.l	#$C0000000,VDP_CTRL		; Write palette to CRAM
000022E4                            ;		lea	rPalette.w,a0			; ''
000022E4                            ;		moveq	#$80>>2-1,d0			; ''
000022E4                            ;
000022E4                            ;.WritePal:
000022E4                            ;		move.l	(a0)+,VDP_DATA			; ''
000022E4                            ;		dbf	d0,.WritePal			; ''
000022E4                            ;
000022E4                            ;		move.l	#$78000003,VDP_CTRL		; Write sprite data to VRAM
000022E4                            ;		lea	rSprites.w,a0			; ''
000022E4                            ;		move.w	#$280>>2-1,d0			; ''
000022E4                            ;
000022E4                            ;.WriteSprs:
000022E4                            ;		move.l	(a0)+,VDP_DATA			; ''
000022E4                            ;		dbf	d0,.WriteSprs			; ''
000022E4                            ;
000022E4                            ;		move.l	#$7C000003,VDP_CTRL		; Write HScroll table to VRAM
000022E4                            ;		lea	rHScroll.w,a0			; ''
000022E4                            ;		move.w	#$380>>2-1,d0			; ''
000022E4                            ;
000022E4                            ;.WriteHScrl:
000022E4                            ;		move.l	(a0)+,VDP_DATA			; ''
000022E4                            ;		dbf	d0,.WriteHScrl			; ''
000022E4                            ;		rts
000022E4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000022E4                            ; Do standard updates in V-INT
000022E4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000022E4                            VInt_Update:
000022E4                            	; NTP: We don't want to update sprites during a fade, thus it's not shared with the below interrupt routine
000022E4                            		dma68k	rSprites,$F800,$280,VRAM	; Load sprite table into VRAM
000022E4 2CBC 9401 9340           M 	move.l	#$94009300|(((($280)/2)&$ff00)<<8)|((($280)/2)&$ff),(a6)
000022EA 2CBC 96CA 9567           M 	move.l	#$96009500|((((rsprites)/2)&$ff00)<<8)|(((rsprites)/2)&$ff),(a6)
000022F0 3CBC 977F                M 	move.w	#$9700|(((rsprites)>>17)&$7f),(a6)
000022F4                          M 	vdpcmd	move.w,$f800,vram,dma,>>16,(a6)
000022F4 3CBC 7800                M 	move.w	#((((vram&dma)&3)<<30)|(($f800&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($f800&$c000)>>14))>>16,(a6)
000022F8                          M 	vdpcmd	move.w,$f800,vram,dma,&$ffff,-(sp)
000022F8 3F3C 0083                M 	move.w	#((((vram&dma)&3)<<30)|(($f800&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($f800&$c000)>>14))&$ffff,-(sp)
000022FC 3C9F                     M 	move.w	(sp)+,(a6)
000022FE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000022FE                            ; V-INT fade routine
000022FE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000022FE                            VInt_Fade:
000022FE 6100 E7BA                  		bsr.w	ReadJoypads			; Read joypads
00002302                            
00002302 4A38 F8F5                  		tst.b	rWaterFullscr.w		; Is water fullscreen?
00002306 6600                       		bne.s	.WaterPal			; If so, branch
00002308                            		dma68k	rPalette,0,$80,CRAM		; Load palette into CRAM
00002308 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
0000230E 2CBC 96CC 9567           M 	move.l	#$96009500|((((rpalette)/2)&$ff00)<<8)|(((rpalette)/2)&$ff),(a6)
00002314 3CBC 977F                M 	move.w	#$9700|(((rpalette)>>17)&$7f),(a6)
00002318                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
00002318 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
0000231C                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
0000231C 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
00002320 3C9F                     M 	move.w	(sp)+,(a6)
00002322 6000                       		bra.s	.Cont				; Continue
00002324                            
00002324                            .WaterPal:
00002324                            		dma68k	rWaterPal,0,$80,CRAM		; Load water palette into CRAM
00002324 2CBC 9400 9340           M 	move.l	#$94009300|(((($80)/2)&$ff00)<<8)|((($80)/2)&$ff),(a6)
0000232A 2CBC 96CC 9527           M 	move.l	#$96009500|((((rwaterpal)/2)&$ff00)<<8)|(((rwaterpal)/2)&$ff),(a6)
00002330 3CBC 977F                M 	move.w	#$9700|(((rwaterpal)>>17)&$7f),(a6)
00002334                          M 	vdpcmd	move.w,0,cram,dma,>>16,(a6)
00002334 3CBC C000                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))>>16,(a6)
00002338                          M 	vdpcmd	move.w,0,cram,dma,&$ffff,-(sp)
00002338 3F3C 0080                M 	move.w	#((((cram&dma)&3)<<30)|((0&$3fff)<<16)|(((cram&dma)&$fc)<<2)|((0&$c000)>>14))&$ffff,-(sp)
0000233C 3C9F                     M 	move.w	(sp)+,(a6)
0000233E                            
0000233E                            .Cont:
0000233E 3CB8 C75E                  		move.w	rHIntReg.w,(a6)		; Set H-INT counter
00002342                            
00002342                            		dma68k	rHScroll,$FC00,$380,VRAM	; Load H-Scroll table into VRAM
00002342 2CBC 9401 93C0           M 	move.l	#$94009300|(((($380)/2)&$ff00)<<8)|((($380)/2)&$ff),(a6)
00002348 2CBC 96C8 957F           M 	move.l	#$96009500|((((rhscroll)/2)&$ff00)<<8)|(((rhscroll)/2)&$ff),(a6)
0000234E 3CBC 977F                M 	move.w	#$9700|(((rhscroll)>>17)&$7f),(a6)
00002352                          M 	vdpcmd	move.w,$fc00,vram,dma,>>16,(a6)
00002352 3CBC 7C00                M 	move.w	#((((vram&dma)&3)<<30)|(($fc00&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($fc00&$c000)>>14))>>16,(a6)
00002356                          M 	vdpcmd	move.w,$fc00,vram,dma,&$ffff,-(sp)
00002356 3F3C 0083                M 	move.w	#((((vram&dma)&3)<<30)|(($fc00&$3fff)<<16)|(((vram&dma)&$fc)<<2)|(($fc00&$c000)>>14))&$ffff,-(sp)
0000235A 3C9F                     M 	move.w	(sp)+,(a6)
0000235C 6000 E04A                  		bra.w	ProcessDMAQueue			; Process DMA queue
00002360                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002360                            ; V-INT routine that only runs the SMPS driver
00002360                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002360                            VInt_RunSMPS:
00002360                            		push.l	d0-a6				; Save registers
00002360 48E7 FFFE                M 	movem.l	d0-a6,-(sp)
00002364                            		
00002364                            .WaitForVBLANK:
00002364 3039 00C0 0004             		move.w	VDP_CTRL,d0			; Get VDP status
0000236A 0240 0008                  		andi.w	#8,d0				; Are we in a VBLANK period?
0000236E 67F4                       		beq.s	.WaitForVBLANK			; If not, wait
00002370                            
00002370 0838 0006 C744             		btst	#6,rHWVersion.w		; Is this a PAL system?
00002376 6700                       		beq.s	.UpdateSMPS			; If not, branch
00002378 303C 0700                  		move.w	#$700,d0			; Do a delay
0000237C 51C8 FFFE                  		dbf	d0,*				; ''
00002380                            
00002380                            .UpdateSMPS:
00002380 4EB9 0000 0000             		jsr	UpdateAMPS			; Run the AMPS driver
00002386                            
00002386 52B8 C756                  		addq.l	#1,rFrameCnt.w		; Increment frame count
0000238A 6100 EFC2                  		bsr.w	RandomNumber			; Generate a random number
0000238E                            		
0000238E                            		pop.l	d0-a6				; Restore registers
0000238E 4CDF 7FFF                M 	movem.l	(sp)+,d0-a6
00002392 4E73                       		rte
00002394                            
00002394                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002394                            ; Wait for the vertical interrupt to run and finish
00002394                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002394                            ; PARAMETERS:
00002394                            ;	Nothing
00002394                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002394                            ; RETURNS:
00002394                            ;	Nothing
00002394                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002394                            VSync:
00002394 50F8 C745                  		st	rVINTFlag.w			; Set V-INT flag
00002398                            
00002398                            VSync_Routine:
00002398                            		intsOn					; Enable interrupts
00002398 027C F8FF                M 	andi	#$f8ff,sr
0000239C                            		lagOff					; Turn off the lag-o-meter
0000239C                            
0000239C                            .Wait:
0000239C 4A38 C745                  		tst.b	rVINTFlag.w			; Has the V-INT run yet?
000023A0 66FA                       		bne.s	.Wait				; If not, wait some more
000023A2 4E75                       		rts
000023A4                            
000023A4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023A4                            ; Horizontal interrupt for palette swapping (for water)
000023A4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000023A4                            HInt_Water:
000023A4                            		intsOff					; Disable interrupts
000023A4 007C 0700                M 	ori	#$700,sr
000023A8                            
000023A8 4A38 C749                  		tst.b	rHIntFlag.w			; Is the H-INT allowed to run?
000023AC 6700                       		beq.s	.End				; If not, branch
000023AE 4238 C749                  		clr.b	rHIntFlag.w			; Clear the H-INT flag
000023B2                            
000023B2                            		push.l	a0-a1				; Save registers
000023B2 48E7 00C0                M 	movem.l	a0-a1,-(sp)
000023B6                            
000023B6 43F9 00C0 0000             		lea	VDP_DATA,a1			; VDP data port
000023BC 337C 8AFF 0004             		move.w	#$8AFF,4(a1)			; Don't do any more H-INT calls for the rest of the frame
000023C2 41F8 984E                  		lea	rWaterPal.w,a0		; Water palette
000023C6                            		vdpCmd	move.l, 0, CRAM, WRITE, 4(a1)	; Set VDP command
000023C6 237C C000 0000 0004      M 	move.l	#((((cram&write)&3)<<30)|((0&$3fff)<<16)|(((cram&write)&$fc)<<2)|((0&$c000)>>14)),4(a1)
000023CE                            		rept	32
000023CE                            			move.l	(a0)+,(a1)		; Tranfer palette
000023CE                            		endr
000023CE 2298                     M 	move.l	(a0)+,(a1)
000023D0 2298                     M 	move.l	(a0)+,(a1)
000023D2 2298                     M 	move.l	(a0)+,(a1)
000023D4 2298                     M 	move.l	(a0)+,(a1)
000023D6 2298                     M 	move.l	(a0)+,(a1)
000023D8 2298                     M 	move.l	(a0)+,(a1)
000023DA 2298                     M 	move.l	(a0)+,(a1)
000023DC 2298                     M 	move.l	(a0)+,(a1)
000023DE 2298                     M 	move.l	(a0)+,(a1)
000023E0 2298                     M 	move.l	(a0)+,(a1)
000023E2 2298                     M 	move.l	(a0)+,(a1)
000023E4 2298                     M 	move.l	(a0)+,(a1)
000023E6 2298                     M 	move.l	(a0)+,(a1)
000023E8 2298                     M 	move.l	(a0)+,(a1)
000023EA 2298                     M 	move.l	(a0)+,(a1)
000023EC 2298                     M 	move.l	(a0)+,(a1)
000023EE 2298                     M 	move.l	(a0)+,(a1)
000023F0 2298                     M 	move.l	(a0)+,(a1)
000023F2 2298                     M 	move.l	(a0)+,(a1)
000023F4 2298                     M 	move.l	(a0)+,(a1)
000023F6 2298                     M 	move.l	(a0)+,(a1)
000023F8 2298                     M 	move.l	(a0)+,(a1)
000023FA 2298                     M 	move.l	(a0)+,(a1)
000023FC 2298                     M 	move.l	(a0)+,(a1)
000023FE 2298                     M 	move.l	(a0)+,(a1)
00002400 2298                     M 	move.l	(a0)+,(a1)
00002402 2298                     M 	move.l	(a0)+,(a1)
00002404 2298                     M 	move.l	(a0)+,(a1)
00002406 2298                     M 	move.l	(a0)+,(a1)
00002408 2298                     M 	move.l	(a0)+,(a1)
0000240A 2298                     M 	move.l	(a0)+,(a1)
0000240C 2298                     M 	move.l	(a0)+,(a1)
0000240E                            		pop.l	a0-a1				; Restore registers
0000240E 4CDF 0300                M 	movem.l	(sp)+,a0-a1
00002412                            		
00002412 4A38 C75D                  		tst.b	rHIntUpdates.w		; Do we need to do level updates in here?
00002416 6600                       		bne.s	.DoUpdates			; If so, branch
00002418                            
00002418                            .End:
00002418 4E73                       		rte
0000241A                            
0000241A                            .DoUpdates:
0000241A 4238 C75D                  		clr.b	rHIntUpdates.w		; Clear the update flag
0000241E                            		push.l	d0-a6				; Save registers
0000241E 48E7 FFFE                M 	movem.l	d0-a6,-(sp)
00002422 4DF9 00C0 0004             		lea	VDP_CTRL,a6			; VDP control port
00002428 4BEE FFFC                  		lea	-4(a6),a5			; VDP data port
0000242C 4EB9 0000 0000             		jsr	Level_UpdateHUD			; Update the HUD
00002432 4EB9 0000 0000             		jsr	UpdateAMPS			; Run the AMPS driver
00002438                            		pop.l	d0-a6				; Restore registers
00002438 4CDF 7FFF                M 	movem.l	(sp)+,d0-a6
0000243C 4E73                       		rte
0000243E                            ; =========================================================================================================================================================
0000243E                            
0000243E                            ; =========================================================================================================================================================
0000243E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000243E                            ; Opmode Main Code
0000243E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000243E                            		include	"Opmodes/Title/Main.asm"
0000243E                            ; =========================================================================================================================================================
0000243E                            ; Title splash screen
0000243E                            ; =========================================================================================================================================================
0000243E                            
0000243E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000243E                            TitleScreen:
0000243E 60FE                       		bra.s	TitleScreen
00002440                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------	
00002440                            ;		playSnd	#Mus_Stop, 1			; Stop sound
00002440                            ;
00002440                            ;		bsr.w	FadeToBlack			; Fade to black
00002440                            ;
00002440                            ;		intsOff					; Disable interrupts
00002440                            ;		clrRAM	rKosPVars
00002440                            ;		clrRAM	rChkpoint
00002440                            ;		clrRAM	rGameVars
00002440                            ;		clrRAM	rObjects
00002440                            ;
00002440                            ;		lea	VDP_CTRL,a5
00002440                            ;		move.w	#$8004,(a5)			; $8004 - Disable H-INT, H/V Counter
00002440                            ;		move.w	#$8174,(a5)			; $8134 - Enable display, enable V-INT, enable DMA, V28
00002440                            ;		move.w	#$8230,(a5)			; $8230 - Plane A at $C000
00002440                            ;		move.w	#$8407,(a5)			; $8407 - Plane B at $E000
00002440                            ;		move.w	#$9011,(a5)			; $9001 - 64x64 cell plane area
00002440                            ;		move.w	#$9200,(a5)			; $9200 - Window V position at default
00002440                            ;		move.w	#$8B00,(a5)			; $8B03 - V-Scroll by screen, H-Scroll by screen
00002440                            ;		move.w	#$8700,(a5)			; $8700 - BG color pal 0 color 0
00002440                            ;		clr.w	rDMAQueue.w			; Set stop token at the beginning of the DMA queue
00002440                            ;		move.w	#rDMAQueue,rDMASlot.w	; Reset the DMA queue slot
00002440                            ;
00002440                            ;		bsr.w	ClearScreen			; Clear screen
00002440                            ;
00002440                            ;		lea	rDestPal.w,a0			; Fade target palette
00002440                            ;		moveq	#$80>>2-1,d0			; Size
00002440                            ;
00002440                            ;.FillPal:
00002440                            ;		move.l	#$0EEE0EEE,(a0)+		; Fill palette with white
00002440                            ;		dbf	d0,.FillPal			; Loop
00002440                            ;
00002440                            ;		bsr.w	FadeFromBlack			; Fade from black
00002440                            ;		
00002440                            ;		bsr.w	SEGA_FMV			; Run SEGA FMV
00002440                            ;
00002440                            ;TitleScreen2:
00002440                            ;		intsOff
00002440                            ;
00002440                            ;		clr.b	rArtCheat.w
00002440                            ;		clrRAM	rGameVars
00002440                            ;		clrRAM	rObjects
00002440                            ;
00002440                            ;		move.w	#$8200|($C000/$400),VDP_CTRL	; Reset plane A address
00002440                            ;		bsr.w	FadeToWhite			; Fade to white
00002440                            ;
00002440                            ;		intsOff
00002440                            ;		bsr.w	ClearScreen			; Clear screen
00002440                            ;
00002440                            ;		lea	MapEni_TitleBG,a0		; Decompress background mappings
00002440                            ;		lea	rBuffer,a1			; Decompress into RAM
00002440                            ;		moveq	#1,d0				; Base tile properties: Tile ID 1, no flags
00002440                            ;		bsr.w	EniDec				; Decompress!
00002440                            ;
00002440                            ;		lea	rBuffer,a1			; Load mappings
00002440                            ;		move.l	#$60000003,d0			; At (0, 0) on plane A
00002440                            ;		moveq	#$27,d1				; $28x$1C tiles
00002440                            ;		moveq	#$1B,d2				; ''
00002440                            ;		moveq	#0,d3				; Base tile properties: Tile ID 0, no flags
00002440                            ;		bsr.w	LoadPlaneMap			; Load the map
00002440                            ;
00002440                            ;		lea	MapEni_TitleLogo,a0		; Decompress logo mappings
00002440                            ;		lea	rBuffer,a1			; Decompress into RAM
00002440                            ;		move.w	#$8370,d0			; Base tile properties: Tile ID 1, no flags
00002440                            ;		bsr.w	EniDec				; Decompress!
00002440                            ;
00002440                            ;		lea	rBuffer,a1			; Load mappings
00002440                            ;		move.l	#$41040003,d0			; At (0, 0) on plane A
00002440                            ;		moveq	#$E,d1				; $28x$1C tiles
00002440                            ;		moveq	#$C,d2				; ''
00002440                            ;		moveq	#0,d3				; Base tile properties: Tile ID 0, no flags
00002440                            ;		bsr.w	LoadPlaneMap			; Load the map
00002440                            ;
00002440                            ;		lea	Pal_Title,a0			; Load palette to target buffer
00002440                            ;		move.w	#(Pal_Title_End-Pal_Title)>>1-1,d0
00002440                            ;		bsr.w	LoadTargetPal			; ''
00002440                            ;
00002440                            ;		lea	ArtKosM_TitleBG,a1		; Load background art
00002440                            ;		move.w	#$20,d2				; ''
00002440                            ;		bsr.w	QueueKosMData			; ''
00002440                            ;
00002440                            ;		lea	ArtKosM_TitleLogo,a1		; Load logo art
00002440                            ;		move.w	#$6E00,d2			; ''
00002440                            ;		bsr.w	QueueKosMData			; ''
00002440                            ;
00002440                            ;		lea	ArtKosM_TtlSonic,a1		; Load Sonic art
00002440                            ;		move.w	#$4000,d2			; ''
00002440                            ;		bsr.w	QueueKosMData			; ''
00002440                            ;
00002440                            ;		lea	ArtKosM_TtlBird,a1		; Load bird art
00002440                            ;		move.w	#$8400,d2			; ''
00002440                            ;		bsr.w	QueueKosMData			; ''
00002440                            ;
00002440                            ;		lea	ArtKosM_TtlGlove,a1		; Load glove art
00002440                            ;		move.w	#$8600,d2			; ''
00002440                            ;		bsr.w	QueueKosMData			; ''
00002440                            ;
00002440                            ;.WaitPLCs:
00002440                            ;		move.b	#vGeneral,rVINTRout.w		; Level load V-INT routine
00002440                            ;		jsr	ProcessKos.w			; Process Kosinski queue
00002440                            ;		jsr	VSync_Routine.w			; V-SYNC
00002440                            ;		jsr	ProcessKosM.w			; Process Kosinski Moduled queue
00002440                            ;		tst.b	rKosPMMods.w			; Are there still modules left?
00002440                            ;		bne.s	.WaitPLCs			; If so, branch
00002440                            ;		move.b	#vGeneral,rVINTRout.w		; Level load V-INT routine
00002440                            ;		jsr	VSync_Routine.w			; V-SYNC
00002440                            ;		
00002440                            ;		move.l	#ObjTtlSonic,rObj_0.w		; Load the Sonic object
00002440                            ;		move.w	#320+96,(rObj_0+oX).w		; Set X
00002440                            ;		move.w	#128,(rObj_0+oY).w		; Set Y
00002440                            ;
00002440                            ;		move.l	#ObjTtlBird,rObj_1.w		; Load the bird object
00002440                            ;		move.w	#-64,(rObj_1+oX).w		; Set X
00002440                            ;		move.w	#64,(rObj_1+oY).w		; Set Y
00002440                            ;
00002440                            ;		move.l	#ObjTtlGlove,rObj_2.w		; Load the glove object
00002440                            ;		move.w	#224,(rObj_2+oX).w		; Set X
00002440                            ;		move.w	#320,(rObj_2+oY).w		; Set Y
00002440                            ;
00002440                            ;		jsr	RunObjects.w			; Run objects
00002440                            ;		jsr	RenderObjects.w			; Render objects
00002440                            ;
00002440                            ;		clr.w	rPalCycTimer.w		; Reset palette cycle
00002440                            ;
00002440                            ;		bsr.w	FadeFromWhite			; Fade from white
00002440                            ;
00002440                            ;		lea	SampleList+$C0,a3		; Play title screen music
00002440                            ;		jsr	PlayDAC1			; ''
00002440                            ;
00002440                            ;.Loop:
00002440                            ;		move.b	#vTitle,rVINTRout.w		; V-SYNC
00002440                            ;		bsr.w	VSync_Routine			; ''
00002440                            ;
00002440                            ;		bsr.s	Title_Updates			; Do updates
00002440                            ;		
00002440                            ;		jsr	RunObjects.w			; Run objects
00002440                            ;		jsr	RenderObjects.w			; Render objects
00002440                            ;
00002440                            ;		lea	FreeMove_Cheat(pc),a0
00002440                            ;		lea	rMoveCheat.w,a1
00002440                            ;		lea	rCheatEntry.w,a2
00002440                            ;		bsr.w	Title_ChkCheats
00002440                            ;		lea	Art_Cheat(pc),a0
00002440                            ;		lea	rArtCheat.w,a1
00002440                            ;		lea	rCheatEntry2.w,a2
00002440                            ;		bsr.w	Title_ChkCheats
00002440                            ;
00002440                            ;		tst.b	rArtCheat.w
00002440                            ;		bne.w	BinbowieArt
00002440                            ;
00002440                            ;		tst.b	rP1Press.w			; Has start been pressed
00002440                            ;		bpl.s	.Loop				; If so, branch
00002440                            ;
00002440                            ;		st	(rObj_2+oGloveFlag).w		; Set the punch flag
00002440                            ;
00002440                            ;		lea	SampleList+$E0,a3		; Punch
00002440                            ;		jsr	PlayDAC1			; ''
00002440                            ;
00002440                            ;.PunchLoop:
00002440                            ;		move.b	#vTitle,rVINTRout.w		; V-SYNC
00002440                            ;		bsr.w	VSync_Routine			; ''
00002440                            ;
00002440                            ;		bsr.s	Title_Updates			; Do updates
00002440                            ;
00002440                            ;		jsr	RunObjects.w			; Run objects
00002440                            ;		jsr	RenderObjects.w			; Render objects
00002440                            ;		
00002440                            ;		tst.b	(rObj_2+oGloveTime).w		; Has the timer run out?
00002440                            ;		bpl.s	.PunchLoop			; If not, loop
00002440                            ;		
00002440                            ;		st	rStartFall.w			; Set flag to start the level by falling
00002440                            ;
00002440                            ;		move.b	#gLevel,rGameMode.w		; Set game mode to "level"
00002440                            ;		jmp	Level				; Go to level
00002440                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002440                            ; Palette cycle
00002440                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002440                            ;Title_Updates:
00002440                            ;		move.b	rLogoAngle.w,d0		; Get logo hover angle
00002440                            ;		addq.b	#4,rLogoAngle.w		; Increment angle
00002440                            ;		jsr	CalcSine.w			; Get sine
00002440                            ;		asr.w	#5,d0				; ''
00002440                            ;		move.w	d0,rVScrollFG.w		; Set logo's Y position
00002440                            ;
00002440                            ;		subq.b	#1,rPalCycTimer.w		; Decrement timer
00002440                            ;		bpl.s	.End				; If it hasn't run out, branch
00002440                            ;		move.b	#6,rPalCycTimer.w		; Reset timer
00002440                            ;		
00002440                            ;		moveq	#0,d0
00002440                            ;		move.b	rPalCycIndex.w,d0		; Get index
00002440                            ;		mulu.w	#$C,d0				; Turn into offset
00002440                            ;		lea	PalCyc_Title(pc,d0.w),a0	; Get pointer to palette data
00002440                            ;		lea	(rPalette+$14).w,a1		; Palette
00002440                            ;		move.w	(a0)+,(a1)+			; Load palette
00002440                            ;		move.w	(a0)+,(a1)+			; ''
00002440                            ;		move.w	(a0)+,(a1)+			; ''
00002440                            ;		move.w	(a0)+,(a1)+			; ''
00002440                            ;		move.w	(a0)+,(a1)+			; ''
00002440                            ;		move.w	(a0)+,(a1)+			; ''
00002440                            ;		
00002440                            ;		addq.b	#1,rPalCycIndex.w		; Increment index
00002440                            ;		cmpi.b	#6,rPalCycIndex.w		; Has it reached the end?
00002440                            ;		bcs.s	.End				; If not, branch
00002440                            ;		clr.b	rPalCycIndex.w		; Reset index
00002440                            
00002440                            ;.End:
00002440                            ;		rts
00002440                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002440                            ;PalCyc_Title:
00002440                            ;		dc.w	$00E, $08E, $0EE, $0E0, $E00, $808
00002440                            ;		dc.w	$08E, $0EE, $0E0, $E00, $808, $00E
00002440                            ;		dc.w	$0EE, $0E0, $E00, $808, $00E, $08E
00002440                            ;		dc.w	$0E0, $E00, $808, $00E, $08E, $0EE
00002440                            ;		dc.w	$E00, $808, $00E, $08E, $0EE, $0E0
00002440                            ;		dc.w	$808, $00E, $08E, $0EE, $0E0, $E00
00002440                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002440                            ; Check for cheats
00002440                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002440                            ;Title_ChkCheats:
00002440                            ;		tst.b	(a1)
00002440                            ;		bne.s	.End
00002440                            ;		move.w	(a2),d0
00002440                            ;		adda.w	d0,a0
00002440                            ;		move.b	rP1Press.w,d0
00002440                            ;		cmp.b	(a0),d0
00002440                            ;		bne.s	.ResetCheat
00002440                            ;		addq.w	#1,(a2)
00002440                            ;		tst.b	d0
00002440                            ;		bne.s	.End
00002440                            ;		st	(a1)
00002440                            ;		playSnd	#sRing, 2
00002440                            ;		rts
00002440                            ;
00002440                            ;.ResetCheat:
00002440                            ;		tst.b	d0
00002440                            ;		beq.s	.End
00002440                            ;		clr.w	(a2)
00002440                            ;
00002440                            ;.End:
00002440                            ;		rts
00002440                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002440                            ;FreeMove_Cheat:
00002440                            ;		dc.b	1, 2, 4, 8, 0, $FF
00002440                            ;		even
00002440                            ;Art_Cheat:
00002440                            ;		dc.b	1, 1, 2, 2, 4, 8, 4, 8, $40, $10, $40, $10, 0, $FF
00002440                            ;		even
00002440                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002440                            ; BinBowie's art
00002440                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002440                            ;BinbowieArt:
00002440                            ;		bsr.w	FadeToWhite			; Fade to white
00002440                            ;		
00002440                            ;		lea	SampleList,a3
00002440                            ;		jsr	PlayDAC1
00002440                            ;
00002440                            ;		intsOff
00002440                            ;
00002440                            ;		jsr	ClearScreen.w
00002440                            ;
00002440                            ;		lea	MapEni_BinBowieArt(pc),a0	; Decompress mappings
00002440                            ;		lea	rBuffer,a1			; Decompress into RAM
00002440                            ;		moveq	#1,d0				; Base tile properties: Tile ID 1, no flags
00002440                            ;		bsr.w	EniDec				; Decompress!
00002440                            ;
00002440                            ;		lea	rBuffer,a1			; Load mappings
00002440                            ;		move.l	#$40000003,d0			; At (0, 0) on plane A
00002440                            ;		moveq	#$27,d1				; $28x$1C tiles
00002440                            ;		moveq	#$1B,d2				; ''
00002440                            ;		moveq	#0,d3				; Base tile properties: Tile ID 0, no flags
00002440                            ;		bsr.w	LoadPlaneMap			; Load the map
00002440                            ;
00002440                            ;		lea	Pal_BinBowieArt,a0		; Load palette to target buffer
00002440                            ;		move.w	#(Pal_BinBowieArt_End-Pal_BinBowieArt)>>1-1,d0
00002440                            ;		bsr.w	LoadTargetPal			; ''
00002440                            ;
00002440                            ;		lea	ArtKosM_BinBowieArt,a1		; Load art
00002440                            ;		move.w	#$20,d2				; ''
00002440                            ;		bsr.w	QueueKosMData			; ''
00002440                            ;
00002440                            ;.WaitPLCs:
00002440                            ;		move.b	#vGeneral,rVINTRout.w		; Level load V-INT routine
00002440                            ;		jsr	ProcessKos.w			; Process Kosinski queue
00002440                            ;		jsr	VSync_Routine.w			; V-SYNC
00002440                            ;		jsr	ProcessKosM.w			; Process Kosinski Moduled queue
00002440                            ;		tst.b	rKosPMMods.w			; Are there still modules left?
00002440                            ;		bne.s	.WaitPLCs			; If so, branch
00002440                            ;		move.b	#vGeneral,rVINTRout.w		; Level load V-INT routine
00002440                            ;		jsr	VSync_Routine.w			; V-SYNC
00002440                            ;
00002440                            ;		jsr	FadeFromWhite.w
00002440                            ;
00002440                            ;		lea	SampleList+$100,a3
00002440                            ;		jsr	PlayDAC1
00002440                            ;
00002440                            ;.Loop:
00002440                            ;		move.b	#vTitle,rVINTRout.w		; Level load V-INT routine
00002440                            ;		jsr	ProcessKos.w			; Process Kosinski queue
00002440                            ;		move.b	rP1Press.w,d0
00002440                            ;		andi.b	#%10010000,d0
00002440                            ;		beq.s	.Loop
00002440                            ;
00002440                            ;		jmp	TitleScreen2
00002440                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002440                            ; Objects
00002440                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002440                            ;		include	"Title Screen/Objects/Sonic/Code.asm"
00002440                            ;		include	"Title Screen/Objects/Bird/Code.asm"
00002440                            ;		include	"Title Screen/Objects/Glove/Code.asm"
00002440                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002440                            ; Art
00002440                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002440                            ;ArtKosM_TitleBG:
00002440                            ;		incbin	"Title Screen/Data/Art - Background.kosm.bin"
00002440                            ;		even
00002440                            ;ArtKosM_TitleLogo:
00002440                            ;		incbin	"Title Screen/Data/Art - Logo.kosm.bin"
00002440                            ;		even
00002440                            ;ArtKosM_BinBowieArt:
00002440                            ;		incbin	"Title Screen/Data/Art - BinBowie.kosm.bin"
00002440                            ;		even
00002440                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002440                            ; Plane mappings
00002440                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002440                            ;MapEni_TitleBG:
00002440                            ;		incbin	"Title Screen/Data/Map - Background.eni.bin"
00002440                            ;		even
00002440                            ;MapEni_TitleLogo:
00002440                            ;		incbin	"Title Screen/Data/Map - Logo.eni.bin"
00002440                            ;		even
00002440                            ;MapEni_BinBowieArt:
00002440                            ;		incbin	"Title Screen/Data/Map - BinBowie.eni.bin"
00002440                            ;		even
00002440                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002440                            ; Palette
00002440                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002440                            ;Pal_Title:
00002440                            ;		incbin	"Title Screen/Data/Palette.pal.bin"
00002440                            ;Pal_Title_End:
00002440                            ;		even
00002440                            ;Pal_BinBowieArt:
00002440                            ;		incbin	"Title Screen/Data/BinBowie Palette.pal.bin"
00002440                            ;Pal_BinBowieArt_End:
00002440                            ;		even
00002440                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002440                            ; SEGA FMV
00002440                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002440                            ;		include	"Title Screen/SEGA FMV/FMV.asm"
00002440                            ; =========================================================================================================================================================
00002440                            		include	"Opmodes/Gameplay/Main.asm"
00002440                            ; =========================================================================================================================================================
00002440                            ; Level
00002440                            ; =========================================================================================================================================================
00002440                            Level:
00002440                            		playSnd	#Mus_FadeOut, 1			; Fade out sound
00002440 11FC 0002 C4BC           M 	move.b	#mus_fadeout,(mqueue+((1)-1)).w
00002446                            
00002446 4EB8 0552                  		jsr	FadeToBlack			; Fade to black
0000244A                            
0000244A                            Level_NoFade:
0000244A                            		; --- Set up the VDP ---
0000244A                            
0000244A                            		intsOff					; Disable interrupts
0000244A 007C 0700                M 	ori	#$700,sr
0000244E                            		displayOff				; Disable display
0000244E 3038 C764                M 	move.w	rvdpreg1.w,d0
00002452 0200 00BF                M 	andi.b	#%10111111,d0
00002456 33C0 00C0 0004           M 	move.w	d0,vdp_ctrl
0000245C                            
0000245C 4BF9 00C0 0004             		lea	VDP_CTRL,a5			; VDP control port
00002462 3ABC 8004                  		move.w	#$8004,(a5)			; Disable H-INT
00002466 3ABC 8230                  		move.w	#$8230,(a5)			; Plane A at $C000
0000246A 3ABC 8407                  		move.w	#$8407,(a5)			; Plane B at $E000
0000246E 3ABC 8720                  		move.w	#$8720,(a5)			; Set background color to palette line 2, entry 0
00002472 3ABC 8B03                  		move.w	#$8B03,(a5)			; V-Scroll by screen, H-Scroll by scanline
00002476 3ABC 9001                  		move.w	#$9001,(a5)			; 64x32 cell plane area
0000247A 303C 9200                  		move.w	#$9200,d0			; Make the window invisible
0000247E 31C0 C766                  		move.w	d0,rWindowY.w			; ''
00002482 3A80                       		move.w	d0,(a5)				; ''
00002484 4278 9000                  		clr.w	rDMAQueue.w			; Set stop token at the beginning of the DMA queue
00002488 31FC 9000 90FC             		move.w	#rDMAQueue,rDMASlot.w	; Reset the DMA queue slot
0000248E                            
0000248E 4EB8 0248                  		jsr	ClearScreen.w			; Clear the screen
00002492                            
00002492                            		; --- Clear some RAM ---
00002492                            
00002492                            		clrRAM	rKosPVars			; Clear Kosinski queue variables
00002492                          M 	local	endaddr
00002492                          M endaddr	equs	"rkospvars_End"
00002492 7000                     M 	moveq	#0,d0
00002494 43F8 994E                M 	lea	(rkospvars).w,a1
00002498 323C 0040                M 	move.w	#(((rkospvars_end)-(rkospvars))-((rkospvars)&1))>>2-1,d1
0000249C 22C0                     M .clear_134:	move.l	d0,(a1)+
0000249E 51C9 FFFC                M 	dbf	d1,.clear_134
000024A2 32C0                     M 	move.w	d0,(a1)+
000024A4                            		clrRAM	rGameVars			; Clear variables
000024A4                          M 	local	endaddr
000024A4                          M endaddr	equs	"rgamevars_End"
000024A4 7000                     M 	moveq	#0,d0
000024A6 43F8 C7D0                M 	lea	(rgamevars).w,a1
000024AA 323C 0DCB                M 	move.w	#(((rgamevars_end)-(rgamevars))-((rgamevars)&1))>>2-1,d1
000024AE 22C0                     M .clear_135:	move.l	d0,(a1)+
000024B0 51C9 FFFC                M 	dbf	d1,.clear_135
000024B4                            		clrRAM	rOscNums			; Clear oscillation data
000024B4                          M 	local	endaddr
000024B4                          M endaddr	equs	"roscnums_End"
000024B4 7000                     M 	moveq	#0,d0
000024B6 43F8 C76A                M 	lea	(roscnums).w,a1
000024BA 323C 000F                M 	move.w	#(((roscnums_end)-(roscnums))-((roscnums)&1))>>2-1,d1
000024BE 22C0                     M .clear_136:	move.l	d0,(a1)+
000024C0 51C9 FFFC                M 	dbf	d1,.clear_136
000024C4 32C0                     M 	move.w	d0,(a1)+
000024C6                            
000024C6                            		; --- Do some final initializing and play the level music ---
000024C6                            
000024C6 11FC 0003 F3D8             		move.b	#3,rRingAniTime.w		; Set ring animation timer
000024CC 31FC 001E F900             		move.w	#30,rFloorTimer.w		; Set floor timer
000024D2 4278 C7CE                  		clr.w	rPalCycTimer.w		; Reset palette cycle
000024D6                            
000024D6 41FA 0000                  		lea	Level_MusicIDs(pc),a0		; Music ID list
000024DA 3038 C7AC                  		move.w	rLevel.w,d0			; Get level ID
000024DE E218                       		ror.b	#1,d0				; Turn into offset
000024E0 EE48                       		lsr.w	#7,d0				; ''
000024E2 1030 0000                  		move.b	(a0,d0.w),d0			; Get music ID
000024E6 11C0 F8D6                  		move.b	d0,rLevelMusic.w		; Store it
000024EA                            		playSnd	d0, 1				; Play it
000024EA 11C0 C4BC                M 	move.b	d0,(mqueue+((1)-1)).w
000024EE                            
000024EE                            		intsOn					; Enable interrupts
000024EE 027C F8FF                M 	andi	#$f8ff,sr
000024F2                            
000024F2                            		; --- Load level data ---
000024F2                            
000024F2 47F9 0000 0000             		lea	PLC_LevelMain,a3		; Load main level PLCs
000024F8 4EB8 0F4C                  		jsr	LoadKosMQueue.w			; ''
000024FC                            
000024FC 4EB8 19BE                  		jsr	InitObjectList.w
00002500                            
00002500 4EB8 1A1C                  		jsr	FindFreeObj.w
00002504 22BC 0000 0000             		move.l	#ObjPlayer,oAddr(a1)		; Load Player object
0000250A 31C9 F86C                  		move.w	a1,rPlayer1Addr.w		; Store the address
0000250E                            
0000250E 4A38 F8F4                  		tst.b	rWaterFlag.w			; Does the level have water?
00002512 6700                       		beq.s	.NoSurface			; If not, branch
00002514                            
00002514                            							; Load water surfaces
00002514 4EB8 1A1C                  		jsr	FindFreeObj.w
00002518 22BC 0000 0000             		move.l	#ObjWaterSurface,oAddr(a1)
0000251E 337C 0060 0014             		move.w	#$60,oXPos(a1)
00002524 31C9 F87C                  		move.w	a1,rWater1Addr.w		; Store the address
00002528                            
00002528 4EB8 1A1C                  		jsr	FindFreeObj.w
0000252C 22BC 0000 0000             		move.l	#ObjWaterSurface,oAddr(a1)
00002532 337C 0120 0014             		move.w	#$120,oXPos(a1)
00002538 31C9 F87E                  		move.w	a1,rWater2Addr.w		; Store the address
0000253C                            
0000253C                            .NoSurface:
0000253C 6100 0000                  		bsr.w	Level_LoadData			; Load level data
00002540                            
00002540                            .WaitPLCs:
00002540 11FC 0002 C745             		move.b	#vGeneral,rVINTRout.w		; Level load V-INT routine
00002546 4EB8 1102                  		jsr	ProcessKos.w			; Process Kosinski queue
0000254A 4EB8 2398                  		jsr	VSync_Routine.w			; V-SYNC
0000254E 4EB8 0FAE                  		jsr	ProcessKosM.w			; Process Kosinski Moduled queue
00002552 4A38 9990                  		tst.b	rKosPMMods.w			; Are there still modules left?
00002556 66E8                       		bne.s	.WaitPLCs			; If so, branch
00002558                            
00002558 4238 F8F4                  		clr.b	rWaterFlag.w			; Clear the water flag
0000255C                            
0000255C 41FA 0000                  		lea	Level_WaterLevels(pc),a0	; Water heights
00002560 3038 C7AC                  		move.w	rLevel.w,d0			; Get level ID
00002564 E218                       		ror.b	#1,d0				; Turn into offset
00002566 EC48                       		lsr.w	#6,d0				; ''
00002568 3030 0000                  		move.w	(a0,d0.w),d0			; Get water height
0000256C 6B00                       		bmi.s	.NoWater			; If it's negative, branch
0000256E 31C0 F8F6                  		move.w	d0,rWaterLvl.w		; Set the water height
00002572 31C0 F8F8                  		move.w	d0,rDestWtrLvl.w
00002576                            
00002576 50F8 F8F4                  		st	rWaterFlag.w			; Set the water flag
0000257A 33FC 8014 00C0 0004        		move.w	#$8014,VDP_CTRL			; Enable H-INT
00002582 6100 0000                  		bsr.w	Level_WaterHeight		; Update water height
00002586 33F8 C75E 00C0 0004        		move.w	rHIntReg.w,VDP_CTRL		; Set H-INT counter
0000258E                            
0000258E                            .NoWater:
0000258E 31FC 00A0 F8D2             		move.w	#320/2,rCamXPosCenter.w		; Set camera X center
00002594                            
00002594 4EB8 18E4                  		jsr	InitOscillation.w		; Initialize oscillation
00002598                            
00002598 6100 0000                  		bsr.w	Level_HandleCamera		; Initialize the camera
0000259C 6100 0000                  		bsr.w	Level_InitHUD			; Initialize the HUD
000025A0 6100 0000                  		bsr.w	Level_WaterHeight		; Initialize water height
000025A4                            
000025A4 6100 0000                  		bsr.w	Level_AnimateArt		; Animate level art
000025A8                            
000025A8                            		; --- Load the planes ---
000025A8                            
000025A8                            		intsOff					; Disable interrupts
000025A8 007C 0700                M 	ori	#$700,sr
000025AC 21FC 0000 2360 C74C        		move.l	#VInt_RunSMPS,rVIntAddr.w	; Swap V-INT
000025B4                            		intsOn					; Enable interrupts
000025B4 027C F8FF                M 	andi	#$f8ff,sr
000025B8 6100 0000                  		bsr.w	Level_InitPlanes		; Initialize the planes
000025BC                            		intsOff					; Disable interrupts
000025BC 007C 0700                M 	ori	#$700,sr
000025C0 21FC 0000 20C6 C74C        		move.l	#VInt_Standard,rVIntAddr.w	; Swap V-INT
000025C8                            		intsOn					; Enable interrupts
000025C8 027C F8FF                M 	andi	#$f8ff,sr
000025CC 11FC 0006 C745             		move.b	#vLvlLoad,rVINTRout.w		; Level load V-INT routine
000025D2 4EB8 2398                  		jsr	VSync_Routine.w			; V-SYNC
000025D6                            
000025D6                            		; --- Load the level objects and rings ---
000025D6                            
000025D6 51F8 C7B8                  		sf	rObjManInit.w			; Reset object manager routine
000025DA 6100 0000                  		bsr.w	Level_RingsManager		; Initialize the ring manager
000025DE 4EB8 1DB8                  		jsr	ObjectManager.w			; Run the object manager
000025E2                            	runObjects
000025E2 3078 BE58                M 	movea.w	rtailnext.w,a0
000025E6 2250                     M 	move.l	oaddr(a0),a1
000025E8 4E91                     M 	jsr	(a1)
000025EA 4EB8 1ABA                  		jsr	RenderObjects.w			; Render objects
000025EE                            
000025EE 4238 F8FC                  		clr.b	rLvlReload.w			; Clear the level reload flag
000025F2                            
000025F2                            		displayOn				; Enable display
000025F2 3038 C764                M 	move.w	rvdpreg1.w,d0
000025F6 0000 0040                M 	ori.b	#%01000000,d0
000025FA 33C0 00C0 0004           M 	move.w	d0,vdp_ctrl
00002600 4EB8 05CE                  		jsr	FadeFromBlack.w			; Fade from black
00002604                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002604                            ; Main loop
00002604                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002604                            .Loop:
00002604 11FC 0004 C745             		move.b	#vLevel,rVINTRout.w		; Level V-INT routine
0000260A 4EB8 1102                  		jsr	ProcessKos.w			; Process Kosinski queue
0000260E 4EB8 2398                  		jsr	VSync_Routine.w			; V-SYNC
00002612                            
00002612 4EB8 0000                  		jsr	CheckPause.w			; Check for pausing
00002616 5278 F8FA                  		addq.w	#1,rLvlFrames.w			; Increment frame counter
0000261A                            
0000261A 4EB8 1938                  		jsr	UpdateOscillation.w		; Update oscillation
0000261E                            
0000261E 6100 0000                  		bsr.w	Level_RingsManager		; Run the ring manager
00002622 4EB8 1DB8                  		jsr	ObjectManager.w			; Run the object manager
00002626                            
00002626                            	runObjects
00002626 3078 BE58                M 	movea.w	rtailnext.w,a0
0000262A 2250                     M 	move.l	oaddr(a0),a1
0000262C 4E91                     M 	jsr	(a1)
0000262E                            
0000262E 4A38 F8FC                  		tst.b	rLvlReload.w			; Does the level need to be reloaded?
00002632 6600 FE0C                  		bne.w	Level				; If so, branch
00002636                            
00002636 6100 0000                  		bsr.w	Level_HandleCamera		; Handle the camera
0000263A 6100 0000                  		bsr.w	Level_UpdatePlanes		; Update the planes (draw new tiles and scroll)
0000263E 6100 0000                  		bsr.w	Level_UpdateWaterSurface	; Update the water surface
00002642                            
00002642 4EB8 1ABA                  		jsr	RenderObjects.w			; Render objects
00002646                            
00002646 6100 0000                  		bsr.w	Level_WaterHeight		; Update water height
0000264A 6100 0000                  		bsr.w	Level_AnimateArt		; Animate level art
0000264E 6100 0000                  		bsr.w	Level_PalCycle			; Do palette cycling
00002652 6100 0000                  		bsr.w	Level_DynEvents			; Run dynamic events
00002656                            
00002656 5338 F3D8                  		subq.b	#1,rRingAniTime.w		; Decrement ring animation timer
0000265A 6A00                       		bpl.s	.NoRingAni			; If it hasn't run out, branch
0000265C 11FC 0003 F3D8             		move.b	#3,rRingAniTime.w		; Reset animation timer
00002662 5238 F3D7                  		addq.b	#1,rRingFrame.w			; Next ring frame
00002666 0238 0007 F3D7             		andi.b	#7,rRingFrame.w			; Limit it
0000266C                            
0000266C 7000                       		moveq	#0,d0
0000266E 1038 F3D7                  		move.b	rRingFrame.w,d0			; Get ring frame
00002672 EF48                       		lsl.w	#7,d0				; Convert to offset
00002674 223C 0000 0000             		move.l	#ArtUnc_Ring,d1			; Source address
0000267A D280                       		add.l	d0,d1				; ''
0000267C 343C D780                  		move.w	#$D780,d2			; VRAM address
00002680 363C 0040                  		move.w	#$80/2,d3			; Size
00002684 4EB8 0304                  		jsr	QueueDMATransfer.w		; Queue a transfer
00002688                            
00002688                            .NoRingAni:
00002688 4A38 F3D9                  		tst.b	rRLossAniT.w
0000268C 6700                       		beq.s	.NoRingLossAni
0000268E 7000                       		moveq	#0,d0
00002690 1038 F3D9                  		move.b	rRLossAniT.w,d0
00002694 D078 F3DA                  		add.w	rRLossAniA.w,d0
00002698 31C0 F3DA                  		move.w	d0,rRLossAniA.w
0000269C E158                       		rol.w	#8,d0
0000269E 0240 0007                  		andi.w	#7,d0
000026A2 11C0 F3DC                  		move.b	d0,rRLossAniF.w
000026A6 5338 F3D9                  		subq.b	#1,rRLossAniT.w
000026AA                            
000026AA 7000                       		moveq	#0,d0
000026AC 1038 F3DC                  		move.b	rRLossAniF.w,d0		; Get ring frame
000026B0 EF48                       		lsl.w	#7,d0				; Convert to offset
000026B2 223C 0000 0000             		move.l	#ArtUnc_Ring,d1			; Source address
000026B8 D280                       		add.l	d0,d1				; ''
000026BA 343C D680                  		move.w	#$D680,d2			; VRAM address
000026BE 363C 0040                  		move.w	#$80/2,d3			; Size
000026C2 4EB8 0304                  		jsr	QueueDMATransfer.w		; Queue a transfer
000026C6                            
000026C6                            .NoRingLossAni:
000026C6 4EB8 0FAE                  		jsr	ProcessKosM.w			; Process Kosinski Moduled queue
000026CA                            
000026CA 0C38 0004 C75A             		cmpi.b	#gLevel,rGameMode.w		; Is the game mode level?
000026D0 6700 FF32                  		beq.w	.Loop				; If so, branch
000026D4 4EF8 0220                  		jmp	GotoGameMode.w			; Go to the correct game mode
000026D8                            
000026D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000026D8                            ; Check for pausing
000026D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000026D8                            CheckPause:
000026D8 4A38 C75C                  		tst.b	rPauseFlag.w			; Is the game already paused?
000026DC 6600                       		bne.s	.SetPause			; If so, branch
000026DE 0838 0007 C741             		btst	#7,rP1Press.w			; Has the start button been pressed?
000026E4 6700                       		beq.s	.End				; If not, branch
000026E6                            
000026E6                            .SetPause:
000026E6 50F8 C75C                  		st	rPauseFlag.w			; Pause the game
000026EA                            		AMPS_MUSPAUSE				; Pause the music
000026EA 11FC 0008 C4BE           M 	move.b	#mus_pause,mqueue+2.w
000026F0                            
000026F0                            .PauseLoop:
000026F0 11FC 0002 C745             		move.b	#vGeneral,rVINTRout.w		; General V-INT routine
000026F6 6100 FCA0                  		bsr.w	VSync_Routine			; V-SYNC
000026FA 0838 0007 C741             		btst	#7,rP1Press.w			; Has the start button been pressed?
00002700 67EE                       		beq.s	.PauseLoop			; If not, branch
00002702                            
00002702                            		AMPS_MUSUNPAUSE				; Unpause the music
00002702 11FC 0009 C4BE           M 	move.b	#mus_unpause,mqueue+2.w
00002708 4238 C75C                  		clr.b	rPauseFlag.w			; Unpause the game
0000270C                            
0000270C                            .End:
0000270C 4E75                       		rts
0000270E                            
0000270E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000270E                            ; Level functions
0000270E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000270E                            		include	"Opmodes/Gameplay/Level Drawing.asm"
0000270E                            ; =========================================================================================================================================================
0000270E                            ; Level drawing functions (Based on Sonic Crackers' and S3K's level drawing engine)
0000270E                            ; =========================================================================================================================================================
0000270E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000270E                            ; Initialize the planes
0000270E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000270E                            ; PARAMETERS:
0000270E                            ;	Nothing
0000270E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000270E                            ; RETURNS:
0000270E                            ;	Nothing
0000270E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000270E                            Level_InitPlanes:
0000270E 43F8 F880                  		lea	rFGCam.w,a1			; Get foreground level drawing RAM
00002712 47F8 C2A0                  		lea	rFGColBuf.w,a3		; Get foreground column plane buffer
00002716 49F8 C19E                  		lea	rFGRowBuf.w,a4		; Get foreground row plane buffer
0000271A                            
0000271A 237C 4000 0003 0012        		move.l	#$40000003,cVDP(a1)		; Set the base VDP command for drawing tiles
00002722 4269 0016                  		clr.w	cLayout(a1)			; Set the offset for the level layout (foreground)
00002726                            		
00002726 3038 C7AC                  		move.w	rLevel.w,d0			; Get level ID
0000272A E218                       		ror.b	#1,d0				; Turn into offset
0000272C E648                       		lsr.w	#3,d0				; ''
0000272E 41F9 0000 0000             		lea	Level_RenderRouts,a0		; Get initialization routine list
00002734 2370 0008 0018             		move.l	8(a0,d0.w),cUpdate(a1)		; Set the update routine pointer
0000273A 2070 0000                  		movea.l	(a0,d0.w),a0			; Get initialization pointer
0000273E 4E90                       		jsr	(a0)				; Jump to it
00002740                            
00002740 31E9 0008 947E             		move.w	cYPos(a1),rVScrollFG.w		; Set the V-Scroll value for the foreground
00002746                            
00002746 43F8 F89E                  		lea	rBGCam.w,a1			; Get background level drawing RAM
0000274A 47F8 C424                  		lea	rBGColBuf.w,a3		; Get background column plane buffer
0000274E 49F8 C322                  		lea	rBGRowBuf.w,a4		; Get background row plane buffer
00002752                            		
00002752 237C 6000 0003 0012        		move.l	#$60000003,cVDP(a1)		; Set the base VDP command for drawing tils
0000275A 337C 0080 0016             		move.w	#$80,cLayout(a1)		; Set the offset for the level layout (background)
00002760                            		
00002760 3038 C7AC                  		move.w	rLevel.w,d0			; Get level ID
00002764 E218                       		ror.b	#1,d0				; Turn into offset
00002766 E648                       		lsr.w	#3,d0				; ''
00002768 41F9 0000 0000             		lea	Level_RenderRouts+4,a0		; Get initialization routine list
0000276E 2370 0008 0018             		move.l	8(a0,d0.w),cUpdate(a1)		; Set the update routine pointer
00002774 2070 0000                  		movea.l	(a0,d0.w),a0			; Get initialization pointer
00002778 4E90                       		jsr	(a0)				; Jump to it
0000277A                            
0000277A 31E9 0008 9480             		move.w	cYPos(a1),rVScrollBG.w		; Set the V-Scroll value for the background
00002780 4E75                       		rts
00002782                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002782                            ; Update the planes
00002782                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002782                            Level_UpdatePlanes:
00002782 43F8 F880                  		lea	rFGCam.w,a1			; Get foreground level drawing RAM
00002786 47F8 C2A0                  		lea	rFGColBuf.w,a3		; Get foreground column plane buffer
0000278A 49F8 C19E                  		lea	rFGRowBuf.w,a4		; Get foreground row plane buffer
0000278E                            		
0000278E 2069 0018                  		movea.l	cUpdate(a1),a0			; Get the update routine pointer
00002792 4E90                       		jsr	(a0)				; Jump to it
00002794                            		
00002794 43F8 F89E                  		lea	rBGCam.w,a1			; Get background level drawing RAM
00002798 47F8 C424                  		lea	rBGColBuf.w,a3		; Get background column plane buffer
0000279C 49F8 C322                  		lea	rBGRowBuf.w,a4		; Get background row plane buffer
000027A0                            
000027A0 2069 0018                  		movea.l	cUpdate(a1),a0			; Get the update routine pointer
000027A4 4E90                       		jsr	(a0)				; Jump to it
000027A6                            
000027A6 45F8 F880                  		lea	rFGCam.w,a2			; Get foreground level drawing RAM
000027AA 3552 0004                  		move.w	cXPos(a2),cXPrev(a2)		; Update the previous X position for the foreground
000027AE 356A 0008 000C             		move.w	cYPos(a2),cYPrev(a2)		; Update the previous Y position for the foreground
000027B4 31EA 0008 947E             		move.w	cYPos(a2),rVScrollFG.w		; Set the V-Scroll value for the foreground
000027BA 3351 0004                  		move.w	cXPos(a1),cXPrev(a1)		; Update the previous X position for the background
000027BE 3369 0008 000C             		move.w	cYPos(a1),cYPrev(a1)		; Update the previous Y position for the background
000027C4 31E9 0008 9480             		move.w	cYPos(a1),rVScrollBG.w		; Set the V-Scroll value for the background
000027CA                            
000027CA 4E75                       		rts
000027CC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000027CC                            ; General foreground initialization
000027CC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000027CC                            General_InitFG:
000027CC 6000 0000                  		bra.w	Level_RefreshPlane		; Refresh the plane
000027D0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000027D0                            ; General background initialization
000027D0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000027D0                            General_InitBG:
000027D0 45F8 F880                  		lea	rFGCam.w,a2			; Get foreground level drawing RAM
000027D4 3012                       		move.w	cXPos(a2),d0			; Get foreground X position
000027D6 E240                       		asr.w	#1,d0				; Divide by 2
000027D8 3280                       		move.w	d0,cXPos(a1)			; Set as background X position
000027DA 302A 0008                  		move.w	cYPos(a2),d0			; Get foreground Y position
000027DE E240                       		asr.w	#1,d0				; Divide by 2
000027E0 3340 0008                  		move.w	d0,cYPos(a1)			; Set as background Y position
000027E4                            
000027E4 6100 0000                  		bsr.w	Level_RefreshPlane		; Refresh the plane
000027E8                            		
000027E8 6000 0000                  		bra.w	ScrollStaticBG			; Set up the scroll offsets
000027EC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000027EC                            ; General foreground update
000027EC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000027EC                            General_UpdateFG:
000027EC 6100 0000                  		bsr.w	Level_ChkRedrawPlane		; Check if the plane needs to be redrawn
000027F0                            		
000027F0 780E                       		moveq	#(240/16)-1,d4			; Number of blocks per column
000027F2 7A14                       		moveq	#(336/16)-1,d5			; Number of blocks per row
000027F4 6000 0000                  		bra.w	Level_UpdatePlane		; Update the plane
000027F8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000027F8                            ; General background update
000027F8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000027F8                            General_UpdateBG:
000027F8 45F8 F880                  		lea	rFGCam.w,a2			; Get foreground level drawing RAM
000027FC 3012                       		move.w	cXPos(a2),d0			; Get foreground X position
000027FE E240                       		asr.w	#1,d0				; Divide by 2
00002800 3280                       		move.w	d0,cXPos(a1)			; Set as background X position
00002802 302A 0008                  		move.w	cYPos(a2),d0			; Get foreground Y position
00002806 E240                       		asr.w	#1,d0				; Divide by 2
00002808 3340 0008                  		move.w	d0,cYPos(a1)			; Set as background Y position
0000280C                            
0000280C 6100 0000                  		bsr.w	Level_ChkRedrawPlane		; Check if the plane needs to be redrawn
00002810 780E                       		moveq	#(240/16)-1,d4			; Number of blocks per column
00002812 7A14                       		moveq	#(336/16)-1,d5			; Number of blocks per row
00002814 6100 0000                  		bsr.w	Level_UpdatePlane		; Update the plane
00002818                            		
00002818 6000 0000                  		bra.w	ScrollStaticBG			; Scroll the planes
0000281C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000281C                            ; Draw new tiles in the level
0000281C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000281C                            ; PARAMETERS:
0000281C                            ;	a1.l	- Camera RAM
0000281C                            ;	a2.l	- Plane buffer for columns
0000281C                            ;	a3.l	- Plane buffer for rows
0000281C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000281C                            ; RETURNS:
0000281C                            ;	Nothing
0000281C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000281C                            VInt_DrawLevel:
0000281C 3629 0012                  		move.w	cVDP(a1),d3			; High word of VDP command
00002820 3829 0014                  		move.w	cVDP+2(a1),d4			; Low word of VDP command
00002824                            
00002824 3013                       		move.w	(a3),d0				; Get high VDP command word
00002826 6700 0000                  		beq.w	VInt_DrawLvlRows2		; If it's 0, branch
0000282A 425B                       		clr.w	(a3)+				; Reset high VDP command word in buffer
0000282C 3CBC 8F80                  		move.w	#$8F80,(a6)			; Set auto-increment to $80
00002830                            
00002830                            		; --- DRAW THE FIRST HALF OF THE COLUMN ---
00002830                            
00002830 3200                       		move.w	d0,d1				; Save high VDP command
00002832 7E0F                       		moveq	#(256/16)-1,d7			; Max number of blocks
00002834 7C00                       		moveq	#0,d6
00002836 1C29 0011                  		move.b	cCBlks(a1),d6			; Get number of blocks in the first set
0000283A 9E46                       		sub.w	d6,d7				; Get number of blocks in the second set
0000283C                            
0000283C 3C80                       		move.w	d0,(a6)				; Set VDP command
0000283E 3C84                       		move.w	d4,(a6)				; ''
00002840 6000                       		bra.s	.DrawCol1_1_Start		; Start
00002842                            
00002842                            .DrawCol1_1_Loop:
00002842 2A9B                       		move.l	(a3)+,(a5)			; Draw blocks
00002844                            
00002844                            .DrawCol1_1_Start:
00002844 51CE FFFC                  		dbf	d6,.DrawCol1_1_Loop		; Loop
00002848                            
00002848 3403                       		move.w	d3,d2				; Wrap to the top of the plane
0000284A 0642 007C                  		addi.w	#$7C,d2				; ''
0000284E C042                       		and.w	d2,d0				; ''
00002850                            
00002850 3C80                       		move.w	d0,(a6)				; Set VDP command
00002852 3C84                       		move.w	d4,(a6)				; ''
00002854                            
00002854                            .DrawCol1_2_Loop:
00002854 2A9B                       		move.l	(a3)+,(a5)			; Draw blocks
00002856 51CF FFFC                  		dbf	d7,.DrawCol1_2_Loop		; Loop
0000285A                            
0000285A                            		; --- DRAW THE SECOND HALF OF THE COLUMN ---
0000285A                            
0000285A 5441                       		addq.w	#2,d1				; Move over to the right
0000285C 7E0F                       		moveq	#(256/16)-1,d7			; Max number of blocks
0000285E 7C00                       		moveq	#0,d6
00002860 1C29 0011                  		move.b	cCBlks(a1),d6			; Get number of blocks in the first set
00002864 9E46                       		sub.w	d6,d7				; Get number of blocks in the second set
00002866                            
00002866 3C81                       		move.w	d1,(a6)				; Set VDP command
00002868 3C84                       		move.w	d4,(a6)				; ''
0000286A 6000                       		bra.s	.DrawCol2_1_Start		; Start
0000286C                            
0000286C                            .DrawCol2_1_Loop:
0000286C 2A9B                       		move.l	(a3)+,(a5)			; Draw blocks
0000286E                            
0000286E                            .DrawCol2_1_Start:
0000286E 51CE FFFC                  		dbf	d6,.DrawCol2_1_Loop		; Loop
00002872                            
00002872 3403                       		move.w	d3,d2				; Wrap to the top of the plane
00002874 0642 007E                  		addi.w	#$7E,d2				; ''
00002878 C242                       		and.w	d2,d1				; ''
0000287A                            
0000287A 3C81                       		move.w	d1,(a6)				; Set VDP command
0000287C 3C84                       		move.w	d4,(a6)				; ''
0000287E                            
0000287E                            .DrawCol2_2_Loop:
0000287E 2A9B                       		move.l	(a3)+,(a5)			; Draw blocks
00002880 51CF FFFC                  		dbf	d7,.DrawCol2_2_Loop		; Loop
00002884                            
00002884 3CBC 8F02                  		move.w	#$8F02,(a6)			; Autoincrement by 2
00002888 6000                       		bra.s	VInt_DrawLvlRows2		; Continue
0000288A                            
0000288A                            VInt_DrawLvlRows:
0000288A 3629 0012                  		move.w	cVDP(a1),d3			; High word of VDP command
0000288E 3829 0014                  		move.w	cVDP+2(a1),d4			; Low word of VDP command
00002892                            
00002892                            VInt_DrawLvlRows2:
00002892 3014                       		move.w	(a4),d0				; Get high VDP command
00002894 6700 0000                  		beq.w	.End				; If it's 0, branch
00002898 425C                       		clr.w	(a4)+				; Don't run this again unless necessary
0000289A                            		
0000289A                            		; --- DRAW THE FIRST HALF OF THE ROW ---
0000289A                            
0000289A 3200                       		move.w	d0,d1				; Save high VDP command
0000289C 7E1F                       		moveq	#(512/16)-1,d7			; Max number of blocks
0000289E 7C00                       		moveq	#0,d6
000028A0 1C29 0010                  		move.b	cRBlks(a1),d6			; Get number of blocks in the first set
000028A4 9E46                       		sub.w	d6,d7				; Get number of blocks in the second set
000028A6                            
000028A6 3C80                       		move.w	d0,(a6)				; Set VDP command
000028A8 3C84                       		move.w	d4,(a6)				; ''
000028AA 6000                       		bra.s	.DrawRow1_1_Start		; Start
000028AC                            
000028AC                            .DrawRow1_1_Loop:
000028AC 2A9C                       		move.l	(a4)+,(a5)			; Draw blocks
000028AE                            
000028AE                            .DrawRow1_1_Start:
000028AE 51CE FFFC                  		dbf	d6,.DrawRow1_1_Loop		; Loop
000028B2                            
000028B2 3403                       		move.w	d3,d2				; Wrap to the leftmost side of the plane
000028B4 0642 0F00                  		addi.w	#$F00,d2			; ''
000028B8 C042                       		and.w	d2,d0				; ''
000028BA                            
000028BA 3C80                       		move.w	d0,(a6)				; Set VDP command
000028BC 3C84                       		move.w	d4,(a6)				; ''
000028BE                            
000028BE                            .DrawRow1_2_Loop:
000028BE 2A9C                       		move.l	(a4)+,(a5)			; Draw blocks
000028C0 51CF FFFC                  		dbf	d7,.DrawRow1_2_Loop		; Loop
000028C4                            
000028C4                            		; --- DRAW THE SECOND HALF OF THE ROW ---
000028C4                            
000028C4 0641 0080                  		addi.w	#$80,d1				; Move over down
000028C8 7E1F                       		moveq	#(512/16)-1,d7			; Max number of blocks
000028CA 7C00                       		moveq	#0,d6
000028CC 1C29 0010                  		move.b	cRBlks(a1),d6			; Get number of blocks in the first set
000028D0 9E46                       		sub.w	d6,d7				; Get number of blocks in the second set
000028D2                            
000028D2 3C81                       		move.w	d1,(a6)				; Set VDP command
000028D4 3C84                       		move.w	d4,(a6)				; ''
000028D6 6000                       		bra.s	.DrawRow2_1_Start		; Start
000028D8                            
000028D8                            .DrawRow2_1_Loop:
000028D8 2A9C                       		move.l	(a4)+,(a5)			; Draw blocks
000028DA                            
000028DA                            .DrawRow2_1_Start:
000028DA 51CE FFFC                  		dbf	d6,.DrawRow2_1_Loop		; Loop
000028DE                            
000028DE 3403                       		move.w	d3,d2				; Wrap to the leftmost side of the plane
000028E0 0642 0F80                  		addi.w	#$F80,d2			; ''
000028E4 C242                       		and.w	d2,d1				; ''
000028E6                            
000028E6 3C81                       		move.w	d1,(a6)				; Set VDP command
000028E8 3C84                       		move.w	d4,(a6)				; ''
000028EA                            
000028EA                            .DrawRow2_2_Loop:
000028EA 2A9C                       		move.l	(a4)+,(a5)			; Draw blocks
000028EC 51CF FFFC                  		dbf	d7,.DrawRow2_2_Loop		; Loop
000028F0                            
000028F0                            .End:
000028F0 4E75                       		rts
000028F2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000028F2                            ; Handle plane drawing
000028F2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000028F2                            ; PARAMETERS:
000028F2                            ;	d4.w	- Number of blocks per column
000028F2                            ;	d5.w	- Number of blocks per row
000028F2                            ;	a1.l	- Camera variables
000028F2                            ;	a2.l	- Layout pointer
000028F2                            ;	a3.l	- Column plane buffer
000028F2                            ;	a4.l	- Row plane buffer
000028F2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000028F2                            ; RETURNS:
000028F2                            ;	Nothing
000028F2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000028F2                            Level_UpdatePlane:
000028F2                            		push.l	d5/a4				; Push row plane buffer address
000028F2 48E7 0408                M 	movem.l	d5/a4,-(sp)
000028F6 6100                       		bsr.s	Level_UpdatePlaneX		; Handle horizontal plane updating
000028F8                            		pop.l	d5/a4				; Restore row plane buffer address
000028F8 4CDF 1020                M 	movem.l	(sp)+,d5/a4
000028FC 3805                       		move.w	d5,d4				; Number of blocks per column
000028FE                            		; Continue to update the plane vertically
000028FE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000028FE                            ; Handle plane drawing (vertical redrawing only)
000028FE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000028FE                            ; PARAMETERS:
000028FE                            ;	d4.w	- Number of blocks per row
000028FE                            ;	a1.l	- Camera variables
000028FE                            ;	a4.l	- Row plane buffer
000028FE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000028FE                            ; RETURNS:
000028FE                            ;	Nothing
000028FE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000028FE                            Level_UpdatePlaneY:
000028FE 3029 0008                  		move.w	cYPos(a1),d0			; Get Y
00002902 0240 FFF0                  		andi.w	#$FFF0,d0			; Only allow multiples of $10
00002906 3229 000E                  		move.w	cYPrevR(a1),d1			; Get previous y (rounded)
0000290A 3340 000E                  		move.w	d0,cYPrevR(a1)			; Save new rounded y
0000290E                            		
0000290E 9240                       		sub.w	d0,d1				; Get distance travelled
00002910 6700                       		beq.s	.End				; If a new row doesn't need to be drawn, branch
00002912 6B00                       		bmi.s	.DrawDown			; If a new column needs to be drawn on the bottom of the screen, branch
00002914                            		
00002914                            .DrawUp:
00002914 3011                       		move.w	cXPos(a1),d0			; Get X
00002916 3229 0008                  		move.w	cYPos(a1),d1			; Get Y
0000291A 6000 0000                  		bra.w	Level_GetRow			; Draw a row
0000291E                            
0000291E                            .DrawDown:
0000291E 3011                       		move.w	cXPos(a1),d0			; Get X
00002920 3229 000C                  		move.w	cYPrev(a1),d1			; Get Y
00002924 0641 00F0                  		addi.w	#224+16,d1			; Go to the bottom of the screen
00002928 6000 0000                  		bra.w	Level_GetRow			; Draw a row
0000292C                            
0000292C                            .End:
0000292C 4E75                       		rts
0000292E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000292E                            ; Handle plane drawing (horizontal redrawing only)
0000292E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000292E                            ; PARAMETERS:
0000292E                            ;	d4.w	- Number of blocks per column
0000292E                            ;	a1.l	- Camera variables
0000292E                            ;	a3.l	- Column plane buffer
0000292E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000292E                            ; RETURNS:
0000292E                            ;	Nothing
0000292E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000292E                            Level_UpdatePlaneX:
0000292E 3011                       		move.w	cXPos(a1),d0			; Get X
00002930 0240 FFF0                  		andi.w	#$FFF0,d0			; Only allow multiples of $10
00002934 3229 0006                  		move.w	cXPrevR(a1),d1			; Get previous X (rounded)
00002938 3340 0006                  		move.w	d0,cXPrevR(a1)			; Save new rounded X
0000293C                            		
0000293C 9240                       		sub.w	d0,d1				; Get distance travelled
0000293E 6700                       		beq.s	.End				; If a new column doesn't need to be drawn, branch
00002940 6B00                       		bmi.s	.DrawRight			; If a new column needs to be drawn on the right side of the screen, branch
00002942                            		
00002942                            .DrawLeft:
00002942 3011                       		move.w	cXPos(a1),d0			; Get X
00002944 3229 0008                  		move.w	cYPos(a1),d1			; Get Y
00002948 6000 0000                  		bra.w	Level_GetCol			; Draw a column
0000294C                            		
0000294C                            .DrawRight:
0000294C 3029 0004                  		move.w	cXPrev(a1),d0			; Get previous X
00002950 0640 0150                  		addi.w	#320+16,d0			; Go to the right side of the screen
00002954 3229 0008                  		move.w	cYPos(a1),d1			; Get Y
00002958 6000 0000                  		bra.w	Level_GetCol			; Draw a column
0000295C                            
0000295C                            .End:
0000295C 4E75                       		rts
0000295E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000295E                            ; Macro to calculate the high VDP command word for the plane buffer
0000295E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000295E                            ; PARAMETERS:
0000295E                            ;	a1.l	- Camera variables
0000295E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000295E                            ; RETURNS:
0000295E                            ;	d2.w	- The high VDP command word
0000295E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000295E                            calcHiVDP	macro
0000295E                            		move.w	d0,d2				; Copy X
0000295E                            		move.w	d1,d3				; Copy Y
0000295E                            		lsl.w	#4,d3				; Multiply Y by $10
0000295E                            		andi.w	#$F00,d3			; Only allow 0-$F00 with multiples of $100
0000295E                            		lsr.w	#2,d2				; Divide X by 4
0000295E                            		andi.w	#$7C,d2				; Only allow 0-$7C with multiples of 4
0000295E                            		add.w	d3,d2				; Add Y onto X
0000295E                            		or.w	cVDP(a1),d2			; Combine with high VDP command word
0000295E                            		endm
0000295E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000295E                            ; Macro to get an address in chunk data relative to a position
0000295E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000295E                            ; PARAMETERS:
0000295E                            ;	d1.l	- $FFFFXXXX
0000295E                            ;	a2.l	- Layout data
0000295E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000295E                            ; RETURNS:
0000295E                            ;	a6.l	- Pointer in chunk data to the correct block
0000295E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000295E                            getChunk	macro
0000295E                            		move.b	(a2,d0.w),d1			; Get chunk ID
0000295E                            		andi.w	#$FF,d1				; ''
0000295E                            		lsl.w	#7,d1				; Turn into offset
0000295E                            		movea.l	d1,a6				; Store into a6
0000295E                            		endm
0000295E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000295E                            ; Get a block row and store it in a plane buffer
0000295E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000295E                            ; PARAMETERS:
0000295E                            ;	d0.w	- X position
0000295E                            ;	d1.w	- Y position
0000295E                            ;	d4.w	- Number of blocks to draw (minus 1)
0000295E                            ;	a1.l	- Camera variables
0000295E                            ;	a4.l	- Row plane buffer
0000295E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000295E                            ; RETURNS:
0000295E                            ;	Nothing
0000295E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000295E                            Level_GetRow:
0000295E 45F8 DFD0                  		lea	rLayout.w,a2			; Get level layout address
00002962 D4E9 0016                  		adda.w	cLayout(a1),a2			; Add offset
00002966 47F8 C7D0                  		lea	rBlocks.w,a3			; Get block table address
0000296A 4BEC 0082                  		lea	$82(a4),a5			; Store plane buffer address for the bottom tiles in the row
0000296E                            
0000296E                            		calcHiVDP				; Get high VDP command word
0000296E 3400                     M 	move.w	d0,d2
00002970 3601                     M 	move.w	d1,d3
00002972 E94B                     M 	lsl.w	#4,d3
00002974 0243 0F00                M 	andi.w	#$f00,d3
00002978 E44A                     M 	lsr.w	#2,d2
0000297A 0242 007C                M 	andi.w	#$7c,d2
0000297E D443                     M 	add.w	d3,d2
00002980 8469 0012                M 	or.w	cvdp(a1),d2
00002984 38C2                       		move.w	d2,(a4)+			; Store it
00002986                            
00002986 3400                       		move.w	d0,d2				; Get X
00002988 E44A                       		lsr.w	#2,d2				; Divide X by 4
0000298A 0242 007C                  		andi.w	#$7C,d2				; Only allow 0-$7C with multiples of 4
0000298E 3A3C 0080                  		move.w	#512/4,d5			; Get max row size in pixels divided by 4
00002992 9A42                       		sub.w	d2,d5				; Get number of pixels (divided by 4) that the first set of tiles for a row takes up
00002994 0245 007C                  		andi.w	#$7C,d5				; Only allow 0-$7C with multiples of 4
00002998 E44D                       		lsr.w	#2,d5				; Divide by 4
0000299A 1345 0010                  		move.b	d5,cRBlks(a1)			; Set tile count for the first set of tiles for a row
0000299E                            		
0000299E E648                       		lsr.w	#3,d0				; Get X within chunk data
000029A0 3400                       		move.w	d0,d2				; ''
000029A2 0242 000E                  		andi.w	#$E,d2				; ''
000029A6 E848                       		lsr.w	#4,d0				; Get X within layout data
000029A8 0240 007F                  		andi.w	#$7F,d0				;''
000029AC 3601                       		move.w	d1,d3				; Get Y within chunk data
000029AE 0243 0070                  		andi.w	#$70,d3				; ''
000029B2 D443                       		add.w	d3,d2				; Combine X and Y to get chunk offset
000029B4                            
000029B4 0241 0780                  		andi.w	#$780,d1			; Get Y within layout data
000029B8 D241                       		add.w	d1,d1				; ''
000029BA D041                       		add.w	d1,d0				; Combine X and Y to get layout offset
000029BC                            
000029BC 72FF                       		moveq	#-1,d1				; Prepare chunk pointer
000029BE                            		getChunk				; Get chunk pointer at current location
000029BE 1232 0000                M 	move.b	(a2,d0.w),d1
000029C2 0241 00FF                M 	andi.w	#$ff,d1
000029C6 EF49                     M 	lsl.w	#7,d1
000029C8 2C41                     M 	movea.l	d1,a6
000029CA                            
000029CA                            .DrawBlock_Loop:
000029CA 3A36 2000                  		move.w	(a6,d2.w),d5			; Get block properties
000029CE 3C05                       		move.w	d5,d6				; ''
000029D0 0245 03FF                  		andi.w	#$3FF,d5			; Mask off flip bits
000029D4 E74D                       		lsl.w	#3,d5				; Get offset in block data
000029D6                            		
000029D6 2E33 5000                  		move.l	(a3,d5.w),d7			; Get block tiles
000029DA 2A33 5004                  		move.l	4(a3,d5.w),d5			; ''
000029DE                            
000029DE 0806 000A                  		btst	#$A,d6				; Is this block flipped horizontally?
000029E2 6700                       		beq.s	.ChkYFlip			; If not, branch
000029E4 0A87 0800 0800             		eori.l	#$08000800,d7			; Flip the tiles horizontally
000029EA 0A85 0800 0800             		eori.l	#$08000800,d5			; ''
000029F0 4847                       		swap	d7				; ''
000029F2 4845                       		swap	d5				; ''
000029F4                            
000029F4                            .ChkYFlip:
000029F4 0806 000B                  		btst	#$B,d6				; Is this block flipped vertically?
000029F8 6700                       		beq.s	.DrawBlock			; If not, branch
000029FA 0A87 1000 1000             		eori.l	#$10001000,d7			; Flip the tiles vertically
00002A00 0A85 1000 1000             		eori.l	#$10001000,d5			; ''
00002A06 CF45                       		exg.l	d7,d5				; ''
00002A08                            
00002A08                            .DrawBlock:
00002A08 28C7                       		move.l	d7,(a4)+			; Save the tiles in the plane buffers
00002A0A 2AC5                       		move.l	d5,(a5)+			; ''
00002A0C                            
00002A0C 5442                       		addq.w	#2,d2				; Go to the next block
00002A0E 0242 000E                  		andi.w	#$E,d2				; Have we gone outside of the chunk?
00002A12 6600                       		bne.s	.DrawBlock_Cont			; If not, branch
00002A14 5240                       		addq.w	#1,d0				; Next chunk
00002A16                            		getChunk				; ''
00002A16 1232 0000                M 	move.b	(a2,d0.w),d1
00002A1A 0241 00FF                M 	andi.w	#$ff,d1
00002A1E EF49                     M 	lsl.w	#7,d1
00002A20 2C41                     M 	movea.l	d1,a6
00002A22                            
00002A22                            .DrawBlock_Cont:
00002A22 D443                       		add.w	d3,d2				; Recombine X and Y to get chunk offset
00002A24 51CC FFA4                  		dbf	d4,.DrawBlock_Loop		; Loop
00002A28                            
00002A28 4E75                       		rts
00002A2A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002A2A                            ; Get a block column and store it in a plane buffer
00002A2A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002A2A                            ; PARAMETERS:
00002A2A                            ;	d0.w	- X position
00002A2A                            ;	d1.w	- Y position
00002A2A                            ;	d4.w	- Number of blocks to draw (minus 1)
00002A2A                            ;	a1.l	- Camera RAM
00002A2A                            ;	a3.l	- Column plane buffer
00002A2A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002A2A                            ; RETURNS:
00002A2A                            ;	Nothing
00002A2A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002A2A                            Level_GetCol:
00002A2A 45F8 DFD0                  		lea	rLayout.w,a2			; Get level layout address
00002A2E D4E9 0016                  		adda.w	cLayout(a1),a2			; Add offset
00002A32 49F8 C7D0                  		lea	rBlocks.w,a4			; Get block table address
00002A36 4BEB 0042                  		lea	$42(a3),a5			; Store plane buffer address for the right tiles in the column
00002A3A                            		
00002A3A                            		calcHiVDP				; Get high VDP command word
00002A3A 3400                     M 	move.w	d0,d2
00002A3C 3601                     M 	move.w	d1,d3
00002A3E E94B                     M 	lsl.w	#4,d3
00002A40 0243 0F00                M 	andi.w	#$f00,d3
00002A44 E44A                     M 	lsr.w	#2,d2
00002A46 0242 007C                M 	andi.w	#$7c,d2
00002A4A D443                     M 	add.w	d3,d2
00002A4C 8469 0012                M 	or.w	cvdp(a1),d2
00002A50 36C2                       		move.w	d2,(a3)+			; Store it
00002A52                            
00002A52 3601                       		move.w	d1,d3				; Get Y
00002A54 E94B                       		lsl.w	#4,d3				; Multiply by $10
00002A56 0243 0F00                  		andi.w	#$F00,d3			; Only allow 0-$F00 with multiples of $100
00002A5A 3A3C 1000                  		move.w	#256*16,d5			; Get max column size in pixels times 16
00002A5E 9A43                       		sub.w	d3,d5				; Get number of pixels (times 16) that the first set of tiles for a column takes up
00002A60 0245 0F00                  		andi.w	#$F00,d5			; Only allow 0-$F00 with multiples of $100
00002A64 E04D                       		lsr.w	#8,d5				; Divide by $100
00002A66 1345 0011                  		move.b	d5,cCBlks(a1)			; Set tile count for the first set of tiles for a column
00002A6A                            
00002A6A E648                       		lsr.w	#3,d0				; Get X within chunk data
00002A6C 3400                       		move.w	d0,d2				; ''
00002A6E 0242 000E                  		andi.w	#$E,d2				; ''
00002A72 E848                       		lsr.w	#4,d0				; Get X within layout data
00002A74 0240 007F                  		andi.w	#$7F,d0				;''
00002A78 3601                       		move.w	d1,d3				; Get Y within chunk data
00002A7A 0243 0070                  		andi.w	#$70,d3				; ''
00002A7E D642                       		add.w	d2,d3				; Combine X and Y to get chunk offset
00002A80                            
00002A80 0241 0780                  		andi.w	#$780,d1			; Get Y within layout data
00002A84 D241                       		add.w	d1,d1				; ''
00002A86 D041                       		add.w	d1,d0				; Combine X and Y to get layout offset
00002A88                            
00002A88 72FF                       		moveq	#-1,d1				; Prepare chunk pointer
00002A8A                            		getChunk				; Get chunk pointer at current location
00002A8A 1232 0000                M 	move.b	(a2,d0.w),d1
00002A8E 0241 00FF                M 	andi.w	#$ff,d1
00002A92 EF49                     M 	lsl.w	#7,d1
00002A94 2C41                     M 	movea.l	d1,a6
00002A96                            
00002A96                            .DrawBlock_Loop:
00002A96 3A36 3000                  		move.w	(a6,d3.w),d5			; Get block properties
00002A9A 3C05                       		move.w	d5,d6				; ''
00002A9C 0245 03FF                  		andi.w	#$3FF,d5			; Mask off flip bits
00002AA0 E74D                       		lsl.w	#3,d5				; Get offset in block data
00002AA2                            		
00002AA2 3E05                       		move.w	d5,d7				; Get block tiles
00002AA4 2A34 7002                  		move.l	2(a4,d7.w),d5			; ''
00002AA8 3A07                       		move.w	d7,d5				; ''
00002AAA 2E34 5000                  		move.l	(a4,d5.w),d7			; ''
00002AAE 3E34 5004                  		move.w	4(a4,d5.w),d7			; ''
00002AB2 3A34 5006                  		move.w	6(a4,d5.w),d5			; ''
00002AB6                            
00002AB6 0806 000A                  		btst	#$A,d6				; Is this block flipped horizontally?
00002ABA 6700                       		beq.s	.ChkYFlip			; If not, branch
00002ABC 0A87 0800 0800             		eori.l	#$08000800,d7			; Flip the tiles horizontally
00002AC2 0A85 0800 0800             		eori.l	#$08000800,d5			; ''
00002AC8 CF45                       		exg.l	d7,d5				; ''
00002ACA                            
00002ACA                            .ChkYFlip:
00002ACA 0806 000B                  		btst	#$B,d6				; Is this block flipped vertically?
00002ACE 6700                       		beq.s	.DrawBlock			; If not, branch
00002AD0 0A87 1000 1000             		eori.l	#$10001000,d7			; Flip the tiles vertically
00002AD6 0A85 1000 1000             		eori.l	#$10001000,d5			; ''
00002ADC 4847                       		swap	d7				; ''
00002ADE 4845                       		swap	d5				; ''
00002AE0                            
00002AE0                            .DrawBlock:
00002AE0 26C7                       		move.l	d7,(a3)+			; Save the tiles in the plane buffers
00002AE2 2AC5                       		move.l	d5,(a5)+			; ''
00002AE4                            
00002AE4 0643 0010                  		addi.w	#$10,d3				; Go to the next block
00002AE8 0243 0070                  		andi.w	#$70,d3				; Have we gone outside of the chunk?
00002AEC 6600                       		bne.s	.DrawBlock_Cont			; If not, branch
00002AEE 0640 0100                  		addi.w	#$100,d0			; Next chunk
00002AF2                            		getChunk				; ''
00002AF2 1232 0000                M 	move.b	(a2,d0.w),d1
00002AF6 0241 00FF                M 	andi.w	#$ff,d1
00002AFA EF49                     M 	lsl.w	#7,d1
00002AFC 2C41                     M 	movea.l	d1,a6
00002AFE                            
00002AFE                            .DrawBlock_Cont:
00002AFE D642                       		add.w	d2,d3				; Recombine X and Y to get chunk offset
00002B00 51CC FF94                  		dbf	d4,.DrawBlock_Loop		; Loop
00002B04                            
00002B04 4E75                       		rts
00002B06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B06                            ; Refresh a plane
00002B06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B06                            ; PARAMETERS:
00002B06                            ;	a1.l	- Camera variables
00002B06                            ;	a4.l	- Row plane buffer
00002B06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B06                            ; RETURNS:
00002B06                            ;	Nothing
00002B06                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B06                            Level_RefreshPlane:
00002B06 3011                       		move.w	cXPos(a1),d0			; Get X position
00002B08 3340 0004                  		move.w	d0,cXPrev(a1)			; Store as previous X position
00002B0C 0240 FFF0                  		andi.w	#$FFF0,d0			; Only get multiples of $10
00002B10 3340 0006                  		move.w	d0,cXPrevR(a1)			; Store as previous X position (rounded)
00002B14                            		
00002B14 3229 0008                  		move.w	cYPos(a1),d1			; Get Y position
00002B18 3341 000C                  		move.w	d1,cYPrev(a1)			; Store as previous Y position
00002B1C 0241 FFF0                  		andi.w	#$FFF0,d1			; Only get multiples of $10
00002B20 3341 000E                  		move.w	d1,cYPrevR(a1)			; Store as previous Y position (rounded)
00002B24                            		
00002B24 781F                       		moveq	#(512/16)-1,d4			; Number of rows to draw
00002B26 7C0F                       		moveq	#(256/16)-1,d6			; Number of blocks per row
00002B28                            		
00002B28                            		push.l	a4				; Save plane buffer address
00002B28 2F0C                     M 	move.l	a4,-(sp)
00002B2A                            		
00002B2A                            .DrawRows:
00002B2A                            		push.w	d0/d1/d4/d6			; Save registers
00002B2A 48A7 CA00                M 	movem.w	d0/d1/d4/d6,-(sp)
00002B2E 286F 0008                  		movea.l	8(sp),a4			; Get plane buffer address
00002B32 6100 FE2A                  		bsr.w	Level_GetRow			; Transfer the row to the plane buffer
00002B36 286F 0008                  		movea.l	8(sp),a4			; Get plane buffer address
00002B3A 4DF9 00C0 0004             		lea	VDP_CTRL,a6			; VDP control port
00002B40 4BEE FFFC                  		lea	-4(a6),a5			; VDP data port
00002B44 6100 FD44                  		bsr.w	VInt_DrawLvlRows		; Draw the new row
00002B48                            		pop.w	d0/d1/d4/d6			; Restore registers
00002B48 4C9F 0053                M 	movem.w	(sp)+,d0/d1/d4/d6
00002B4C                            		
00002B4C 0641 0010                  		addi.w	#$10,d1				; Increment Y
00002B50 51CE FFD8                  		dbf	d6,.DrawRows			; Loop
00002B54                            		
00002B54                            		pop.l	a4				; Restore a3
00002B54 285F                     M 	move.l	(sp)+,a4
00002B56 4E75                       		rts
00002B58                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B58                            ; Check if the plane needs to be redrawn
00002B58                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B58                            ; PARAMETERS:
00002B58                            ;	a1.l	- Camera RAM
00002B58                            ;	a3.l	- Row plane buffer
00002B58                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B58                            ; RETURNS:
00002B58                            ;	Nothing
00002B58                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B58                            Level_ChkRedrawPlane:
00002B58 4A29 001C                  		tst.b	cRedraw(a1)			; Does this plane need to be redrawn?
00002B5C                            		; Comment out the following line to disable blast processing :^)
00002B5C 6700                       		beq.s	.End				; If not, branch
00002B5E 4229 001C                  		clr.b	cRedraw(a1)			; Clear the redraw flag
00002B62 60A2                       		bra.s	Level_RefreshPlane		; Redraw the plane
00002B64                            
00002B64                            .End:
00002B64 4E75                       		rts
00002B66                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B66                            ; Scroll sections macro
00002B66                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B66 =00008000                  SCROLL_AUTOMATIC	EQU	$8000			; Automatic scroll flag
00002B66                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B66                            scrollInit	macro	label
00002B66                            SCROLL_LABEL	equs	"\label"
00002B66                            \label\:	dc.w	((\label\_End-\label\-2)/6)-1	; Number of sections
00002B66                            		endm
00002B66                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B66                            scrollEnd	macro
00002B66                            \SCROLL_LABEL\_End:					; End label
00002B66                            		endm
00002B66                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B66                            scrollSection	macro
00002B66                            	if narg<3
00002B66                            		dc.w	\2, 0, \1			; Speed, 0, Size
00002B66                            	else
00002B66                            		dc.w	\2, \3, \1			; Speed, Flags, Size
00002B66                            	endif
00002B66                            		endm
00002B66                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B66                            ; Do section scrolling
00002B66                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B66                            ; PARAMERERS:
00002B66                            ;	a1.l	- Background camera RAM
00002B66                            ;	a3.l	- Scroll section data
00002B66                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B66                            ; RETURNS:
00002B66                            ;	Nothing
00002B66                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B66                            ScrollSections:
00002B66 45F8 F880                  		lea	rFGCam.w,a2			; Get foreground level drawing variables
00002B6A 49F8 EFD0                  		lea	rScrlSecs.w,a4		; Deformation offset buffer
00002B6E 4BF8 90FE                  		lea	rHScroll.w,a5			; Horizontal scroll buffer
00002B72                            
00002B72 301B                       		move.w	(a3)+,d0			; Get the total number of scroll sections
00002B74                            
00002B74 3812                       		move.w	cXPos(a2),d4			; Get camera speed
00002B76 986A 0004                  		sub.w	cXPrev(a2),d4			; ''
00002B7A 48C4                       		ext.l	d4				; ''
00002B7C E184                       		asl.l	#8,d4				; Shift over to use for calculation speeds
00002B7E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002B7E                            		; Update each section offset
00002B7E                            		push.w	d0/a4				; Save registers
00002B7E 48A7 8008                M 	movem.w	d0/a4,-(sp)
00002B82                            
00002B82                            .ScrollSects:
00002B82 361B                       		move.w	(a3)+,d3			; Get section speed
00002B84 48C3                       		ext.l	d3				; ''
00002B86                            
00002B86 4A5B                       		tst.w	(a3)+				; Is this section set to scroll automatically?
00002B88 6A00                       		bpl.s	.NotAuto			; If not, branch
00002B8A 3C04                       		move.w	d4,d6				; Get camera speed
00002B8C CDC3                       		muls.w	d3,d6				; Multiply by section speed
00002B8E E183                       		asl.l	#8,d3				; Shift section speed
00002B90 D686                       		add.l	d6,d3				; Add camera speed to section speed
00002B92 6000                       		bra.s	.ApplySpeed			; Apply that speed
00002B94                            
00002B94                            .NotAuto:
00002B94 C7C4                       		muls.w	d4,d3				; Multiply the the background's X scroll offset with the speed
00002B96                            
00002B96                            .ApplySpeed:
00002B96 D79C                       		add.l	d3,(a4)+			; Set the new section offset
00002B98 38DB                       		move.w	(a3)+,(a4)+			; Save the section size for later
00002B9A 51C8 FFE6                  		dbf	d0,.ScrollSects			; If there are still sections to check, loop
00002B9E                            
00002B9E                            		pop.w	d0/a4				; Restore registers
00002B9E 4C9F 1001                M 	movem.w	(sp)+,d0/a4
00002BA2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002BA2                            		; Set the scroll offsets on screen
00002BA2 3A3C 00E0                  		move.w	#224,d5				; Scanline counter
00002BA6 3C29 0008                  		move.w	cYPos(a1),d6			; Get the background's Y position
00002BAA                            		
00002BAA                            .FindStart:
00002BAA 221C                       		move.l	(a4)+,d1			; Get section offset
00002BAC 9C5C                       		sub.w	(a4)+,d6			; Subtract the size of the section
00002BAE 6B00                       		bmi.s	.FoundStart			; If the current section is on screen, branch
00002BB0 51C8 FFF8                  		dbf	d0,.FindStart			; If not, continue the search
00002BB4 3212                       		move.w	cXPos(a2),d1			; Get the foreground's X position
00002BB6 4441                       		neg.w	d1				; Make it scroll the right direction
00002BB8 4841                       		swap	d1				; Fix which planes the scroll values go to
00002BBA 4441                       		neg.w	d1				; Make the background scroll the right direction
00002BBC 6000                       		bra.s	.LastSection			; If there are no more sections to go through, branch
00002BBE                            
00002BBE                            .FoundStart:
00002BBE 4446                       		neg.w	d6				; Get remaining size of the section
00002BC0 3212                       		move.w	cXPos(a2),d1			; Get the foreground's X position
00002BC2 4441                       		neg.w	d1				; Make it scroll the right direction
00002BC4 4841                       		swap	d1				; Fix which planes the scroll values go to
00002BC6 4441                       		neg.w	d1				; Make the background scroll the right direction
00002BC8 6000                       		bra.s	.CheckScroll			; Go set some scroll offsets
00002BCA                            
00002BCA                            .NextSection:
00002BCA 321C                       		move.w	(a4)+,d1			; Set scroll offset
00002BCC 4441                       		neg.w	d1				; Make the section scroll the correct way
00002BCE 2C1C                       		move.l	(a4)+,d6			; Get section size
00002BD0                            		
00002BD0                            .CheckScroll:
00002BD0 9A46                       		sub.w	d6,d5				; Subtract that from the scanline count
00002BD2 6B00                       		bmi.s	.EndSection			; If there is still screen space to cover, loop
00002BD4 5346                       		subq.w	#1,d6				; Convert for use with dbf
00002BD6                            
00002BD6                            .Scroll:
00002BD6 2AC1                       		move.l	d1,(a5)+			; Scroll the section
00002BD8 51CE FFFC                  		dbf	d6,.Scroll			; Repeat
00002BDC 51C8 FFEC                  		dbf	d0,.NextSection			; If there are any sections left, branch
00002BE0 5245                       		addq.w	#1,d5				; Add 1 so that the foreground can still scroll properly
00002BE2                            		
00002BE2                            .EndSection:
00002BE2 DA46                       		add.w	d6,d5				; Get remaining screen space
00002BE4                            		
00002BE4                            .LastSection:
00002BE4 5345                       		subq.w	#1,d5				; Convert to use with dbf
00002BE6 6B00                       		bmi.s	.End				; If there are none, exit
00002BE8                            
00002BE8                            .FillScroll:
00002BE8 2AC1                       		move.l	d1,(a5)+			; Set previous scroll values
00002BEA 51CD FFFC                  		dbf	d5,.FillScroll			; Repeat
00002BEE                            
00002BEE                            .End:
00002BEE 4E75                       		rts
00002BF0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002BF0                            ; Static background scrolling (no parallax)
00002BF0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002BF0                            ; PARAMERERS:
00002BF0                            ;	a1.l	- Background camera RAM
00002BF0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002BF0                            ; RETURNS:
00002BF0                            ;	Nothing
00002BF0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002BF0                            ScrollStaticBG:
00002BF0 45F8 F880                  		lea	rFGCam.w,a2		; Get foreground level drawing variables
00002BF4 4BF8 90FE                  		lea	rHScroll.w,a5		; Horizontal scroll buffer
00002BF8                            		
00002BF8 2212                       		move.l	cXPos(a2),d1			; Get foreground X position
00002BFA 4481                       		neg.l	d1				; Negate it so it scrolls properly
00002BFC 3211                       		move.w	cXPos(a1),d1			; Get background X position
00002BFE 4441                       		neg.w	d1				; Negate it so it scrolls properly
00002C00                            
00002C00 303C 00DF                  		move.w	#224-1,d0			; Number of scanlines to scroll
00002C04                            
00002C04                            .Scroll:
00002C04 2AC1                       		move.l	d1,(a5)+			; Set the scroll offsets
00002C06 51C8 FFFC                  		dbf	d0,.Scroll			; Repeat
00002C0A 4E75                       		rts
00002C0C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002C0C                            ; Generate fake layer art
00002C0C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002C0C                            ; PARAMETERS:
00002C0C                            ;	a0.l	- Layer art data pointer
00002C0C                            ;	a1.l	- Layer tile ID mappings pointer
00002C0C                            ;	d0.w	- Layer offset
00002C0C                            ;	d1.l	- Buffer pointer
00002C0C                            ;	d2.w	- VRAM destination address
00002C0C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002C0C                            Level_UpdateLayer:
00002C0C                            		; Prepare for transfer
00002C0C 3619                       		move.w	(a1)+,d3			; Get number of tiles to copy
00002C0E 2441                       		movea.l	d1,a2				; Copy layer buffer pointer
00002C10                            		
00002C10                            		; Queue a DMA transfer for later
00002C10                            		push.l	d0/d3/a1			; Save registers
00002C10 48E7 9040                M 	movem.l	d0/d3/a1,-(sp)
00002C14 5243                       		addq.w	#1,d3				; Get size of transfer
00002C16 E94B                       		lsl.w	#4,d3				; ''
00002C18 4EB8 0304                  		jsr	QueueDMATransfer.w		; Queue the transfer
00002C1C                            		pop.l	d0/d3/a1			; Restore registers
00002C1C 4CDF 0209                M 	movem.l	(sp)+,d0/d3/a1
00002C20                            
00002C20                            		; Copy the tiles for the layer
00002C20 D040                       		add.w	d0,d0				; Double it
00002C22 D2F1 0000                  		adda.w	(a1,d0.w),a1			; Get pointer to layer data for the offset
00002C26                            		
00002C26                            .CopyTiles:
00002C26 3219                       		move.w	(a1)+,d1			; Get tile offset
00002C28 47F0 1000                  		lea	(a0,d1.w),a3			; Get pointer to tile data
00002C2C 24DB                       		move.l	(a3)+,(a2)+			; Copy tile data
00002C2E 24DB                       		move.l	(a3)+,(a2)+			; ''
00002C30 24DB                       		move.l	(a3)+,(a2)+			; ''
00002C32 24DB                       		move.l	(a3)+,(a2)+			; ''
00002C34 24DB                       		move.l	(a3)+,(a2)+			; ''
00002C36 24DB                       		move.l	(a3)+,(a2)+			; ''
00002C38 24DB                       		move.l	(a3)+,(a2)+			; ''
00002C3A 24DB                       		move.l	(a3)+,(a2)+			; ''
00002C3C 51CB FFE8                  		dbf	d3,.CopyTiles			; Loop
00002C40                            
00002C40                            .End
00002C40 4E75                       		rts
00002C42                            ; =========================================================================================================================================================
00002C42                            		include	"Opmodes/Gameplay/Level Collision.asm"
00002C42                            ; =========================================================================================================================================================
00002C42                            ; Level collision functions
00002C42                            ; =========================================================================================================================================================
00002C42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002C42                            ; Check if a player object has touched any level collision
00002C42                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002C42                            PlayerChkCollision:
00002C42 21F8 F8D8 F8E0             		move.l	r1stCol.w,rColAddr.w	; Get primary collision address
00002C48 0C28 000C 0000             		cmpi.b	#$C,oTopSolid(a0)		; Are we on the primary path?
00002C4E 6700                       		beq.s	.NotPrimary			; If not, branch
00002C50 21F8 F8DC F8E0             		move.l	r2ndCol.w,rColAddr.w	; Get secondary collision address
00002C56                            
00002C56                            .NotPrimary:
00002C56 1A28 0000                  		move.b	oLRBSolid(a0),d5		; Get LRB solid bits
00002C5A                            		
00002C5A 3228 001C                  		move.w	oXVel(a0),d1			; Get X velocity
00002C5E 3428 001E                  		move.w	oYVel(a0),d2			; Get Y velocity
00002C62 4EB8 1786                  		jsr	CalcArcTan.w			; Get the angle
00002C66 0400 0020                  		subi.b	#$20,d0				; Shift it over
00002C6A 0200 00C0                  		andi.b	#$C0,d0				; Get the quadrant
00002C6E 0C00 0040                  		cmpi.b	#$40,d0				; Are we hitting a left wall?
00002C72 6700 0000                  		beq.w	PlayerHitLWall			; If so, branch
00002C76 0C00 0080                  		cmpi.b	#$80,d0				; Are we hitting a ceiling?
00002C7A 6700 0000                  		beq.w	PlayerHitCeilAndWalls		; If so, branch
00002C7E 0C00 00C0                  		cmpi.b	#$C0,d0				; Are we hitting a right wall?
00002C82 6700 0000                  		beq.w	PlayerHitRWall			; If so, branch
00002C86                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002C86                            PlayerHitFloorAndWalls:
00002C86 6100 0000                  		bsr.w	PlayerChkLeftWallDist		; Get left wall distance
00002C8A 4A41                       		tst.w	d1				; Have we hit the wall?
00002C8C 6A00                       		bpl.s	.NoLeftHit			; If not, branch
00002C8E 9368 0014                  		sub.w	d1,oXPos(a0)			; Move out of the wall
00002C92 4268 001C                  		clr.w	oXVel(a0)			; Stop moving
00002C96                            
00002C96                            .NoLeftHit:
00002C96 6100 0000                  		bsr.w	PlayerChkRightWallDist		; Get right wall distance
00002C9A 4A41                       		tst.w	d1				; Have we hit the wall?
00002C9C 6A00                       		bpl.s	.NoRightHit			; If not, branch
00002C9E D368 0014                  		add.w	d1,oXPos(a0)			; Move out of the wall
00002CA2 4268 001C                  		clr.w	oXVel(a0)			; Stop moving
00002CA6                            
00002CA6                            .NoRightHit:
00002CA6 6100 0000                  		bsr.w	PlayerChkFloor			; Get floor distance
00002CAA 4A41                       		tst.w	d1				; Have we hit the floor?
00002CAC 6A00                       		bpl.s	.End				; If not, branch
00002CAE                            
00002CAE 1428 001E                  		move.b	oYVel(a0),d2			; Get the integer part of the Y velocity
00002CB2 5002                       		addq.b	#8,d2				; Get the max distance we have to have from the floor in order to collide with it
00002CB4 4402                       		neg.b	d2				; Negate it since we are in the floor
00002CB6 B202                       		cmp.b	d2,d1				; Is the chosen primary distance small enough?
00002CB8 6C00                       		bge.s	.TouchFloor			; If so, branch
00002CBA B002                       		cmp.b	d2,d0				; What about the other angle that was found?
00002CBC 6D00                       		blt.s	.End				; If not, branch
00002CBE                            
00002CBE                            .TouchFloor:
00002CBE 1143 0000                  		move.b	d3,oAngle(a0)			; Set the angle
00002CC2 D368 0018                  		add.w	d1,oYPos(a0)			; Move out of the floor
00002CC6 1003                       		move.b	d3,d0				; Copy angle
00002CC8 0600 0020                  		addi.b	#$20,d0				; Shift it
00002CCC 0200 0040                  		andi.b	#$40,d0				; Are we on a wall?
00002CD0 6600                       		bne.s	.HitWall			; If so, branch
00002CD2 1003                       		move.b	d3,d0				; Copy angle
00002CD4 0600 0010                  		addi.b	#$10,d0				; Shift it
00002CD8 0200 0020                  		andi.b	#$20,d0				; Are we on a slope?
00002CDC 6700                       		beq.s	.HitFloor			; If not, branch
00002CDE E0E8 001E                  		asr	oYVel(a0)			; Divide the Y velocity by 2
00002CE2 6000                       		bra.s	.HitSlope			; Continue
00002CE4                            
00002CE4                            .HitFloor:
00002CE4 4268 001E                  		clr.w	oYVel(a0)			; Stop Y movement
00002CE8 3168 001C 0000             		move.w	oXVel(a0),oGVel(a0)		; Set ground velocity
00002CEE 6000 0000                  		bra.w	PlayerResetOnFloor		; Reset status on floor
00002CF2                            
00002CF2                            .HitWall:
00002CF2 4268 001C                  		clr.w	oXVel(a0)			; Stop X movement
00002CF6 0C68 0FC0 001E             		cmpi.w	#$FC0,oYVel(a0)			; Cap the Y velocity at $FC0
00002CFC 6F00                       		ble.s	.HitSlope			; ''
00002CFE 317C 0FC0 001E             		move.w	#$FC0,oYVel(a0)			; ''
00002D04                            
00002D04                            .HitSlope:
00002D04 6100 0000                  		bsr.w	PlayerResetOnFloor		; Reset status on floor
00002D08 3168 001E 0000             		move.w	oYVel(a0),oGVel(a0)		; Set ground velocity
00002D0E 4A03                       		tst.b	d3				; Have we touched a right side angle ($80-$FF)?
00002D10 6A00                       		bpl.s	.End				; If so, branch
00002D12 4468 0000                  		neg.w	oGVel(a0)			; Negate the ground velocity
00002D16                            
00002D16                            .End:
00002D16 4E75                       		rts
00002D18                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002D18                            PlayerHitLWall:
00002D18 6100 0000                  		bsr.w	PlayerChkLeftWallDist		; Get left wall distance
00002D1C 4A41                       		tst.w	d1				; Have we hit the wall?
00002D1E 6A00                       		bpl.s	.ChkCeil			; If not, branch
00002D20 9368 0014                  		sub.w	d1,oXPos(a0)			; Move out of the wall
00002D24 4268 001C                  		clr.w	oXVel(a0)			; Stop moving
00002D28 3168 001E 0000             		move.w	oYVel(a0),oGVel(a0)		; Set ground velocity
00002D2E                            
00002D2E                            .ChkCeil:
00002D2E 6100 0000                  		bsr.w	PlayerChkCeiling		; Get ceiling distance
00002D32 4A41                       		tst.w	d1				; Have we hit the ceiling?
00002D34 6A00                       		bpl.s	.ChkFloor			; If not, branch
00002D36 4441                       		neg.w	d1				; Get the distance inside the ceiling
00002D38 0C41 0014                  		cmpi.w	#$14,d1				; Are we too far into the ceiling?
00002D3C 6400                       		bhs.s	.ChkRightWall			; If so, branch
00002D3E D368 0018                  		add.w	d1,oYPos(a0)			; Move out of the ceiling
00002D42 4A68 001E                  		tst.w	oYVel(a0)			; Are we moving up?
00002D46 6A00                       		bpl.s	.End				; If not, branch
00002D48 4268 001E                  		clr.w	oYVel(a0)			; Stop Y movement
00002D4C                            
00002D4C                            .End:
00002D4C 4E75                       		rts
00002D4E                            
00002D4E                            .ChkRightWall:
00002D4E 6100 0000                  		bsr.w	PlayerChkRightWallDist		; Get right wall distance
00002D52 4A41                       		tst.w	d1				; Have we hit the wall?
00002D54 6A00                       		bpl.s	.End2				; If not, branch
00002D56 D368 0014                  		add.w	d1,oXPos(a0)			; Move out of the wall
00002D5A 4268 001C                  		clr.w	oXVel(a0)			; Stop moving
00002D5E                            		
00002D5E                            .End2:
00002D5E 4E75                       		rts
00002D60                            
00002D60                            .ChkFloor:
00002D60 4A68 001E                  		tst.w	oYVel(a0)			; Are we moving up?
00002D64 6B00                       		bmi.s	.End3				; If so, branch
00002D66 6100 0000                  		bsr.w	PlayerChkFloor			; Get floor distance
00002D6A 4A41                       		tst.w	d1				; Have we hit the ceiling?
00002D6C 6A00                       		bpl.s	.End3				; If not, branch
00002D6E D368 0018                  		add.w	d1,oYPos(a0)			; Move out of the ceiling
00002D72 1143 0000                  		move.b	d3,oAngle(a0)			; Set angle
00002D76 4268 001E                  		clr.w	oYVel(a0)			; Stop Y movement
00002D7A 3168 001C 0000             		move.w	oXVel(a0),oGVel(a0)		; Set ground velocity
00002D80 6000 0000                  		bra.w	PlayerResetOnFloor		; Reset status on floor
00002D84                            		
00002D84                            .End3:
00002D84 4E75                       		rts
00002D86                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002D86                            PlayerHitCeilAndWalls:
00002D86 6100 0000                  		bsr.w	PlayerChkLeftWallDist		; Get left wall distance
00002D8A 4A41                       		tst.w	d1				; Have we hit the wall?
00002D8C 6A00                       		bpl.s	.NoLeftHit			; If not, branch
00002D8E 9368 0014                  		sub.w	d1,oXPos(a0)			; Move out of the wall
00002D92 4268 001C                  		clr.w	oXVel(a0)			; Stop moving
00002D96                            
00002D96                            .NoLeftHit:
00002D96 6100 0000                  		bsr.w	PlayerChkRightWallDist		; Get right wall distance
00002D9A 4A41                       		tst.w	d1				; Have we hit the wall?
00002D9C 6A00                       		bpl.s	.NoRightHit			; If not, branch
00002D9E D368 0014                  		add.w	d1,oXPos(a0)			; Move out of the wall
00002DA2 4268 001C                  		clr.w	oXVel(a0)			; Stop moving
00002DA6                            
00002DA6                            .NoRightHit:
00002DA6 6100 0000                  		bsr.w	PlayerChkCeiling		; Get ceiling distance
00002DAA 4A41                       		tst.w	d1				; Have we hit the floor?
00002DAC 6A00                       		bpl.s	.End				; If not, branch
00002DAE 9368 0018                  		sub.w	d1,oYPos(a0)			; Move out of ceiling
00002DB2 1003                       		move.b	d3,d0				; Get angle
00002DB4 0600 0020                  		addi.b	#$20,d0				; Shift it
00002DB8 0200 0040                  		andi.b	#$40,d0				; Are we on a wall?
00002DBC 6600                       		bne.s	.HitWall			; If so, branch
00002DBE 4268 001E                  		clr.w	oYVel(a0)			; Stop Y movement
00002DC2 4E75                       		rts
00002DC4                            
00002DC4                            .HitWall:
00002DC4 1143 0000                  		move.b	d3,oAngle(a0)			; Set angle
00002DC8 6100 0000                  		bsr.w	PlayerResetOnFloor		; Reset status on floor
00002DCC 3168 001E 0000             		move.w	oYVel(a0),oGVel(a0)		; Set ground velocity
00002DD2 4A03                       		tst.b	d3				; Have we touched a right side angle ($80-$FF)?
00002DD4 6A00                       		bpl.s	.End				; If so, branch
00002DD6 4468 0000                  		neg.w	oGVel(a0)			; Negate the ground velocity
00002DDA                            
00002DDA                            .End:
00002DDA 4E75                       		rts
00002DDC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002DDC                            PlayerHitRWall:
00002DDC 6100 0000                  		bsr.w	PlayerChkRightWallDist		; Get right wall distance
00002DE0 4A41                       		tst.w	d1				; Have we hit the wall?
00002DE2 6A00                       		bpl.s	.ChkCeil			; If not, branch
00002DE4 D368 0014                  		add.w	d1,oXPos(a0)			; Move out of the wall
00002DE8 4268 001C                  		clr.w	oXVel(a0)			; Stop moving
00002DEC 3168 001E 0000             		move.w	oYVel(a0),oGVel(a0)		; Set ground velocity
00002DF2                            
00002DF2                            .ChkCeil:
00002DF2 6100 0000                  		bsr.w	PlayerChkCeiling		; Get ceiling distance
00002DF6 4A41                       		tst.w	d1				; Have we hit the ceiling?
00002DF8 6A00                       		bpl.s	.ChkFloor			; If not, branch
00002DFA 9368 0018                  		sub.w	d1,oYPos(a0)			; Move out of the ceiling
00002DFE 4A68 001E                  		tst.w	oYVel(a0)			; Are we moving up?
00002E02 6A00                       		bpl.s	.End				; If not, branch
00002E04 4268 001E                  		clr.w	oYVel(a0)			; Stop Y movement
00002E08                            
00002E08                            .End:
00002E08 4E75                       		rts
00002E0A                            
00002E0A                            .ChkFloor:
00002E0A 4A68 001E                  		tst.w	oYVel(a0)			; Are we moving up?
00002E0E 6B00                       		bmi.s	.End2				; If so, branch
00002E10 6100 0000                  		bsr.w	PlayerChkFloor			; Get floor distance
00002E14 4A41                       		tst.w	d1				; Have we hit the ceiling?
00002E16 6A00                       		bpl.s	.End2				; If not, branch
00002E18 D368 0018                  		add.w	d1,oYPos(a0)			; Move out of the ceiling
00002E1C 1143 0000                  		move.b	d3,oAngle(a0)			; Set angle
00002E20 4268 001E                  		clr.w	oYVel(a0)			; Stop Y movement
00002E24 3168 001C 0000             		move.w	oXVel(a0),oGVel(a0)		; Set ground velocity
00002E2A 6000                       		bra.s	PlayerResetOnFloor		; Reset status on floor
00002E2C                            		
00002E2C                            .End2:
00002E2C 4E75                       		rts
00002E2E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002E2E                            ; Reset a player object's status on the floor
00002E2E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002E2E                            PlayerResetOnFloor:
00002E2E 4A28 0000                  		tst.b	oBallMode(a0)			; Are we in ball mode?
00002E32 6600                       		bne.s	PlayerResetOnFloorPart3	; If so, branch
00002E34 4228 0020                  		clr.b	oAni(a0)			; Set walking animation
00002E38                            		
00002E38                            PlayerResetOnFloorPart2:
00002E38 0828 0002 0028             		btst	#2,oStatus(a0)			; Was Sonic rolling?
00002E3E 6700                       		beq.s	PlayerResetOnFloorPart3	; If so, branch
00002E40 08A8 0002 0028             		bclr	#2,oStatus(a0)			; Clear roll flag
00002E46 1168 0000 002C             		move.b	oInitColW(a0),oColW(a0)		; Reset collision width
00002E4C 1168 0000 002D             		move.b	oInitColH(a0),oColH(a0)		; Reset collision height
00002E52 4228 0020                  		clr.b	oAni(a0)			; Set walking animation
00002E56 5B68 0018                  		subq.w	#5,oYPos(a0)			; Align with floor
00002E5A                            
00002E5A                            PlayerResetOnFloorPart3:
00002E5A 0228 00DD 0028             		andi.b	#$DD,oStatus(a0)		; Clear "pushing", and "jumping" flag
00002E60 4228 0000                  		clr.b	oJumping(a0)			; Clear jumping flag
00002E64 4228 0000                  		clr.b	oFlipAngle(a0)			; Reset flip angle
00002E68 4228 0000                  		clr.b	oFlipTurned(a0)			; Reset flip inverted flag
00002E6C 4228 0000                  		clr.b	oFlipRemain(a0)			; Reset flips remaining
00002E70 4E75                       		rts
00002E72                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002E72                            ; Calculate the room in front of a player object
00002E72                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002E72                            PlayerCalcRoomInFront:
00002E72 21F8 F8D8 F8E0             		move.l	r1stCol.w,rColAddr.w	; Get primary collision address
00002E78 0C28 000C 0000             		cmpi.b	#$C,oTopSolid(a0)		; Are we on the primary path?
00002E7E 6700                       		beq.s	.NotPrimary			; If not, branch
00002E80 21F8 F8DC F8E0             		move.l	r2ndCol.w,rColAddr.w	; Get secondary collision address
00002E86                            
00002E86                            .NotPrimary:
00002E86 1A28 0000                  		move.b	oLRBSolid(a0),d5		; Get LRB solid bits
00002E8A                            		
00002E8A 2628 0014                  		move.l	oXPos(a0),d3			; Get X position
00002E8E 2428 0018                  		move.l	oYPos(a0),d2			; Get Y position
00002E92 3228 001C                  		move.w	oXVel(a0),d1			; Get X velocity
00002E96 48C1                       		ext.l	d1				; ''
00002E98 E181                       		asl.l	#8,d1				; Shift it
00002E9A D681                       		add.l	d1,d3				; Add onto X position
00002E9C 3228 001E                  		move.w	oYVel(a0),d1			; Get Y velocity
00002EA0 48C1                       		ext.l	d1				; ''
00002EA2 E181                       		asl.l	#8,d1				; Shift it
00002EA4 D481                       		add.l	d1,d2				; Add onto Y position
00002EA6 4842                       		swap	d2				; Get actual Y
00002EA8 4843                       		swap	d3				; Get actual X
00002EAA 1140 002E                  		move.b	d0,oNextTilt(a0)		; Set primary angle
00002EAE 1140 002F                  		move.b	d0,oTilt(a0)			; Set secondary angle
00002EB2 1200                       		move.b	d0,d1				; Copy angle
00002EB4 0800 0006                  		btst	#6,d0				; Are we in quadrants 0 or $80? (use 5 instaead of 6 for 8 directions)
00002EB8 6700                       		beq.s	.DownUp				; If not, branch
00002EBA 5200                       		addq.b	#1,d0				; Shift the angle
00002EBC                            
00002EBC                            .DownUp:
00002EBC 0600 001F                  		addi.b	#$1F,d0				; Shift the angle (use $F instaead of $1F for 8 directions)
00002EC0 0200 00C0                  		andi.b	#$C0,d0				; Get quadrant
00002EC4 6700 0000                  		beq.w	PlayerChkFloorDist_Part2	; If quadrant 0, get the floor distance
00002EC8 0C00 0080                  		cmpi.b	#$80,d0				; Are we in quadrant $80?
00002ECC 6700 0000                  		beq.w	PlayerChkCeilingDist_Part2	; If so, branch
00002ED0 0201 0038                  		andi.b	#$38,d1				; Are we on a flat enough surface?
00002ED4 6600                       		bne.s	.ChkWall			; If not, branch
00002ED6 5042                       		addq.w	#8,d2				; Add 8 to the Y position
00002ED8                            
00002ED8                            .ChkWall:
00002ED8 0C00 0040                  		cmpi.b	#$40,d0				; Are we in quadrant $40?
00002EDC 6700 0000                  		beq.w	PlayerChkLeftWallDist_Part2	; If so, branch
00002EE0 6000 0000                  		bra.w	PlayerChkRightWallDist_Part2	; Get the right wall distance
00002EE4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002EE4                            ; Calculate the room over a player object
00002EE4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002EE4                            PlayerCalcRoomOverHead:
00002EE4 21F8 F8D8 F8E0             		move.l	r1stCol.w,rColAddr.w	; Get primary collision address
00002EEA 0C28 000C 0000             		cmpi.b	#$C,oTopSolid(a0)		; Are we on the primary path?
00002EF0 6700                       		beq.s	.NotPrimary			; If not, branch
00002EF2 21F8 F8DC F8E0             		move.l	r2ndCol.w,rColAddr.w	; Get secondary collision address
00002EF8                            
00002EF8                            .NotPrimary:
00002EF8 1A28 0000                  		move.b	oLRBSolid(a0),d5		; Get LRB solid bits
00002EFC 1140 002E                  		move.b	d0,oNextTilt(a0)		; Set primary angle
00002F00 1140 002F                  		move.b	d0,oTilt(a0)			; Set secondary angle
00002F04                            		
00002F04 0600 0020                  		addi.b	#$20,d0				; Shift the angle
00002F08 0200 00C0                  		andi.b	#$C0,d0				; Get quadrant
00002F0C 0C00 0040                  		cmpi.b	#$40,d0				; Are we in quadrant $40?
00002F10 6700 0000                  		beq.w	PlayerChkLeftCeilDist		; If so, branch
00002F14 0C00 0080                  		cmpi.b	#$80,d0				; Are we in quadrant $80?
00002F18 6700 0000                  		beq.w	PlayerChkCeiling		; If so, branch
00002F1C 0C00 00C0                  		cmpi.b	#$C0,d0				; Are we in quadrant $C0?
00002F20 6700 0000                  		beq.w	PlayerChkRightCeilDist		; If so, branch
00002F24                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002F24                            ; Get the distance between the floor and a player object (with primary and secondary angles)
00002F24                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002F24                            PlayerChkFloor:
00002F24 21F8 F8D8 F8E0             		move.l	r1stCol.w,rColAddr.w	; Get primary collision address
00002F2A 0C28 000C 0000             		cmpi.b	#$C,oTopSolid(a0)		; Are we on the primary path?
00002F30 6700                       		beq.s	.NotPrimary			; If not, branch
00002F32 21F8 F8DC F8E0             		move.l	r2ndCol.w,rColAddr.w	; Get secondary collision address
00002F38                            
00002F38                            .NotPrimary:
00002F38 1A28 0000                  		move.b	oTopSolid(a0),d5		; Get top solid bits
00002F3C                            		
00002F3C                            		; Get the angle on the bottom right sensor
00002F3C 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00002F40 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
00002F44 7000                       		moveq	#0,d0
00002F46 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
00002F4A 4880                       		ext.w	d0				; ''
00002F4C D440                       		add.w	d0,d2				; Add onto Y position
00002F4E 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
00002F52 4880                       		ext.w	d0				; ''
00002F54 D640                       		add.w	d0,d3				; Add onto X position
00002F56 49E8 002E                  		lea	oNextTilt(a0),a4		; Get primary angle
00002F5A 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00002F5E 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
00002F60 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
00002F64                            		push.w	d1				; Save the primary floor distance
00002F64 3F01                     M 	move.w	d1,-(sp)
00002F66                            
00002F66                            		; Get the angle on the bottom left sensor
00002F66 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00002F6A 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
00002F6E 7000                       		moveq	#0,d0
00002F70 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
00002F74 4880                       		ext.w	d0				; ''
00002F76 D440                       		add.w	d0,d2				; Add onto Y position
00002F78 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
00002F7C 4880                       		ext.w	d0				; ''
00002F7E 9640                       		sub.w	d0,d3				; Subtract from X position
00002F80 49E8 002F                  		lea	oTilt(a0),a4			; Get secondary angle
00002F84 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00002F88 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
00002F8A 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
00002F8E                            		
00002F8E                            		; Update the object's angle
00002F8E                            		pop.w	d0				; Restore the primary floor distance
00002F8E 301F                     M 	move.w	(sp)+,d0
00002F90 4202                       		clr.b	d2				; Angle value for when the object touched an odd angle (usually $FF)
00002F92                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002F92                            PlayerPickAngle:
00002F92 1628 002F                  		move.b	oTilt(a0),d3			; Get secondary angle
00002F96 B240                       		cmp.w	d0,d1				; Is the primary floor distance lower than the secondary?
00002F98 6F00                       		ble.s	.ChkSetAngle			; If not, branch
00002F9A 1628 002E                  		move.b	oNextTilt(a0),d3		; Get primary angle
00002F9E C141                       		exg.l	d0,d1				; Switch floor distance values
00002FA0                            		
00002FA0                            .ChkSetAngle:
00002FA0 0803 0000                  		btst	#0,d3				; Is this an odd angle (usually $FF)?
00002FA4 6700                       		beq.s	.End				; If not, branch
00002FA6 1602                       		move.b	d2,d3				; Set the new angle value
00002FA8                            		
00002FA8                            .End:
00002FA8 4E75                       		rts
00002FAA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002FAA                            ; Get the distance between the floor and the player object
00002FAA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002FAA                            PlayerChkFloorDist:
00002FAA 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00002FAE 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
00002FB2                            
00002FB2                            PlayerChkFloorDist_Part2:
00002FB2 0642 000A                  		addi.w	#10,d2				; Check 10 pixels down
00002FB6 49E8 002E                  		lea	oNextTilt(a0),a4		; Primary angle
00002FBA 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00002FBE 4246                       		clr.w	d6				; No flip bits
00002FC0 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
00002FC4 4202                       		clr.b	d2				; Angle value for when the object touched an odd angle (usually $FF)
00002FC6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002FC6                            PlayerGetPrimaryAngle:
00002FC6 1628 002E                  		move.b	oNextTilt(a0),d3		; Get primary angle
00002FCA 0803 0000                  		btst	#0,d3				; Is this an odd angle (usually $FF)?
00002FCE 6700                       		beq.s	.End				; If not, branch
00002FD0 1602                       		move.b	d2,d3				; Set the new angle value
00002FD2                            		
00002FD2                            .End:
00002FD2 4E75                       		rts
00002FD4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00002FD4                            sub_F846:
00002FD4 3628 0014                  		move.w	oXPos(a0),d3
00002FD8 3428 0018                  		move.w	oYPos(a0),d2
00002FDC 5942                       		subq.w	#4,d2
00002FDE 21F8 F8D8 F8E0             		move.l	r1stCol.w,rColAddr.w	; Get primary collision address
00002FE4 0C28 000D 0000             		cmpi.b	#$D,oLRBSolid(a0)		; Are we on the primary path?
00002FEA 6700                       		beq.s	.NotPrimary			; If not, branch
00002FEC 21F8 F8DC F8E0             		move.l	r2ndCol.w,rColAddr.w	; Get secondary collision address
00002FF2                            
00002FF2                            .NotPrimary:
00002FF2 49E8 002E                  		lea	oNextTilt(a0),a4		; Primary angle
00002FF6 4214                       		clr.b	(a4)				; Clear it
00002FF8 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00002FFC 4246                       		clr.w	d6				; No flip bits
00002FFE 1A28 0000                  		move.b	oLRBSolid(a0),d5		; Solidity bits
00003002 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
00003006 1628 002E                  		move.b	oNextTilt(a0),d3		; Get primary angle
0000300A 0803 0000                  		btst	#0,d3				; Are we on an odd angle (usually $FF)?
0000300E 6700                       		beq.s	.End				; If not, branch
00003010 4203                       		clr.b	d3				; Angle value for when the object touched an odd angle (usually $FF)
00003012                            
00003012                            .End:
00003012 4E75                       		rts
00003014                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003014                            ; Check for the edge of a floor
00003014                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003014                            PlayerChkFloorEdge:
00003014 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
00003018                            
00003018                            PlayerChkFloorEdge_Part2:
00003018 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
0000301C 7000                       		moveq	#0,d0
0000301E 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
00003022 4880                       		ext.w	d0				; ''
00003024 D440                       		add.w	d0,d2				; Add onto Y position
00003026                            
00003026                            PlayerChkFloorEdge_Part3:
00003026 21F8 F8D8 F8E0             		move.l	r1stCol.w,rColAddr.w	; Get primary collision address
0000302C 0C28 000C 0000             		cmpi.b	#$C,oTopSolid(a0)		; Are we on the primary path?
00003032 6700                       		beq.s	.NotPrimary			; If not, branch
00003034 21F8 F8DC F8E0             		move.l	r2ndCol.w,rColAddr.w	; Get secondary collision address
0000303A                            
0000303A                            .NotPrimary:
0000303A 49E8 002E                  		lea	oNextTilt(a0),a4		; Primary angle
0000303E 4214                       		clr.b	(a4)				; Clear it
00003040 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00003044 4246                       		clr.w	d6				; No flip bits
00003046 1A28 0000                  		move.b	oTopSolid(a0),d5		; Solidity bits
0000304A 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
0000304E 1628 002E                  		move.b	oNextTilt(a0),d3		; Get primary angle
00003052 0803 0000                  		btst	#0,d3				; Are we on an odd angle (usually $FF)?
00003056 6700                       		beq.s	.End				; If not, branch
00003058 4203                       		clr.b	d3				; Angle value for when the object touched an odd angle (usually $FF)
0000305A                            
0000305A                            .End:
0000305A 4E75                       		rts
0000305C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000305C                            ; Get the distance between the floor and an object
0000305C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000305C                            ObjCheckFloorDist:
0000305C 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
00003060                            		
00003060                            ObjCheckFloorDist_Part2:
00003060 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00003064                            
00003064                            ObjCheckFloorDist_Part3:
00003064 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
00003068 4880                       		ext.w	d0				; ''
0000306A D440                       		add.w	d0,d2				; Add onto Y position
0000306C 49E8 002E                  		lea	oNextTilt(a0),a4		; Primary angle
00003070 4214                       		clr.b	(a4)				; Clear it
00003072 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00003076 4246                       		clr.w	d6				; No flip bits
00003078 7A0C                       		moveq	#$C,d5				; Solidity bits
0000307A 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
0000307E 1628 002E                  		move.b	oNextTilt(a0),d3		; Get primary angle
00003082 0803 0000                  		btst	#0,d3				; Are we on an odd angle (usually $FF)?
00003086 6700                       		beq.s	.End				; If not, branch
00003088 4203                       		clr.b	d3				; Angle value for when the object touched an odd angle (usually $FF)
0000308A                            
0000308A                            .End:
0000308A 4E75                       		rts
0000308C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000308C                            ; Get the distance between a right ceiling and a player object
0000308C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000308C                            PlayerChkRightCeilDist:
0000308C                            		; Get the angle on the bottom right (rotated) sensor
0000308C 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00003090 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
00003094 7000                       		moveq	#0,d0
00003096 1028 002C                  		move.b	oColW(a0),d0			; Get collision height
0000309A 4880                       		ext.w	d0				; ''
0000309C 9440                       		sub.w	d0,d2				; Subtract from Y position
0000309E 1028 002D                  		move.b	oColH(a0),d0			; Get collision width
000030A2 4880                       		ext.w	d0				; ''
000030A4 D640                       		add.w	d0,d3				; Add onto X position
000030A6 49E8 002E                  		lea	oNextTilt(a0),a4		; Get primary angle
000030AA 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
000030AE 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
000030B0 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
000030B4                            		push.w	d1				; Save the primary floor distance
000030B4 3F01                     M 	move.w	d1,-(sp)
000030B6                            
000030B6                            		; Get the angle on the bottom left (rotated) sensor
000030B6 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
000030BA 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
000030BE 7000                       		moveq	#0,d0
000030C0 1028 002C                  		move.b	oColW(a0),d0			; Get collision height
000030C4 4880                       		ext.w	d0				; ''
000030C6 D440                       		add.w	d0,d2				; Add onto Y position
000030C8 1028 002D                  		move.b	oColH(a0),d0			; Get collision width
000030CC 4880                       		ext.w	d0				; ''
000030CE D640                       		add.w	d0,d3				; Add onto X position
000030D0 49E8 002F                  		lea	oTilt(a0),a4			; Get secondary angle
000030D4 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
000030D8 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
000030DA 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
000030DE                            
000030DE                            		; Update the object's angle
000030DE                            		pop.w	d0				; Restore the primary floor distance
000030DE 301F                     M 	move.w	(sp)+,d0
000030E0 143C 00C0                  		move.b	#-$40,d2			; Angle value for when the object touched an odd angle (usually $FF)
000030E4 6000 FEAC                  		bra.w	PlayerPickAngle		; Get the angle
000030E8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000030E8                            ; Get the distance between a right wall and a player object
000030E8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000030E8                            PlayerChkRightWallDist:
000030E8 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
000030EC 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
000030F0                            
000030F0                            PlayerChkRightWallDist_Part2:
000030F0 0643 000A                  		addi.w	#10,d3				; Check 10 pixels to the right
000030F4 49E8 002E                  		lea	oNextTilt(a0),a4		; Primary angle
000030F8 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
000030FC 4246                       		clr.w	d6				; No flip bits
000030FE 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
00003102 143C 00C0                  		move.b	#-$40,d2			; Angle value for when the object touched an odd angle (usually $FF)
00003106 6000 FEBE                  		bra.w	PlayerGetPrimaryAngle		; Get angle
0000310A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000310A                            ; Get the distance between a right wall and an object
0000310A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000310A                            ObjCheckRightWallDist:
0000310A D668 0014                  		add.w	oXPos(a0),d3			; Add X position
0000310E 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00003112 49E8 002E                  		lea	oNextTilt(a0),a4		; Primary angle
00003116 4214                       		clr.b	(a4)				; Clear it
00003118 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
0000311C 4246                       		clr.w	d6				; No flip bits
0000311E 7A0D                       		moveq	#$D,d5				; Solidity bits
00003120 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
00003124 1628 002E                  		move.b	oNextTilt(a0),d3		; Get primary angle
00003128 0803 0000                  		btst	#0,d3				; Are we on an odd angle (usually $FF)?
0000312C 6700                       		beq.s	.End				; If not, branch
0000312E 163C 00C0                  		move.b	#-$40,d3			; Angle value for when the object touched an odd angle (usually $FF)
00003132                            
00003132                            .End:
00003132 4E75                       		rts
00003134                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003134                            ; Get the distance between a ceiling and a player object (with primary and secondary angles)
00003134                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003134                            PlayerChkCeiling:
00003134                            		; Get the angle on the bottom right sensor
00003134 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00003138 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
0000313C 7000                       		moveq	#0,d0
0000313E 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
00003142 4880                       		ext.w	d0				; ''
00003144 9440                       		sub.w	d0,d2				; Subtract from Y position
00003146 0A42 000F                  		eori.w	#$F,d2				; Flip it
0000314A 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
0000314E 4880                       		ext.w	d0				; ''
00003150 D640                       		add.w	d0,d3				; Add onto X position
00003152 49E8 002E                  		lea	oNextTilt(a0),a4		; Get primary angle
00003156 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
0000315A 3C3C 0800                  		move.w	#$800,d6			; Vertical flip
0000315E 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
00003162                            		push.w	d1				; Save the primary floor distance
00003162 3F01                     M 	move.w	d1,-(sp)
00003164                            
00003164                            		; Get the angle on the bottom left sensor
00003164 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00003168 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
0000316C 7000                       		moveq	#0,d0
0000316E 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
00003172 4880                       		ext.w	d0				; ''
00003174 9440                       		sub.w	d0,d2				; Subtract from Y position
00003176 0A42 000F                  		eori.w	#$F,d2				; Flip it
0000317A 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
0000317E 4880                       		ext.w	d0				; ''
00003180 9640                       		sub.w	d0,d3				; Subtract from X position
00003182 49E8 002F                  		lea	oTilt(a0),a4			; Get secondary angle
00003186 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
0000318A 3C3C 0800                  		move.w	#$800,d6			; Vertical flip
0000318E 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
00003192                            		
00003192                            		; Update the object's angle
00003192                            		pop.w	d0				; Restore the primary floor distance
00003192 301F                     M 	move.w	(sp)+,d0
00003194 143C 0080                  		move.b	#$80,d2				; Angle value for when the object touched an odd angle (usually $FF)
00003198 6000 FDF8                  		bra.w	PlayerPickAngle		; Get the angle
0000319C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000319C                            ; Get the distance between a ceiling and a player object
0000319C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000319C                            PlayerChkCeilingDist:
0000319C 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
000031A0 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
000031A4                            
000031A4                            PlayerChkCeilingDist_Part2:
000031A4 0442 000A                  		subi.w	#10,d2				; Check 10 pixels up
000031A8 0A42 000F                  		eori.w	#$F,d2				; Flip it
000031AC 49E8 002E                  		lea	oNextTilt(a0),a4		; Primary angle
000031B0 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
000031B4 3C3C 0800                  		move.w	#$800,d6			; Vertical flip
000031B8 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
000031BC 143C 0080                  		move.b	#$80,d2				; Angle value for when the object touched an odd angle (usually $FF)
000031C0 6000 FE04                  		bra.w	PlayerGetPrimaryAngle		; Get angle
000031C4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000031C4                            ; Get the distance between a ceiling and an object
000031C4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000031C4                            ObjCheckCeilingDist:
000031C4 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
000031C8 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
000031CC 7000                       		moveq	#0,d0
000031CE 1028 002D                  		move.b	oColH(a0),d0		; Get collision height
000031D2 4880                       		ext.w	d0				; ''
000031D4 9440                       		sub.w	d0,d2				; Subtract it from Y position
000031D6 0A42 000F                  		eori.w	#$F,d2				; Flip it
000031DA 49E8 002E                  		lea	oNextTilt(a0),a4		; Primary angle
000031DE 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
000031E2 3C3C 0800                  		move.w	#$800,d6			; Vertical flip
000031E6 7A0D                       		moveq	#$D,d5				; Solidity bits
000031E8 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
000031EC 1628 002E                  		move.b	oNextTilt(a0),d3		; Get primary angle
000031F0 0803 0000                  		btst	#0,d3				; Are we on an odd angle (usually $FF)?
000031F4 6700                       		beq.s	.End				; If not, branch
000031F6 163C 0080                  		move.b	#$80,d3				; Angle value for when the object touched an odd angle (usually $FF)
000031FA                            
000031FA                            .End:
000031FA 4E75                       		rts
000031FC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000031FC                            ; Get the distance between a left ceiling and a player object
000031FC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000031FC                            PlayerChkLeftCeilDist:
000031FC                            		; Get the angle on the bottom right (rotated) sensor
000031FC 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00003200 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
00003204 7000                       		moveq	#0,d0
00003206 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
0000320A 4880                       		ext.w	d0				; ''
0000320C 9440                       		sub.w	d0,d2				; Subtract from Y position
0000320E 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
00003212 4880                       		ext.w	d0				; ''
00003214 9640                       		sub.w	d0,d3				; Subtract from X position
00003216 0A43 000F                  		eori.w	#$F,d3				; Flip it
0000321A 49E8 002E                  		lea	oNextTilt(a0),a4		; Get primary angle
0000321E 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
00003222 3C3C 0400                  		move.w	#$400,d6			; Horizontal flip
00003226 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
0000322A                            		push.w	d1				; Save the primary floor distance
0000322A 3F01                     M 	move.w	d1,-(sp)
0000322C                            
0000322C                            		; Get the angle on the bottom left (rotated) sensor
0000322C 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00003230 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
00003234 7000                       		moveq	#0,d0
00003236 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
0000323A 4880                       		ext.w	d0				; ''
0000323C D440                       		add.w	d0,d2				; Add onto Y position
0000323E 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
00003242 4880                       		ext.w	d0				; ''
00003244 9640                       		sub.w	d0,d3				; Subtract from X position
00003246 0A43 000F                  		eori.w	#$F,d3				; Flip it
0000324A 49E8 002F                  		lea	oTilt(a0),a4			; Get secondary angle
0000324E 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
00003252 3C3C 0400                  		move.w	#$400,d6			; Horizontal flip
00003256 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
0000325A                            
0000325A                            		; Update the object's angle
0000325A                            		pop.w	d0				; Restore the primary floor distance
0000325A 301F                     M 	move.w	(sp)+,d0
0000325C 143C 0040                  		move.b	#$40,d2				; Angle value for when the object touched an odd angle (usually $FF)
00003260 6000 FD30                  		bra.w	PlayerPickAngle		; Get the angle
00003264                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003264                            ; Get the distance between a left wall and a player object
00003264                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003264                            PlayerChkLeftWallDist:
00003264 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00003268 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
0000326C                            
0000326C                            PlayerChkLeftWallDist_Part2:
0000326C 0443 000A                  		subi.w	#10,d3				; Check 10 pixels to the left
00003270 0A43 000F                  		eori.w	#$F,d3				; Flip it
00003274 49E8 002E                  		lea	oNextTilt(a0),a4		; Primary angle
00003278 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
0000327C 3C3C 0400                  		move.w	#$400,d6			; Horizontal flip
00003280 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
00003284 143C 0040                  		move.b	#$40,d2				; Angle value for when the object touched an odd angle (usually $FF)
00003288 6000 FD3C                  		bra.w	PlayerGetPrimaryAngle		; Get angle
0000328C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000328C                            ; Get the distance between a left wall and an object
0000328C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000328C                            ObjCheckLeftWallDist:
0000328C D668 0014                  		add.w	oXPos(a0),d3			; Add X position
00003290 0A43 000F                  		eori.w	#$F,d3				; Flip it
00003294 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00003298 49E8 002E                  		lea	oNextTilt(a0),a4		; Primary angle
0000329C 4214                       		clr.b	(a4)				; Clear it
0000329E 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
000032A2 3C3C 0400                  		move.w	#$400,d6			; Horizontal flip
000032A6 7A0D                       		moveq	#$D,d5				; Solidity bits
000032A8 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
000032AC 1628 002E                  		move.b	oNextTilt(a0),d3		; Get primary angle
000032B0 0803 0000                  		btst	#0,d3				; Are we on an odd angle (usually $FF)?
000032B4 6700                       		beq.s	.End				; If not, branch
000032B6 163C 0040                  		move.b	#$40,d3				; Angle value for when the object touched an odd angle (usually $FF)
000032BA                            
000032BA                            .End:
000032BA 4E75                       		rts
000032BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000032BC                            ; Move a player object along on the ground
000032BC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000032BC                            PlayerAnglePos:
000032BC 21F8 F8D8 F8E0             		move.l	r1stCol.w,rColAddr.w	; Get primary collision address
000032C2 0C28 000C 0000             		cmpi.b	#$C,oTopSolid(a0)		; Are we on the primary path?
000032C8 6700                       		beq.s	.NotPrimary			; If not, branch
000032CA 21F8 F8DC F8E0             		move.l	r2ndCol.w,rColAddr.w	; Get secondary collision address
000032D0                            
000032D0                            .NotPrimary:
000032D0 1A28 0000                  		move.b	oTopSolid(a0),d5		; Get top solid bits
000032D4 0828 0003 0028             		btst	#3,oStatus(a0)			; Are we standing on a player object?
000032DA 6700                       		beq.s	.NotOnObj			; If not, branch
000032DC 4268 002E                  		clr.w	oNextTilt(a0)			; Set the angles to 0
000032E0 4E75                       		rts
000032E2                            
000032E2                            .NotOnObj:
000032E2 317C 0303 002E             		move.w	#$0303,oNextTilt(a0)		; Set the angles to 3
000032E8                            		
000032E8                            		; Get which quadrant the object is in on the ground
000032E8                            		; This makes it so that angles:
000032E8                            		; 	$E0-$20 = Quadrant 0 (floor)
000032E8                            		;	$1F-$5F = Quadrant $40 (left wall)
000032E8                            		;	$60-$A0 = Quadrant $80 (ceiling)
000032E8                            		;	$A1-$DF = Quadrant $C0 (right wall)
000032E8 1028 0000                  		move.b	oAngle(a0),d0			; Get the angle
000032EC 0800 0006                  		btst	#6,d0				; Are we in quadrants 0 or $80? (use 5 instaead of 6 for 8 directions)
000032F0 6700                       		beq.s	.DownUp				; If not, branch
000032F2 5200                       		addq.b	#1,d0				; Shift the angle
000032F4                            
000032F4                            .DownUp:
000032F4 0600 001F                  		addi.b	#$1F,d0				; Shift the angle (use $F instaead of $1F for 8 directions)
000032F8 0200 00C0                  		andi.b	#$C0,d0				; Get which quadrant we are in (use $E0 instaead of $C0 for 8 directions)
000032FC 0C00 0040                  		cmpi.b	#$40,d0				; Are we in quadrant $40 (left wall)?
00003300 6700 0000                  		beq.w	PlayerMoveLWall		; If so, branch
00003304 0C00 0080                  		cmpi.b	#$80,d0				; Are we in quadrant $80 (ceiling)?
00003308 6700 0000                  		beq.w	PlayerMoveCeiling		; Is so, branch
0000330C 0C00 00C0                  		cmpi.b	#$C0,d0				; Are we in quadrant $C0 (right wall)?
00003310 6700 0000                  		beq.w	PlayerMoveRWall		; If so, branch
00003314                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003314                            ; Move the object along the floor
00003314                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003314                            PlayerMoveFloor:
00003314                            		; Get the angle on the bottom right sensor
00003314 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00003318 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
0000331C 7000                       		moveq	#0,d0
0000331E 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
00003322 4880                       		ext.w	d0				; ''
00003324 D440                       		add.w	d0,d2				; Add onto Y position
00003326 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
0000332A 4880                       		ext.w	d0				; ''
0000332C D640                       		add.w	d0,d3				; Add onto X position
0000332E 49E8 002E                  		lea	oNextTilt(a0),a4		; Get primary angle
00003332 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00003336 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
00003338 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
0000333C                            		push.w	d1				; Save the primary floor distance
0000333C 3F01                     M 	move.w	d1,-(sp)
0000333E                            
0000333E                            		; Get the angle on the bottom left sensor
0000333E 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00003342 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
00003346 7000                       		moveq	#0,d0
00003348 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
0000334C 4880                       		ext.w	d0				; ''
0000334E D440                       		add.w	d0,d2				; Add onto Y position
00003350 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
00003354 4880                       		ext.w	d0				; ''
00003356 9640                       		sub.w	d0,d3				; Add onto X position
00003358 49E8 002F                  		lea	oTilt(a0),a4			; Get secondary angle
0000335C 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00003360 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
00003362 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
00003366                            		
00003366                            		; Update the object's angle
00003366                            		pop.w	d0				; Restore the primary floor distance
00003366 301F                     M 	move.w	(sp)+,d0
00003368 6100 0000                  		bsr.w	PlayerSetAngle			; Set the new angle
0000336C                            		
0000336C                            		; Check if the object has hit a wall or is about to fall
0000336C 4A41                       		tst.w	d1				; Is we already perfectly standing on the surface?
0000336E 6700                       		beq.s	.End				; If so, branch
00003370 6A00                       		bpl.s	.ChkFall			; If the there's possibly a floor below us, branch
00003372 0C41 FFF2                  		cmpi.w	#-$E,d1				; Have we hit a wall?
00003376 6D00                       		blt.s	.End				; If so, branch
00003378 D368 0018                  		add.w	d1,oYPos(a0)			; Move us on to the surface
0000337C                            
0000337C                            .End:
0000337C 4E75                       		rts
0000337E                            
0000337E                            .ChkFall:
0000337E 1028 001C                  		move.b	oXVel(a0),d0			; Get the integer part of the X velocity
00003382 6A00                       		bpl.s	.GetMinDist			; If it's already positive, branch
00003384 4400                       		neg.b	d0				; Force it to be positive
00003386                            
00003386                            .GetMinDist:
00003386 5800                       		addq.b	#4,d0				; The Y distance must be at least 4 pixels down
00003388 0C00 000E                  		cmpi.b	#$E,d0				; ...but cannot be more than 14 pixels down
0000338C 6500                       		blo.s	.ChkDist			; ...for us to not fall off the surface
0000338E 103C 000E                  		move.b	#$E,d0				; ''
00003392                            
00003392                            .ChkDist:
00003392 B200                       		cmp.b	d0,d1				; Are we about to fall off?
00003394 6E00                       		bgt.s	.SetAir				; If so, branch
00003396 D368 0018                  		add.w	d1,oYPos(a0)			; Move us on to the surface
0000339A 4E75                       		rts
0000339C                            
0000339C                            .SetAir:
0000339C 08E8 0001 0028             		bset	#1,oStatus(a0)			; Set "in air" flag
000033A2 08A8 0005 0028             		bclr	#5,oStatus(a0)			; Clear "pushing" flag
000033A8 117C 0001 0021             		move.b	#1,oPrevAni(a0)			; Reset the animation
000033AE 4E75                       		rts
000033B0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000033B0                            ; Set the objects's angle
000033B0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000033B0                            PlayerSetAngle:
000033B0 1428 002F                  		move.b	oTilt(a0),d2			; Get secondary angle
000033B4 B240                       		cmp.w	d0,d1				; Is the primary floor distance lower than the secondary?
000033B6 6F00                       		ble.s	.ChkSetAngle			; If not, branch
000033B8 1428 002E                  		move.b	oNextTilt(a0),d2		; Get primary angle
000033BC 3200                       		move.w	d0,d1				; Get primary floor distance
000033BE                            		
000033BE                            .ChkSetAngle:
000033BE 0802 0000                  		btst	#0,d2				; Is this an odd angle (usually $FF)?
000033C2 6600                       		bne.s	.LatchOnFlat			; If so, branch
000033C4 1002                       		move.b	d2,d0				; Get angle change
000033C6 9028 0000                  		sub.b	oAngle(a0),d0			; ''
000033CA 6A00                       		bpl.s	.ChkDist			; ''
000033CC 4400                       		neg.b	d0				; ''
000033CE                            
000033CE                            .ChkDist:
000033CE 0C00 0020                  		cmpi.b	#$20,d0				; Has the player moved $20 degrees or more?
000033D2 6400                       		bhs.s	.LatchOnFlat			; If so, branch
000033D4 1142 0000                  		move.b	d2,oAngle(a0)			; Set the new angle value
000033D8 4E75                       		rts
000033DA                            
000033DA                            .LatchOnFlat:
000033DA 1428 0000                  		move.b	oAngle(a0),d2			; Get old angle value
000033DE 0602 0020                  		addi.b	#$20,d2				; Shift the angle
000033E2 0202 00C0                  		andi.b	#$C0,d2				; Flatten the angle
000033E6 1142 0000                  		move.b	d2,oAngle(a0)			; Set the new angle value
000033EA 4E75                       		rts
000033EC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000033EC                            ; Move the object along the right wall
000033EC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000033EC                            PlayerMoveRWall:
000033EC                            		; Get the angle on the bottom right (rotated) sensor
000033EC 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
000033F0 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
000033F4 7000                       		moveq	#0,d0
000033F6 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
000033FA 4880                       		ext.w	d0				; ''
000033FC 9440                       		sub.w	d0,d2				; Add onto Y position
000033FE 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
00003402 4880                       		ext.w	d0				; ''
00003404 D640                       		add.w	d0,d3				; Add onto X position
00003406 49E8 002E                  		lea	oNextTilt(a0),a4		; Get primary angle
0000340A 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
0000340E 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
00003410 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
00003414                            		push.w	d1				; Save the primary floor distance
00003414 3F01                     M 	move.w	d1,-(sp)
00003416                            
00003416                            		; Get the angle on the bottom left (rotated) sensor
00003416 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
0000341A 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
0000341E 7000                       		moveq	#0,d0
00003420 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
00003424 4880                       		ext.w	d0				; ''
00003426 D440                       		add.w	d0,d2				; Add onto Y position
00003428 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
0000342C 4880                       		ext.w	d0				; ''
0000342E D640                       		add.w	d0,d3				; Add onto X position
00003430 49E8 002F                  		lea	oTilt(a0),a4			; Get secondary angle
00003434 367C 0010                  		movea.w	#$10,a3				; Height of bottom right sensor
00003438 4246                       		clr.w	d6				; Don't switch any flip bits for blocks
0000343A 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
0000343E                            		
0000343E                            		; Update the object's angle
0000343E                            		pop.w	d0				; Restore the primary floor distance
0000343E 301F                     M 	move.w	(sp)+,d0
00003440 6100 FF6E                  		bsr.w	PlayerSetAngle			; Set the new angle
00003444                            
00003444                            		; Check if the object has hit a wall or is about to fall
00003444 4A41                       		tst.w	d1				; Is we already perfectly standing on the surface?
00003446 6700                       		beq.s	.End				; If so, branch
00003448 6A00                       		bpl.s	.ChkFall			; If the there's possibly a floor below us, branch
0000344A 0C41 FFF2                  		cmpi.w	#-$E,d1				; Have we hit a wall?
0000344E 6D00                       		blt.s	.End				; If so, branch
00003450 D368 0014                  		add.w	d1,oXPos(a0)			; Move us on to the surface
00003454                            
00003454                            .End:
00003454 4E75                       		rts
00003456                            
00003456                            .ChkFall:
00003456 1028 001E                  		move.b	oYVel(a0),d0			; Get the integer part of the Y velocity
0000345A 6A00                       		bpl.s	.GetMinDist			; If it's already positive, branch
0000345C 4400                       		neg.b	d0				; Force it to be positive
0000345E                            
0000345E                            .GetMinDist:
0000345E 5800                       		addq.b	#4,d0				; The X distance must be at least 4 pixels down
00003460 0C00 000E                  		cmpi.b	#$E,d0				; ...but cannot be more than 14 pixels down
00003464 6500                       		blo.s	.ChkDist			; ...for us to not fall off the surface
00003466 103C 000E                  		move.b	#$E,d0				; ''
0000346A                            
0000346A                            .ChkDist:
0000346A B200                       		cmp.b	d0,d1				; Are we about to fall off?
0000346C 6E00                       		bgt.s	.SetAir				; If so, branch
0000346E D368 0014                  		add.w	d1,oXPos(a0)			; Move us on to the surface
00003472 4E75                       		rts
00003474                            
00003474                            .SetAir:
00003474 08E8 0001 0028             		bset	#1,oStatus(a0)			; Set "in air" flag
0000347A 08A8 0005 0028             		bclr	#5,oStatus(a0)			; Clear "pushing" flag
00003480 117C 0001 0021             		move.b	#1,oPrevAni(a0)			; Reset the animation
00003486 4E75                       		rts
00003488                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003488                            ; Move the object along the ceiling
00003488                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003488                            PlayerMoveCeiling:
00003488                            		; Get the angle on the bottom right (rotated) sensor
00003488 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
0000348C 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
00003490 7000                       		moveq	#0,d0
00003492 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
00003496 4880                       		ext.w	d0				; ''
00003498 9440                       		sub.w	d0,d2				; Subtract from the Y position
0000349A 0A42 000F                  		eori.w	#$F,d2				; Flip it
0000349E 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
000034A2 4880                       		ext.w	d0				; ''
000034A4 D640                       		add.w	d0,d3				; Add onto X position
000034A6 49E8 002E                  		lea	oNextTilt(a0),a4		; Get primary angle
000034AA 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
000034AE 3C3C 0800                  		move.w	#$800,d6			; Vertical flip
000034B2 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
000034B6                            		push.w	d1				; Save the primary floor distance
000034B6 3F01                     M 	move.w	d1,-(sp)
000034B8                            
000034B8                            		; Get the angle on the bottom left (rotated) sensor
000034B8 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
000034BC 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
000034C0 7000                       		moveq	#0,d0
000034C2 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
000034C6 4880                       		ext.w	d0				; ''
000034C8 9440                       		sub.w	d0,d2				; Subtract from the Y position
000034CA 0A42 000F                  		eori.w	#$F,d2				; Flip it
000034CE 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
000034D2 4880                       		ext.w	d0				; ''
000034D4 9640                       		sub.w	d0,d3				; Subtract from the X position
000034D6 49E8 002F                  		lea	oTilt(a0),a4			; Get secondary angle
000034DA 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
000034DE 3C3C 0800                  		move.w	#$800,d6			; Vertical flip
000034E2 6100 0000                  		bsr.w	Level_FindFloor			; Find the floor
000034E6                            		
000034E6                            		; Update the object's angle
000034E6                            		pop.w	d0				; Restore the primary floor distance
000034E6 301F                     M 	move.w	(sp)+,d0
000034E8 6100 FEC6                  		bsr.w	PlayerSetAngle			; Set the new angle
000034EC                            		
000034EC                            		; Check if the object has hit a wall or is about to fall
000034EC 4A41                       		tst.w	d1				; Is we already perfectly standing on the surface?
000034EE 6700                       		beq.s	.End				; If so, branch
000034F0 6A00                       		bpl.s	.ChkFall			; If the there's possibly a floor below us, branch
000034F2 0C41 FFF2                  		cmpi.w	#-$E,d1				; Have we hit a wall?
000034F6 6D00                       		blt.s	.End				; If so, branch
000034F8 9368 0018                  		sub.w	d1,oYPos(a0)			; Move us on to the surface
000034FC                            
000034FC                            .End:
000034FC 4E75                       		rts
000034FE                            
000034FE                            .ChkFall:
000034FE 1028 001C                  		move.b	oXVel(a0),d0			; Get the integer part of the X velocity
00003502 6A00                       		bpl.s	.GetMinDist			; If it's already positive, branch
00003504 4400                       		neg.b	d0				; Force it to be positive
00003506                            
00003506                            .GetMinDist:
00003506 5800                       		addq.b	#4,d0				; The Y distance must be at least 4 pixels down
00003508 0C00 000E                  		cmpi.b	#$E,d0				; ...but cannot be more than 14 pixels down
0000350C 6500                       		blo.s	.ChkDist			; ...for us to not fall off the surface
0000350E 103C 000E                  		move.b	#$E,d0				; ''
00003512                            
00003512                            .ChkDist:
00003512 B200                       		cmp.b	d0,d1				; Are we about to fall off?
00003514 6E00                       		bgt.s	.SetAir				; If so, branch
00003516 9368 0018                  		sub.w	d1,oYPos(a0)			; Move us on to the surface
0000351A 4E75                       		rts
0000351C                            
0000351C                            .SetAir:
0000351C 08E8 0001 0028             		bset	#1,oStatus(a0)			; Set "in air" flag
00003522 08A8 0005 0028             		bclr	#5,oStatus(a0)			; Clear "pushing" flag
00003528 117C 0001 0021             		move.b	#1,oPrevAni(a0)			; Reset the animation
0000352E 4E75                       		rts
00003530                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003530                            ; Move the object along the left wall
00003530                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003530                            PlayerMoveLWall:
00003530                            		; Get the angle on the bottom right (rotated) sensor
00003530 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00003534 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
00003538 7000                       		moveq	#0,d0
0000353A 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
0000353E 4880                       		ext.w	d0				; ''
00003540 9440                       		sub.w	d0,d2				; Subtract from the Y position
00003542 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
00003546 4880                       		ext.w	d0				; ''
00003548 9640                       		sub.w	d0,d3				; Subtract from X position
0000354A 0A43 000F                  		eori.w	#$F,d3				; Flip it
0000354E 49E8 002E                  		lea	oNextTilt(a0),a4		; Get primary angle
00003552 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
00003556 3C3C 0400                  		move.w	#$400,d6			; Horizontal flip
0000355A 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
0000355E                            		push.w	d1				; Save the primary floor distance
0000355E 3F01                     M 	move.w	d1,-(sp)
00003560                            
00003560                            		; Get the angle on the bottom left (rotated) sensor
00003560 3428 0018                  		move.w	oYPos(a0),d2			; Get Y position
00003564 3628 0014                  		move.w	oXPos(a0),d3			; Get X position
00003568 7000                       		moveq	#0,d0
0000356A 1028 002C                  		move.b	oColW(a0),d0			; Get collision width
0000356E 4880                       		ext.w	d0				; ''
00003570 D440                       		add.w	d0,d2				; Add onto Y position
00003572 1028 002D                  		move.b	oColH(a0),d0			; Get collision height
00003576 4880                       		ext.w	d0				; ''
00003578 9640                       		sub.w	d0,d3				; Subtract from X position
0000357A 0A43 000F                  		eori.w	#$F,d3				; Flip it
0000357E 49E8 002F                  		lea	oTilt(a0),a4			; Get secondary angle
00003582 367C FFF0                  		movea.w	#-$10,a3			; Height of bottom right sensor
00003586 3C3C 0400                  		move.w	#$400,d6			; Horizontal flip
0000358A 6100 0000                  		bsr.w	Level_FindWall			; Find the wall
0000358E                            		
0000358E                            		; Update the object's angle
0000358E                            		pop.w	d0				; Restore the primary floor distance
0000358E 301F                     M 	move.w	(sp)+,d0
00003590 6100 FE1E                  		bsr.w	PlayerSetAngle			; Set the new angle
00003594                            		
00003594                            		; Check if the object has hit a wall or is about to fall
00003594 4A41                       		tst.w	d1				; Is we already perfectly standing on the surface?
00003596 6700                       		beq.s	.End				; If so, branch
00003598 6A00                       		bpl.s	.ChkFall			; If the there's possibly a floor below us, branch
0000359A 0C41 FFF2                  		cmpi.w	#-$E,d1				; Have we hit a wall?
0000359E 6D00                       		blt.s	.End				; If so, branch
000035A0 9368 0014                  		sub.w	d1,oXPos(a0)			; Move us on to the surface
000035A4                            
000035A4                            .End:
000035A4 4E75                       		rts
000035A6                            
000035A6                            .ChkFall:
000035A6 1028 001E                  		move.b	oYVel(a0),d0			; Get the integer part of the Y velocity
000035AA 6A00                       		bpl.s	.GetMinDist			; If it's already positive, branch
000035AC 4400                       		neg.b	d0				; Force it to be positive
000035AE                            
000035AE                            .GetMinDist:
000035AE 5800                       		addq.b	#4,d0				; The X distance must be at least 4 pixels down
000035B0 0C00 000E                  		cmpi.b	#$E,d0				; ...but cannot be more than 14 pixels down
000035B4 6500                       		blo.s	.ChkDist			; ...for us to not fall off the surface
000035B6 103C 000E                  		move.b	#$E,d0				; ''
000035BA                            
000035BA                            .ChkDist:
000035BA B200                       		cmp.b	d0,d1				; Are we about to fall off?
000035BC 6E00                       		bgt.s	.SetAir				; If so, branch
000035BE 9368 0014                  		sub.w	d1,oXPos(a0)			; Move us on to the surface
000035C2 4E75                       		rts
000035C4                            
000035C4                            .SetAir:
000035C4 08E8 0001 0028             		bset	#1,oStatus(a0)			; Set "in air" flag
000035CA 08A8 0005 0028             		bclr	#5,oStatus(a0)			; Clear "pushing" flag
000035D0 117C 0001 0021             		move.b	#1,oPrevAni(a0)			; Reset the animation
000035D6 4E75                       		rts
000035D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000035D8                            ; Find the nearest floor from the object's position
000035D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000035D8                            ; PARAMETERS:
000035D8                            ;	d2.w	- Y position of the object's bottom sensor
000035D8                            ;	d3.w	- X position of the object's bottom sensor
000035D8                            ;	d5.w	- Bit to chect for solidity
000035D8                            ;	d6.w	- Flip bits (for walls and ceilings)
000035D8                            ;	a3.w	- Distance in pixels to check for blocks above or below the sensor
000035D8                            ;	a4.w	- Pointer to where the angle value will be stored
000035D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000035D8                            ; RETURNS:
000035D8                            ;	d1.w	- The distance from the object to the floor
000035D8                            ;	(a1).w	- The block ID in the chunk where the object is standing
000035D8                            ;	(a4).w	- The floor angle
000035D8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000035D8                            Level_FindFloor:
000035D8 6100 0000                  		bsr.w	Level_FindBlock			; Find the nearest tile
000035DC 3011                       		move.w	(a1),d0				; Get block ID
000035DE 3800                       		move.w	d0,d4				; Copy that
000035E0 0240 03FF                  		andi.w	#$3FF,d0			; Get only the block ID
000035E4 6700                       		beq.s	.IsBlank			; If it's blank, branch
000035E6 0B04                       		btst	d5,d4				; Is the block solid?
000035E8 6600                       		bne.s	.IsSolid			; If so, branch
000035EA                            
000035EA                            .IsBlank:
000035EA D44B                       		add.w	a3,d2				; Check below the sensor
000035EC 6100 0000                  		bsr.w	Level_FindFloor2		; Try to find a solid block there
000035F0 944B                       		sub.w	a3,d2				; Restore Y position of sensor
000035F2 0641 0010                  		addi.w	#$10,d1				; Return distance to floor
000035F6 4E75                       		rts
000035F8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000035F8                            .IsSolid:
000035F8 2478 F8E0                  		movea.l	rColAddr.w,a2			; Get collision data pointer
000035FC D040                       		add.w	d0,d0				; Turn ID into offset
000035FE 1032 0000                  		move.b	(a2,d0.w),d0			; Get collision block ID
00003602 0240 00FF                  		andi.w	#$FF,d0				; ''
00003606 67E2                       		beq.s	.IsBlank			; If the angle is 0, branch
00003608                            
00003608 2478 F8E6                  		movea.l	rAngleVals.w,a2		; Angle value array
0000360C 18B2 0000                  		move.b	(a2,d0.w),(a4)			; Get angle value and store it
00003610 E948                       		lsl.w	#4,d0				; Turn collision block ID into offset
00003612                            
00003612 3203                       		move.w	d3,d1				; Get the object's X position
00003614 0804 000A                  		btst	#$A,d4				; Is the block flipped horizontally?
00003618 6700                       		beq.s	.NoXFlip			; If not, branch
0000361A 4641                       		not.w	d1				; Flip the X position
0000361C 4414                       		neg.b	(a4)				; Flip the angle
0000361E                            		
0000361E                            .NoXFlip:
0000361E 0804 000B                  		btst	#$B,d4				; Is the block vertically flipped?
00003622 6700                       		beq.s	.NoYFlip			; If not, branch
00003624 0614 0040                  		addi.b	#$40,(a4)			; Flip the angle
00003628 4414                       		neg.b	(a4)				; ''
0000362A 0414 0040                  		subi.b	#$40,(a4)			; ''
0000362E                            
0000362E                            .NoYFlip:
0000362E 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the collsion block
00003632 D240                       		add.w	d0,d1				; Add the collision block's offset
00003634                            
00003634 2478 F8EA                  		movea.l	rColArrayN.w,a2		; Get the normal collision array
00003638 1032 1000                  		move.b	(a2,d1.w),d0			; Get height value
0000363C 4880                       		ext.w	d0				; ''
0000363E BD44                       		eor.w	d6,d4				; Flip the flip bits from the block
00003640 0804 000B                  		btst	#$B,d4				; Is the block vertically flipped?
00003644 6700                       		beq.s	.NoYFlip2			; If not, branch
00003646 4440                       		neg.w	d0				; Flip the height
00003648                            
00003648                            .NoYFlip2:
00003648 4A40                       		tst.w	d0				; Check the height
0000364A 679E                       		beq.s	.IsBlank			; If the height is 0, branch
0000364C 6B00                       		bmi.s	.NegHeight			; If the height is negative, branch
0000364E 0C00 0010                  		cmpi.b	#$10,d0				; Is the height 16 (the max height)?
00003652 6700                       		beq.s	.MaxFloor			; If so, branch
00003654 3202                       		move.w	d2,d1				; Get the object's Y position
00003656 0241 000F                  		andi.w	#$F,d1				; Get the Y offset in the height
0000365A D041                       		add.w	d1,d0				; Add onto the height
0000365C 323C 000F                  		move.w	#$F,d1				; Get actual distance
00003660 9240                       		sub.w	d0,d1				; ''
00003662 4E75                       		rts
00003664                            
00003664                            .NegHeight:
00003664 3202                       		move.w	d2,d1				; Get the object's Y position
00003666 0241 000F                  		andi.w	#$F,d1				; Get the Y offset in the height
0000366A D041                       		add.w	d1,d0				; Add onto the height
0000366C 6A00 FF7C                  		bpl.w	.IsBlank			; If the object is outside of the collision, branch
00003670                            
00003670                            .MaxFloor:
00003670 944B                       		sub.w	a3,d2				; Check above the sensor
00003672 6100                       		bsr.s	Level_FindFloor2		; Try to find a solid block there
00003674 D44B                       		add.w	a3,d2				; Restore Y position of sensor
00003676 0441 0010                  		subi.w	#$10,d1				; Return distance to floor
0000367A 4E75                       		rts
0000367C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000367C                            Level_FindFloor2:
0000367C 6100 0000                  		bsr.w	Level_FindBlock			; Find the nearest tile
00003680 3011                       		move.w	(a1),d0				; Get block ID
00003682 3800                       		move.w	d0,d4				; Copy that
00003684 0240 03FF                  		andi.w	#$3FF,d0			; Get only the block ID
00003688 6700                       		beq.s	.IsBlank			; If it's blank, branch
0000368A 0B04                       		btst	d5,d4				; Is the block solid?
0000368C 6600                       		bne.s	.IsSolid			; If so, branch
0000368E                            
0000368E                            .IsBlank:
0000368E 323C 000F                  		move.w	#$F,d1				; Get max distance
00003692 3002                       		move.w	d2,d0				; Get the object's Y position
00003694 0240 000F                  		andi.w	#$F,d0				; Get the Y offset in the height
00003698 9240                       		sub.w	d0,d1				; Get actual distance
0000369A 4E75                       		rts
0000369C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000369C                            .IsSolid:
0000369C 2478 F8E0                  		movea.l	rColAddr.w,a2			; Get collision data pointer
000036A0 D040                       		add.w	d0,d0				; Turn ID into offset
000036A2 1032 0000                  		move.b	(a2,d0.w),d0			; Get collision block ID
000036A6 0240 00FF                  		andi.w	#$FF,d0				; ''
000036AA 67E2                       		beq.s	.IsBlank			; If the angle is 0, branch
000036AC                            
000036AC 2478 F8E6                  		movea.l	rAngleVals.w,a2		; Angle value array
000036B0 18B2 0000                  		move.b	(a2,d0.w),(a4)			; Get angle value and store it
000036B4 E948                       		lsl.w	#4,d0				; Turn collision block ID into offset
000036B6                            
000036B6 3203                       		move.w	d3,d1				; Get the object's X position
000036B8 0804 000A                  		btst	#$A,d4				; Is the block flipped horizontally?
000036BC 6700                       		beq.s	.NoXFlip			; If not, branch
000036BE 4641                       		not.w	d1				; Flip the X position
000036C0 4414                       		neg.b	(a4)				; Flip the angle
000036C2                            
000036C2                            .NoXFlip:
000036C2 0804 000B                  		btst	#$B,d4				; Is the block vertically flipped?
000036C6 6700                       		beq.s	.NoYFlip			; If not, branch
000036C8 0614 0040                  		addi.b	#$40,(a4)			; Flip the angle
000036CC 4414                       		neg.b	(a4)				; ''
000036CE 0414 0040                  		subi.b	#$40,(a4)			; ''
000036D2                            
000036D2                            .NoYFlip:
000036D2 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the collsion block
000036D6 D240                       		add.w	d0,d1				; Add the collision block's offset
000036D8                            
000036D8 2478 F8EA                  		movea.l	rColArrayN.w,a2		; Get the normal collision array
000036DC 1032 1000                  		move.b	(a2,d1.w),d0			; Get height value
000036E0 4880                       		ext.w	d0				; ''
000036E2 BD44                       		eor.w	d6,d4				; Flip the flip bits from the block
000036E4 0804 000B                  		btst	#$B,d4				; Is the block vertically flipped?
000036E8 6700                       		beq.s	.NoYFlip2			; If not, branch
000036EA 4440                       		neg.w	d0				; Flip the height
000036EC                            
000036EC                            .NoYFlip2:
000036EC 4A40                       		tst.w	d0				; Check the height
000036EE 679E                       		beq.s	.IsBlank			; If the height is 0, branch
000036F0 6B00                       		bmi.s	.NegHeight			; If the height is negative, branch
000036F2 3202                       		move.w	d2,d1				; Get the object's Y position
000036F4 0241 000F                  		andi.w	#$F,d1				; Get the Y offset in the height
000036F8 D041                       		add.w	d1,d0				; Add onto the height
000036FA 323C 000F                  		move.w	#$F,d1				; Get actual distance
000036FE 9240                       		sub.w	d0,d1				; ''
00003700 4E75                       		rts
00003702                            
00003702                            .NegHeight:
00003702 3202                       		move.w	d2,d1				; Get the object's Y position
00003704 0241 000F                  		andi.w	#$F,d1				; Get the Y offset in the height
00003708 D041                       		add.w	d1,d0				; Add onto the height
0000370A 6A00 FF82                  		bpl.w	.IsBlank			; If the object is outside of the collision, branch
0000370E 4641                       		not.w	d1				; Flip the height
00003710 4E75                       		rts
00003712                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003712                            ; Find the nearest wall from the object's position
00003712                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003712                            ; PARAMETERS:
00003712                            ;	d2.w	- Y position of the object's bottom sensor
00003712                            ;	d3.w	- X position of the object's bottom sensor
00003712                            ;	d5.w	- Bit to chect for solidity
00003712                            ;	d6.w	- Flip bits (for walls and ceilings)
00003712                            ;	a3.w	- Distance in pixels to check for blocks left of or right of the sensor
00003712                            ;	a4.w	- Pointer to where the angle value will be stored
00003712                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003712                            ; RETURNS:
00003712                            ;	d1.w	- The distance from the object to the floor
00003712                            ;	(a1).w	- The block ID in the chunk where the object is standing
00003712                            ;	(a4).w	- The floor angle
00003712                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003712                            Level_FindWall:
00003712 6100 0000                  		bsr.w	Level_FindBlock			; Find the nearest tile
00003716 3011                       		move.w	(a1),d0				; Get block ID
00003718 3800                       		move.w	d0,d4				; Copy that
0000371A 0240 03FF                  		andi.w	#$3FF,d0			; Get only the block ID
0000371E 6700                       		beq.s	.IsBlank			; If it's blank, branch
00003720 0B04                       		btst	d5,d4				; Is the block solid?
00003722 6600                       		bne.s	.IsSolid			; If so, branch
00003724                            
00003724                            .IsBlank:
00003724 D64B                       		add.w	a3,d3				; Check right to the sensor
00003726 6100 0000                  		bsr.w	Level_FindWall2			; Try to find a solid block there
0000372A 964B                       		sub.w	a3,d3				; Restore X position of sensor
0000372C 0641 0010                  		addi.w	#$10,d1				; Return distance to floor
00003730 4E75                       		rts
00003732                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003732                            .IsSolid:
00003732 2478 F8E0                  		movea.l	rColAddr.w,a2			; Get collision data pointer
00003736 D040                       		add.w	d0,d0				; Turn ID into offset
00003738 1032 0000                  		move.b	(a2,d0.w),d0			; Get collision block ID
0000373C 0240 00FF                  		andi.w	#$FF,d0				; ''
00003740 67E2                       		beq.s	.IsBlank			; If the angle is 0, branch
00003742                            
00003742 2478 F8E6                  		movea.l	rAngleVals.w,a2		; Angle value array
00003746 18B2 0000                  		move.b	(a2,d0.w),(a4)			; Get angle value and store it
0000374A E948                       		lsl.w	#4,d0				; Turn collision block ID into offset
0000374C                            
0000374C 3202                       		move.w	d2,d1				; Get the object's Y position
0000374E 0804 000B                  		btst	#$B,d4				; Is the block vertically flipped?
00003752 6700                       		beq.s	.NoYFlip			; If not, branch
00003754 4641                       		not.w	d1				; Flip the Y position
00003756 0614 0040                  		addi.b	#$40,(a4)			; Flip the angle
0000375A 4414                       		neg.b	(a4)				; ''
0000375C 0414 0040                  		subi.b	#$40,(a4)			; ''
00003760                            
00003760                            .NoYFlip:
00003760 0804 000A                  		btst	#$A,d4				; Is the block flipped horizontally?
00003764 6700                       		beq.s	.NoXFlip			; If not, branch
00003766 4414                       		neg.b	(a4)				; Flip the angle
00003768                            
00003768                            .NoXFlip:
00003768 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the collsion block
0000376C D240                       		add.w	d0,d1				; Add the collision block's offset
0000376E                            
0000376E 2478 F8EE                  		movea.l	rColArrayR.w,a2		; Get the normal collision array
00003772 1032 1000                  		move.b	(a2,d1.w),d0			; Get height value
00003776 4880                       		ext.w	d0				; ''
00003778 BD44                       		eor.w	d6,d4				; Flip the flip bits from the block
0000377A 0804 000A                  		btst	#$A,d4				; Is the block horizontally flipped?
0000377E 6700                       		beq.s	.NoYFlip2			; If not, branch
00003780 4440                       		neg.w	d0				; Flip the height
00003782                            
00003782                            .NoYFlip2:
00003782 4A40                       		tst.w	d0				; Check the height
00003784 679E                       		beq.s	.IsBlank			; If the height is 0, branch
00003786 6B00                       		bmi.s	.NegHeight			; If the height is negative, branch
00003788 0C00 0010                  		cmpi.b	#$10,d0				; Is the height 16 (the max height)?
0000378C 6700                       		beq.s	.MaxFloor			; If so, branch
0000378E 3203                       		move.w	d3,d1				; Get the object's X position
00003790 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the height
00003794 D041                       		add.w	d1,d0				; Add onto the height
00003796 323C 000F                  		move.w	#$F,d1				; Get actual distance
0000379A 9240                       		sub.w	d0,d1				; ''
0000379C 4E75                       		rts
0000379E                            
0000379E                            .NegHeight:
0000379E 3203                       		move.w	d3,d1				; Get the object's X position
000037A0 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the height
000037A4 D041                       		add.w	d1,d0				; Add onto the height
000037A6 6A00 FF7C                  		bpl.w	.IsBlank			; If the object is outside of the collision, branch
000037AA                            
000037AA                            .MaxFloor:
000037AA 964B                       		sub.w	a3,d3				; Check left to the sensor
000037AC 6100                       		bsr.s	Level_FindWall2			; Try to find a solid block there
000037AE D64B                       		add.w	a3,d3				; Restore X position of sensor
000037B0 0441 0010                  		subi.w	#$10,d1				; Return distance to floor
000037B4 4E75                       		rts
000037B6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000037B6                            Level_FindWall2:
000037B6 6100 0000                  		bsr.w	Level_FindBlock			; Find the nearest tile
000037BA 3011                       		move.w	(a1),d0				; Get block ID
000037BC 3800                       		move.w	d0,d4				; Copy that
000037BE 0240 03FF                  		andi.w	#$3FF,d0			; Get only the block ID
000037C2 6700                       		beq.s	.IsBlank			; If it's blank, branch
000037C4 0B04                       		btst	d5,d4				; Is the block solid?
000037C6 6600                       		bne.s	.IsSolid			; If so, branch
000037C8                            
000037C8                            .IsBlank:
000037C8 323C 000F                  		move.w	#$F,d1				; Get max distance
000037CC 3003                       		move.w	d3,d0				; Get the object's X position
000037CE 0240 000F                  		andi.w	#$F,d0				; Get the X offset in the height
000037D2 9240                       		sub.w	d0,d1				; Get actual distance
000037D4 4E75                       		rts
000037D6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000037D6                            .IsSolid:
000037D6 2478 F8E0                  		movea.l	rColAddr.w,a2			; Get collision data pointer
000037DA D040                       		add.w	d0,d0				; Turn ID into offset
000037DC 1032 0000                  		move.b	(a2,d0.w),d0			; Get collision block ID
000037E0 0240 00FF                  		andi.w	#$FF,d0				; ''
000037E4 67E2                       		beq.s	.IsBlank			; If the angle is 0, branch
000037E6                            
000037E6 2478 F8E6                  		movea.l	rAngleVals.w,a2		; Angle value array
000037EA 18B2 0000                  		move.b	(a2,d0.w),(a4)			; Get angle value and store it
000037EE E948                       		lsl.w	#4,d0				; Turn collision block ID into offset
000037F0                            
000037F0 3202                       		move.w	d2,d1				; Get the object's Y position
000037F2 0804 000B                  		btst	#$B,d4				; Is the block vertically flipped?
000037F6 6700                       		beq.s	.NoYFlip			; If not, branch
000037F8 4641                       		not.w	d1				; Flip the Y position
000037FA 0614 0040                  		addi.b	#$40,(a4)			; Flip the angle
000037FE 4414                       		neg.b	(a4)				; ''
00003800 0414 0040                  		subi.b	#$40,(a4)			; ''
00003804                            
00003804                            .NoYFlip:
00003804 0804 000A                  		btst	#$A,d4				; Is the block flipped horizontally?
00003808 6700                       		beq.s	.NoXFlip			; If not, branch
0000380A 4414                       		neg.b	(a4)				; Flip the angle
0000380C                            
0000380C                            .NoXFlip:
0000380C 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the collsion block
00003810 D240                       		add.w	d0,d1				; Add the collision block's offset
00003812                            
00003812 2478 F8EE                  		movea.l	rColArrayR.w,a2		; Get the normal collision array
00003816 1032 1000                  		move.b	(a2,d1.w),d0			; Get height value
0000381A 4880                       		ext.w	d0				; ''
0000381C BD44                       		eor.w	d6,d4				; Flip the flip bits from the block
0000381E 0804 000A                  		btst	#$A,d4				; Is the block horizontally flipped?
00003822 6700                       		beq.s	.NoYFlip2			; If not, branch
00003824 4440                       		neg.w	d0				; Flip the height
00003826                            
00003826                            .NoYFlip2:
00003826 4A40                       		tst.w	d0				; Check the height
00003828 679E                       		beq.s	.IsBlank			; If the height is 0, branch
0000382A 6B00                       		bmi.s	.NegHeight			; If the height is negative, branch
0000382C 3203                       		move.w	d3,d1				; Get the object's X position
0000382E 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the height
00003832 D041                       		add.w	d1,d0				; Add onto the height
00003834 323C 000F                  		move.w	#$F,d1				; Get actual distance
00003838 9240                       		sub.w	d0,d1				; ''
0000383A 4E75                       		rts
0000383C                            
0000383C                            .NegHeight:
0000383C 3203                       		move.w	d3,d1				; Get the object's X position
0000383E 0241 000F                  		andi.w	#$F,d1				; Get the X offset in the height
00003842 D041                       		add.w	d1,d0				; Add onto the height
00003844 6A00 FF82                  		bpl.w	.IsBlank			; If the object is outside of the collision, branch
00003848 4641                       		not.w	d1				; Flip the height
0000384A 4E75                       		rts
0000384C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000384C                            ; Find the nearest block in the level from the player
0000384C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000384C                            ; PARAMETERS:
0000384C                            ;	d2.w	- Y position of the object's sensor
0000384C                            ;	d3.w	- X position of the object's sensor
0000384C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000384C                            ; RETURNS:
0000384C                            ;	(a1).w	- The block ID in the chunk where the object is standing
0000384C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000384C                            Level_FindBlock:
0000384C 3002                       		move.w	d2,d0				; Get the object's Y position
0000384E D040                       		add.w	d0,d0				; Double it
00003850 0240 0F00                  		andi.w	#$F00,d0			; Get chunk row offset
00003854 3203                       		move.w	d3,d1				; Get the object's X position
00003856 E649                       		lsr.w	#3,d1				; Divide by 8
00003858 3801                       		move.w	d1,d4				; Save for later
0000385A E849                       		lsr.w	#4,d1				; Divide by 16 to get the offset of the chunk in the chunk row
0000385C 0241 007F                  		andi.w	#$7F,d1				; Only 128 chunks per row
00003860 D041                       		add.w	d1,d0				; Get offset in the level layout
00003862 72FF                       		moveq	#-1,d1				; Prepare the chunk table pointer
00003864 4241                       		clr.w	d1				; ''
00003866 43F8 DFD0                  		lea	rLayout.w,a1			; Get layout pointer
0000386A 1231 0000                  		move.b	(a1,d0.w),d1			; Get chunk ID
0000386E D241                       		add.w	d1,d1				; Turn into offset
00003870 323B 1000                  		move.w	.ChunkOffsets(pc,d1.w),d1	; Get offset in chunk table
00003874 3002                       		move.w	d2,d0				; Get the object's Y position
00003876 0240 0070                  		andi.w	#$70,d0				; Get Y position within chunk
0000387A D240                       		add.w	d0,d1				; Add onto the offset
0000387C 0244 000E                  		andi.w	#$E,d4				; Get the previously saved X position divided by 8 (for the row offset)
00003880 D244                       		add.w	d4,d1				; Add onto the offset
00003882 2241                       		movea.l	d1,a1				; Get pointer in chunk table
00003884 4E75                       		rts
00003886                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003886                            .ChunkOffsets:
00003886 =00000000                  c		= 0
00003886                            		rept	256
00003886                            			dc.w	c
00003886                            c			= c+$80
00003886                            		endr
00003886 0000                     M 	dc.w	c
00003888 =00000080                M c	=	c+$80
00003888 0080                     M 	dc.w	c
0000388A =00000100                M c	=	c+$80
0000388A 0100                     M 	dc.w	c
0000388C =00000180                M c	=	c+$80
0000388C 0180                     M 	dc.w	c
0000388E =00000200                M c	=	c+$80
0000388E 0200                     M 	dc.w	c
00003890 =00000280                M c	=	c+$80
00003890 0280                     M 	dc.w	c
00003892 =00000300                M c	=	c+$80
00003892 0300                     M 	dc.w	c
00003894 =00000380                M c	=	c+$80
00003894 0380                     M 	dc.w	c
00003896 =00000400                M c	=	c+$80
00003896 0400                     M 	dc.w	c
00003898 =00000480                M c	=	c+$80
00003898 0480                     M 	dc.w	c
0000389A =00000500                M c	=	c+$80
0000389A 0500                     M 	dc.w	c
0000389C =00000580                M c	=	c+$80
0000389C 0580                     M 	dc.w	c
0000389E =00000600                M c	=	c+$80
0000389E 0600                     M 	dc.w	c
000038A0 =00000680                M c	=	c+$80
000038A0 0680                     M 	dc.w	c
000038A2 =00000700                M c	=	c+$80
000038A2 0700                     M 	dc.w	c
000038A4 =00000780                M c	=	c+$80
000038A4 0780                     M 	dc.w	c
000038A6 =00000800                M c	=	c+$80
000038A6 0800                     M 	dc.w	c
000038A8 =00000880                M c	=	c+$80
000038A8 0880                     M 	dc.w	c
000038AA =00000900                M c	=	c+$80
000038AA 0900                     M 	dc.w	c
000038AC =00000980                M c	=	c+$80
000038AC 0980                     M 	dc.w	c
000038AE =00000A00                M c	=	c+$80
000038AE 0A00                     M 	dc.w	c
000038B0 =00000A80                M c	=	c+$80
000038B0 0A80                     M 	dc.w	c
000038B2 =00000B00                M c	=	c+$80
000038B2 0B00                     M 	dc.w	c
000038B4 =00000B80                M c	=	c+$80
000038B4 0B80                     M 	dc.w	c
000038B6 =00000C00                M c	=	c+$80
000038B6 0C00                     M 	dc.w	c
000038B8 =00000C80                M c	=	c+$80
000038B8 0C80                     M 	dc.w	c
000038BA =00000D00                M c	=	c+$80
000038BA 0D00                     M 	dc.w	c
000038BC =00000D80                M c	=	c+$80
000038BC 0D80                     M 	dc.w	c
000038BE =00000E00                M c	=	c+$80
000038BE 0E00                     M 	dc.w	c
000038C0 =00000E80                M c	=	c+$80
000038C0 0E80                     M 	dc.w	c
000038C2 =00000F00                M c	=	c+$80
000038C2 0F00                     M 	dc.w	c
000038C4 =00000F80                M c	=	c+$80
000038C4 0F80                     M 	dc.w	c
000038C6 =00001000                M c	=	c+$80
000038C6 1000                     M 	dc.w	c
000038C8 =00001080                M c	=	c+$80
000038C8 1080                     M 	dc.w	c
000038CA =00001100                M c	=	c+$80
000038CA 1100                     M 	dc.w	c
000038CC =00001180                M c	=	c+$80
000038CC 1180                     M 	dc.w	c
000038CE =00001200                M c	=	c+$80
000038CE 1200                     M 	dc.w	c
000038D0 =00001280                M c	=	c+$80
000038D0 1280                     M 	dc.w	c
000038D2 =00001300                M c	=	c+$80
000038D2 1300                     M 	dc.w	c
000038D4 =00001380                M c	=	c+$80
000038D4 1380                     M 	dc.w	c
000038D6 =00001400                M c	=	c+$80
000038D6 1400                     M 	dc.w	c
000038D8 =00001480                M c	=	c+$80
000038D8 1480                     M 	dc.w	c
000038DA =00001500                M c	=	c+$80
000038DA 1500                     M 	dc.w	c
000038DC =00001580                M c	=	c+$80
000038DC 1580                     M 	dc.w	c
000038DE =00001600                M c	=	c+$80
000038DE 1600                     M 	dc.w	c
000038E0 =00001680                M c	=	c+$80
000038E0 1680                     M 	dc.w	c
000038E2 =00001700                M c	=	c+$80
000038E2 1700                     M 	dc.w	c
000038E4 =00001780                M c	=	c+$80
000038E4 1780                     M 	dc.w	c
000038E6 =00001800                M c	=	c+$80
000038E6 1800                     M 	dc.w	c
000038E8 =00001880                M c	=	c+$80
000038E8 1880                     M 	dc.w	c
000038EA =00001900                M c	=	c+$80
000038EA 1900                     M 	dc.w	c
000038EC =00001980                M c	=	c+$80
000038EC 1980                     M 	dc.w	c
000038EE =00001A00                M c	=	c+$80
000038EE 1A00                     M 	dc.w	c
000038F0 =00001A80                M c	=	c+$80
000038F0 1A80                     M 	dc.w	c
000038F2 =00001B00                M c	=	c+$80
000038F2 1B00                     M 	dc.w	c
000038F4 =00001B80                M c	=	c+$80
000038F4 1B80                     M 	dc.w	c
000038F6 =00001C00                M c	=	c+$80
000038F6 1C00                     M 	dc.w	c
000038F8 =00001C80                M c	=	c+$80
000038F8 1C80                     M 	dc.w	c
000038FA =00001D00                M c	=	c+$80
000038FA 1D00                     M 	dc.w	c
000038FC =00001D80                M c	=	c+$80
000038FC 1D80                     M 	dc.w	c
000038FE =00001E00                M c	=	c+$80
000038FE 1E00                     M 	dc.w	c
00003900 =00001E80                M c	=	c+$80
00003900 1E80                     M 	dc.w	c
00003902 =00001F00                M c	=	c+$80
00003902 1F00                     M 	dc.w	c
00003904 =00001F80                M c	=	c+$80
00003904 1F80                     M 	dc.w	c
00003906 =00002000                M c	=	c+$80
00003906 2000                     M 	dc.w	c
00003908 =00002080                M c	=	c+$80
00003908 2080                     M 	dc.w	c
0000390A =00002100                M c	=	c+$80
0000390A 2100                     M 	dc.w	c
0000390C =00002180                M c	=	c+$80
0000390C 2180                     M 	dc.w	c
0000390E =00002200                M c	=	c+$80
0000390E 2200                     M 	dc.w	c
00003910 =00002280                M c	=	c+$80
00003910 2280                     M 	dc.w	c
00003912 =00002300                M c	=	c+$80
00003912 2300                     M 	dc.w	c
00003914 =00002380                M c	=	c+$80
00003914 2380                     M 	dc.w	c
00003916 =00002400                M c	=	c+$80
00003916 2400                     M 	dc.w	c
00003918 =00002480                M c	=	c+$80
00003918 2480                     M 	dc.w	c
0000391A =00002500                M c	=	c+$80
0000391A 2500                     M 	dc.w	c
0000391C =00002580                M c	=	c+$80
0000391C 2580                     M 	dc.w	c
0000391E =00002600                M c	=	c+$80
0000391E 2600                     M 	dc.w	c
00003920 =00002680                M c	=	c+$80
00003920 2680                     M 	dc.w	c
00003922 =00002700                M c	=	c+$80
00003922 2700                     M 	dc.w	c
00003924 =00002780                M c	=	c+$80
00003924 2780                     M 	dc.w	c
00003926 =00002800                M c	=	c+$80
00003926 2800                     M 	dc.w	c
00003928 =00002880                M c	=	c+$80
00003928 2880                     M 	dc.w	c
0000392A =00002900                M c	=	c+$80
0000392A 2900                     M 	dc.w	c
0000392C =00002980                M c	=	c+$80
0000392C 2980                     M 	dc.w	c
0000392E =00002A00                M c	=	c+$80
0000392E 2A00                     M 	dc.w	c
00003930 =00002A80                M c	=	c+$80
00003930 2A80                     M 	dc.w	c
00003932 =00002B00                M c	=	c+$80
00003932 2B00                     M 	dc.w	c
00003934 =00002B80                M c	=	c+$80
00003934 2B80                     M 	dc.w	c
00003936 =00002C00                M c	=	c+$80
00003936 2C00                     M 	dc.w	c
00003938 =00002C80                M c	=	c+$80
00003938 2C80                     M 	dc.w	c
0000393A =00002D00                M c	=	c+$80
0000393A 2D00                     M 	dc.w	c
0000393C =00002D80                M c	=	c+$80
0000393C 2D80                     M 	dc.w	c
0000393E =00002E00                M c	=	c+$80
0000393E 2E00                     M 	dc.w	c
00003940 =00002E80                M c	=	c+$80
00003940 2E80                     M 	dc.w	c
00003942 =00002F00                M c	=	c+$80
00003942 2F00                     M 	dc.w	c
00003944 =00002F80                M c	=	c+$80
00003944 2F80                     M 	dc.w	c
00003946 =00003000                M c	=	c+$80
00003946 3000                     M 	dc.w	c
00003948 =00003080                M c	=	c+$80
00003948 3080                     M 	dc.w	c
0000394A =00003100                M c	=	c+$80
0000394A 3100                     M 	dc.w	c
0000394C =00003180                M c	=	c+$80
0000394C 3180                     M 	dc.w	c
0000394E =00003200                M c	=	c+$80
0000394E 3200                     M 	dc.w	c
00003950 =00003280                M c	=	c+$80
00003950 3280                     M 	dc.w	c
00003952 =00003300                M c	=	c+$80
00003952 3300                     M 	dc.w	c
00003954 =00003380                M c	=	c+$80
00003954 3380                     M 	dc.w	c
00003956 =00003400                M c	=	c+$80
00003956 3400                     M 	dc.w	c
00003958 =00003480                M c	=	c+$80
00003958 3480                     M 	dc.w	c
0000395A =00003500                M c	=	c+$80
0000395A 3500                     M 	dc.w	c
0000395C =00003580                M c	=	c+$80
0000395C 3580                     M 	dc.w	c
0000395E =00003600                M c	=	c+$80
0000395E 3600                     M 	dc.w	c
00003960 =00003680                M c	=	c+$80
00003960 3680                     M 	dc.w	c
00003962 =00003700                M c	=	c+$80
00003962 3700                     M 	dc.w	c
00003964 =00003780                M c	=	c+$80
00003964 3780                     M 	dc.w	c
00003966 =00003800                M c	=	c+$80
00003966 3800                     M 	dc.w	c
00003968 =00003880                M c	=	c+$80
00003968 3880                     M 	dc.w	c
0000396A =00003900                M c	=	c+$80
0000396A 3900                     M 	dc.w	c
0000396C =00003980                M c	=	c+$80
0000396C 3980                     M 	dc.w	c
0000396E =00003A00                M c	=	c+$80
0000396E 3A00                     M 	dc.w	c
00003970 =00003A80                M c	=	c+$80
00003970 3A80                     M 	dc.w	c
00003972 =00003B00                M c	=	c+$80
00003972 3B00                     M 	dc.w	c
00003974 =00003B80                M c	=	c+$80
00003974 3B80                     M 	dc.w	c
00003976 =00003C00                M c	=	c+$80
00003976 3C00                     M 	dc.w	c
00003978 =00003C80                M c	=	c+$80
00003978 3C80                     M 	dc.w	c
0000397A =00003D00                M c	=	c+$80
0000397A 3D00                     M 	dc.w	c
0000397C =00003D80                M c	=	c+$80
0000397C 3D80                     M 	dc.w	c
0000397E =00003E00                M c	=	c+$80
0000397E 3E00                     M 	dc.w	c
00003980 =00003E80                M c	=	c+$80
00003980 3E80                     M 	dc.w	c
00003982 =00003F00                M c	=	c+$80
00003982 3F00                     M 	dc.w	c
00003984 =00003F80                M c	=	c+$80
00003984 3F80                     M 	dc.w	c
00003986 =00004000                M c	=	c+$80
00003986 4000                     M 	dc.w	c
00003988 =00004080                M c	=	c+$80
00003988 4080                     M 	dc.w	c
0000398A =00004100                M c	=	c+$80
0000398A 4100                     M 	dc.w	c
0000398C =00004180                M c	=	c+$80
0000398C 4180                     M 	dc.w	c
0000398E =00004200                M c	=	c+$80
0000398E 4200                     M 	dc.w	c
00003990 =00004280                M c	=	c+$80
00003990 4280                     M 	dc.w	c
00003992 =00004300                M c	=	c+$80
00003992 4300                     M 	dc.w	c
00003994 =00004380                M c	=	c+$80
00003994 4380                     M 	dc.w	c
00003996 =00004400                M c	=	c+$80
00003996 4400                     M 	dc.w	c
00003998 =00004480                M c	=	c+$80
00003998 4480                     M 	dc.w	c
0000399A =00004500                M c	=	c+$80
0000399A 4500                     M 	dc.w	c
0000399C =00004580                M c	=	c+$80
0000399C 4580                     M 	dc.w	c
0000399E =00004600                M c	=	c+$80
0000399E 4600                     M 	dc.w	c
000039A0 =00004680                M c	=	c+$80
000039A0 4680                     M 	dc.w	c
000039A2 =00004700                M c	=	c+$80
000039A2 4700                     M 	dc.w	c
000039A4 =00004780                M c	=	c+$80
000039A4 4780                     M 	dc.w	c
000039A6 =00004800                M c	=	c+$80
000039A6 4800                     M 	dc.w	c
000039A8 =00004880                M c	=	c+$80
000039A8 4880                     M 	dc.w	c
000039AA =00004900                M c	=	c+$80
000039AA 4900                     M 	dc.w	c
000039AC =00004980                M c	=	c+$80
000039AC 4980                     M 	dc.w	c
000039AE =00004A00                M c	=	c+$80
000039AE 4A00                     M 	dc.w	c
000039B0 =00004A80                M c	=	c+$80
000039B0 4A80                     M 	dc.w	c
000039B2 =00004B00                M c	=	c+$80
000039B2 4B00                     M 	dc.w	c
000039B4 =00004B80                M c	=	c+$80
000039B4 4B80                     M 	dc.w	c
000039B6 =00004C00                M c	=	c+$80
000039B6 4C00                     M 	dc.w	c
000039B8 =00004C80                M c	=	c+$80
000039B8 4C80                     M 	dc.w	c
000039BA =00004D00                M c	=	c+$80
000039BA 4D00                     M 	dc.w	c
000039BC =00004D80                M c	=	c+$80
000039BC 4D80                     M 	dc.w	c
000039BE =00004E00                M c	=	c+$80
000039BE 4E00                     M 	dc.w	c
000039C0 =00004E80                M c	=	c+$80
000039C0 4E80                     M 	dc.w	c
000039C2 =00004F00                M c	=	c+$80
000039C2 4F00                     M 	dc.w	c
000039C4 =00004F80                M c	=	c+$80
000039C4 4F80                     M 	dc.w	c
000039C6 =00005000                M c	=	c+$80
000039C6 5000                     M 	dc.w	c
000039C8 =00005080                M c	=	c+$80
000039C8 5080                     M 	dc.w	c
000039CA =00005100                M c	=	c+$80
000039CA 5100                     M 	dc.w	c
000039CC =00005180                M c	=	c+$80
000039CC 5180                     M 	dc.w	c
000039CE =00005200                M c	=	c+$80
000039CE 5200                     M 	dc.w	c
000039D0 =00005280                M c	=	c+$80
000039D0 5280                     M 	dc.w	c
000039D2 =00005300                M c	=	c+$80
000039D2 5300                     M 	dc.w	c
000039D4 =00005380                M c	=	c+$80
000039D4 5380                     M 	dc.w	c
000039D6 =00005400                M c	=	c+$80
000039D6 5400                     M 	dc.w	c
000039D8 =00005480                M c	=	c+$80
000039D8 5480                     M 	dc.w	c
000039DA =00005500                M c	=	c+$80
000039DA 5500                     M 	dc.w	c
000039DC =00005580                M c	=	c+$80
000039DC 5580                     M 	dc.w	c
000039DE =00005600                M c	=	c+$80
000039DE 5600                     M 	dc.w	c
000039E0 =00005680                M c	=	c+$80
000039E0 5680                     M 	dc.w	c
000039E2 =00005700                M c	=	c+$80
000039E2 5700                     M 	dc.w	c
000039E4 =00005780                M c	=	c+$80
000039E4 5780                     M 	dc.w	c
000039E6 =00005800                M c	=	c+$80
000039E6 5800                     M 	dc.w	c
000039E8 =00005880                M c	=	c+$80
000039E8 5880                     M 	dc.w	c
000039EA =00005900                M c	=	c+$80
000039EA 5900                     M 	dc.w	c
000039EC =00005980                M c	=	c+$80
000039EC 5980                     M 	dc.w	c
000039EE =00005A00                M c	=	c+$80
000039EE 5A00                     M 	dc.w	c
000039F0 =00005A80                M c	=	c+$80
000039F0 5A80                     M 	dc.w	c
000039F2 =00005B00                M c	=	c+$80
000039F2 5B00                     M 	dc.w	c
000039F4 =00005B80                M c	=	c+$80
000039F4 5B80                     M 	dc.w	c
000039F6 =00005C00                M c	=	c+$80
000039F6 5C00                     M 	dc.w	c
000039F8 =00005C80                M c	=	c+$80
000039F8 5C80                     M 	dc.w	c
000039FA =00005D00                M c	=	c+$80
000039FA 5D00                     M 	dc.w	c
000039FC =00005D80                M c	=	c+$80
000039FC 5D80                     M 	dc.w	c
000039FE =00005E00                M c	=	c+$80
000039FE 5E00                     M 	dc.w	c
00003A00 =00005E80                M c	=	c+$80
00003A00 5E80                     M 	dc.w	c
00003A02 =00005F00                M c	=	c+$80
00003A02 5F00                     M 	dc.w	c
00003A04 =00005F80                M c	=	c+$80
00003A04 5F80                     M 	dc.w	c
00003A06 =00006000                M c	=	c+$80
00003A06 6000                     M 	dc.w	c
00003A08 =00006080                M c	=	c+$80
00003A08 6080                     M 	dc.w	c
00003A0A =00006100                M c	=	c+$80
00003A0A 6100                     M 	dc.w	c
00003A0C =00006180                M c	=	c+$80
00003A0C 6180                     M 	dc.w	c
00003A0E =00006200                M c	=	c+$80
00003A0E 6200                     M 	dc.w	c
00003A10 =00006280                M c	=	c+$80
00003A10 6280                     M 	dc.w	c
00003A12 =00006300                M c	=	c+$80
00003A12 6300                     M 	dc.w	c
00003A14 =00006380                M c	=	c+$80
00003A14 6380                     M 	dc.w	c
00003A16 =00006400                M c	=	c+$80
00003A16 6400                     M 	dc.w	c
00003A18 =00006480                M c	=	c+$80
00003A18 6480                     M 	dc.w	c
00003A1A =00006500                M c	=	c+$80
00003A1A 6500                     M 	dc.w	c
00003A1C =00006580                M c	=	c+$80
00003A1C 6580                     M 	dc.w	c
00003A1E =00006600                M c	=	c+$80
00003A1E 6600                     M 	dc.w	c
00003A20 =00006680                M c	=	c+$80
00003A20 6680                     M 	dc.w	c
00003A22 =00006700                M c	=	c+$80
00003A22 6700                     M 	dc.w	c
00003A24 =00006780                M c	=	c+$80
00003A24 6780                     M 	dc.w	c
00003A26 =00006800                M c	=	c+$80
00003A26 6800                     M 	dc.w	c
00003A28 =00006880                M c	=	c+$80
00003A28 6880                     M 	dc.w	c
00003A2A =00006900                M c	=	c+$80
00003A2A 6900                     M 	dc.w	c
00003A2C =00006980                M c	=	c+$80
00003A2C 6980                     M 	dc.w	c
00003A2E =00006A00                M c	=	c+$80
00003A2E 6A00                     M 	dc.w	c
00003A30 =00006A80                M c	=	c+$80
00003A30 6A80                     M 	dc.w	c
00003A32 =00006B00                M c	=	c+$80
00003A32 6B00                     M 	dc.w	c
00003A34 =00006B80                M c	=	c+$80
00003A34 6B80                     M 	dc.w	c
00003A36 =00006C00                M c	=	c+$80
00003A36 6C00                     M 	dc.w	c
00003A38 =00006C80                M c	=	c+$80
00003A38 6C80                     M 	dc.w	c
00003A3A =00006D00                M c	=	c+$80
00003A3A 6D00                     M 	dc.w	c
00003A3C =00006D80                M c	=	c+$80
00003A3C 6D80                     M 	dc.w	c
00003A3E =00006E00                M c	=	c+$80
00003A3E 6E00                     M 	dc.w	c
00003A40 =00006E80                M c	=	c+$80
00003A40 6E80                     M 	dc.w	c
00003A42 =00006F00                M c	=	c+$80
00003A42 6F00                     M 	dc.w	c
00003A44 =00006F80                M c	=	c+$80
00003A44 6F80                     M 	dc.w	c
00003A46 =00007000                M c	=	c+$80
00003A46 7000                     M 	dc.w	c
00003A48 =00007080                M c	=	c+$80
00003A48 7080                     M 	dc.w	c
00003A4A =00007100                M c	=	c+$80
00003A4A 7100                     M 	dc.w	c
00003A4C =00007180                M c	=	c+$80
00003A4C 7180                     M 	dc.w	c
00003A4E =00007200                M c	=	c+$80
00003A4E 7200                     M 	dc.w	c
00003A50 =00007280                M c	=	c+$80
00003A50 7280                     M 	dc.w	c
00003A52 =00007300                M c	=	c+$80
00003A52 7300                     M 	dc.w	c
00003A54 =00007380                M c	=	c+$80
00003A54 7380                     M 	dc.w	c
00003A56 =00007400                M c	=	c+$80
00003A56 7400                     M 	dc.w	c
00003A58 =00007480                M c	=	c+$80
00003A58 7480                     M 	dc.w	c
00003A5A =00007500                M c	=	c+$80
00003A5A 7500                     M 	dc.w	c
00003A5C =00007580                M c	=	c+$80
00003A5C 7580                     M 	dc.w	c
00003A5E =00007600                M c	=	c+$80
00003A5E 7600                     M 	dc.w	c
00003A60 =00007680                M c	=	c+$80
00003A60 7680                     M 	dc.w	c
00003A62 =00007700                M c	=	c+$80
00003A62 7700                     M 	dc.w	c
00003A64 =00007780                M c	=	c+$80
00003A64 7780                     M 	dc.w	c
00003A66 =00007800                M c	=	c+$80
00003A66 7800                     M 	dc.w	c
00003A68 =00007880                M c	=	c+$80
00003A68 7880                     M 	dc.w	c
00003A6A =00007900                M c	=	c+$80
00003A6A 7900                     M 	dc.w	c
00003A6C =00007980                M c	=	c+$80
00003A6C 7980                     M 	dc.w	c
00003A6E =00007A00                M c	=	c+$80
00003A6E 7A00                     M 	dc.w	c
00003A70 =00007A80                M c	=	c+$80
00003A70 7A80                     M 	dc.w	c
00003A72 =00007B00                M c	=	c+$80
00003A72 7B00                     M 	dc.w	c
00003A74 =00007B80                M c	=	c+$80
00003A74 7B80                     M 	dc.w	c
00003A76 =00007C00                M c	=	c+$80
00003A76 7C00                     M 	dc.w	c
00003A78 =00007C80                M c	=	c+$80
00003A78 7C80                     M 	dc.w	c
00003A7A =00007D00                M c	=	c+$80
00003A7A 7D00                     M 	dc.w	c
00003A7C =00007D80                M c	=	c+$80
00003A7C 7D80                     M 	dc.w	c
00003A7E =00007E00                M c	=	c+$80
00003A7E 7E00                     M 	dc.w	c
00003A80 =00007E80                M c	=	c+$80
00003A80 7E80                     M 	dc.w	c
00003A82 =00007F00                M c	=	c+$80
00003A82 7F00                     M 	dc.w	c
00003A84 =00007F80                M c	=	c+$80
00003A84 7F80                     M 	dc.w	c
00003A86 =00008000                M c	=	c+$80
00003A86                            ; =========================================================================================================================================================
00003A86                            		include	"Opmodes/Gameplay/Level Functions.asm"
00003A86                            ; =========================================================================================================================================================
00003A86                            ; General level functions
00003A86                            ; =========================================================================================================================================================
00003A86                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003A86                            ; Load level data
00003A86                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003A86                            Level_LoadData:
00003A86                            		; --- Initialize the start position and camera ---
00003A86                            
00003A86 47F9 0000 0000             		lea	Level_SizeStartPos,a3		; Get size and start position data
00003A8C 3038 C7AC                  		move.w	rLevel.w,d0			; Get level ID
00003A90 E218                       		ror.b	#1,d0				; Turn into offset
00003A92 E848                       		lsr.w	#4,d0				; ''
00003A94 47F3 0000                  		lea	(a3,d0.w),a3			; Get pointer to the correct pointers
00003A98                            
00003A98 42B8 F8C4                  		clr.l	rDestMinCam.w		; Set target minimum camera values
00003A9C 42B8 F8C8                  		clr.l	rMinCam.w			; Set minimum camera values
00003AA0 21D3 F8BC                  		move.l	(a3),rDestMaxCam.w		; Set target maximum camera values
00003AA4 21DB F8C0                  		move.l	(a3)+,rMaxCam.w		; Set maximum camera values
00003AA8                            
00003AA8 31FC 0060 F8CC             		move.w	#(224/2)-16,rCamYPosDist.w	; Set camera Y distance
00003AAE                            
00003AAE 3078 F86C                  		movea.w	rPlayer1Addr.w,a0		; Player object
00003AB2 321B                       		move.w	(a3)+,d1			; Get starting X position
00003AB4 3141 0014                  		move.w	d1,oXPos(a0)			; Set the player's X position
00003AB8 3013                       		move.w	(a3),d0				; Get starting Y position
00003ABA 3140 0018                  		move.w	d0,oYPos(a0)			; Set the player's Y position
00003ABE                            
00003ABE 4A38 C7B9                  		tst.b	rStartFall.w			; Should we start the level by falling?
00003AC2 6700                       		beq.s	.InitCam			; If not, branch
00003AC4 08E8 0002 000C             		bset	#2,oFlags(a0)
00003ACA 7272                       		moveq	#$72,d1				; Reset Sonic's X position
00003ACC 3141 0014                  		move.w	d1,oXPos(a0)			; ''
00003AD0 70E0                       		moveq	#-32,d0				; Reset Sonic's Y position
00003AD2 3140 0018                  		move.w	d0,oYPos(a0)			; ''
00003AD6                            
00003AD6                            .InitCam:
00003AD6 4A38 C7AE                  		tst.b	rLastChkpoint.w		; Has a checkpoint been hit?
00003ADA 6700                       		beq.s	.SetCam				; If not, branch
00003ADC 6100 0000                  		bsr.w	Level_LoadSavedInfo		; Load data
00003AE0 3228 0014                  		move.w	oXPos(a0),d1			; Get X position
00003AE4 3028 0018                  		move.w	oYPos(a0),d0			; Get Y position
00003AE8                            
00003AE8                            .SetCam:
00003AE8 0441 00A0                  		subi.w	#320/2,d1			; Get camera's X position
00003AEC 6C00                       		bge.s	.ChkMaxX			; If it doesn't go beyond the left boundary, branch
00003AEE 7200                       		moveq	#0,d1				; Cap it
00003AF0                            
00003AF0                            .ChkMaxX:
00003AF0 3438 F8C0                  		move.w	rMaxCamX.w,d2		; Get max camera X position
00003AF4 B242                       		cmp.w	d2,d1				; Have we gone beyond it?
00003AF6 6500                       		bcs.s	.SetCamX			; If not, branch
00003AF8 3202                       		move.w	d2,d1				; Cap it
00003AFA                            
00003AFA                            .SetCamX:	
00003AFA 31C1 F880                  		move.w	d1,rCamXPos.w			; Set the camera's X position
00003AFE                            
00003AFE 0440 0060                  		subi.w	#(224/2)-16,d0			; Get camera's Y position
00003B02 6C00                       		bge.s	.ChkMaxY			; If it doesn't go beyond the upper boundary, branch
00003B04 7000                       		moveq	#0,d0				; Cap it
00003B06                            
00003B06                            .ChkMaxY:
00003B06 3438 F8C2                  		move.w	rMaxCamY.w,d2		; Get max camera Y position
00003B0A B042                       		cmp.w	d2,d0				; Have we gone beyond it?
00003B0C 6D00                       		blt.s	.SetCamY			; If not, branch
00003B0E 3002                       		move.w	d2,d0				; Cap it
00003B10                            
00003B10                            .SetCamY:	
00003B10 31C0 F888                  		move.w	d0,rCamYPos.w			; Set the camera's Y position
00003B14                            
00003B14                            		; --- Load level data ---
00003B14                            
00003B14 47F9 0000 0000             		lea	Level_DataPointers,a3		; Level data pointers
00003B1A 3038 C7AC                  		move.w	rLevel.w,d0			; Get level ID
00003B1E E218                       		ror.b	#1,d0				; Turn into offset
00003B20 E448                       		lsr.w	#2,d0				; ''
00003B22 47F3 0000                  		lea	(a3,d0.w),a3			; Get pointer to the correct pointers
00003B26                            
00003B26 205B                       		movea.l	(a3)+,a0			; Get chunk data pointer
00003B28 43F9 00FF 0000             		lea	rChunks,a1			; Decompress into chunk table
00003B2E 4EB8 0B06                  		jsr	KosDec.w			; ''
00003B32                            
00003B32 205B                       		movea.l	(a3)+,a0			; Get block data pointer
00003B34 43F8 C7D0                  		lea	rBlocks.w,a1			; Decompress into block table
00003B38 4EB8 0B06                  		jsr	KosDec.w			; ''
00003B3C                            
00003B3C 225B                       		movea.l	(a3)+,a1			; Get tile data pointer
00003B3E 7400                       		moveq	#0,d2				; Store in the beginning of VRAM
00003B40 4EB8 0F5C                  		jsr	QueueKosMData.w			; Queue for decompression
00003B44                            
00003B44 205B                       		movea.l	(a3)+,a0			; Get palette data pointer
00003B46 3018                       		move.w	(a0)+,d0			; Size of palette data
00003B48 4EB8 053A                  		jsr	LoadTargetPal.w			; Load the palette
00003B4C                            
00003B4C 205B                       		movea.l	(a3)+,a0			; Get layout pointer
00003B4E 43F8 DFD0                  		lea	rLayout.w,a1			; Decompress into layout buffer
00003B52 4EB8 0B06                  		jsr	KosDec.w			; ''
00003B56                            
00003B56 21DB C7B4                  		move.l	(a3)+,rObjPosAddr.w		; Set object position data pointer
00003B5A 21DB F85E                  		move.l	(a3)+,rRingPosAddr.w		; Set ring position data pointer
00003B5E 265B                       		movea.l	(a3)+,a3			; Get collision data pointers
00003B60 201B                       		move.l	(a3)+,d0			; Get collision data address
00003B62 21C0 F8E0                  		move.l	d0,rColAddr.w			; Set collision address to primary
00003B66 21C0 F8D8                  		move.l	d0,r1stCol.w			; Set primary collision data pointer
00003B6A 5280                       		addq.l	#1,d0				; Increment address for secondary collision
00003B6C 21C0 F8DC                  		move.l	d0,r2ndCol.w			; Set secondary collision data pointer
00003B70 43F8 F8E6                  		lea	rAngleVals.w,a1		; Collision pointers
00003B74 22DB                       		move.l	(a3)+,(a1)+			; Set angle value array pointer
00003B76 22DB                       		move.l	(a3)+,(a1)+			; Set normal hiehgt map array pointer
00003B78 229B                       		move.l	(a3)+,(a1)			; Set rotated hiehgt map array pointer
00003B7A                            
00003B7A 47F9 0000 0000             		lea	Level_PLCs,a3			; Get PLC list pointer
00003B80 3038 C7AC                  		move.w	rLevel.w,d0			; Get level ID
00003B84 E218                       		ror.b	#1,d0				; Turn into offset
00003B86 EA48                       		lsr.w	#5,d0				; ''
00003B88 2673 0000                  		movea.l	(a3,d0.w),a3			; Get pointer to the correct pointers
00003B8C 4EF8 0F4C                  		jmp	LoadKosMQueue.w			; Load the PLCs
00003B90                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003B90                            ; Update the water surface
00003B90                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003B90                            Level_UpdateWaterSurface:
00003B90 4A38 F8F4                  		tst.b	rWaterFlag.w			; Does the level have water?
00003B94 6700                       		beq.s	.End				; If not, branch
00003B96 3238 F880                  		move.w	rCamXPos.w,d1			; Get camera X position
00003B9A 0838 0000 F8FB             		btst	#0,(rLvlFrames+1).w		; Are we on an odd frame?
00003BA0 6700                       		beq.s	.SetXPos			; If not, branch
00003BA2 0641 0020                  		addi.w	#$20,d1				; Shift X position
00003BA6                            
00003BA6                            .SetXPos:
00003BA6 3001                       		move.w	d1,d0				; Copy X postion
00003BA8 0640 0060                  		addi.w	#$60,d0				; Add surface #1's X position
00003BAC 3078 F87C                  		movea.w	rWater1Addr.w,a0
00003BB0 3140 0014                  		move.w	d0,oXPos(a0)			; Set it
00003BB4 0641 0120                  		addi.w	#$120,d1			; Add surface #2's X position
00003BB8 3078 F87E                  		movea.w	rWater2Addr.w,a0
00003BBC 3141 0014                  		move.w	d1,oXPos(a0)			; Set it
00003BC0                            
00003BC0                            .End:
00003BC0 4E75                       		rts
00003BC2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003BC2                            ; Handle water height
00003BC2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003BC2                            Level_WaterHeight:
00003BC2 4A38 F8F4                  		tst.b	rWaterFlag.w			; Does the level have water?
00003BC6 6700                       		beq.s	.End				; If not, branch
00003BC8 6100 0000                  		bsr.w	Level_MoveWater			; Move the water when appropriate
00003BCC 4238 F8F5                  		clr.b	rWaterFullscr.w		; Clear water fullscreen flag
00003BD0                            
00003BD0 7201                       		moveq	#1,d1				; Water movement speed
00003BD2 3038 F8F8                  		move.w	rDestWtrLvl.w,d0		; Get destination water level
00003BD6 9078 F8F6                  		sub.w	rWaterLvl.w,d0		; Is the current water level at that destination?
00003BDA 6700                       		beq.s	.ChkOnScr			; If so, branch
00003BDC 6400                       		bcc.s	.MoveDown			; If it needs to go down, branch
00003BDE 4441                       		neg.w	d1				; Go up
00003BE0                            
00003BE0                            .MoveDown:
00003BE0 D378 F8F6                  		add.w	d1,rWaterLvl.w		; Move water
00003BE4                            
00003BE4                            .ChkOnScr:
00003BE4 3038 F8F6                  		move.w	rWaterLvl.w,d0		; Get water height
00003BE8 9078 F888                  		sub.w	rCamYPos.w,d0			; Get camera's Y position
00003BEC 6700                       		beq.s	.Fullscreen			; If they are the same, branch
00003BEE 6400                       		bcc.s	.ChkBottom			; If the water height is below the top of the camera, branch
00003BF0                            		
00003BF0                            .Fullscreen:
00003BF0 50F8 F8F5                  		st	rWaterFullscr.w		; Set water fullscreen flag
00003BF4 50F8 C75F                  		st	rHIntCnt.w			; Set H-INT counter to be offscreen
00003BF8 4E75                       		rts
00003BFA                            
00003BFA                            .ChkBottom:
00003BFA 0C40 00DF                  		cmpi.w	#224-1,d0			; Is the water below the camera?
00003BFE 6500                       		blo.s	.SetCounter			; If not, branch
00003C00 70FF                       		moveq	#-1,d0				; Set H-INT counter to be offscreen
00003C02                            
00003C02                            .SetCounter:
00003C02 11C0 C75F                  		move.b	d0,rHIntCnt.w			; Set H-INT counter
00003C06                            
00003C06                            .End:
00003C06 4E75                       		rts
00003C08                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003C08                            Level_MoveWater:
00003C08 4E75                       		rts
00003C0A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003C0A                            ; Do level palette cycling
00003C0A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003C0A                            Level_PalCycle:
00003C0A 41F9 0000 0000             		lea	Level_PalCycRouts,a0		; Palette cycle routines
00003C10 3038 C7AC                  		move.w	rLevel.w,d0			; Get level ID
00003C14 E218                       		ror.b	#1,d0				; Turn into offset
00003C16 EA48                       		lsr.w	#5,d0				; ''
00003C18 2070 0000                  		movea.l	(a0,d0.w),a0			; Get correct routine pointer
00003C1C 4ED0                       		jmp	(a0)				; Jump to it
00003C1E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003C1E                            ; Do level art animation
00003C1E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003C1E                            Level_AnimateArt:
00003C1E 41F9 0000 0000             		lea	Level_AniArtRouts,a0		; Animated art routines
00003C24 3038 C7AC                  		move.w	rLevel.w,d0			; Get level ID
00003C28 E218                       		ror.b	#1,d0				; Turn into offset
00003C2A EA48                       		lsr.w	#5,d0				; ''
00003C2C 2070 0000                  		movea.l	(a0,d0.w),a0			; Get correct routine pointer
00003C30 4ED0                       		jmp	(a0)				; Jump to it
00003C32                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003C32                            ; Do dynamic events
00003C32                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003C32                            Level_DynEvents:
00003C32 41F9 0000 0000             		lea	Level_DynEvenRouts,a0		; Dynamic events routines
00003C38 3038 C7AC                  		move.w	rLevel.w,d0			; Get level ID
00003C3C E218                       		ror.b	#1,d0				; Turn into offset
00003C3E EA48                       		lsr.w	#5,d0				; ''
00003C40 2070 0000                  		movea.l	(a0,d0.w),a0			; Get correct routine pointer
00003C44 4ED0                       		jmp	(a0)				; Jump to it
00003C46                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003C46                            ; Handle the camera
00003C46                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003C46                            Level_HandleCamera:
00003C46 3078 F86C                  		movea.w	rPlayer1Addr.w,a0		; Get player object
00003C4A                            		
00003C4A 4A38 F8CE                  		tst.b	rCamLockX.w			; Is the camera locked horizontally?
00003C4E 6600                       		bne.s	.ChkY				; If so, branch
00003C50 43F8 F880                  		lea	rCamXPos.w,a1			; Get foreground level variables
00003C54 6100                       		bsr.s	Level_MoveCameraX		; Move the camera horiozntally
00003C56                            		
00003C56                            .ChkY:
00003C56 4A38 F8CF                  		tst.b	rCamLockY.w			; Is the camera locked vertically?
00003C5A 6600                       		bne.s	.ChkMaxY			; If not, branch
00003C5C 43F8 F888                  		lea	rCamYPos.w,a1			; Get foreground level variables
00003C60 3638 F8CC                  		move.w	rCamYPosDist.w,d3		; Get camera Y distance
00003C64 6100 0000                  		bsr.w	Level_MoveCameraY		; Move the camera vertically
00003C68                            
00003C68                            .ChkMaxY:
00003C68 7202                       		moveq	#2,d1				; Target camera scroll speed
00003C6A 3038 F8BE                  		move.w	rDestMaxY.w,d0		; Get distance between target and actual target max camera Y position
00003C6E 9078 F8C2                  		sub.w	rMaxCamY.w,d0		; ''
00003C72 6700                       		beq.s	.End				; If it's 0, branch
00003C74 6400                       		bcc.s	.MoveDown			; If it's positive, branch
00003C76 3038 F888                  		move.w	rCamYPos.w,d0			; Get current camera Y position
00003C7A B078 F8BE                  		cmp.w	rDestMaxY.w,d0		; Is it past the boundary?
00003C7E 6300                       		bls.s	.ScrollUp			; If not, branch
00003C80 31C0 F8C2                  		move.w	d0,rMaxCamY.w		; Set max camera Y position
00003C84 0278 FFFE F8C2             		andi.w	#$FFFE,rMaxCamY.w		; Keep it a multiple of 2
00003C8A                            
00003C8A                            .ScrollUp:
00003C8A 9378 F8C2                  		sub.w	d1,rMaxCamY.w		; Scroll up
00003C8E 50F8 F8D0                  		st	rCamMaxChg.w			; Indicate that the max Y boundary is changing
00003C92                            
00003C92                            
00003C92                            .End:
00003C92 4E75                       		rts
00003C94                            
00003C94                            .MoveDown:
00003C94 3038 F888                  		move.w	rCamYPos.w,d0			; Get current camera Y position
00003C98 5040                       		addq.w	#8,d0				; ''
00003C9A B078 F8C2                  		cmp.w	rMaxCamY.w,d0		; Is it past the boundary?
00003C9E 6500                       		bcs.s	.ScrollDown			; If not, branch
00003CA0 0828 0001 0028             		btst	#1,oStatus(a0)		; Is the player in the air?
00003CA6 6700                       		beq.s	.ScrollDown			; If not, branch
00003CA8 D241                       		add.w	d1,d1				; Scroll down faster
00003CAA D241                       		add.w	d1,d1				; ''
00003CAC                            
00003CAC                            .ScrollDown:
00003CAC D378 F8C2                  		add.w	d1,rMaxCamY.w		; Scroll down
00003CB0 50F8 F8D0                  		st	rCamMaxChg.w			; Indicate that the max Y boundary is changing
00003CB4 4E75                       		rts
00003CB6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003CB6                            Level_MoveCameraX:
00003CB6 3028 0014                  		move.w	oXPos(a0),d0			; Get the player's X position
00003CBA 9051                       		sub.w	(a1),d0				; Get distance from the camera's X position
00003CBC 9078 F8D2                  		sub.w	rCamXPosCenter.w,d0		; Subtract center
00003CC0 6D00                       		blt.s	.MoveLeft			; If we are going left, branch
00003CC2 6C00                       		bge.s	.MoveRight			; If we are going right, branch
00003CC4 4E75                       		rts
00003CC6                            
00003CC6                            .MoveLeft:
00003CC6 0C40 FFF0                  		cmpi.w	#-16,d0				; Is the camera moving more than 16 pixels per frame?
00003CCA 6E00                       		bgt.s	.ChkLeftBound			; If not, branch
00003CCC 303C FFF0                  		move.w	#-16,d0				; Keep the camera from moving too fast
00003CD0                            
00003CD0                            .ChkLeftBound:
00003CD0 D051                       		add.w	(a1),d0				; Add back the camera's X position
00003CD2 B078 F8C8                  		cmp.w	rMinCamX.w,d0		; Have we gone past the left boundary?
00003CD6 6E00                       		bgt.s	.SetCamX			; If not, branch
00003CD8 3038 F8C8                  		move.w	rMinCamX.w,d0		; Cap at the left boundary
00003CDC 6000                       		bra.s	.SetCamX			; Continue
00003CDE                            
00003CDE                            .MoveRight:
00003CDE 0C40 0010                  		cmpi.w	#16,d0				; Is the camera moving more than 16 pixels per frame?
00003CE2 6500                       		blo.s	.ChkRightBound			; If not, branch
00003CE4 303C 0010                  		move.w	#16,d0				; Keep the camera from moving too fast
00003CE8                            
00003CE8                            .ChkRightBound:
00003CE8 D051                       		add.w	(a1),d0				; Add back the camera's X position
00003CEA B078 F8C0                  		cmp.w	rMaxCamX.w,d0		; Has the camera gone beyond the right boundary?
00003CEE 6D00                       		blt.s	.SetCamX			; If not, branch
00003CF0 3038 F8C0                  		move.w	rMaxCamX.w,d0		; Cap at the right boundary
00003CF4                            
00003CF4                            .SetCamX:
00003CF4 3280                       		move.w	d0,(a1)				; Set the new camera X position
00003CF6 4E75                       		rts
00003CF8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003CF8                            Level_MoveCameraY:
00003CF8 7200                       		moveq	#0,d1
00003CFA 3028 0018                  		move.w	oYPos(a0),d0			; Get the player's Y position
00003CFE 9051                       		sub.w	(a1),d0				; Get distance from the camera's Y position
00003D00                            
00003D00 0828 0002 0028             		btst	#2,oStatus(a0)			; Is the player rolling?
00003D06 6700                       		beq.s	.NoRoll				; If not, branch
00003D08 5B40                       		subq.w	#5,d0				; Move up some
00003D0A                            
00003D0A                            .NoRoll:
00003D0A 0828 0001 0028             		btst	#1,oStatus(a0)			; Is the player in the air?
00003D10 6700                       		beq.s	.ChkBoundCross_Ground		; If not, branch
00003D12                            
00003D12                            .ChkBoundCross_Air:
00003D12 0640 0020                  		addi.w	#$20,d0				; You have 32 pixels above and below to move without disturbing the camera
00003D16 9043                       		sub.w	d3,d0				; Subtract camera Y distance
00003D18 6500                       		bcs.s	.ScrollFast			; If the player is above the boundary, branch
00003D1A 0440 0040                  		subi.w	#$40,d0				; Subtract 64
00003D1E 6400                       		bcc.s	.ScrollFast			; If the player is below the boundary, branch
00003D20                            
00003D20 4A38 F8D0                  		tst.b	rCamMaxChg.w			; Is the max Y boundary changing?
00003D24 6600                       		bne.s	.ScrollMaxYChange		; If so, branch
00003D26 6000                       		bra.s	.NoScroll			; Continue
00003D28                            
00003D28                            .ChkBoundCross_Ground:
00003D28 9043                       		sub.w	d3,d0				; Subtract camera Y distance
00003D2A 6600                       		bne.s	.DecideScrollType		; If the player moved, branch
00003D2C 4A38 F8D0                  		tst.b	rCamMaxChg.w			; Is the max Y boundary changing?
00003D30 6600                       		bne.s	.ScrollMaxYChange		; If so, branch
00003D32                            
00003D32                            .NoScroll:
00003D32 4E75                       		rts		
00003D34                            
00003D34                            .DecideScrollType:
00003D34 0C43 0060                  		cmpi.w	#(224/2)-16,d3			; Is the camera Y distance normal?
00003D38 6600                       		bne.s	.ScrollSlow			; If not, branch
00003D3A                            
00003D3A 3228 0000                  		move.w	oGVel(a0),d1			; Get the players' ground velocity
00003D3E 6A00                       		bpl.s	.Positive			; If it's positive, branch
00003D40 4441                       		neg.w	d1				; Force it to be positive
00003D42                            
00003D42                            .Positive:
00003D42 0C41 0800                  		cmpi.w	#$800,d1			; Is the player travelling very fast?
00003D46 6400                       		bhs.s	.ScrollFast			; If so, branch
00003D48                            
00003D48                            .ScrollMedium:
00003D48 323C 0600                  		move.w	#6<<8,d1			; Cap camera movement at 6 if going too fast
00003D4C 0C40 0006                  		cmpi.w	#6,d0				; Is the player going down too fast?
00003D50 6E00                       		bgt.s	.ScrollDownMax			; If so, branch
00003D52 0C40 FFFA                  		cmpi.w	#-6,d0				; Is the player going up too fast?
00003D56 6D00                       		blt.s	.ScrollUpMax			; If so, branch
00003D58 6000                       		bra.s	.ScrollUpOrDown			; Continue
00003D5A                            
00003D5A                            .ScrollSlow:
00003D5A 323C 0200                  		move.w	#2<<8,d1			; Cap camera movement at 2 if going too fast
00003D5E 0C40 0002                  		cmpi.w	#2,d0				; Is the player going down too fast?
00003D62 6E00                       		bgt.s	.ScrollDownMax			; If so, branch
00003D64 0C40 FFFE                  		cmpi.w	#-2,d0				; Is the player going up too fast?
00003D68 6D00                       		blt.s	.ScrollUpMax			; If so, branch
00003D6A 6000                       		bra.s	.ScrollUpOrDown			; Continue
00003D6C                            
00003D6C                            .ScrollFast:
00003D6C 323C 1000                  		move.w	#16<<8,d1			; Cap camera movement at 16 if going too fast
00003D70 0C40 0010                  		cmpi.w	#16,d0				; Is the player going down too fast?
00003D74 6E00                       		bgt.s	.ScrollDownMax			; If so, branch
00003D76 0C40 FFF0                  		cmpi.w	#-16,d0				; Is the player going up too fast?
00003D7A 6D00                       		blt.s	.ScrollUpMax			; If so, branch
00003D7C 6000                       		bra.s	.ScrollUpOrDown			; Continue
00003D7E                            
00003D7E                            .ScrollMaxYChange:
00003D7E 7000                       		moveq	#0,d0				; Distance for the camera to move = 0
00003D80 11C0 F8D0                  		move.b	d0,rCamMaxChg.w		; Clear the max Y boundary changing flag
00003D84                            		
00003D84                            .ScrollUpOrDown:
00003D84 7200                       		moveq	#0,d1
00003D86 3200                       		move.w	d0,d1				; Get position difference
00003D88 D251                       		add.w	(a1),d1				; Add old camera Y position
00003D8A 4A40                       		tst.w	d0				; Is the camera to scroll down?
00003D8C 6A00                       		bpl.s	.ScrollDown			; If so, branch
00003D8E 6000 0000                  		bra.w	.ScrollUp			; Scroll up
00003D92                            
00003D92                            .ScrollUpMax:
00003D92 4441                       		neg.w	d1				; Make the value negative, since we are going up
00003D94 48C1                       		ext.l	d1
00003D96 E181                       		asl.l	#8,d1				; Move into upper word tp lie up with the actual value for the Y position
00003D98 D291                       		add.l	(a1),d1				; Add the camera's Y position
00003D9A 4841                       		swap	d1				; Get the actual Y position
00003D9C                            
00003D9C                            .ScrollUp:
00003D9C B278 F8CA                  		cmp.w	rMinCamY.w,d1		; Has the camera gone beyond the upper boundary?
00003DA0 6E00                       		bgt.s	.DoScroll			; If not, branch
00003DA2 3238 F8CA                  		move.w	rMinCamY.w,d1		; Cap at upper boundary
00003DA6 6000                       		bra.s	.DoScroll			; Continue
00003DA8                            
00003DA8                            .ScrollDownMax:
00003DA8 48C1                       		ext.l	d1
00003DAA E181                       		asl.l	#8,d1				; Move into upper word tp lie up with the actual value for the Y position
00003DAC D291                       		add.l	(a1),d1				; Add the camera's Y position
00003DAE 4841                       		swap	d1				; Get the actual Y position
00003DB0                            
00003DB0                            .ScrollDown:
00003DB0 B278 F8C2                  		cmp.w	rMaxCamY.w,d1		; Has the camera gone beyond the lower boundary?
00003DB4 6D00                       		blt.s	.DoScroll			; If not, branch
00003DB6 3238 F8C2                  		move.w	rMaxCamY.w,d1		; Cap at lower boundary
00003DBA                            
00003DBA                            .DoScroll:
00003DBA 4841                       		swap	d1				; Put Y coordinate in the higher word
00003DBC 2281                       		move.l	d1,(a1)				; Set Y position
00003DBE 4E75                       		rts
00003DC0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003DC0                            ; Level ring manager
00003DC0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003DC0                            Level_RingsManager:
00003DC0 7000                       		moveq	#0,d0
00003DC2 1038 F3D6                  		move.b	rRingManRout.w,d0		; Get routine
00003DC6 303B 0000                  		move.w	.Routines(pc,d0.w),d0		; Get offset
00003DCA 4EFB 0000                  		jmp	.Routines(pc,d0.w)		; Jump to the right routine
00003DCE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003DCE                            .Routines:
00003DCE 0000                       		dc.w	Level_RingsManagerInit-.Routines
00003DD0 0000                       		dc.w	Level_RingsManagerMain-.Routines
00003DD2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003DD2                            ; Ring manager initialization
00003DD2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003DD2                            Level_RingsManagerInit:
00003DD2 5438 F3D6                  		addq.b	#2,rRingManRout.w		; The next time the manager is run, only go to the main routine
00003DD6                            		
00003DD6 6100 0000                  		bsr.w	Level_RingsManagerSetup	; Prepare the tables and load the ring data
00003DDA                            
00003DDA                            		; Set up the addresses to use in the current location of the level
00003DDA                            
00003DDA                            		; Start at the left side of the screen
00003DDA                            		; We get the location of the first ring that shows up at the left side of the screen in the data and store that
00003DDA                            
00003DDA 2278 F862                  		movea.l	rRingLoadL.w,a1		; Get current ring data address for the left side of the screen
00003DDE 45F8 F3DE                  		lea	rRingStat.w,a2		; Ring status table
00003DE2 3838 F880                  		move.w	rCamXPos.w,d4			; Get camera's X position
00003DE6 5144                       		subq.w	#8,d4				; Check 8 pixels to the left of it
00003DE8 6200                       		bhi.s	.CheckLeftSide			; Branch if not beyond 0
00003DEA 7801                       		moveq	#1,d4				; Cap left side to 1
00003DEC 6000                       		bra.s	.CheckLeftSide			; Start checking
00003DEE                            
00003DEE                            .NextLeftRing:
00003DEE 5849                       		addq.w	#4,a1				; Next ring in ring data
00003DF0 544A                       		addq.w	#2,a2				; Next ring in status table
00003DF2                            
00003DF2                            .CheckLeftSide:
00003DF2 B851                       		cmp.w	(a1),d4				; Is this ring located to the right of the left boundary?
00003DF4 62F8                       		bhi.s	.NextLeftRing			; If not, get the next ring
00003DF6 21C9 F862                  		move.l	a1,rRingLoadL.w		; Store starting ring data address
00003DFA 31CA F86A                  		move.w	a2,rRingStatPtr.w		; Store ring status address
00003DFE                            
00003DFE                            		; Now the right side of the screen
00003DFE                            		; We get the location of the first ring that goes beyond the right side of the screen in the data and store that
00003DFE                            
00003DFE 0644 0150                  		addi.w	#320+16,d4			; Right boundary
00003E02 6000                       		bra.s	.CheckRightSide			; Start checking
00003E04                            
00003E04                            .NextRightRing:
00003E04 5849                       		addq.w	#4,a1				; Next ring in ring data
00003E06                            
00003E06                            .CheckRightSide:
00003E06 B851                       		cmp.w	(a1),d4				; Is this ring located to the right of the right boundary?
00003E08 62FA                       		bhi.s	.NextRightRing			; If not, get the next ring
00003E0A 21C9 F866                  		move.l	a1,rRingLoadR.w		; Store ending ring data address
00003E0E 4E75                       		rts
00003E10                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003E10                            ; Ring manager main routine
00003E10                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003E10                            Level_RingsManagerMain:
00003E10 6100 0000                  		bsr.w	Level_RingsManagerDoCollect	; Handle ring collection
00003E14                            
00003E14 2278 F862                  		movea.l	rRingLoadL.w,a1		; Get the current starting address for the ring data
00003E18 3478 F86A                  		movea.w	rRingStatPtr.w,a2		; Get the current starting address for the status table
00003E1C                            		
00003E1C                            		; Get the new starting addresses for ring data
00003E1C                            		; This is done by getting to a point from the current starting address where there's a ring onscreen
00003E1C                            		; and then going back to get the very first ring that's on screen
00003E1C                            
00003E1C 3838 F880                  		move.w	rCamXPos.w,d4			; Get camera's X position
00003E20 5144                       		subq.w	#8,d4				; Check 8 pixels to the left of it
00003E22 6200                       		bhi.s	.CheckNewLeftSide		; Branch if not beyond 0
00003E24 7801                       		moveq	#1,d4				; Cap left side to 1
00003E26 6000                       		bra.s	.CheckNewLeftSide		; Start checking
00003E28                            
00003E28                            .NextNewLeftRing:
00003E28 5849                       		addq.w	#4,a1				; Next ring in ring data
00003E2A 544A                       		addq.w	#2,a2				; Next ring in status table
00003E2C                            
00003E2C                            .CheckNewLeftSide:
00003E2C B851                       		cmp.w	(a1),d4				; Is this ring located to the right of the left boundary?
00003E2E 62F8                       		bhi.s	.NextNewLeftRing		; If not, get the next ring
00003E30 6000                       		bra.s	.CheckNewLeftSide2		; Start checking
00003E32                            
00003E32                            .NextNewLeftRing2:
00003E32 5949                       		subq.w	#4,a1				; Previous ring in ring data
00003E34 554A                       		subq.w	#2,a2				; Previous ring in status table
00003E36                            
00003E36                            .CheckNewLeftSide2:
00003E36 B869 FFFC                  		cmp.w	-4(a1),d4			; Is this ring located to the left of the left boundary?
00003E3A 63F6                       		bls.s	.NextNewLeftRing2		; If not, get the next ring
00003E3C 21C9 F862                  		move.l	a1,rRingLoadL.w		; Store starting ring data address
00003E40 31CA F86A                  		move.w	a2,rRingStatPtr.w		; Store ring status address
00003E44                            
00003E44                            		; Now get the new ending addresses for ring data
00003E44                            		; This is done by getting to a point from the current starting address where there's a ring at the right of the left boundary
00003E44                            		; and then going back to get the very first ring that's on screen on the left side
00003E44                            
00003E44 2278 F866                  		movea.l	rRingLoadR.w,a1		; Get the current ending address for the ring data
00003E48                            
00003E48 0644 0150                  		addi.w	#320+16,d4			; Right boundary
00003E4C 6000                       		bra.s	.CheckNewRightSide		; Start checking
00003E4E                            
00003E4E                            .NextNewRightRing:
00003E4E 5849                       		addq.w	#4,a1				; Next ring in ring data
00003E50                            
00003E50                            .CheckNewRightSide:
00003E50 B851                       		cmp.w	(a1),d4				; Is this ring located to the right of the right boundary?
00003E52 62FA                       		bhi.s	.NextNewRightRing		; If not, get the next ring
00003E54 6000                       		bra.s	.CheckNewRightSide2		; Start checking
00003E56                            
00003E56                            .NextNewRightRing2:
00003E56 5949                       		subq.w	#4,a1				; Previous ring in ring data
00003E58                            
00003E58                            .CheckNewRightSide2:
00003E58 B869 FFFC                  		cmp.w	-4(a1),d4			; Is this ring located to the left of the right boundary?
00003E5C 63F8                       		bls.s	.NextNewRightRing2		; If not, get the next ring
00003E5E 21C9 F866                  		move.l	a1,rRingLoadR.w		; Store ending ring data address
00003E62 4E75                       		rts
00003E64                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003E64                            ; Handle ring collection
00003E64                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003E64                            Level_RingsManagerDoCollect:
00003E64 45F8 F7DE                  		lea	rRingCol.w,a2			; Ring collection table
00003E68 321A                       		move.w	(a2)+,d1			; Get consumed ring count
00003E6A 5341                       		subq.w	#1,d1				; Sutbract 1
00003E6C 6500                       		bcs.s	.End				; If there are no consumed rings to handle, branch
00003E6E                            
00003E6E                            .Loop:
00003E6E 301A                       		move.w	(a2)+,d0			; Get ring status address
00003E70 67FC                       		beq.s	.Loop				; If 0, get the next ring
00003E72 3240                       		movea.w	d0,a1				; Save in a1
00003E74 5311                       		subq.b	#1,(a1)				; Decrement timer
00003E76 6600                       		bne.s	.Next				; If nonzero, branch
00003E78 12BC 0006                  		move.b	#6,(a1)				; Reset timer
00003E7C 5229 0001                  		addq.b	#1,1(a1)			; Increment frame
00003E80                            							; Is it the last frame?
00003E80 0C29 0000 0001             		cmpi.b	#(CMap_Ring_Sparkle_Last-CMap_Ring)/8,1(a1)
00003E86 6600                       		bne.s	.Next				; If not, branch
00003E88 32BC FFFF                  		move.w	#-1,(a1)			; Set timer and frame to -1
00003E8C 426A FFFE                  		clr.w	-2(a2)				; Set address in collection table to 0
00003E90 5378 F7DE                  		subq.w	#1,rRingColCnt.w		; Decrement collection table count
00003E94                            
00003E94                            .Next:
00003E94 51C9 FFD8                  		dbf	d1,.Loop			; Loop
00003E98                            
00003E98                            .End:
00003E98 4E75                       		rts
00003E9A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003E9A                            ; Set up the tables and load ring data
00003E9A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003E9A                            Level_RingsManagerSetup:
00003E9A                            		; Clear tables
00003E9A                            		clrRAM	rRingStat
00003E9A                          M 	local	endaddr
00003E9A                          M endaddr	equs	"rringstat_End"
00003E9A 7000                     M 	moveq	#0,d0
00003E9C 43F8 F3DE                M 	lea	(rringstat).w,a1
00003EA0 323C 00FF                M 	move.w	#(((rringstat_end)-(rringstat))-((rringstat)&1))>>2-1,d1
00003EA4 22C0                     M .clear_180:	move.l	d0,(a1)+
00003EA6 51C9 FFFC                M 	dbf	d1,.clear_180
00003EAA                            		clrRAM	rRingCol
00003EAA                          M 	local	endaddr
00003EAA                          M endaddr	equs	"rringcol_End"
00003EAA 7000                     M 	moveq	#0,d0
00003EAC 43F8 F7DE                M 	lea	(rringcol).w,a1
00003EB0 323C 001F                M 	move.w	#(((rringcol_end)-(rringcol))-((rringcol)&1))>>2-1,d1
00003EB4 22C0                     M .clear_181:	move.l	d0,(a1)+
00003EB6 51C9 FFFC                M 	dbf	d1,.clear_181
00003EBA                            
00003EBA 2278 F85E                  		movea.l	rRingPosAddr.w,a1		; Get ring data pointer
00003EBE 21C9 F862                  		move.l	a1,rRingLoadL.w		; Store address
00003EC2 5849                       		addq.w	#4,a1				; Increment address by 4
00003EC4 7A00                       		moveq	#0,d5				; Initialize the ring counter
00003EC6 303C 01FE                  		move.w	#$1FE,d0			; Max number of ring
00003ECA                            
00003ECA                            .GetRingCount:
00003ECA 4A99                       		tst.l	(a1)+				; Have all the ring been counted?
00003ECC 6B00                       		bmi.s	.Exit				; If so, branch
00003ECE 5245                       		addq.w	#1,d5				; Increment ring counter
00003ED0 51C8 FFF8                  		dbf	d0,.GetRingCount		; Loop
00003ED4                            
00003ED4                            .Exit:
00003ED4 4E75                       		rts
00003ED6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003ED6                            ; Do ring collision for the player
00003ED6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003ED6                            PlayerRingCollision:
00003ED6 0C28 0069 0000             		cmpi.b	#105,oInvulTime(a0)		; Is the player able to collect rings while hurt?
00003EDC 6400 0000                  		bhs.w	.End				; If it hasn't been long enough, branch
00003EE0 2278 F862                  		movea.l	rRingLoadL.w,a1		; Get starting address of ring data
00003EE4 2478 F866                  		movea.l	rRingLoadR.w,a2		; Get starting address of status table
00003EE8 B5C9                       		cmpa.l	a1,a2				; Are there any rings to test collision with?
00003EEA 6700 0000                  		beq.w	.End				; If not, branch
00003EEE 3878 F86A                  		movea.w	rRingStatPtr.w,a4
00003EF2 3428 0014                  		move.w	oXPos(a0),d2			; Player's X position
00003EF6 3628 0018                  		move.w	oYPos(a0),d3			; Player's Y position
00003EFA 5142                       		subq.w	#8,d2				; Subtract 8 from X
00003EFC 7A00                       		moveq	#0,d5
00003EFE 1A28 002D                  		move.b	oColH(a0),d5			; Player's collision height
00003F02 5705                       		subq.b	#3,d5				; Subtract 3 from collision height
00003F04 9645                       		sub.w	d5,d3				; Subtract from Y
00003F06 323C 0006                  		move.w	#6,d1
00003F0A 3C3C 000C                  		move.w	#$C,d6
00003F0E 383C 0010                  		move.w	#$10,d4				; Width
00003F12 DA45                       		add.w	d5,d5				; Double the height
00003F14                            
00003F14                            .NextRing:
00003F14 4A54                       		tst.w	(a4)				; Is the current ring already consumed?
00003F16 6600                       		bne.s	.GetNext			; If so, get the next ring
00003F18 3011                       		move.w	(a1),d0				; Get ring's X position
00003F1A 9041                       		sub.w	d1,d0				; Subtract the player's X from the ring's X
00003F1C 9042                       		sub.w	d2,d0				; Check collision
00003F1E 6400                       		bcc.s	.ChkCol
00003F20 D046                       		add.w	d6,d0
00003F22 6500                       		bcs.s	.ChkCol2
00003F24 6000 0000                  		bra.w	.GetNext			; If no collision, get the next ring
00003F28                            
00003F28                            .ChkCol:
00003F28 B044                       		cmp.w	d4,d0				; Check collision
00003F2A 6200 0000                  		bhi.w	.GetNext			; If no collision, get the next ring
00003F2E                            
00003F2E                            .ChkCol2:
00003F2E 3029 0002                  		move.w	2(a1),d0			; Do Y collision check
00003F32 9041                       		sub.w	d1,d0
00003F34 9043                       		sub.w	d3,d0
00003F36 6400                       		bcc.s	.ChkCol3
00003F38 D046                       		add.w	d6,d0
00003F3A 6500                       		bcs.s	.Collect
00003F3C 6000 0000                  		bra.w	.GetNext			; If no collision, get the next ring
00003F40                            
00003F40                            .ChkCol3:
00003F40 B045                       		cmp.w	d5,d0
00003F42 6200 0000                  		bhi.w	.GetNext			; If no collision, get the next ring
00003F46                            
00003F46                            .Collect:
00003F46                            							; Consume the ring
00003F46 38BC 0000                  		move.w	#(6<<8)|((CMap_Ring_Sparkle-CMap_Ring)/8),(a4)
00003F4A 6100                       		bsr.s	CollectRing			; Collect it
00003F4C 47F8 F7E0                  		lea	rRingColList.w,a3		; Get collection list
00003F50                            
00003F50                            .Consume:
00003F50 4A5B                       		tst.w	(a3)+				; Has this slot been used up?
00003F52 66FC                       		bne.s	.Consume			; If not, get the next one
00003F54 370C                       		move.w	a4,-(a3)			; Save the status table RAM address for the current ring
00003F56 5278 F7DE                  		addq.w	#1,rRingColCnt.w		; Add to the number of rings consumed
00003F5A                            
00003F5A                            .GetNext:
00003F5A 5849                       		addq.w	#4,a1				; Next ring in ring data
00003F5C 544C                       		addq.w	#2,a4				; Next ring in status table
00003F5E B5C9                       		cmpa.l	a1,a2				; Have we reached the end?
00003F60 6600 FFB2                  		bne.w	.NextRing			; If not, loop
00003F64                            
00003F64                            .End:
00003F64 4E75                       		rts
00003F66                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003F66                            ; Collect a ring
00003F66                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003F66                            CollectRing:
00003F66 5278 F3D4                  		addq.w	#1,rRings.w			; Incremment ring count
00003F6A 50F8 F8F3                  		st	rUpdateRings.w			; Update ring counter in HUD
00003F6E                            		playSnd	#sRing, 2			; Play ring sound
00003F6E 11FC 008C C4BD           M 	move.b	#sring,(mqueue+((2)-1)).w
00003F74 4E75                       		rts
00003F76                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003F76                            ; Render the HUD
00003F76                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00003F76                            Level_RenderHUDAndRings:
00003F76 7C00                       		moveq	#0,d6				; Clear render flags
00003F78 7802                       		moveq	#1*2,d4				; Standard frame
00003F7A 4A78 F3D4                  		tst.w	rRings.w			; Do we have 0 rings?
00003F7E 6600                       		bne.s	.Not0Rings			; If not, branch
00003F80 0838 0003 F8FB             		btst	#3,(rLvlFrames+1).w		; Can the timer blink?
00003F86 6600                       		bne.s	.Not0Rings			; If not, branch
00003F88 7800                       		moveq	#0*2,d4				; Set frame to blink the timer
00003F8A                            
00003F8A                            .Not0Rings:
00003F8A 3A3C 8680                  		move.w	#$8680,d5			; Tile properties
00003F8E                            		
00003F8E 303C 0090                  		move.w	#16+128,d0			; X position
00003F92 323C 0088                  		move.w	#8+128,d1			; Y position
00003F96 43FA 0000                  		lea	Map_HUD(pc),a1			; Mappings
00003F9A D2F1 4000                  		adda.w	(a1,d4.w),a1			; Get address of frame
00003F9E 3819                       		move.w	(a1)+,d4			; Get number of sprites in the frame
00003FA0 5344                       		subq.w	#1,d4				; Subtract 1 from sprite count
00003FA2 4EB8 0852                  		jsr	DrawSprite.w			; Draw the HUD frame
00003FA6                            
00003FA6                            .RenderRings:
00003FA6 2078 F862                  		movea.l	rRingLoadL.w,a0			; Get starting address of ring data
00003FAA 2438 F866                  		move.l	rRingLoadR.w,d2			; Get ending address of ring data
00003FAE 9488                       		sub.l	a0,d2				; Get length of the data to read
00003FB0 6700                       		beq.s	.End				; If zero length, branch
00003FB2 3878 F86A                  		movea.w	rRingStatPtr.w,a4		; Get starting address of status table
00003FB6 43FA 0000                  		lea	CMap_Ring(pc),a1		; Get mappings pointer
00003FBA 3A3C 00F0                  		move.w	#224+16,d5			; Get bottom screen boundary
00003FBE                            		
00003FBE                            .Loop:
00003FBE 4A5C                       		tst.w	(a4)+				; Is this ring collected?
00003FC0 6B00                       		bmi.s	.Next				; If so, branch
00003FC2 3228 0002                  		move.w	2(a0),d1			; Get Y position
00003FC6 926B 0008                  		sub.w	cYPos(a3),d1			; Subtract camera's Y position to get screen position
00003FCA 5041                       		addq.w	#8,d1				; Add 8
00003FCC B245                       		cmp.w	d5,d1				; Is it below the bottom of the screen?
00003FCE 6400                       		bhs.s	.Next				; If so, branch
00003FD0 0641 0078                  		addi.w	#120,d1				; Add 120 to move it within screen space
00003FD4 3010                       		move.w	(a0),d0				; Get X position
00003FD6 9053                       		sub.w	cXPos(a3),d0			; Subtract camera's X position to get screen position
00003FD8 0640 0080                  		addi.w	#128,d0				; Add 128 to move it within screen space
00003FDC 7C00                       		moveq	#0,d6
00003FDE 1C2C FFFF                  		move.b	-1(a4),d6			; Get frame
00003FE2                            
00003FE2                            .Draw:
00003FE2 E74E                       		lsl.w	#3,d6				; Turn frame ID into offset
00003FE4 45F1 6000                  		lea	(a1,d6.w),a2			; Get address of frame map data
00003FE8 D25A                       		add.w	(a2)+,d1			; Add Y offset
00003FEA 3CC1                       		move.w	d1,(a6)+			; Save Y position
00003FEC 3C1A                       		move.w	(a2)+,d6			; Get sprite size
00003FEE 1C86                       		move.b	d6,(a6)				; Save it
00003FF0 544E                       		addq.w	#2,a6				; Skip link value
00003FF2 3CDA                       		move.w	(a2)+,(a6)+			; Save base tile ID and properites
00003FF4 D05A                       		add.w	(a2)+,d0			; Add X offset
00003FF6 3CC0                       		move.w	d0,(a6)+			; Save X position
00003FF8 5347                       		subq.w	#1,d7				; Decrement the number of sprites left available
00003FFA                            
00003FFA                            .Next:
00003FFA 5848                       		addq.w	#4,a0				; Next ring in ring data
00003FFC 5942                       		subq.w	#4,d2				; Decrement the ring count
00003FFE 66BE                       		bne.s	.Loop				; If there are still rings to check, loop
00004000                            
00004000                            .End:
00004000 4E75                       		rts
00004002                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004002                            ; Custom mappings format.
00004002                            ; Differences include...
00004002                            ;	No offset table (each sprite assumed to be 8 bytes)
00004002                            ;	No 'sprite pieces per frame' value (hardcoded to 1)
00004002                            ;	Sign-extended Y-pos value
00004002                            ;	Sign-extended sprite size value
00004002                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004002                            CMap_Ring:
00004002                            		; Main ring frame
00004002 FFF8                       		dc.w	$FFF8
00004004 0005                       		dc.w	$0005
00004006 26BC                       		dc.w	$0000+$26BC
00004008 FFF8                       		dc.w	$FFF8
0000400A                            
0000400A                            CMap_Ring_Sparkle:
0000400A                            		; Ring sparkle frame 1
0000400A FFF8                       		dc.w	$FFF8
0000400C 0005                       		dc.w	$0005
0000400E 26B8                       		dc.w	$0000+$26B8
00004010 FFF8                       		dc.w	$FFF8
00004012                            		; Ring sparkle frame 2
00004012 FFF8                       		dc.w	$FFF8
00004014 0005                       		dc.w	$0005
00004016 3EB8                       		dc.w	($0000+$26B8)|$1800
00004018 FFF8                       		dc.w	$FFF8
0000401A                            		; Ring sparkle frame 3
0000401A FFF8                       		dc.w	$FFF8
0000401C 0005                       		dc.w	$0005
0000401E 2EB8                       		dc.w	($0000+$26B8)|$800
00004020 FFF8                       		dc.w	$FFF8
00004022                            		; Ring sparkle frame 4
00004022 FFF8                       		dc.w	$FFF8
00004024 0005                       		dc.w	$0005
00004026 36B8                       		dc.w	($0000+$26B8)|$1000
00004028 FFF8                       		dc.w	$FFF8
0000402A                            CMap_Ring_Sparkle_Last:
0000402A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000402A                            ; HUD mappings
0000402A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000402A                            Map_HUD:	
0000402A 0000 0000                  		dc.w Map_HUD_4-Map_HUD, Map_HUD_18-Map_HUD	
0000402E                            
0000402E 0003                       Map_HUD_4:	dc.b 0, 3	
00004030 000D 0002 0000             		dc.b 0, $D, 0, 2, 0, 0	
00004036 0001 0000 0020             		dc.b 0, 1, 0, 0, 0, $20	
0000403C 0009 000A 0030             		dc.b 0, 9, 0, $A, 0, $30
00004042                            
00004042 0003                       Map_HUD_18:	dc.b 0, 3	
00004044 000D 2002 0000             		dc.b 0, $D, $20, 2, 0, 0	
0000404A 0001 2000 0020             		dc.b 0, 1, $20, 0, 0, $20	
00004050 0009 000A 0030             		dc.b 0, 9, 0, $A, 0, $30	
00004056                            		even
00004056                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004056                            ; Update the HUD
00004056                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004056                            ; PARAMETERS:
00004056                            ;	a5.l	- VDP data port
00004056                            ;	a6.l	- VDP control port
00004056                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004056                            ; RETURNS:
00004056                            ;	Nothing
00004056                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004056                            Level_UpdateHUD:
00004056 4A38 F8F3                  		tst.b	rUpdateRings.w		; Does the ring counter need to be updated?
0000405A 6700                       		beq.s	.End				; If not, branch
0000405C 6B00                       		bmi.s	.DontZero			; If the flag is negative, branch
0000405E 6100 0000                  		bsr.w	Level_HUDResetRings		; Reset the ring counter
00004062                            
00004062                            .DontZero:
00004062 4238 F8F3                  		clr.b	rUpdateRings.w		; Clear update value
00004066                            		vdpCmd	move.l,$D140,VRAM,WRITE,d0	; Set VDP command
00004066 203C 5140 0003           M 	move.l	#((((vram&write)&3)<<30)|(($d140&$3fff)<<16)|(((vram&write)&$fc)<<2)|(($d140&$c000)>>14)),d0
0000406C 7200                       		moveq	#0,d1
0000406E 3238 F3D4                  		move.w	rRings.w,d1			; Ring count
00004072 6000                       		bra.s	.UpdateRings			; Update the rings counter
00004074                            
00004074                            .End
00004074 4E75                       		rts
00004076                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004076                            .UpdateRings:
00004076 7800                       		moveq	#0,d4				; Reset the "draw digit" flag
00004078 45F9 0000 0000             		lea	HUDMod_100,a2			; Start with the 100s digit
0000407E 7C02                       		moveq	#3-1,d6				; Number of digits to draw
00004080 43F9 0000 0000             		lea	ArtUnc_HUDNumbers.l,a1		; HUD numbers
00004086                            		
00004086                            .LoadDigit_Loop:
00004086 7400                       		moveq	#0,d2				; Reset the digit
00004088 261A                       		move.l	(a2)+,d3			; Get the number that's used to calculute what the current digit is
0000408A                            		
0000408A                            .GetDigit:
0000408A 9283                       		sub.l	d3,d1				; Subtract
0000408C 6500                       		bcs.s	.InitDrawDigit			; If it's gone below 0, branch
0000408E 5242                       		addq.w	#1,d2				; Increment digit
00004090 60F8                       		bra.s	.GetDigit			; Loop until the digit is corret
00004092                            
00004092                            .InitDrawDigit:
00004092 D283                       		add.l	d3,d1				; Add back
00004094 4A42                       		tst.w	d2				; Is the digit 0?
00004096 6700                       		beq.s	.DrawDigit			; If so, branch
00004098 50C4                       		st	d4				; Set the "draw digit" flag
0000409A                            
0000409A                            .DrawDigit:
0000409A 4A04                       		tst.b	d4				; Should we draw the digit?
0000409C 6700                       		beq.s	.NextDigit			; If not, branch
0000409E ED4A                       		lsl.w	#6,d2				; Multiply the digit by $40
000040A0 2C80                       		move.l	d0,(a6)				; Set the VDP command
000040A2 47F1 2000                  		lea	(a1,d2.w),a3			; Get address of the digit art
000040A6                            		rept	16
000040A6                            			move.l	(a3)+,(a5)		; Load the digit art
000040A6                            		endr
000040A6 2A9B                     M 	move.l	(a3)+,(a5)
000040A8 2A9B                     M 	move.l	(a3)+,(a5)
000040AA 2A9B                     M 	move.l	(a3)+,(a5)
000040AC 2A9B                     M 	move.l	(a3)+,(a5)
000040AE 2A9B                     M 	move.l	(a3)+,(a5)
000040B0 2A9B                     M 	move.l	(a3)+,(a5)
000040B2 2A9B                     M 	move.l	(a3)+,(a5)
000040B4 2A9B                     M 	move.l	(a3)+,(a5)
000040B6 2A9B                     M 	move.l	(a3)+,(a5)
000040B8 2A9B                     M 	move.l	(a3)+,(a5)
000040BA 2A9B                     M 	move.l	(a3)+,(a5)
000040BC 2A9B                     M 	move.l	(a3)+,(a5)
000040BE 2A9B                     M 	move.l	(a3)+,(a5)
000040C0 2A9B                     M 	move.l	(a3)+,(a5)
000040C2 2A9B                     M 	move.l	(a3)+,(a5)
000040C4 2A9B                     M 	move.l	(a3)+,(a5)
000040C6                            		
000040C6                            .NextDigit:
000040C6 0680 0040 0000             		addi.l	#$400000,d0			; Next digit
000040CC 51CE FFB8                  		dbf	d6,.LoadDigit_Loop		; Loop
000040D0 4E75                       		rts
000040D2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000040D2 0000 0064                  HUDMod_100:	dc.l	100
000040D6 0000 000A                  HUDMod_10:	dc.l	10
000040DA 0000 0001                  HUDMod_1:	dc.l	1
000040DE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000040DE                            ; Initialize the HUD
000040DE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000040DE                            Level_InitHUD:
000040DE 4DF9 00C0 0004             		lea	VDP_CTRL,a6			; VDP data port
000040E4 4BEE FFFC                  		lea	-4(a6),a5			; VDP control port
000040E8                            		
000040E8                            Level_HUDResetRings:
000040E8                            		vdpCmd	move.l,$D140,VRAM,WRITE,(a6)	; Set VDP command
000040E8 2CBC 5140 0003           M 	move.l	#((((vram&write)&3)<<30)|(($d140&$3fff)<<16)|(((vram&write)&$fc)<<2)|(($d140&$c000)>>14)),(a6)
000040EE 45FA 0000                  		lea	HUD_RingsBase(pc),a2		; Tile base
000040F2 343C 0002                  		move.w	#3-1,d2				; Length
000040F6                            
000040F6 43F9 0000 0000             		lea	ArtUnc_HUDNumbers.l,a1		; HUD numbers art
000040FC                            
000040FC                            .LoadTiles:
000040FC 101A                       		move.b	(a2)+,d0			; Get digit
000040FE 4880                       		ext.w	d0
00004100 ED48                       		lsl.w	#6,d0				; Turn into offset
00004102 47F1 0000                  		lea	(a1,d0.w),a3			; Get address of digit art
00004106                            
00004106                            		rept	8*2
00004106                            			move.l	(a3)+,(a5)		; Load art
00004106                            		endr
00004106 2A9B                     M 	move.l	(a3)+,(a5)
00004108 2A9B                     M 	move.l	(a3)+,(a5)
0000410A 2A9B                     M 	move.l	(a3)+,(a5)
0000410C 2A9B                     M 	move.l	(a3)+,(a5)
0000410E 2A9B                     M 	move.l	(a3)+,(a5)
00004110 2A9B                     M 	move.l	(a3)+,(a5)
00004112 2A9B                     M 	move.l	(a3)+,(a5)
00004114 2A9B                     M 	move.l	(a3)+,(a5)
00004116 2A9B                     M 	move.l	(a3)+,(a5)
00004118 2A9B                     M 	move.l	(a3)+,(a5)
0000411A 2A9B                     M 	move.l	(a3)+,(a5)
0000411C 2A9B                     M 	move.l	(a3)+,(a5)
0000411E 2A9B                     M 	move.l	(a3)+,(a5)
00004120 2A9B                     M 	move.l	(a3)+,(a5)
00004122 2A9B                     M 	move.l	(a3)+,(a5)
00004124 2A9B                     M 	move.l	(a3)+,(a5)
00004126                            
00004126 51CA FFD4                  		dbf	d2,.LoadTiles			; Loop
0000412A                            
0000412A 4E75                       		rts
0000412C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000412C                            HUD_RingsBase:
0000412C 0A0A 00                    		dc.b	$A, $A, 0			; Ring count
00004130 00                         		even
00004130                            
00004130                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004130                            ; Animate the level art
00004130                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004130                            ; LEVEL ANIMATION SCRIPTS
00004130                            ;
00004130                            ; The AniArt_DoAnimate subroutine uses these scripts to reload certain tiles,
00004130                            ; thus animating them. All the relevant art must be uncompressed, because
00004130                            ; otherwise the subroutine would spend so much time waiting for the art to be
00004130                            ; decompressed that the VBLANK window would close before all the animating was done.
00004130                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004130                            ;	zoneanimdecl -1, ArtUnc_Flowers1, ArtTile_ArtUnc_Flowers1, 6, 2
00004130                            ;		-1			Global frame duration. If -1, then each frame will use its own duration, instead
00004130                            ;		ArtUnc_Flowers1		Source address
00004130                            ;		ArtTile_ArtUnc_Flowers1	Destination VRAM address
00004130                            ;		6			Number of frames
00004130                            ;		2			Number of tiles to load into VRAM for each frame
00004130                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004130                            ;	dc.b   0,$7F			Start of the script proper
00004130                            ;		0			Tile ID of first tile in ArtUnc_Flowers1 to transfer
00004130                            ;		$7F			Frame duration. Only here if global duration is -1
00004130                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004130                            AniArt_DoAnimate:
00004130 47F8 F902                  		lea	rAnimCnts.w,a3		; Level art animation counters
00004134 3C1A                       		move.w	(a2)+,d6			; Get number of scripts in list
00004136 6A00                       		bpl.s	.ListNotEmpty			; If there are any, continue
00004138 4E75                       		rts
0000413A                            
0000413A                            .ListNotEmpty:
0000413A                            .Loop:
0000413A 5313                       		subq.b	#1,(a3)				; Tick down frame duration
0000413C 6400                       		bcc.s	.NextScript			; If frame isn't over, move on to next script
0000413E                            
0000413E                            .NextFrame:
0000413E 7000                       		moveq	#0,d0
00004140 102B 0001                  		move.b	1(a3),d0			; Get current frame
00004144 B02A 0006                  		cmp.b	6(a2),d0			; Have we processed the last frame in the script?
00004148 6500                       		blo.s	.NotLastFrame			; If not, branch
0000414A 7000                       		moveq	#0,d0				; If so, reset to first frame
0000414C 1740 0001                  		move.b	d0,1(a3)			; ''
00004150                            
00004150                            .NotLastFrame:
00004150 522B 0001                  		addq.b	#1,1(a3)			; Consider this frame processed; set counter to next frame
00004154 1692                       		move.b	(a2),(a3)			; Set frame duration to global duration value
00004156 6A00                       		bpl.s	.GlobalDuration
00004158 D040                       		add.w	d0,d0				; If script uses per-frame durations, use those instead
0000415A 16B2 0009                  		move.b	9(a2,d0.w),(a3)			; Set frame duration to current frame's duration value
0000415E                            
0000415E                            .GlobalDuration:
0000415E 1032 0008                  		move.b	8(a2,d0.w),d0			; Get tile ID
00004162 EB48                       		lsl.w	#5,d0				; Turn it into an offset
00004164 342A 0004                  		move.w	4(a2),d2			; Get VRAM destination address
00004168 2212                       		move.l	(a2),d1				; Get ROM source address
0000416A 0281 00FF FFFF             		andi.l	#$FFFFFF,d1			; ''
00004170 D280                       		add.l	d0,d1				; Offset into art, to get the address of new frame
00004172 7600                       		moveq	#0,d3
00004174 162A 0007                  		move.b	7(a2),d3			; Get size of art to be transferred 
00004178 E94B                       		lsl.w	#4,d3				; Turn it into actual size (in words)
0000417A 4EB8 0304                  		jsr	QueueDMATransfer.w		; Queue a DMA transfer
0000417E                            
0000417E                            .NextScript:
0000417E 102A 0006                  		move.b	6(a2),d0			; Get total size of frame data
00004182 4A12                       		tst.b	(a2)				; Is per-frame duration data present?
00004184 6A00                       		bpl.s	.GlobalDuration2		; If not, keep the current size; it's correct
00004186 D000                       		add.b	d0,d0				; Double size to account for the additional frame duration data
00004188                            
00004188                            .GlobalDuration2:
00004188 5200                       		addq.b	#1,d0
0000418A 0240 00FE                  		andi.w	#$FE,d0				; Round to next even address, if it isn't already
0000418E 45F2 0008                  		lea	8(a2,d0.w),a2			; Advance to next script in list
00004192 544B                       		addq.w	#2,a3				; Advance to next script's slot in a3 (usually Anim_Counters)
00004194 51CE FFA4                  		dbf	d6,.Loop			; Loop
00004198 4E75                       		rts
0000419A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000419A                            ; Set an object as solid and check for collision
0000419A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000419A                            ; RETURNING SOLID OBJECT COLLISION BIT FORMAT (For oStatus):
0000419A                            ;	XXPXSXAX
0000419A                            ;	X	- Unused
0000419A                            ;	P	- Pushing flag
0000419A                            ;	S	- Standing on flag
0000419A                            ;	A	- In air flag (for the player)
0000419A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000419A                            ; RETURNING SOLID OBJECT COLLISION BIT FORMAT (For d6):
0000419A                            ;	XXXTXBXS
0000419A                            ;	X	- Unused
0000419A                            ;	T	- Touch top flag
0000419A                            ;	B	- Touch bottom flag
0000419A                            ;	S	- Touch side flag
0000419A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000419A                            ; PARAMETERS:
0000419A                            ;	d1.w	- Object width
0000419A                            ;	d2.w	- Object height / 2 (when jumping)
0000419A                            ;	d3.w	- Object height / 2 (when walking)
0000419A                            ;	d4.w	- Object x-axis position
0000419A                            ;	a0.l	- Object space pointer
0000419A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000419A                            ; RETURNS:
0000419A                            ;	See object collision return values above
0000419A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000419A                            SolidObject:
0000419A 7C00                       		moveq	#0,d6				; Clear collision flag register
0000419C 3278 F86C                  		movea.w	rPlayer1Addr.w,a1		; Set player object RAM
000041A0 0828 0003 0028             		btst	#cStandBit,oStatus(a0)		; Is the player standing on the current object?
000041A6 6700 0000                  		beq.w	SolidObject_ChkColOnScr		; If not, branch
000041AA 3401                       		move.w	d1,d2				; Copy object width
000041AC D442                       		add.w	d2,d2				; Double it
000041AE 0829 0001 0028             		btst	#1,oStatus(a1)			; Is the player in midair?
000041B4 6600                       		bne.s	.NotOnTop			; If so, branch
000041B6 3029 0014                  		move.w	oXPos(a1),d0			; Get player's X position
000041BA 9068 0014                  		sub.w	oXPos(a0),d0			; Subtract the current object's X position
000041BE D041                       		add.w	d1,d0				; Add width
000041C0 6B00                       		bmi.s	.NotOnTop			; If not colliding, branch
000041C2 B042                       		cmp.w	d2,d0				; Compare with the width
000041C4 6500                       		bcs.s	.IsOnTop			; If not colliding, branch
000041C6                            
000041C6                            .NotOnTop:
000041C6 08A9 0003 0028             		bclr	#cStandBit,oStatus(a1)		; Clear the standing on object bit for the player
000041CC 08E9 0001 0028             		bset	#1,oStatus(a1)			; Make the player be in midair
000041D2 08A8 0003 0028             		bclr	#cStandBit,oStatus(a0)		; Clear the player standing on this object bit
000041D8 4269 0000                  		clr.w	oInteract(a1)			; Clear the player's interact object pointer
000041DC 7800                       		moveq	#0,d4				; Set collision status to 0
000041DE 4E75                       		rts
000041E0                            
000041E0                            .IsOnTop:
000041E0 3404                       		move.w	d4,d2				; Copy X position to d2
000041E2 6100 0000                  		bsr.w	PlayerMoveOnPtfm		; Move the player on top of the current object
000041E6 7800                       		moveq	#0,d4				; Set collision status to 0
000041E8 4E75                       		rts
000041EA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000041EA                            ; Set an object as solid and check for collision (even if off screen)
000041EA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000041EA                            ; PARAMETERS:
000041EA                            ;	d1.w	- Object width
000041EA                            ;	d2.w	- Object height / 2 (when jumping)
000041EA                            ;	d3.w	- Object height / 2 (when walking)
000041EA                            ;	d4.w	- Object x-axis position
000041EA                            ;	a0.l	- Object space pointer
000041EA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000041EA                            ; RETURNS:
000041EA                            ;	See object collision return values above
000041EA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000041EA                            SolidObject_Always:
000041EA 7C00                       		moveq	#0,d6				; Clear collision flag register
000041EC 3278 F86C                  		movea.w	rPlayer1Addr.w,a1		; Set player object RAM
000041F0 0828 0003 0028             		btst	#cStandBit,oStatus(a0)		; Is the player standing on the current object?
000041F6 6700 0000                  		beq.w	SolidObject_ChkCollision	; If not, branch
000041FA 3401                       		move.w	d1,d2				; Copy object width
000041FC D442                       		add.w	d2,d2				; Double it
000041FE 0829 0001 0028             		btst	#1,oStatus(a1)			; Is the player in midair?
00004204 6600                       		bne.s	.NotOnTop			; If so, branch
00004206 3029 0014                  		move.w	oXPos(a1),d0			; Get player's X position
0000420A 9068 0014                  		sub.w	oXPos(a0),d0			; Subtract the current object's X position
0000420E D041                       		add.w	d1,d0				; Add width
00004210 6B00                       		bmi.s	.NotOnTop			; If not colliding, branch
00004212 B042                       		cmp.w	d2,d0				; Compare with the width
00004214 6500                       		bcs.s	.IsOnTop			; If not colliding, branch
00004216                            
00004216                            .NotOnTop:
00004216 08A9 0003 0028             		bclr	#cStandBit,oStatus(a1)		; Clear the standing on object bit for the player
0000421C 08E9 0001 0028             		bset	#1,oStatus(a1)			; Make the player be in midair
00004222 08A8 0003 0028             		bclr	#cStandBit,oStatus(a0)		; Clear the player standing on this object bit
00004228 4269 0000                  		clr.w	oInteract(a1)			; Clear the player's interact object pointer
0000422C 7800                       		moveq	#0,d4				; Set collision status to 0
0000422E 4E75                       		rts
00004230                            
00004230                            .IsOnTop:
00004230 3404                       		move.w	d4,d2				; Copy X position to d2
00004232 6100 0000                  		bsr.w	PlayerMoveOnPtfm		; Move the player on top of the current object
00004236 7800                       		moveq	#0,d4				; Set collision status to 0
00004238 4E75                       		rts
0000423A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000423A                            ; Set an object as a solid slope and check for collision
0000423A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000423A                            ; PARAMETERS:
0000423A                            ;	d1.w	- Object width
0000423A                            ;	d2.w	- Object height / 2 (when jumping)
0000423A                            ;	d3.w	- Object height / 2 (when walking)
0000423A                            ;	d4.w	- Object x-axis position
0000423A                            ;	a0.l	- Object space pointer
0000423A                            ;	a2.l	- Slope height data pointer
0000423A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000423A                            ; RETURNS:
0000423A                            ;	See object collision return values above
0000423A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000423A                            SlopedSolid:
0000423A 7C00                       		moveq	#0,d6				; Clear collision flag register
0000423C 3278 F86C                  		movea.w	rPlayer1Addr.w,a1		; Set player object RAM
00004240 0828 0003 0028             		btst	#cStandBit,oStatus(a0)		; Is the player standing on the current object?
00004246 6700 0000                  		beq.w	SlopedSolid_ChkCollision	; If not, branch
0000424A 3401                       		move.w	d1,d2				; Copy object width
0000424C D442                       		add.w	d2,d2				; Double it
0000424E 0829 0001 0028             		btst	#1,oStatus(a1)			; Is the player in midair?
00004254 6600                       		bne.s	.NotOnTop			; If so, branch
00004256 3029 0014                  		move.w	oXPos(a1),d0			; Get player's X position
0000425A 9068 0014                  		sub.w	oXPos(a0),d0			; Subtract the current object's X position
0000425E D041                       		add.w	d1,d0				; Add width
00004260 6B00                       		bmi.s	.NotOnTop			; If not colliding, branch
00004262 B042                       		cmp.w	d2,d0				; Compare with the width
00004264 6500                       		bcs.s	.IsOnTop			; If not colliding, branch
00004266                            
00004266                            .NotOnTop:
00004266 08A9 0003 0028             		bclr	#cStandBit,oStatus(a1)		; Clear the standing on object bit for the player
0000426C 08E9 0001 0028             		bset	#1,oStatus(a1)			; Make the player be in midair
00004272 08A8 0003 0028             		bclr	#cStandBit,oStatus(a0)		; Clear the player standing on this object bit
00004278 4269 0000                  		clr.w	oInteract(a1)			; Clear the player's interact object pointer
0000427C 7800                       		moveq	#0,d4				; Set collision status to 0
0000427E 4E75                       		rts
00004280                            
00004280                            .IsOnTop:
00004280 3404                       		move.w	d4,d2				; Copy X position to d2
00004282 6100 0000                  		bsr.w	PlayerMoveOnSlope		; Move the player on top of the current object
00004286 7800                       		moveq	#0,d4				; Set collision status to 0
00004288 4E75                       		rts
0000428A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000428A                            SlopedSolid_ChkCollision:
0000428A 3029 0014                  		move.w	oXPos(a1),d0			; Get player's X position
0000428E 9068 0014                  		sub.w	oXPos(a0),d0			; Subtract current object's X position
00004292 D041                       		add.w	d1,d0				; Add width to it
00004294 6B00 0000                  		bmi.w	SolidObject_TestClearPush	; If not colliding, branch
00004298 3601                       		move.w	d1,d3				; Copy width to d3
0000429A D643                       		add.w	d3,d3				; Double it
0000429C B043                       		cmp.w	d3,d0				; Compare to the X position
0000429E 6200 0000                  		bhi.w	SolidObject_TestClearPush	; If not colliding, branch
000042A2 3A00                       		move.w	d0,d5				; Copy the X position to d5
000042A4 0828 0000 000D             		btst	#0,oRender(a0)			; Is the object X-flipped?
000042AA 6700                       		beq.s	.NoFlip				; If not, branch
000042AC 4645                       		not.w	d5				; Logical notation on d5
000042AE DA43                       		add.w	d3,d5				; Add width
000042B0                            
000042B0                            .NoFlip:
000042B0 E24D                       		lsr.w	#1,d5				; Divide by 2
000042B2 1632 5000                  		move.b	(a2,d5.w),d3			; Get height of this segment
000042B6 9612                       		sub.b	(a2),d3				; Subtract first bytes from the value
000042B8 4883                       		ext.w	d3				; Sign extend to word
000042BA 3A28 0018                  		move.w	oYPos(a0),d5			; Get the current object's Y position
000042BE 9A43                       		sub.w	d3,d5				; Subtract the height from the Y position
000042C0 1629 002D                  		move.b	oColH(a1),d3			; Get the player's collision height
000042C4 4883                       		ext.w	d3				; Sign extend to word
000042C6 D443                       		add.w	d3,d2				; Add collision height to the object height
000042C8 3629 0018                  		move.w	oYPos(a1),d3			; Get the player's Y position
000042CC 9645                       		sub.w	d5,d3				; Subtract d5
000042CE 5843                       		addq.w	#4,d3				; Add 4
000042D0 D642                       		add.w	d2,d3				; Add height and collision height
000042D2 6B00 0000                  		bmi.w	SolidObject_TestClearPush	; If not colliding, branch
000042D6 3802                       		move.w	d2,d4				; Copy height and collision height
000042D8 D844                       		add.w	d4,d4				; Double it
000042DA B644                       		cmp.w	d4,d3				; Compare to Y position
000042DC 6400 0000                  		bcc.w	SolidObject_TestClearPush	; If not colliding, branch
000042E0 6000 0000                  		bra.w	SolidObject_ChkBounds		; If anything else, we are colliding
000042E4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000042E4                            SolidObject_ChkColOnScr:
000042E4 4A28 000D                  		tst.b	oRender(a0)			; Is the object on screen?
000042E8 6A00 0000                  		bpl.w	SolidObject_TestClearPush	; If not, branch
000042EC                            
000042EC                            SolidObject_ChkCollision:
000042EC 3029 0014                  		move.w	oXPos(a1),d0			; Get player's X position
000042F0 9068 0014                  		sub.w	oXPos(a0),d0			; Subtract the current object's X position
000042F4 D041                       		add.w	d1,d0				; Add width
000042F6 3601                       		move.w	d1,d3				; Copy width
000042F8 D643                       		add.w	d3,d3				; Double it
000042FA B043                       		cmp.w	d3,d0				; Compare with the X position
000042FC 6200 0000                  		bhi.w	SolidObject_TestClearPush	; If not colliding, branch
00004300                            		
00004300 1829 0000                  		move.b	oInitColH(a1),d4		; Get the player's default collision height
00004304 4884                       		ext.w	d4				; Sign extend to word
00004306 D842                       		add.w	d2,d4				; Add height
00004308 1629 002D                  		move.b	oColH(a1),d3			; Get the player's collision height
0000430C 4883                       		ext.w	d3				; Sign extend to word
0000430E D443                       		add.w	d3,d2				; Add to height
00004310 3629 0018                  		move.w	oYPos(a1),d3			; Get player's Y position
00004314 9668 0018                  		sub.w	oYPos(a0),d3			; Subtract the current object's Y position
00004318 5843                       		addq.w	#4,d3				; Add 4
0000431A D642                       		add.w	d2,d3				; Add height
0000431C 0243 0FFF                  		andi.w	#$FFF,d3			; Keep in range
00004320 D842                       		add.w	d2,d4				; Add height
00004322 B644                       		cmp.w	d4,d3				; Compare with the Y position
00004324 6400 0000                  		bcc.w	SolidObject_TestClearPush	; If not colliding, branch
00004328                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004328                            SolidObject_ChkBounds:
00004328 4A29 000C                  		tst.b	oFlags(a1)			; Is the player being carried by another object?
0000432C 6B00 0000                  		bmi.w	SolidObject_TestClearPush	; If so, branch
00004330 0C29 000C 0025             		cmpi.b	#$C,oRoutine(a1)			; Is the player dead?
00004336 6400 0000                  		bcc.w	SolidObject_End			; If so, branch
0000433A 4A38 F8D1                  		tst.b	rDebugMode.w			; Is debug mode active?
0000433E 6600 0000                  		bne.w	SolidObject_End			; If so, branch
00004342                            
00004342 3A00                       		move.w	d0,d5				; Copy X offset
00004344 B240                       		cmp.w	d0,d1				; Check against the "middle" of the object
00004346 6400                       		bcc.s	.IsLeft				; If the player is left of the middle, branch
00004348 D241                       		add.w	d1,d1				; Double collision width
0000434A 9041                       		sub.w	d1,d0				; Subtract from X offset
0000434C 3A00                       		move.w	d0,d5				; Copy X offset
0000434E 4445                       		neg.w	d5				; Negate offset
00004350                            
00004350                            .IsLeft:
00004350 3203                       		move.w	d3,d1				; Copy Y offset
00004352 B443                       		cmp.w	d3,d2				; Check against the "middle" of the object
00004354 6400                       		bcc.s	.IsAbove			; If the player is above of the middle, branch
00004356 5943                       		subq.w	#4,d3				; Subtract 4 from the collision height
00004358 9644                       		sub.w	d4,d3				; Subtract height from the collision height
0000435A 3203                       		move.w	d3,d1				; Copy Y offset
0000435C 4441                       		neg.w	d1				; Negate offset
0000435E                            
0000435E                            .IsAbove:
0000435E BA41                       		cmp.w	d1,d5
00004360 6200 0000                  		bhi.w	SolidObject_UpDown		; Branch if we are in the object less vertically than horizontally(?)
00004364 0C41 0004                  		cmpi.w	#4,d1
00004368 6300 0000                  		bls.w	SolidObject_UpDown		; I assume this ensures the corners are not solid until some point
0000436C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000436C                            SolidObject_Sides:
0000436C 4A40                       		tst.w	d0
0000436E 6700                       		beq.s	.AlignPlayer			; Branch if we are in the middle of the object?
00004370 6B00                       		bmi.s	.ChkRight			; Branch if we are right of the object
00004372 4A69 001C                  		tst.w	oXVel(a1)			; Is the player moving left?
00004376 6B00                       		bmi.s	.AlignPlayer			; If so, branch
00004378 6000                       		bra.s	.ClearGroundVel			; If else player is moving right, branch
0000437A                            
0000437A                            .ChkRight:
0000437A 4A69 001C                  		tst.w	oXVel(a1)
0000437E 6A00                       		bpl.s	.AlignPlayer			; Branch if player is moving right
00004380                            
00004380                            .ClearGroundVel:
00004380 4269 0000                  		clr.w	oGVel(a1)			; Stop the player from moving
00004384 4269 001C                  		clr.w	oXVel(a1)			; Clear the player's X velocity
00004388                            
00004388                            .AlignPlayer:
00004388 9169 0014                  		sub.w	d0,oXPos(a1)			; Align player to the side of the object
0000438C 0829 0001 0028             		btst	#1,oStatus(a1)			; Is the player in midair?
00004392 6600                       		bne.s	.InAir				; If so, branch
00004394 08E8 0005 0028             		bset	#cPushBit,oStatus(a0)		; Set the pushing bit
0000439A 08E9 0005 0028             		bset	#cPushBit,oStatus(a1)		; Set the player's pushing bit
000043A0 08C6 0000                  		bset	#cTouchSideBit,d6		; Set "touch side" flag
000043A4 7801                       		moveq	#1,d4				; Set collision status to 1
000043A6 4E75                       		rts
000043A8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000043A8                            .InAir:
000043A8 6100                       		bsr.s	SolidObject_ClearPush		; Clear pushing bits
000043AA 08C6 0000                  		bset	#cTouchSideBit,d6		; Set "touch side" flag
000043AE 7801                       		moveq	#1,d4				; Set collision status to 1
000043B0 4E75                       		rts
000043B2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000043B2                            SolidObject_TestClearPush:
000043B2 0828 0005 0028             		btst	#cPushBit,oStatus(a0)		; Is the player pushing this object?
000043B8 6700                       		beq.s	SolidObject_End			; If not, branch
000043BA 0C29 0002 0020             		cmpi.b	#2,oAni(a1)			; Is the player jumping/rolling?
000043C0 6700                       		beq.s	SolidObject_ClearPush		; If so, branch
000043C2 0C29 0017 0020             		cmpi.b	#$17,oAni(a1)			; Is the player in using the drowning animation
000043C8 6700                       		beq.s	SolidObject_ClearPush		; If so, branch
000043CA 0C29 001A 0020             		cmpi.b	#$1A,oAni(a1)			; Is the player in using the hurt animation
000043D0 6700                       		beq.s	SolidObject_ClearPush		; If so, branch
000043D2 337C 0001 0020             		move.w	#1,oAni(a1)			; Make the player use the walking animation
000043D8                            
000043D8                            SolidObject_ClearPush:
000043D8 08A8 0005 0028             		bclr	#cPushBit,oStatus(a0)		; Clear the pushing bit
000043DE 08A9 0005 0028             		bclr	#cPushBit,oStatus(a1)		; Clear the player's pushing bit
000043E4                            
000043E4                            SolidObject_End:
000043E4 7800                       		moveq	#0,d4				; Set collision status to 0
000043E6 4E75                       		rts
000043E8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000043E8                            SolidObject_UpDown:
000043E8 4A43                       		tst.w	d3				; Is the player below the middle of the object?
000043EA 6B00                       		bmi.s	SolidObject_Below		; If so, branch
000043EC 0C43 0010                  		cmpi.w	#$10,d3				; Is the player 16 pixels or less above the middle of the object?
000043F0 6500                       		bcs.s	SolidObject_Above		; If so, branch
000043F2 60BE                       		bra.s	SolidObject_TestClearPush	; If not, the player is not colliding
000043F4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000043F4                            SolidObject_Below:
000043F4 4A69 001E                  		tst.w	oYVel(a1)			; Is the player moving vertically?
000043F8 6700                       		beq.s	.CheckCrush			; If so, branch
000043FA 6A00                       		bpl.s	.SetY				; If the player's moving down, branch
000043FC 4A43                       		tst.w	d3				; Is the player above the middle of the object?
000043FE 6A00                       		bpl.s	.SetY				; If so, branch
00004400 4269 001E                  		clr.w	oYVel(a1)			; Clear the player's Y velocity
00004404                            
00004404                            .SetY:
00004404 9769 0018                  		sub.w	d3,oYPos(a1)			; Push the player below the object
00004408 08C6 0002                  		bset	#cTouchBtmBit,d6		; Set "touch bottom" flag
0000440C 78FE                       		moveq	#-2,d4				; Set the collision status to -2
0000440E 4E75                       		rts
00004410                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004410                            .CheckCrush:
00004410 0829 0001 0028             		btst	#1,oStatus(a1)			; Is the player in midair?
00004416 66EC                       		bne.s	.SetY				; If so, branch
00004418 3800                       		move.w	d0,d4				; Get x offset
0000441A 6A00                       		bpl.s	.NoNeg				; If it's positive branch
0000441C 4444                       		neg.w	d4				; Negate it (absolute value)
0000441E                            
0000441E                            .NoNeg:
0000441E 0C44 0010                  		cmpi.w	#$10,d4				; Is the player near the edge of object collision?
00004422 6500 FF48                  		blo.w	SolidObject_Sides		; If so, branch
00004426                            		
00004426                            		push.l	a0				; Store the current object's address
00004426 2F08                     M 	move.l	a0,-(sp)
00004428 2049                       		movea.l	a1,a0				; Replace with the player's address
0000442A 4EB9 0000 0000             		jsr	ObjPlayer_GetKilled		; Kill the player
00004430                            		pop.l	a0				; Restore the current object's address
00004430 205F                     M 	move.l	(sp)+,a0
00004432 08C6 0002                  		bset	#cTouchBtmBit,d6		; Set "touch bottom" flag
00004436 78FE                       		moveq	#-2,d4				; Set collision status to -2
00004438 4E75                       		rts
0000443A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000443A                            SolidObject_Above:
0000443A 5943                       		subq.w	#4,d3				; Get the sub Y offset
0000443C                            		
0000443C                            		; This next bit ensures the player does not collide with the top when next to the walls
0000443C                            		; recalculates object width.
0000443C                            
0000443C 7200                       		moveq	#0,d1
0000443E 1228 002C                  		move.b	oColW(a0),d1			; Get the current object's width
00004442 3401                       		move.w	d1,d2				; Copy it
00004444 D442                       		add.w	d2,d2				; Double it
00004446                            		
00004446 D269 0014                  		add.w	oXPos(a1),d1			; Add the player's X position
0000444A 9268 0014                  		sub.w	oXPos(a0),d1			; Subtract the current object's X position
0000444E 6B00                       		bmi.s	.NoCollision			; If the player is not colliding, branch
00004450                            		
00004450 B242                       		cmp.w	d2,d1				; Is the plauer colliding from the right?
00004452 6400                       		bcc.s	.NoCollision			; If the player is not colliding, branch
00004454                            		
00004454 5369 0018                  		subq.w	#1,oYPos(a1)			; Subtract 1 from the player's Y position
00004458 9769 0018                  		sub.w	d3,oYPos(a1)			; Move the player above the object
0000445C 4A69 001E                  		tst.w	oYVel(a1)			; Is the player moving up?
00004460 6B00                       		bmi.s	.NoCollision			; If so, branch
00004462 6100 0000                  		bsr.w	RideObject_SetRide		; Allow the player to stand on top (and set the "ride" bit)
00004466 08C6 0004                  		bset	#cTouchTopBit,d6		; Set "touch top" flag
0000446A 78FF                       		moveq	#-1,d4				; Set collision status to -1
0000446C 4E75                       		rts
0000446E                            
0000446E                            .NoCollision:
0000446E 7800                       		moveq	#0,d4				; Set collision status to 0
00004470 4E75                       		rts
00004472                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004472                            ; Set an object as a platform and check for collision
00004472                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004472                            ; PARAMETERS:
00004472                            ;	d1.w	- Object's width
00004472                            ;	d2.w	- Object's width*2 (only for Platform_ChkBridgeCol)
00004472                            ;	d3.w	- Object's height
00004472                            ;	d4.w	- Object x-axis position
00004472                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004472                            ; RETURNS:
00004472                            ;	See object collision return values above (side and bottom collision doesn't apply here)
00004472                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004472                            PlatformObject:
00004472 7C00                       		moveq	#0,d6				; Clear collision flag register
00004474 3278 F86C                  		movea.w	rPlayer1Addr.w,a1		; Get the player RAM
00004478 0828 0003 0028             		btst	#cStandBit,oStatus(a0)		; Is the player standing on the object?
0000447E 6700 0000                  		beq.w	Platform_ChkCollision		; If not, branch
00004482 3401                       		move.w	d1,d2				; Copy the object's width
00004484 D442                       		add.w	d2,d2				; Double it
00004486 0829 0001 0028             		btst	#1,oStatus(a1)			; Is the player in midair?
0000448C 6600                       		bne.s	.NotOnTop			; If so, branch
0000448E 3029 0014                  		move.w	oXPos(a1),d0			; Get the player's X position
00004492 9068 0014                  		sub.w	oXPos(a0),d0			; Subtract the object's X position
00004496 D041                       		add.w	d1,d0				; Add width
00004498 6B00                       		bmi.s	.NotOnTop			; If the player is not colliding, branch
0000449A B042                       		cmp.w	d2,d0				; Compare with the width
0000449C 6500                       		blo.s	.OnTop				; If the player is not colliding, branch
0000449E                            
0000449E                            .NotOnTop:
0000449E 08A9 0003 0028             		bclr	#cStandBit,oStatus(a1)		; Clear the player's standing on object bit
000044A4 08E9 0001 0028             		bset	#1,oStatus(a1)			; Make the player be in midair
000044AA 08A8 0003 0028             		bclr	#cStandBit,oStatus(a0)		; Clear the player standing on this object bit
000044B0 4269 0000                  		clr.w	oInteract(a1)			; Clear the player's interact object pointer
000044B4 7800                       		moveq	#0,d4				; Set the collision status to 0
000044B6 4E75                       		rts
000044B8                            
000044B8                            .OnTop:
000044B8 3404                       		move.w	d4,d2				; Copy X position
000044BA 6100 0000                  		bsr.w	PlayerMoveOnPtfm		; Make the player stand on top of this object
000044BE 7800                       		moveq	#0,d4				; Set the collision status to 0
000044C0 4E75                       		rts
000044C2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000044C2                            Platform_ChkBridgeCol:
000044C2 4A69 001E                  		tst.w	oYVel(a1)			; Is the player moving up?
000044C6 6B00 0000                  		bmi.w	PlatformObject_End		; If so, branch
000044CA 3029 0014                  		move.w	oXPos(a1),d0			; Get the player's X position
000044CE 9068 0014                  		sub.w	oXPos(a0),d0			; Subtract the object's X position
000044D2 D041                       		add.w	d1,d0				; Add width
000044D4 6B00 0000                  		bmi.w	PlatformObject_End		; If the player is not colliding, branch
000044D8 B042                       		cmp.w	d2,d0				; Compare with width
000044DA 6400 0000                  		bcc.w	PlatformObject_End		; If the player is not colliding, branch
000044DE 6000                       		bra.s	Platform_ChkCol_Cont		; Continue
000044E0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000044E0                            Platform_ChkCollision:
000044E0 4A69 001E                  		tst.w	oYVel(a1)			; Is the player moving up?
000044E4 6B00 0000                  		bmi.w	PlatformObject_End		; If so, branch
000044E8 3029 0014                  		move.w	oXPos(a1),d0			; Get the player's X position
000044EC 9068 0014                  		sub.w	oXPos(a0),d0			; Subtract the object's X position
000044F0 D041                       		add.w	d1,d0				; Add width
000044F2 6B00 0000                  		bmi.w	PlatformObject_End		; If the player is not colliding, branch
000044F6 D241                       		add.w	d1,d1				; Double width
000044F8 B041                       		cmp.w	d1,d0				; Compare with width
000044FA 6400 0000                  		bcc.w	PlatformObject_End		; If the player is not colliding, branch
000044FE                            
000044FE                            Platform_ChkCol_Cont:
000044FE 3028 0018                  		move.w	oYPos(a0),d0			; Get the object's Y position
00004502 9043                       		sub.w	d3,d0				; Subtract the height from it
00004504                            
00004504                            PlatformObject_ChkYRange:
00004504 3429 0018                  		move.w	oYPos(a1),d2			; Get the player's Y position
00004508 1229 002D                  		move.b	oColH(a1),d1			; Get the player's collision height
0000450C 4881                       		ext.w	d1				; Sign extend it
0000450E D242                       		add.w	d2,d1				; Add the Y position to the collision height
00004510 5841                       		addq.w	#4,d1				; Add 4
00004512 9041                       		sub.w	d1,d0				; Subract the result from the Y position
00004514 6200 0000                  		bhi.w	PlatformObject_End		; If it's greater than 0, branch
00004518 0C40 FFF0                  		cmpi.w	#-$10,d0			; Is the result less than -16?
0000451C 6500 0000                  		bcs.w	PlatformObject_End		; If so, branch
00004520 4A38 F8D1                  		tst.b	rDebugMode.w			; Is debug mode active?
00004524 6600 0000                  		bne.w	PlatformObject_End		; If so, branch
00004528 4A29 000C                  		tst.b	oFlags(a1)			; Is the player being carried by another object?
0000452C 6B00 0000                  		bmi.w	PlatformObject_End		; If so, branch
00004530 0C29 000C 0025             		cmpi.b	#$C,oRoutine(a1)		; Is the player dead?
00004536 6400 0000                  		bcc.w	PlatformObject_End		; If so, branch
0000453A D440                       		add.w	d0,d2				; Add the previous result to the Y position
0000453C 5642                       		addq.w	#3,d2				; Add 3
0000453E 3342 0018                  		move.w	d2,oYPos(a1)			; Add to the player's Y position
00004542                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004542                            ; Set the player on top of the object
00004542                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004542                            ; PARAMETERS:
00004542                            ;	a0.l	- Object space pointer
00004542                            ;	a1.l	- Player object space pointer
00004542                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004542                            ; RETURNS:
00004542                            ;	Nothing
00004542                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004542                            RideObject_SetRide:
00004542 0829 0003 0028             		btst	#cStandBit,oStatus(a1)		; Is the player standing on the object?
00004548 6700                       		beq.s	.IsStanding			; If not, branch
0000454A 3669 0000                  		movea.w	oInteract(a1),a3		; Get the object the player is standing on
0000454E 08AB 0003 0028             		bclr	#cStandBit,oStatus(a3)		; Clear its standing on object bit
00004554 4269 0000                  		clr.w	oInteract(a1)			; Clear the player's interact object pointer
00004558                            
00004558                            .IsStanding:
00004558 3348 0000                  		move.w	a0,oInteract(a1)		; Set it as the object the player is standing on
0000455C 4229 0000                  		clr.b	oAngle(a1)			; Clear the player's angle
00004560 4269 001E                  		clr.w	oYVel(a1)			; Clear the player's Y velocity
00004564 3369 001C 0000             		move.w	oXVel(a1),oGVel(a1)		; Set the player's X velocity as its ground velocity
0000456A 08E9 0003 0028             		bset	#cStandBit,oStatus(a1)		; Set the player's standing on object bit
00004570 08E8 0003 0028             		bset	#cStandBit,oStatus(a0)		; Set the player standing on this object bir
00004576 08A9 0001 0028             		bclr	#1,oStatus(a1)			; Clear the player's in midair bit
0000457C 6700                       		beq.s	PlatformObject_End		; If it was already clear, branch
0000457E 2F08                       		move.l	a0,-(sp)			; Store the current object's address
00004580 2049                       		movea.l	a1,a0				; Replace it with the player's address
00004582 6100 E8AA                  		bsr.w	PlayerResetOnFloor		; Reset the player's variables to make it touch the floor
00004586 205F                       		movea.l	(sp)+,a0			; Restore the current object's address
00004588                            
00004588                            PlatformObject_End:
00004588 4E75                       		rts
0000458A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000458A                            ; Set an object as a solid slope and check for collision
0000458A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000458A                            ; PARAMETERS:
0000458A                            ;	d1.w	- Object width
0000458A                            ;	d3.w	- Object height
0000458A                            ;	d4.w	- Object x-axis position
0000458A                            ;	a0.l	- Object space pointer
0000458A                            ;	a2.l	- Slope height data pointer
0000458A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000458A                            ; RETURNS:
0000458A                            ;	See object collision return values above (side and bottom collision doesn't apply here)
0000458A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000458A                            SlopedPlatform:
0000458A 7C00                       		moveq	#0,d6				; Clear collision flag register
0000458C 3278 F86C                  		movea.w	rPlayer1Addr.w,a1		; Get the player RAM
00004590 0828 0003 0028             		btst	#cStandBit,oStatus(a0)		; Is the player standing on the object?
00004596 6700 0000                  		beq.w	SlopedPlarform_ChkCol		; If not branch
0000459A 3401                       		move.w	d1,d2				; Copy the object's width
0000459C D442                       		add.w	d2,d2				; Double it
0000459E 0829 0001 0028             		btst	#1,oStatus(a1)			; Is the player in midair?
000045A4 6600                       		bne.s	.NotOnTop			; If so, branch
000045A6 3029 0014                  		move.w	oXPos(a1),d0			; Get the player's X position
000045AA 9068 0014                  		sub.w	oXPos(a0),d0			; Subtract the object's X position
000045AE D041                       		add.w	d1,d0				; Add width
000045B0 6B00                       		bmi.s	.NotOnTop			; If the player is not colliding, branch
000045B2 B042                       		cmp.w	d2,d0				; Compare with the width
000045B4 6500                       		blo.s	.OnTop				; If the player is not colliding, branch
000045B6                            
000045B6                            .NotOnTop:
000045B6 08A9 0003 0028             		bclr	#cStandBit,oStatus(a1)		; Clear the player's standing on object bit
000045BC 08E9 0001 0028             		bset	#1,oStatus(a1)			; Make the player be in midair
000045C2 08A8 0003 0028             		bclr	#cStandBit,oStatus(a0)		; Clear the player standing on this object bit
000045C8 4269 0000                  		clr.w	oInteract(a1)			; Clear the player's interact object pointer
000045CC 7800                       		moveq	#0,d4				; Set the collision status to 0
000045CE 4E75                       		rts
000045D0                            
000045D0                            .OnTop:
000045D0 3404                       		move.w	d4,d2				; Copy X position
000045D2 6100 0000                  		bsr.w	PlayerMoveOnSlope		; Make the player stand on top of this object
000045D6 7800                       		moveq	#0,d4				; Set the collision status to 0
000045D8 4E75                       		rts
000045DA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000045DA                            SlopedPlarform_ChkCol:
000045DA 4A69 001E                  		tst.w	oYVel(a1)			; Is the player moving up?
000045DE 6B00 FFA8                  		bmi.w	PlatformObject_End		; If so, branch
000045E2 3029 0014                  		move.w	oXPos(a1),d0			; Get the player's X position
000045E6 9068 0014                  		sub.w	oXPos(a0),d0			; Subtract the object's X position
000045EA D041                       		add.w	d1,d0				; Add width
000045EC 6B00 FF9A                  		bmi.w	PlatformObject_End		; If the player is not colliding, branch
000045F0 D241                       		add.w	d1,d1				; Double width
000045F2 B041                       		cmp.w	d1,d0				; Compare with width
000045F4 6400 FF92                  		bcc.w	PlatformObject_End		; If the player is not colliding, branch
000045F8 0828 0000 000D             		btst	#0,oRender(a0)			; Is the object X flipped?
000045FE 6700                       		beq.s	.NoXFlip			; If not, skip
00004600 4640                       		not.w	d0				; Logical notation
00004602 D041                       		add.w	d1,d0				; Add width
00004604                            
00004604                            .NoXFlip:
00004604 E248                       		lsr.w	#1,d0				; Divide by 2 (by shifting right once)
00004606 1632 0000                  		move.b	(a2,d0.w),d3			; Get height of the next segment
0000460A 4883                       		ext.w	d3				; Sign extend to word
0000460C 3028 0018                  		move.w	oYPos(a0),d0			; Get the current object's Y position
00004610 9043                       		sub.w	d3,d0				; Subtract the height from the Y position
00004612 6000 FEF0                  		bra.w	PlatformObject_ChkYRange	; Check the Y range
00004616                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004616                            ; Move the player along a platform/solid object
00004616                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004616                            ; PARAMETERS:
00004616                            ;	d2.w	- X position of the platform
00004616                            ;	d3.w	- Height of the platform
00004616                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004616                            ; RETURNS:
00004616                            ;	Nothing
00004616                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004616                            PlayerMoveOnPtfm:
00004616 3028 0018                  		move.w	oYPos(a0),d0			; Get the current object's Y position
0000461A 9043                       		sub.w	d3,d0				; Subtract height
0000461C 4A29 000C                  		tst.b	oFlags(a1)			; Is the player being carried by another object?
00004620 6B00                       		bmi.s	.End				; If so, branch
00004622 0C29 000C 0025             		cmpi.b	#$C,oRoutine(a1)			; Is the player dead?
00004628 6400                       		bcc.s	.End				; If so, branch
0000462A 4A38 F8D1                  		tst.b	rDebugMode.w			; Is debug mode active?
0000462E 6600                       		bne.s	.End				; If so, branch
00004630 7200                       		moveq	#0,d1
00004632 1229 002D                  		move.b	oColH(a1),d1			; Get the player's collision height
00004636 9041                       		sub.w	d1,d0				; Subtract from the Y position
00004638 3340 0018                  		move.w	d0,oYPos(a1)			; Set as the player's Y position
0000463C 9468 0014                  		sub.w	oXPos(a0),d2			; Subtract the current object's X position from the suggest X position
00004640 9569 0014                  		sub.w	d2,oXPos(a1)			; Subtract the difference from the X position of the player
00004644                            		;tst.b	(Shield_Flag).w			; Does the player have a shield?
00004644                            		;beq.s	.End				; If not branch
00004644                            		;move.w	d0,(Object_Space_7+oY).w	; Apply to the shield's Y position
00004644                            		;sub.w	d2,(Object_Space_7+oX).w	; Apply to the shield's X position
00004644                            
00004644                            .End:
00004644 4E75                       		rts
00004646                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004646                            ; Move the player along a sloped platform/solid object
00004646                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004646                            ; PARAMETERS:
00004646                            ;	d3.w	- Height of the platform
00004646                            ;	d4.w	- X position of the platform
00004646                            ;	a2.l	- Slope height data pointer
00004646                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004646                            ; RETURNS:
00004646                            ;	Nothing
00004646                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004646                            PlayerMoveOnSlope:
00004646 0829 0003 0028             		btst	#cStandBit,oStatus(a1)		; Is the player standing on the object?
0000464C 6700                       		beq.s	.End				; If not, branch
0000464E 3029 0014                  		move.w	oXPos(a1),d0			; Get the player's X position
00004652 9068 0014                  		sub.w	oXPos(a0),d0			; Subtract the current object's X position
00004656 D041                       		add.w	d1,d0				; Add width
00004658 E248                       		lsr.w	#1,d0				; Divide by 2 (by shifting right once)
0000465A 0828 0000 000D             		btst	#0,oRender(a0)			; Is the object X flipped?
00004660 6700                       		beq.s	.NoXFlip			; If not, branch
00004662 4640                       		not.w	d0				; Logical notation on d0
00004664 D041                       		add.w	d1,d0				; Add width
00004666                            
00004666                            .NoXFlip:
00004666 1232 0000                  		move.b	(a2,d0.w),d1			; Get Y offset
0000466A 4881                       		ext.w	d1				; Sign extend to word
0000466C 3028 0018                  		move.w	oYPos(a0),d0			; Get current object's Y position
00004670 9041                       		sub.w	d1,d0				; Subtract the Y offset
00004672 7200                       		moveq	#0,d1
00004674 1229 002D                  		move.b	oColH(a1),d1			; Get the player's collision height
00004678 9041                       		sub.w	d1,d0				; Subtract from the Y position
0000467A 3340 0018                  		move.w	d0,oYPos(a1)			; Set as the player's Y position
0000467E 9468 0014                  		sub.w	oXPos(a0),d2			; Subtract the current object's X position from the suggest X position
00004682 9569 0014                  		sub.w	d2,oXPos(a1)			; Subtract the difference from the X position of the player
00004686                            
00004686                            .End:
00004686 4E75                       		rts
00004688                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004688                            ; Do object collision for the player object
00004688                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004688                            PlayerDoObjCollision:
00004688 4EB8 3ED6                  		jsr	PlayerRingCollision		; Do ring collision
0000468C                            		
0000468C 3428 0014                  		move.w	oXPos(a0),d2			; Get X position
00004690 3628 0018                  		move.w	oYPos(a0),d3			; Get Y position
00004694 5142                       		subq.w	#8,d2				; Get left sensor X
00004696 7A00                       		moveq	#0,d5
00004698 1A28 002D                  		move.b	oColH(a0),d5			; Get collision height
0000469C 5705                       		subq.b	#3,d5				; Subtract 3
0000469E 9645                       		sub.w	d5,d3				; Get left sensor Y
000046A0 383C 0010                  		move.w	#$10,d4				; Get right sensor delta X
000046A4 DA45                       		add.w	d5,d5				; Get right sensor delta Y
000046A6                            
000046A6 49F8 F354                  		lea	rColList.w,a4			; Get collision response list
000046AA 3C1C                       		move.w	(a4)+,d6			; Get count
000046AC 6700                       		beq.s	.End				; If there are no objects to test, branch
000046AE                            
000046AE                            .ObjLoop:
000046AE 325C                       		movea.w	(a4)+,a1			; Get object
000046B0 1029 002A                  		move.b	oColType(a1),d0			; Does touching it do anything?
000046B4 6600                       		bne.s	.ChkPosition			; If so, branch
000046B6                            
000046B6                            .NextObj:
000046B6 5546                       		subq.w	#2,d6				; Decrement count
000046B8 66F4                       		bne.s	.ObjLoop			; Branch if there are still objects to check
000046BA 7000                       		moveq	#0,d0				; Reset d0
000046BC                            
000046BC                            .End:
000046BC 4278 F354                  		clr.w	rColList.w			; Clear the collision response list count
000046C0 4E75                       		rts
000046C2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000046C2                            .ChkPosition:
000046C2 7200                       		moveq	#0,d1
000046C4 1229 002C                  		move.b	oColW(a1),d1			; Get object width
000046C8 3029 0014                  		move.w	oXPos(a1),d0			; Get object X position
000046CC 9041                       		sub.w	d1,d0				; Get left side of object
000046CE 9042                       		sub.w	d2,d0				; Is the player right of the left side of the object?
000046D0 6400                       		bcc.s	.ChkRightSide			; If so, branch
000046D2 D241                       		add.w	d1,d1				; Get right side delta X
000046D4 D041                       		add.w	d1,d0				; Is the player right of the right side of the object?
000046D6 6500                       		bcs.s	.ChkHeight			; If not, branch
000046D8 60DC                       		bra.s	.NextObj			; The player isn't touching the object horizontally; check the next object
000046DA                            
000046DA                            .ChkRightSide:
000046DA B044                       		cmp.w	d4,d0				; Is the player inside the object horizontally?
000046DC 62D8                       		bhi.s	.NextObj			; If not, branch
000046DE                            
000046DE                            .ChkHeight:
000046DE 7200                       		moveq	#0,d1
000046E0 1229 002D                  		move.b	oColH(a1),d1			; Get object height
000046E4 3029 0018                  		move.w	oYPos(a1),d0			; Get object Y position
000046E8 9041                       		sub.w	d1,d0				; Get top of object
000046EA 9043                       		sub.w	d3,d0				; Is the player below the top of the object?
000046EC 6400                       		bcc.s	.ChkBottom			; If so, branch
000046EE D241                       		add.w	d1,d1				; Get bottom delta Y
000046F0 D240                       		add.w	d0,d1				; Is the player below the bottom of the object?
000046F2 6500                       		bcs.s	.ChkType			; If not, branch
000046F4 60C0                       		bra.s	.NextObj			; The player isn't touching the object vertically; check the next object
000046F6                            
000046F6                            .ChkBottom:
000046F6 B045                       		cmp.w	d5,d0				; Is the player inside the object vertically?
000046F8 62BC                       		bhi.s	.NextObj			; If not, branch
000046FA                            
000046FA                            .ChkType:
000046FA 7000                       		moveq	#0,d0
000046FC 1029 002A                  		move.b	oColType(a1),d0			; Get collision type
00004700 4EFB 0000                  		jmp	.CollisionTypes-2(pc,d0.w)	; Go to the appropriate routine
00004704                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004704                            .CollisionTypes:
00004704 6000                       		bra.s	.Enemy				; Enemy
00004706 6000                       		bra.s	.Indestructable			; Indestructable
00004708 6000                       		bra.s	.Monitor			; Monitor
0000470A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000470A                            .Enemy:
0000470A 0C28 0002 0020             		cmpi.b	#2,oAni(a0)			; Are we rolling?
00004710 6600 0000                  		bne.w	.ChkHurt			; If not, branch
00004714                            
00004714                            .ChkBoss:
00004714 4A29 002B                  		tst.b	oHitCnt(a1)			; Do we have a hit count?
00004718 6700                       		beq.s	.Kill				; If not, branch
0000471A 4468 001C                  		neg.w	oXVel(a0)			; Bounce backwards
0000471E 4468 001E                  		neg.w	oYVel(a0)			; ''
00004722 4229 002A                  		clr.b	oColType(a1)			; Indicate that we have hit the boss
00004726 5329 002B                  		subq.b	#1,oHitCnt(a1)			; Decrement hit count
0000472A 6600                       		bne.s	.BossEnd			; If it hasn't reached 0, branch
0000472C 08E9 0007 0028             		bset	#7,oStatus(a1)			; Set the "killed" flag
00004732                            
00004732                            .BossEnd:
00004732 4E75                       		rts
00004734                            
00004734                            .Kill:
00004734 08E9 0007 0028             		bset	#7,oStatus(a1)			; Set the "killed" flag
0000473A 22BC 0000 0000             		move.l	#ObjExplosion,oAddr(a1)		; Change into an explosion
00004740 4229 002A                  		clr.b	oColType(a1)			; Indicate that we have hit the boss
00004744 4229 0025                  		clr.b	oRoutine(a1)			; Reset the routine ID
00004748 4A68 001E                  		tst.w	oYVel(a0)			; Are we going up?
0000474C 6B00                       		bmi.s	.MoveDown			; If so, branch
0000474E 3028 0018                  		move.w	oYPos(a0),d0			; Are we below the object?
00004752 B069 0018                  		cmp.w	oYPos(a1),d0			; ''
00004756 6400                       		bhs.s	.MoveUp				; If so, branch
00004758 4468 001E                  		neg.w	oYVel(a0)			; Bounce up
0000475C 4E75                       		rts
0000475E                            
0000475E                            .MoveDown:
0000475E 0668 0100 001E             		addi.w	#$100,oYVel(a0)			; Move down
00004764 4E75                       		rts
00004766                            
00004766                            .MoveUp:
00004766 0468 0100 001E             		subi.w	#$100,oYVel(a0)			; Move up
0000476C 4E75                       		rts
0000476E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000476E                            .Indestructable:
0000476E 6000                       		bra.s	.ChkHurt			; Get hurt
00004770                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004770                            .Monitor:
00004770 3028 001E                  		move.w	oYVel(a0),d0			; Get Y velocity
00004774 6A00                       		bpl.s	.ChkDestroy			; If it's falling or staying still, branch
00004776 3028 0018                  		move.w	oYPos(a0),d0			; Get player's Y position
0000477A 0440 0010                  		subi.w	#$10,d0				; Subtract 16
0000477E B069 0018                  		cmp.w	oYPos(a1),d0			; Is the plyaer hitting the bottom of the object?
00004782 6500                       		blo.s	.MonitorEnd			; If not, branch
00004784 337C FE80 001E             		move.w	#-$180,oYVel(a1)		; Bounce the monitor up
0000478A 4A29 0000                  		tst.b	oMonFall(a1)			; Is it already falling?
0000478E 6600                       		bne.s	.MonitorEnd			; If so, branch
00004790 50E9 0000                  		st	oMonFall(a1)			; Set the fall flag
00004794 4E75                       		rts
00004796                            
00004796                            .ChkDestroy:
00004796 0C28 0002 0020             		cmpi.b	#2,oAni(a0)			; Are we rolling?
0000479C 6600                       		bne.s	.MonitorEnd			; If not, branch
0000479E 4468 001E                  		neg.w	oYVel(a0)			; Bounce up
000047A2 22BC 0000 0000             		move.l	#ObjMonitorBreakOpen,oAddr(a1)	; Set to destroyed routine
000047A8                            		
000047A8                            .MonitorEnd:
000047A8 4E75                       		rts
000047AA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000047AA                            .ChkHurt:
000047AA 4A68 0000                  		tst.w	oInvulTime(a0)			; Are we invulnerable?
000047AE 6600                       		bne.s	.NoHurt				; If so, branch
000047B0 2449                       		movea.l	a1,a2				; Copy harmful object's pointer
000047B2 4EF9 0000 0000             		jmp	ObjPlayer_GetHurt		; Get hurts
000047B8                            
000047B8                            .NoHurt:
000047B8 4E75                       		rts
000047BA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000047BA                            ; Add a new entry to the collision response list
000047BA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000047BA                            AddToColResponse:
000047BA 43F8 F354                  		lea	rColList.w,a1			; Get collision response list
000047BE 0C51 007E                  		cmpi.w	#$7E,(a1)			; Is it full?
000047C2 6400                       		bhs.s	.End				; If so, branch
000047C4 5451                       		addq.w	#2,(a1)				; Add a new entry
000047C6 D2D1                       		adda.w	(a1),a1				; Get entry pointer
000047C8 3288                       		move.w	a0,(a1)				; Store entry
000047CA                            
000047CA                            .End:
000047CA 4E75                       		rts
000047CC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000047CC                            ; Save some info in a level (mainly for checkpoints)
000047CC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000047CC                            ; PARAMETERS:
000047CC                            ;	a0.l	- Object space pointer
000047CC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000047CC                            ; RETURNS:
000047CC                            ;	Nothing
000047CC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000047CC                            Level_SaveInfo:
000047CC 31E8 0014 C7B0             		move.w	oXPos(a0),rSavedXPos.w		; Save X position
000047D2 31E8 0018 C7B2             		move.w	oYPos(a0),rSavedYPos.w		; Save Y position
000047D8 4E75                       		rts
000047DA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000047DA                            ; Load some info in a level (mainly for checkpoints)
000047DA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000047DA                            ; PARAMETERS:
000047DA                            ;	a0.l	- Object space pointer
000047DA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000047DA                            ; RETURNS:
000047DA                            ;	Nothing
000047DA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000047DA                            Level_LoadSavedInfo:
000047DA 3178 C7B0 0014             		move.w	rSavedXPos.w,oXPos(a0)		; Load X position
000047E0 3178 C7B2 0018             		move.w	rSavedYPos.w,oYPos(a0)		; Load Y position
000047E6 4E75                       		rts
000047E8                            ; =========================================================================================================================================================
000047E8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000047E8                            ; Music IDs
000047E8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000047E8                            Level_MusicIDs:
000047E8 0B0B                       		dc.b	mWWZ, mWWZ
000047EA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000047EA                            ; Level water heights (-1 for no water)
000047EA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000047EA                            Level_WaterLevels:
000047EA                            		;dc.w	$490, -1			; Wacky Workbench
000047EA FFFF FFFF                  		dc.w	-1, -1
000047EE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000047EE                            ; Level data pointers
000047EE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000047EE                            ; FORMAT:
000047EE                            ;	dc.l	CHUNKS, BLOCKS, TILES, PALETTE
000047EE                            ;	dc.l	LAYOUT, OBJECTS, RINGS, COLLISION
000047EE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000047EE                            Level_DataPointers:
000047EE 0000 0000 0000 0000 0000+  		dc.l	WWZ_Chunks, WWZ_Blocks,  WWZ_Tiles, WWZ_Pal
000047FE 0000 0000 0000 0000 0000+  		dc.l	WWZ_Layout, WWZ_Objects, WWZ_Rings, WWZ_Collision
0000480E 0000 0000 0000 0000 0000+  		dc.l	WWZ_Chunks, WWZ_Blocks,  WWZ_Tiles, WWZ_Pal
0000481E 0000 0000 0000 0000 0000+  		dc.l	WWZ_Layout, WWZ_Objects, WWZ_Rings, WWZ_Collision
0000482E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000482E                            ; Size and start position data
0000482E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000482E                            Level_SizeStartPos:
0000482E 3000 0580                  		dc.w	$3000, $580
00004832                            		incbin	"Zones/Wacky Workbench/Start Position.bin"
00004836 3000 0580                  		dc.w	$3000, $580
0000483A                            		incbin	"Zones/Wacky Workbench/Start Position.bin"
0000483E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000483E                            ; Dynamic events routines
0000483E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000483E                            Level_DynEvenRouts:
0000483E 0000 0000                  		dc.l	DynEv_WWZ			; Wacky Workbench
00004842 0000 0000                  		dc.l	DynEv_WWZ
00004846                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004846                            ; Wacky Workbench dynamic events routine
00004846                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004846                            DynEv_WWZ:
00004846 7000                       		moveq	#0,d0
00004848 1038 F8FE                  		move.b	rDynEvRout.w,d0
0000484C 303B 0000                  		move.w	.Index(pc,d0.w),d0
00004850 4EFB 0000                  		jmp	.Index(pc,d0.w)
00004854                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004854                            .Index:
00004854 0000                       		dc.w	.WaitBoss-.Index
00004856 0000                       		dc.w	.Done-.Index
00004858                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004858                            .WaitBoss:
00004858 0C78 2EE0 F880             		cmpi.w	#$2EE0,rCamXPos.w
0000485E 6D00                       		blt.s	.Done
00004860 31FC 0340 F8CA             		move.w	#$340,rMinCamY.w
00004866 31FC 0340 F8BE             		move.w	#$340,rDestMaxY.w
0000486C 31FC 2EE0 F8C8             		move.w	#$2EE0,rMinCamX.w
00004872 31FC 2EE0 F8C0             		move.w	#$2EE0,rMaxCamX.w
00004878 5438 F8FE                  		addq.b	#2,rDynEvRout.w
0000487C                            
0000487C                            .Done:
0000487C 4E75                       		rts
0000487E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000487E                            ; Palette cycle routines
0000487E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000487E                            Level_PalCycRouts:
0000487E 0000 0000                  		dc.l	PalCycle_WWZ			; Wacky Workbench
00004882 0000 0000                  		dc.l	PalCycle_WWZ
00004886                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004886                            ; Wacky Workbench palette cycle routine
00004886                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004886                            PalCycle_WWZ:
00004886 4A38 F8FF                  		tst.b	rFloorActive.w		; Is the floor active?
0000488A 6600                       		bne.s	.Flash				; If so, branch
0000488C                            
0000488C 5378 F900                  		subq.w	#1,rFloorTimer.w		; Decrement the floor timer
00004890 6A00                       		bpl.s	.ResetPal			; If it hasn't run out, branch
00004892 50F8 F8FF                  		st	rFloorActive.w		; Set the floor active flag
00004896 31FC 00B4 F900             		move.w	#180,rFloorTimer.w		; Set the floor timer
0000489C                            
0000489C                            .ResetPal:
0000489C 4278 C7CE                  		clr.w	rPalCycTimer.w		; Reset the palette cycle
000048A0 31FC 0C28 9930             		move.w	#$C28,(rPalette+$62).w		; Set the floor color to be deactivated
000048A6 31FC 0E48 98B0             		move.w	#$E48,(rWaterPal+$62).w	; ''
000048AC 4E75                       		rts
000048AE                            
000048AE                            .Flash:
000048AE 5378 F900                  		subq.w	#1,rFloorTimer.w		; Decrement the floor timer
000048B2 6A00                       		bpl.s	.UpdatePal			; If it hasn't run out, branch
000048B4 4238 F8FF                  		clr.b	rFloorActive.w		; Clear the floor active flag
000048B8 31FC 001E F900             		move.w	#30,rFloorTimer.w		; Set the floor timer
000048BE                            
000048BE                            .UpdatePal:
000048BE 5338 C7CE                  		subq.b	#1,rPalCycTimer.w		; Decrement the palette cycle timer
000048C2 6A00                       		bpl.s	.End				; If it hasn't run out, branch
000048C4 11FC 0001 C7CE             		move.b	#1,rPalCycTimer.w		; Reset the palette cycle timer
000048CA                            
000048CA 7000                       		moveq	#0,d0
000048CC 1038 C7CF                  		move.b	rPalCycIndex.w,d0		; Get the palette cycle index
000048D0 D040                       		add.w	d0,d0				; Turn into offset
000048D2                            							; Set the floor color
000048D2 31FB 0000 9930             		move.w	PalCyc_WWZFloor(pc,d0.w),(rPalette+$62).w
000048D8 31FB 0000 98B0             		move.w	PalCyc_WWZFloorUW(pc,d0.w),(rWaterPal+$62).w
000048DE                            
000048DE 5238 C7CF                  		addq.b	#1,rPalCycIndex.w		; Increment the palette cycle index
000048E2 0C38 0005 C7CF             		cmpi.b	#5,rPalCycIndex.w		; Has it reached the end of the cycle?
000048E8 6500                       		bcs.s	.End				; If not, branch
000048EA 4238 C7CF                  		clr.b	rPalCycIndex.w		; Reset the palette cycle index
000048EE                            
000048EE                            .End:
000048EE 4E75                       		rts
000048F0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000048F0                            PalCyc_WWZFloor:
000048F0 0C28 0000 00EE 0000 0EEE   		dc.w	$C28, $000, $0EE, $000, $EEE
000048FA                            PalCyc_WWZFloorUW:
000048FA 0E48 0220 02EE 0220 0EEE   		dc.w	$E48, $220, $2EE, $220, $EEE
00004904                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004904                            ; Animated art routines
00004904                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004904                            Level_AniArtRouts:
00004904 0000 0000                  		dc.l	AniArt_WWZ			; Wacky Workbench
00004908 0000 0000                  		dc.l	AniArt_WWZ
0000490C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000490C                            ; Wacky Workbench animated art routine
0000490C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000490C                            AniArt_WWZ:
0000490C 45FA 0000                  		lea	.AniData(pc),a2			; Tutorial animated art data
00004910 6000 F81E                  		bra.w	AniArt_DoAnimate		; Handle animations
00004914                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004914                            .AniData:
00004914 0002                       		dc.w	2
00004916                            
00004916                            		lvlAniDat 3, ArtUnc_Electricity, $162, 4, 8
00004916 0000 0000                M 	dc.l	(3&$ff)<<24|artunc_electricity
0000491A 2C40                     M 	dc.w	(($162&$7ff)<<5)
0000491C 0408                     M 	dc.b	4,8
0000491E 0008 1018                  		dc.b	0, 8, $10, $18
00004922                            
00004922                            		lvlAniDat 1, ArtUnc_ElectricOrbs, $15E, $E, 4
00004922 0000 0000                M 	dc.l	(1&$ff)<<24|artunc_electricorbs
00004926 2BC0                     M 	dc.w	(($15e&$7ff)<<5)
00004928 0E04                     M 	dc.b	$e,4
0000492A 0004 0400 0404 0804 0408+  		dc.b	0, 4, 4, 0, 4, 4, 8, 4, 4, 8, $C, 4, 4, $C
00004938                            
00004938                            		lvlAniDat 4, ArtUnc_Sirens, $A8, 8, 4
00004938 0000 0000                M 	dc.l	(4&$ff)<<24|artunc_sirens
0000493C 1500                     M 	dc.w	(($a8&$7ff)<<5)
0000493E 0804                     M 	dc.b	8,4
00004940 0004 0408 0C0C 0C0C        		dc.b	0, 4, 4, 8, $C, $C, $C, $C
00004948                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004948                            ; Level drawing initialization and update routines
00004948                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004948                            ; PARAMETERS:
00004948                            ;	a1.l	- Camera RAM
00004948                            ;	a3.l	- Row plane buffer
00004948                            ;	a4.l	- Column plane buffer
00004948                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004948                            ; RETURNS:
00004948                            ;	Nothing
00004948                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004948                            Level_RenderRouts:
00004948 0000 27CC                  		dc.l	General_InitFG			; Wacky Workbench
0000494C 0000 0000                  		dc.l	WWZ_InitBG
00004950 0000 27EC                  		dc.l	General_UpdateFG
00004954 0000 0000                  		dc.l	WWZ_UpdateBG
00004958 0000 27CC                  		dc.l	General_InitFG
0000495C 0000 0000                  		dc.l	WWZ_InitBG
00004960 0000 27EC                  		dc.l	General_UpdateFG
00004964 0000 0000                  		dc.l	WWZ_UpdateBG
00004968                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004968                            ; Wacky Workbench background initialization
00004968                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004968                            WWZ_InitBG:
00004968 45F8 F880                  		lea	rFGCam.w,a2			; Get foreground camera RAM
0000496C 302A 0008                  		move.w	cYPos(a2),d0			; Get foreground Y position
00004970 E440                       		asr.w	#2,d0				; Divide by $20
00004972 3340 0008                  		move.w	d0,cYPos(a1)			; Set as background Y position
00004976                            
00004976 6100 E18E                  		bsr.w	Level_RefreshPlane		; Refresh the plane
0000497A                            
0000497A 47FA 0000                  		lea	WWZ_Scroll(pc),a3		; Get background scroll data
0000497E 6000 E1E6                  		bra.w	ScrollSections			; Scroll the planes
00004982                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004982                            ; Wacky Workbench background update
00004982                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004982                            WWZ_UpdateBG:
00004982 45F8 F880                  		lea	rFGCam.w,a2			; Get foreground camera RAM
00004986 302A 0008                  		move.w	cYPos(a2),d0			; Get foreground Y position
0000498A E440                       		asr.w	#2,d0				; Divide by $20
0000498C 3340 0008                  		move.w	d0,cYPos(a1)			; Set as background Y position
00004990                            
00004990 6100 E1C6                  		bsr.w	Level_ChkRedrawPlane		; Check if the plane needs to be redrawn
00004994 781F                       		moveq	#(512/16)-1,d4			; Number of blocks per column
00004996 6100 DF66                  		bsr.w	Level_UpdatePlaney		; Update the plane
0000499A                            
0000499A 47FA 0000                  		lea	WWZ_Scroll(pc),a3		; Get background scroll data
0000499E 6000 E1C6                  		bra.w	ScrollSections			; Scroll the planes
000049A2                            ; --------------------------------------------------------------------------------------------------------------------------------------
000049A2                            		scrollInit WWZ_Scroll
000049A2                          M scroll_label	equs	"wwz_scroll"
000049A2 0000                     M wwz_scroll:	dc.w	((wwz_scroll_end-wwz_scroll-2)/6)-1
000049A4                            
000049A4                            		; CEILING LIGHTS
000049A4                            		scrollSection	 48, $80
000049A4 0080 0000 0030           M 	dc.w	$80,0,48
000049AA                            		scrollSection	 32, $60
000049AA 0060 0000 0020           M 	dc.w	$60,0,32
000049B0                            		scrollSection	 32, $50
000049B0 0050 0000 0020           M 	dc.w	$50,0,32
000049B6                            		scrollSection	 24, $40
000049B6 0040 0000 0018           M 	dc.w	$40,0,24
000049BC                            		scrollSection	 24, $38
000049BC 0038 0000 0018           M 	dc.w	$38,0,24
000049C2                            		scrollSection	 16, $30
000049C2 0030 0000 0010           M 	dc.w	$30,0,16
000049C8                            		scrollSection	 16, $2C
000049C8 002C 0000 0010           M 	dc.w	$2c,0,16
000049CE                            		scrollSection	 16, $28
000049CE 0028 0000 0010           M 	dc.w	$28,0,16
000049D4                            		scrollSection	 16, $24
000049D4 0024 0000 0010           M 	dc.w	$24,0,16
000049DA                            		scrollSection	 16, $20
000049DA 0020 0000 0010           M 	dc.w	$20,0,16
000049E0                            
000049E0                            		; BACK WALL
000049E0                            		scrollSection	160, $40
000049E0 0040 0000 00A0           M 	dc.w	$40,0,160
000049E6                            
000049E6                            		; FRONT WALL
000049E6                            		scrollSection	368, $80
000049E6 0080 0000 0170           M 	dc.w	$80,0,368
000049EC                            
000049EC                            		scrollEnd
000049EC                          M wwz_scroll_end:
000049EC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049EC                            ; Main level PLCs
000049EC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000049EC                            PLC_LevelMain:
000049EC 000A                       		dc.w	$A
000049EE 0000 0000                  		dc.l	ArtKosM_Chkpoint
000049F2 AFC0                       		dc.w	$AFC0
000049F4 0000 0000                  		dc.l	ArtKosM_Monitor
000049F8 B100                       		dc.w	$B100
000049FA 0000 0000                  		dc.l	ArtKosM_SpringH
000049FE B740                       		dc.w	$B740
00004A00 0000 0000                  		dc.l	ArtKosM_SpringV
00004A04 B940                       		dc.w	$B940
00004A06 0000 0000                  		dc.l	ArtKosM_SpringD
00004A0A BB20                       		dc.w	$BB20
00004A0C 0000 0000                  		dc.l	ArtKosM_HUD
00004A10 D000                       		dc.w	$D000
00004A12 0000 0000                  		dc.l	ArtKosM_WaterSurface
00004A16 D200                       		dc.w	$D200
00004A18 0000 0000                  		dc.l	ArtKosM_SpikesN
00004A1C D500                       		dc.w	$D500
00004A1E 0000 0000                  		dc.l	ArtKosM_SpikesS
00004A22 D580                       		dc.w	$D580
00004A24 0000 0000                  		dc.l	ArtKosM_RingSparkle
00004A28 D700                       		dc.w	$D700
00004A2A 0000 0000                  		dc.l	ArtKosM_Explosion
00004A2E D800                       		dc.w	$D800
00004A30                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A30                            ; Level PLCs
00004A30                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A30                            Level_PLCs:
00004A30 0000 0000                  		dc.l	PLC_WWZ
00004A34 0000 0000                  		dc.l	PLC_WWZ
00004A38                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A38                            ; Wacky Workbench PLCs
00004A38                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A38                            PLC_WWZ:
00004A38 0000                       		dc.w	0
00004A3A 0000 0000                  		dc.l	ArtKosM_Bumper
00004A3E 6B60                       		dc.w	$6B60
00004A40                            	;	dc.l	ArtKosM_Orbinaut
00004A40                            	;	dc.w	$71A0
00004A40                            	;	dc.l	ArtKosM_Diamond
00004A40                            	;	dc.w	$7580
00004A40                            	;	dc.l	ArtKosM_CNZBarrel
00004A40                            	;	dc.w	$7A00
00004A40                            	;	dc.l	ArtKosM_Slicer
00004A40                            	;	dc.w	$8000
00004A40                            	;	dc.l	ArtKosM_ShlCrker
00004A40                            	;	dc.w	$8400
00004A40                            	;	dc.l	ArtKosM_Asteron
00004A40                            	;	dc.w	$8880
00004A40                            	;	dc.l	ArtKosM_Harpoon
00004A40                            	;	dc.w	$8A60
00004A40                            	;	dc.l	ArtKosM_WFZBoss
00004A40                            	;	dc.w	$9000
00004A40                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A40                            ; Object index
00004A40                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A40                            Level_ObjIndex:
00004A40 0000 0000                  		dc.l	ObjMonitor
00004A44 0000 0000                  		dc.l	ObjSpike
00004A48 0000 0000                  		dc.l	ObjSpring
00004A4C 0000 0000                  		dc.l	ObjCheckpoint
00004A50 0000 0000                  		dc.l	ObjNull			;ObjSlicer
00004A54 0000 0000                  		dc.l	ObjNull			;ObjShlCrker
00004A58 0000 0000                  		dc.l	ObjNull			;ObjAsteron
00004A5C 0000 0000                  		dc.l	ObjNull			;ObjWFZBoss
00004A60 0000 0000                  		dc.l	ObjWallSpring
00004A64 0000 0000                  		dc.l	ObjNull			;ObjHarpoon
00004A68 0000 0000                  		dc.l	ObjBallMode
00004A6C 0000 0000                  		dc.l	ObjBumper
00004A70 0000 0000                  		dc.l	ObjNull			;ObjCNZBarrel
00004A74 0000 0000                  		dc.l	ObjNull			;ObjDiamond
00004A78 0000 0000                  		dc.l	ObjNull			;ObjOrbinaut
00004A7C                            
00004A7C                            ; =========================================================================================================================================================
00004A7C                            		include	"Opmodes/Ending/Main.asm"
00004A7C                            ; =========================================================================================================================================================
00004A7C                            ; End splash screen
00004A7C                            ; =========================================================================================================================================================
00004A7C                            
00004A7C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A7C                            Ending:
00004A7C 60FE                       		bra.s	Ending
00004A7E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A7E                            ;		playSnd	#Mus_Stop, 1			; Stop sound
00004A7E                            ;
00004A7E                            ;		intsOff					; Disable interrupts
00004A7E                            ;
00004A7E                            ;		lea	VDP_CTRL,a5
00004A7E                            ;		move.w	#$8004,(a5)			; $8004 - Disable H-INT, H/V Counter
00004A7E                            ;		move.w	#$8134,(a5)			; $8134 - Disable display, enable V-INT, enable DMA, V28
00004A7E                            ;		move.w	#$8230,(a5)			; $8230 - Plane A at $C000
00004A7E                            ;		move.w	#$8407,(a5)			; $8407 - Plane B at $E000
00004A7E                            ;		move.w	#$9001,(a5)			; $9001 - 64x32 cell plane area
00004A7E                            ;		move.w	#$9200,(a5)			; $9200 - Window V position at default
00004A7E                            ;		move.w	#$8B00,(a5)			; $8B03 - V-Scroll by screen, H-Scroll by screen
00004A7E                            ;		move.w	#$8700,(a5)			; $8700 - BG color pal 0 color 0
00004A7E                            ;		clr.w	rDMAQueue.w			; Set stop token at the beginning of the DMA queue
00004A7E                            ;		move.w	#rDMAQueue,rDMASlot.w	; Reset the DMA queue slot
00004A7E                            ;
00004A7E                            ;		jsr	ClearScreen.w			; Clear screen
00004A7E                            ;
00004A7E                            ;		lea	MapEni_End(pc),a0		; Decompress background mappings
00004A7E                            ;		lea	rBuffer,a1			; Decompress into RAM
00004A7E                            ;		moveq	#1,d0				; Base tile properties: Tile ID 1, no flags
00004A7E                            ;		jsr	EniDec.w			; Decompress!
00004A7E                            ;
00004A7E                            ;		lea	rBuffer,a1			; Load mappings
00004A7E                            ;		move.l	#$60000003,d0			; At (0, 0) on plane A
00004A7E                            ;		moveq	#$27,d1				; $28x$1C tiles
00004A7E                            ;		moveq	#$1B,d2				; ''
00004A7E                            ;		moveq	#0,d3				; Base tile properties: Tile ID 0, no flags
00004A7E                            ;		jsr	LoadPlaneMap.w			; Load the map
00004A7E                            ;
00004A7E                            ;		lea	ArtKosM_End,a1			; Load background art
00004A7E                            ;		move.w	#$20,d2				; ''
00004A7E                            ;		jsr	QueueKosMData.w			; ''
00004A7E                            ;
00004A7E                            ;.WaitPLCs:
00004A7E                            ;		move.b	#vGeneral,rVINTRout.w		; Level load V-INT routine
00004A7E                            ;		jsr	ProcessKos.w			; Process Kosinski queue
00004A7E                            ;		jsr	VSync_Routine.w			; V-SYNC
00004A7E                            ;		jsr	ProcessKosM.w			; Process Kosinski Moduled queue
00004A7E                            ;		tst.b	rKosPMMods.w			; Are there still modules left?
00004A7E                            ;		bne.s	.WaitPLCs			; If so, branch
00004A7E                            ;		move.b	#vGeneral,rVINTRout.w		; Level load V-INT routine
00004A7E                            ;		jsr	VSync_Routine.w			; V-SYNC
00004A7E                            ;
00004A7E                            ;		lea	SampleList+$F0,a3
00004A7E                            ;		jsr	PlayDAC1
00004A7E                            ;
00004A7E                            ;		lea	Pal_End(pc),a0			; Load palette to target buffer
00004A7E                            ;		move.w	#(Pal_End_End-Pal_End)>>1-1,d0	; ''
00004A7E                            ;		jsr	LoadPalette.w			; ''
00004A7E                            ;
00004A7E                            ;		displayOn
00004A7E                            ;
00004A7E                            ;.Loop:
00004A7E                            ;		move.b	#vTitle,rVINTRout.w		; V-SYNC
00004A7E                            ;		jsr	VSync_Routine.w			; ''
00004A7E                            ;		bra.s	.Loop
00004A7E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A7E                            ; Art
00004A7E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A7E                            ;ArtKosM_End:
00004A7E                            ;		incbin	"Ending/Data/Art - Background.kosm.bin"
00004A7E                            ;		even
00004A7E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A7E                            ; Plane mappings
00004A7E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A7E                            ;MapEni_End:
00004A7E                            ;		incbin	"Ending/Data/Map - Background.eni.bin"
00004A7E                            ;		even
00004A7E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A7E                            ; Palette
00004A7E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A7E                            ;Pal_End:
00004A7E                            ;		incbin	"Ending/Data/Palette.pal.bin"
00004A7E                            ;Pal_End_End:
00004A7E                            ;		even
00004A7E                            ; =========================================================================================================================================================
00004A7E                            
00004A7E                            ; =========================================================================================================================================================
00004A7E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A7E                            ; Object Code
00004A7E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A7E                            ObjNull:
00004A7E 4EF8 1A72                  		jmp	DeleteObject
00004A82                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A82                            		include	"Objects/Player/Code.asm"		; Player object
00004A82                            ; =========================================================================================================================================================
00004A82                            ; Sonic object
00004A82                            ; =========================================================================================================================================================
00004A82 =00000600                  TOP_SPD		EQU	$600				; Top speed
00004A82 =0000000C                  ACC_SPD		EQU	$C				; Acceleration
00004A82 =00000080                  DEC_SPD		EQU	$80				; Deceleration
00004A82 =00000680                  JUMP_HEIGHT	EQU	$680				; Jump height
00004A82 =00000400                  MIN_JMP_HEIGHT	EQU	$400				; Minimum jump height
00004A82                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A82                            		rsset	oLvlSSTs
00004A82 =00000030                  oInitColH	rs.b	1				; Initial collision height
00004A82 =00000031                  oInitColW	rs.b	1				; Initial collision width
00004A82 =00000032                  oTopSolid	rs.b	1				; Top solid bit
00004A82 =00000033                  oLRBSolid	rs.b	1				; LRB solid bit
00004A82 =00000034                  oTopSpd		rs.w	1				; Top speed
00004A82 =00000036                  oAcc		rs.w	1				; Acceleration
00004A82 =00000038                  oDec		rs.w	1				; Deceleration
00004A82 =0000003A                  oFlipDir	rs.w	0				; Flip direction
00004A82 =0000003A                  oGVel		rs.w	1				; Ground velocity
00004A82 =0000003C                  oInteract	rs.w	1				; Interacted object space pointer
00004A82 =0000003E                  oAirTimer	rs.b	1				; Air timer
00004A82 =0000003F                  oMoveLock	rs.b	1				; Move lock timer
00004A82 =00000040                  oJumping	rs.b	1				; Jumping flag
00004A82 =00000041                  oAngle		rs.b	1				; Angle
00004A82 =00000042                  oInvulTime	rs.b	1				; Invulnerability timer
00004A82 =00000043                  oDeathTimer	rs.b	1				; Death timer
00004A82 =00000044                  oScrlDelay	rs.b	1				; Look up and down scroll delay counter
00004A82 =00000045                  oDashFlag	rs.b	1				; Dash flags
00004A82 =00000046                  oDashTimer	rs.b	1				; Dash timer
00004A82 =00000047                  oFlipAngle	rs.b	1				; Flip angle about the X axis
00004A82 =00000048                  oFlipTurned	rs.b	1				; Inverted flip flag
00004A82 =00000049                  oFlipRemain	rs.b	1				; Remaining flips to do
00004A82 =0000004A                  oFlipSpeed	rs.b	1				; Flip speed
00004A82 =0000004B                  oBallMode	rs.b	1				; Ball mode flag
00004A82 =0000004C                  oHangAniTime	rs.b	1				; Hang animation timer
00004A82                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A82                            ObjPlayer:
00004A82 7000                       		moveq	#0,d0
00004A84 1028 0025                  		move.b	oRoutine(a0),d0			; Get routine ID
00004A88 4EBB 0000                  		jsr	.Index(pc,d0.w)			; Jump to it
00004A8C                            	nextObject
00004A8C 3068 0004                M 	movea.w	onext(a0),a0
00004A90 2250                     M 	move.l	oaddr(a0),a1
00004A92 4ED1                     M 	jmp	(a1)
00004A94                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004A94                            .Index:
00004A94 6000 0000                  		bra.w	ObjPlayer_Init			; Initialization(00)
00004A98 6000 0000                  		bra.w	ObjPlayer_Main			; Main		(04)
00004A9C 6000 0000                  		bra.w	ObjPlayer_Hurt			; Hurt		(08)
00004AA0 6000 0000                  		bra.w	ObjPlayer_Dead			; Dead		(0C)
00004AA4 6000 0000                  		bra.w	ObjPlayer_Gone			; Gone		(10)
00004AA8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004AA8                            ; Initialization routine
00004AA8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004AA8                            ObjPlayer_Init:
00004AA8 5828 0025                  		addq.b	#4,oRoutine(a0)			; Next routine
00004AAC                            
00004AAC 117C 0009 002C             		move.b	#9,oColW(a0)			; Collision width
00004AB2 117C 0013 002D             		move.b	#$13,oColH(a0)			; Collision height
00004AB8 1168 002C 0031             		move.b	oColW(a0),oInitColW(a0)		; Set initial collision width
00004ABE 1168 002D 0030             		move.b	oColH(a0),oInitColH(a0)		; Set initial collision height
00004AC4 217C 0000 0000 0010        		move.l	#Map_ObjPlayer,oMap(a0)		; Mappings
00004ACC 317C 0780 000E             		move.w	#$780,oVRAM(a0)			; Sprite tile properties
00004AD2                            	displaySprite	2,a0,a1,0			; Priority
00004AD2 317C BE6A 0008           M 	move.w	#rdispinput+(2*dsize),odrawnext(a0)
00004AD8 3278 BE74                M 	move.w	rdispinput+dprev+(2*dsize).w,a1
00004ADC 3149 000A                M 	move.w	a1,odrawprev(a0)
00004AE0 3348 0008                M 	move.w	a0,odrawnext(a1)
00004AE4 31C8 BE74                M 	move.w	a0,rdispinput+dprev+(2*dsize).w
00004AE8                          M .no_205
00004AE8 117C 0018 0017             		move.b	#$18,oDrawW(a0)			; Sprite width
00004AEE 117C 0018 001B             		move.b	#$18,oDrawH(a0)			; Sprite height
00004AF4 117C 0004 000D             		move.b	#4,oRender(a0)			; Render flags
00004AFA                            
00004AFA 117C 000C 0032             		move.b	#$C,oTopSolid(a0)		; Top solid bit
00004B00 117C 000D 0033             		move.b	#$D,oLRBSolid(a0)		; LRB solid bit
00004B06 117C 001E 003E             		move.b	#$1E,oAirTimer(a0)		; Set air timer
00004B0C 50D0                       		st	oPrevDPLC(a0)			; Reset saved DPLC frame
00004B0E 4228 0049                  		clr.b	oFlipRemain(a0)			; No flips remaining
00004B12 117C 0004 004A             		move.b	#4,oFlipSpeed(a0)		; Flip speed
00004B18                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B18                            ; Main routine
00004B18                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B18                            ObjPlayer_Main:
00004B18 4A38 C768                  		tst.b	rMoveCheat.w
00004B1C 6700                       		beq.s	.NoPlacementEnter
00004B1E 0838 0004 C741             		btst	#4,rP1Press.w			; Has the B button been pressed?
00004B24 6700                       		beq.s	.NoPlacementEnter		; If not, branch
00004B26 11FC 0001 F8D1             		move.b	#1,rDebugMode.w		; Enable debug placement mode
00004B2C 20BC 0000 0000             		move.l	#DebugPlacement,oAddr(a0)	; Set to debug placement mode
00004B32 4E75                       		rts
00004B34                            
00004B34                            .NoPlacementEnter:
00004B34 0828 0002 000C             		btst	#2,oFlags(a0)			; Are the controls locked?
00004B3A 6600                       		bne.s	.Update				; If so, branch
00004B3C 31F8 C740 F8D4             		move.w	rP1Data.w,rCtrl.w		; Set the player's control data
00004B42                            
00004B42                            .Update:
00004B42                            	;	btst	#1,oStatus(a0)
00004B42                            	;	bne.s	.NotOnGround
00004B42                            
00004B42                            ;.NotOnGround:
00004B42 6100 0000                  		bsr.w	ObjPlayer_Water			; Handle Sonic in water
00004B46 6100 0000                  		bsr.w	ObjPlayer_GetPhysics		; Update Sonic's physics
00004B4A 6100 0000                  		bsr.w	ObjPlayer_DoModes		; Do modes
00004B4E 6100 0000                  		bsr.w	ObjPlayer_LvlBound		; Handle level boundaries
00004B52 4EB8 4688                  		jsr	PlayerDoObjCollision		; Do object collision
00004B56                            
00004B56 6100 0000                  		bsr.w	ObjPlayer_Animate		; Animate sprite
00004B5A 6100 0000                  		bsr.w	ObjPlayer_Display		; Display sprite
00004B5E 6000 0000                  		bra.w	ObjPlayer_LoadDPLCs		; Load DPLCs
00004B62                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B62                            ; Handle the extended camera
00004B62                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004B62                            ObjPlayer_ExtendedCam:
00004B62 3238 F8D2                  		move.w	rCamXPosCenter.w,d1		; Get camera X center
00004B66 3028 003A                  		move.w	oGVel(a0),d0			; Get ground velocity
00004B6A 6A00                       		bpl.s	.PosGVel			; Get absolute value
00004B6C 4440                       		neg.w	d0				; ''
00004B6E                            
00004B6E                            .PosGVel:
00004B6E 0C40 0600                  		cmpi.w	#$600,d0			; Is Sonic going at 6 pixels/frame?
00004B72 6500                       		bcs.s	.ResetXShift			; If not, branch
00004B74 4A68 003A                  		tst.w	oGVel(a0)			; Is Sonic moving right?
00004B78 6A00                       		bpl.s	.MoveRight			; If so, branch
00004B7A 5441                       		addq.w	#2,d1				; Move right
00004B7C 0C41 00E0                  		cmpi.w	#$E0,d1				; Cap it
00004B80 6500                       		bcs.s	.SetShift			; ''
00004B82 323C 00E0                  		move.w	#$E0,d1				; ''
00004B86 6000                       		bra.s	.SetShift			; Continue
00004B88                            
00004B88                            .MoveRight:
00004B88 5541                       		subq.w	#2,d1				; Move left
00004B8A 0C41 0060                  		cmpi.w	#$60,d1				; Cap it
00004B8E 6400                       		bcc.s	.SetShift			; ''
00004B90 323C 0060                  		move.w	#$60,d1				; ''
00004B94 6000                       		bra.s	.SetShift			; Continue
00004B96                            
00004B96                            .ResetXShift:
00004B96 0C41 00A0                  		cmpi.w	#$A0,d1				; Are we already back at the center?
00004B9A 6700                       		beq.s	.SetShift			; If so, branch
00004B9C 6400                       		bcc.s	.ReduceShift			; If we have to go back left, branch
00004B9E 5441                       		addq.w	#2,d1				; Move back right
00004BA0 6000                       		bra.s	.SetShift			; Continue
00004BA2                            
00004BA2                            .ReduceShift:
00004BA2 5541                       		subq.w	#2,d1				; Move back left
00004BA4                            
00004BA4                            .SetShift:
00004BA4 31C1 F8D2                  		move.w	d1,rCamXPosCenter.w		; Set camera X center
00004BA8 4E75                       		rts
00004BAA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004BAA                            ; Update Sonic's physics
00004BAA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004BAA                            ObjPlayer_GetPhysics:
00004BAA 7000                       		moveq	#0,d0
00004BAC 0828 0006 0028             		btst	#6,oStatus(a0)			; Is Sonic underwater?
00004BB2 6700                       		beq.s	.GetOffset			; If not, branch
00004BB4 7008                       		moveq	#8,d0				; Set the underwater bit
00004BB6                            
00004BB6                            .GetOffset:
00004BB6 43FB 0000                  		lea	ObjPlayer_Physics(pc,d0.w),a1	; Get pointer to correct physics values
00004BBA 2159 0034                  		move.l	(a1)+,oTopSpd(a0)		; Set top speed and acceleration
00004BBE 3151 0038                  		move.w	(a1),oDec(a0)			; Set deceleration
00004BC2 4E75                       		rts
00004BC4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004BC4                            ; Physics values
00004BC4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004BC4                            ; FORMAT:
00004BC4                            ;	dc.w	TOP SPEED, ACCELERATION, DECELERATION, 0
00004BC4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004BC4                            ObjPlayer_Physics:
00004BC4 0600 000C 0080 0000        		dc.w	TOP_SPD,     ACC_SPD,     DEC_SPD,     0; Normal
00004BCC 0300 0006 0040 0000        		dc.w	TOP_SPD/2,   ACC_SPD/2,   DEC_SPD/2,   0; Underwater
00004BD4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004BD4                            ; Handle Sonic in the water
00004BD4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004BD4                            ObjPlayer_Water:
00004BD4 4A38 F8F4                  	tst.b	rWaterFlag.w			; Is there water in the level?
00004BD8 6600                       	bne.s	.HandleWater			; If so, branch
00004BDA                            
00004BDA                            .End:
00004BDA 4E75                       	rts
00004BDC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004BDC                            .HandleWater:
00004BDC 3038 F8F6                  		move.w	rWaterLvl.w,d0		; Get water height
00004BE0 B068 0018                  		cmp.w	oYPos(a0),d0			; Is Lover in the water?
00004BE4 6C00                       		bge.s	.NotInWater			; If not, branch
00004BE6                            
00004BE6 08E8 0006 0028             		bset	#6,oStatus(a0)			; Set the "in water" flag
00004BEC 66EC                       		bne.s	.End				; If Lover is already in the water, branch
00004BEE                            
00004BEE E0E8 001C                  		asr.w	oXVel(a0)			; Make Lover move slower
00004BF2 E0E8 001E                  		asr.w	oYVel(a0)
00004BF6 E0E8 001E                  		asr.w	oYVel(a0)
00004BFA 67DE                       		beq.s	.End				; If a splash doesn't need to be created, branch
00004BFC                            
00004BFC                            		playSnd	#sSplash, 2			; Play splash sound
00004BFC 11FC 0090 C4BD           M 	move.b	#ssplash,(mqueue+((2)-1)).w
00004C02 4E75                       		rts
00004C04                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C04                            .NotInWater:
00004C04 08A8 0006 0028             		bclr	#6,oStatus(a0)			; Clear "in water" flag
00004C0A 67CE                       		beq.s	.End				; If Lover was already out of the water, branch
00004C0C                            
00004C0C 0C28 0010 0025             		cmpi.b	#$10,oRoutine(a0)			; Is Lover falling back from getting hurt?
00004C12 6700                       		beq.s	.ChkSplash			; If so, branch
00004C14 E1E8 001E                  		asl	oYVel(a0)			; Make Lover move faster vertically
00004C18                            
00004C18                            .ChkSplash:
00004C18 4A68 001E                  		tst.w	oYVel(a0)			; Does a splash need to be created?
00004C1C 67BC                       		beq.s	.End				; If not, branch
00004C1E                            
00004C1E 0C68 F000 001E             		cmpi.w	#-$1000,oYVel(a0)		; Is Lover moving more than -$10 pixels per frame?
00004C24 6E00                       		bgt.s	.PlaySplashSnd			; If not, branch
00004C26 317C F000 001E             		move.w	#-$1000,oYVel(a0)		; Cap the speed
00004C2C                            
00004C2C                            .PlaySplashSnd:
00004C2C                            		playSnd	#sSplash, 2			; Play splash sound
00004C2C 11FC 0090 C4BD           M 	move.b	#ssplash,(mqueue+((2)-1)).w
00004C32 4E75                       		rts
00004C34                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C34                            ; Do Sonic's modes
00004C34                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C34                            ObjPlayer_DoModes:
00004C34 0828 0000 000C             		btst	#0,oFlags(a0)			; Is running Sonic's mode disabled?
00004C3A 6600                       		bne.s	.NoMode				; If so, branch
00004C3C                            
00004C3C 7000                       		moveq	#0,d0
00004C3E 1028 0028                  		move.b	oStatus(a0),d0			; Get status
00004C42 0240 0006                  		andi.w	#6,d0				; Only get mode bits
00004C46 D040                       		add.w	d0,d0
00004C48 4EBB 0000                  		jsr	ObjPlayer_Modes(pc,d0.w)	; Jump to the right routine
00004C4C                            
00004C4C 6100 FF14                  		bsr.w	ObjPlayer_ExtendedCam		; Handle extended camera
00004C50 6100 0000                  		bsr.w	ObjPlayer_ChkBounce		; Check for bouncy floor collision
00004C54 6100 0000                  		bsr.w	ObjPlayer_ChkHang		; Check for hanging
00004C58 6000 0000                  		bra.w	ObjPlayer_ChkElectric		; Check for electricity
00004C5C                            
00004C5C                            .NoMode:
00004C5C 4E75                       		rts
00004C5E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C5E                            ; Sonic's modes
00004C5E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C5E                            ObjPlayer_Modes:
00004C5E 6000 0000                  		bra.w	ObjPlayer_MdGround		; Ground
00004C62 6000 0000                  		bra.w	ObjPlayer_MdAir			; Air
00004C66 6000 0000                  		bra.w	ObjPlayer_MdRoll		; Roll
00004C6A 6000 0000                  		bra.w	ObjPlayer_MdJump		; Jumping
00004C6E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C6E                            ; Ground mode
00004C6E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C6E                            ObjPlayer_MdGround:
00004C6E 6100 0000                  		bsr.w	ObjPlayer_Peelout		; Handle the peelout
00004C72 6100 0000                  		bsr.w	ObjPlayer_Spindash		; Handle the spindash
00004C76 6100 0000                  		bsr.w	ObjPlayer_ChkJump		; Check for jumping
00004C7A 6100 0000                  		bsr.w	ObjPlayer_ChkRoll		; Check for rolling
00004C7E 6100 0000                  		bsr.w	ObjPlayer_MoveGround		; Do movement on the ground
00004C82 4EB8 1D4C                  		jsr	ObjectMove.w			; Allow movement
00004C86 4EB8 32BC                  		jsr	PlayerAnglePos			; Update position and angle along the ground
00004C8A                            
00004C8A 6100 0000                  		bsr.w	ObjPlayer_SlopePush		; Affect Sonic's speed on a slope
00004C8E 6100 0000                  		bsr.w	ObjPlayer_FallOffSlope		; Check if Sonic is going to fall off the slope
00004C92                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C92                            ; Misc. updates
00004C92                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004C92                            ObjPlayer_MiscUpdates:
00004C92 4A28 003F                  		tst.b	oMoveLock(a0)			; Is the move lock timer finished?
00004C96 6700                       		beq.s	.NoMoveLock			; If so, branch
00004C98 5328 003F                  		subq.b	#1,oMoveLock(a0)		; Decrement the timer
00004C9C                            
00004C9C                            .NoMoveLock:
00004C9C 4EB8 2FD4                  		jsr	sub_F846
00004CA0 4A41                       		tst.w	d1
00004CA2 6B00 0000                  		bmi.w	ObjPlayer_GetKilled
00004CA6 4EB8 3264                  		jsr	PlayerChkLeftWallDist		; Check for left wall collision
00004CAA 4A41                       		tst.w	d1				; Has Sonic entered the wall?
00004CAC 6A00                       		bpl.s	.ChkRight			; If not, branch
00004CAE 9368 0014                  		sub.w	d1,oXPos(a0)			; Fix Sonic's X position
00004CB2                            
00004CB2                            .ChkRight:
00004CB2 4EB8 30E8                  		jsr	PlayerChkRightWallDist		; Check for right wall collision
00004CB6 4A41                       		tst.w	d1				; Has Sonic entered the wall?
00004CB8 6A00                       		bpl.s	.End				; If not, branch
00004CBA D368 0014                  		add.w	d1,oXPos(a0)			; Fix Sonic's X position
00004CBE                            
00004CBE                            .End:
00004CBE 4E75                       		rts
00004CC0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004CC0                            ; Air and jump modes
00004CC0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004CC0                            ObjPlayer_MdJump:
00004CC0                            ObjPlayer_MdAir:
00004CC0 4268 003C                  		clr.w	oInteract(a0)			; Sonic cannot be interacting with objects while in midair
00004CC4 08A8 0003 0028             		bclr	#cStandBit,oStatus(a0)		; ''
00004CCA                            
00004CCA 0828 0003 000C             		btst	#3,oFlags(a0)			; Is Sonic hanging?
00004CD0 6700                       		beq.s	.DoModes			; If not, branch
00004CD2 6100 0000                  		bsr.w	ObjPlayer_Hang			; Hang
00004CD6 6000                       		bra.s	.DoCol				; Continue
00004CD8                            
00004CD8                            .DoModes:
00004CD8 6100 0000                  		bsr.w	ObjPlayer_JumpHeight		; Handle jump height
00004CDC 6100 0000                  		bsr.w	ObjPlayer_MoveAir		; Do movement
00004CE0 4EB8 1D66                  		jsr	ObjectMoveAndFall.w		; Allow movement
00004CE4 0C68 1000 001E             		cmpi.w	#$1000,oYVel(a0)		; Is Sonic moving down too fasr?
00004CEA 6F00                       		ble.s	.NoCap				; If not, branch
00004CEC 317C 1000 001E             		move.w	#$1000,oYVel(a0)		; Cap the downward speed
00004CF2                            
00004CF2                            .NoCap:
00004CF2 6100 0000                  		bsr.w	ObjPlayer_JumpAngle		; Reset Sonic's angle in mid air
00004CF6                            
00004CF6                            .DoCol:
00004CF6 0828 0006 0028             		btst	#6,oStatus(a0)
00004CFC 6700                       		beq.s	.NoWater
00004CFE 0468 0028 001E             		subi.w	#$28,oYVel(a0)
00004D04                            
00004D04                            .NoWater:
00004D04 4EB8 2C42                  		jsr	PlayerChkCollision		; Check for level collision
00004D08 6088                       		bra.s	ObjPlayer_MiscUpdates
00004D0A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004D0A                            ; Roll mode
00004D0A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004D0A                            ObjPlayer_MdRoll:
00004D0A 4A28 004B                  		tst.b	oBallMode(a0)			; Are we in ball mode?
00004D0E 6600                       		bne.s	.NoJump				; If so, branch
00004D10 6100 0000                  		bsr.w	ObjPlayer_ChkJump		; Check for jumping
00004D14                            
00004D14                            .NoJump:
00004D14 6100 0000                  		bsr.w	ObjPlayer_RollSlopePush		; Push Sonic on a slope while rolling
00004D18 6100 0000                  		bsr.w	ObjPlayer_MoveRoll		; Do movement
00004D1C 4EB8 1D4C                  		jsr	ObjectMove.w			; Allow movement
00004D20 4EB8 32BC                  		jsr	PlayerAnglePos			; Update position and angle along the ground
00004D24                            
00004D24 6100 0000                  		bsr.w	ObjPlayer_FallOffSlope		; Check if Sonic is going to fall off the slope
00004D28 6000 FF68                  		bra.w	ObjPlayer_MiscUpdates		; Do misc. updates
00004D2C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004D2C                            ; Do movement on the ground
00004D2C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004D2C                            ObjPlayer_MoveGround:
00004D2C 3C28 0034                  		move.w	oTopSpd(a0),d6			; Get top speed
00004D30 3A28 0036                  		move.w	oAcc(a0),d5			; Get acceleration
00004D34 3828 0038                  		move.w	oDec(a0),d4			; Get deceleration
00004D38                            
00004D38 4A28 003F                  		tst.b	oMoveLock(a0)			; Is the move lock timer active?
00004D3C 6600 0000                  		bne.w	.ResetScr			; If so, branch
00004D40                            
00004D40 0838 0002 F8D4             		btst	#2,rCtrlHold.w		; Is left held?
00004D46 6700                       		beq.s	.NotLeft			; If so, branch
00004D48 6100 0000                  		bsr.w	ObjPlayer_MoveLeft		; Move left
00004D4C                            
00004D4C                            .NotLeft:
00004D4C 0838 0003 F8D4             		btst	#3,rCtrlHold.w		; Is right held?
00004D52 6700                       		beq.s	.NotRight			; If so, branch
00004D54 6100 0000                  		bsr.w	ObjPlayer_MoveRight		; Move right
00004D58                            
00004D58                            .NotRight:
00004D58 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
00004D5C 0600 0020                  		addi.b	#$20,d0				; Shift it
00004D60 0200 00C0                  		andi.b	#$C0,d0				; Get quadrant
00004D64 6600 0000                  		bne.w	.ResetScr			; If Sonic is not on the floor, branch
00004D68 4A68 003A                  		tst.w	oGVel(a0)			; Has Sonic already been halted?
00004D6C 6600 0000                  		bne.w	.ResetScr			; If not, branch
00004D70                            
00004D70 08A8 0005 0028             		bclr	#5,oStatus(a0)			; Stop pushing
00004D76 117C 0005 0020             		move.b	#5,oAni(a0)			; Set to ducking animation
00004D7C                            
00004D7C 0828 0003 0028             		btst	#cStandBit,oStatus(a0)		; Is Sonic standing on an object?
00004D82 6700 0000                  		beq.w	.ChkBalance			; If not, branch
00004D86 3268 003C                  		movea.w	oInteract(a0),a1		; Get interacted object
00004D8A 4A29 0028                  		tst.b	oStatus(a1)			; Is Sonic standing on it?
00004D8E 6B00                       		bmi.s	.ChkLookUp			; If not, branch
00004D90 7200                       		moveq	#0,d1
00004D92 1229 002C                  		move.b	oColW(a1),d1			; Get width of object
00004D96 3401                       		move.w	d1,d2				; Copy it
00004D98 D442                       		add.w	d2,d2				; Double the copy
00004D9A 5942                       		subq.w	#4,d2				; Subtract 4 from the copy
00004D9C D268 0014                  		add.w	oXPos(a0),d1			; Add Sonic's X position
00004DA0 9269 0014                  		sub.w	oXPos(a1),d1			; Subtract the object's X position
00004DA4 0C41 0004                  		cmpi.w	#4,d1				; Is Sonic balancing on the left side of it?
00004DA8 6D00                       		blt.s	.BalanceOnObjLeft		; If so, branch
00004DAA B242                       		cmp.w	d2,d1				; Is Sonic balacning on the right side of it?
00004DAC 6C00                       		bge.s	.BalanceOnObjRight		; If so, branch
00004DAE 6000                       		bra.s	.ChkLookUp			; Continue
00004DB0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004DB0                            .ChkBalance:
00004DB0 4EB8 2FAA                  		jsr	PlayerChkFloorDist		; Get floor distance
00004DB4 0C41 000C                  		cmpi.w	#$C,d1				; Is Sonic balancing?
00004DB8 6D00                       		blt.s	.ChkLookUp			; If not, branch
00004DBA 0C28 0003 002E             		cmpi.b	#3,oNextTilt(a0)		; Is Sonic balancing on the right side?
00004DC0 6600                       		bne.s	.ChkLeftBalance			; If not, branch
00004DC2                            
00004DC2                            .BalanceOnObjRight:
00004DC2 08A8 0000 0028             		bclr	#0,oStatus(a0)			; Face right
00004DC8 6000                       		bra.s	.SetBalanceAnim			; Set the animation
00004DCA                            
00004DCA                            .ChkLeftBalance:
00004DCA 0C28 0003 002F             		cmpi.b	#3,oTilt(a0)			; Is Sonic balancing on the left side?
00004DD0 6600                       		bne.s	.ChkLookUp			; If not, branch
00004DD2                            
00004DD2                            .BalanceOnObjLeft:
00004DD2 08E8 0000 0028             		bset	#0,oStatus(a0)			; Face left
00004DD8                            
00004DD8                            .SetBalanceAnim:
00004DD8 117C 0006 0020             		move.b	#6,oAni(a0)			; Set balancing animation
00004DDE 6000                       		bra.s	.ResetScr			; Continue
00004DE0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004DE0                            .ChkLookUp:
00004DE0 0838 0000 F8D4             		btst	#0,rCtrlHold.w		; Is the up button being held?
00004DE6 6700                       		beq.s	.ChkDown			; If not, branch
00004DE8 117C 0007 0020             		move.b	#7,oAni(a0)			; Set to looking up animation
00004DEE                            
00004DEE 5228 0044                  		addq.b	#1,oScrlDelay(a0)		; Increment scroll delay counter
00004DF2 0C28 0078 0044             		cmpi.b	#$78,oScrlDelay(a0)		; Has it reached $78?
00004DF8 6500                       		blo.s	.ResetScrPart2			; If not, branch
00004DFA 117C 0078 0044             		move.b	#$78,oScrlDelay(a0)		; Cap at $78
00004E00 0C78 00C8 F8CC             		cmpi.w	#200,rCamYPosDist.w		; Has the camera finished scrolling?
00004E06 6700                       		beq.s	.UpdateSpdOnGround		; If so, branch
00004E08 5478 F8CC                  		addq.w	#2,rCamYPosDist.w		; Scroll the camera
00004E0C 6000                       		bra.s	.UpdateSpdOnGround		; Continue
00004E0E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004E0E                            .ChkDown:
00004E0E 0838 0001 F8D4             		btst	#1,rCtrlHold.w		; Is the down button being held?
00004E14 6700                       		beq.s	.ResetScr			; If not, branch
00004E16 117C 0008 0020             		move.b	#8,oAni(a0)			; Set to ducking animation
00004E1C                            
00004E1C 5228 0044                  		addq.b	#1,oScrlDelay(a0)		; Increment scroll delay counter
00004E20 0C28 0078 0044             		cmpi.b	#$78,oScrlDelay(a0)		; Has it reached $78?
00004E26 6500                       		blo.s	.ResetScrPart2			; If not, branch
00004E28 117C 0078 0044             		move.b	#$78,oScrlDelay(a0)		; Cap at $78
00004E2E 0C78 0008 F8CC             		cmpi.w	#8,rCamYPosDist.w		; Has the camera finished scrolling?
00004E34 6700                       		beq.s	.UpdateSpdOnGround		; If so, branch
00004E36 5578 F8CC                  		subq.w	#2,rCamYPosDist.w		; Scroll the camera
00004E3A 6000                       		bra.s	.UpdateSpdOnGround		; Continue
00004E3C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004E3C                            .ResetScr:
00004E3C 4228 0044                  		clr.b	oScrlDelay(a0)			; Reset scroll delay counter
00004E40                            
00004E40                            .ResetScrPart2:
00004E40 0C78 0060 F8CC             		cmpi.w	#(224/2)-16,rCamYPosDist.w	; Is the camera centered vertically?
00004E46 6700                       		beq.s	.UpdateSpdOnGround		; If so, branch
00004E48 6400                       		bhs.s	.ScrollUp			; If it's below the center, branch
00004E4A 5878 F8CC                  		addq.w	#4,rCamYPosDist.w		; Scroll the camera up
00004E4E                            
00004E4E                            .ScrollUp:
00004E4E 5578 F8CC                  		subq.w	#2,rCamYPosDist.w		; Scroll the camera down
00004E52                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004E52                            .UpdateSpdOnGround:
00004E52 1038 F8D4                  		move.b	rCtrlHold.w,d0		; Get held buttons
00004E56 0200 000C                  		andi.b	#$C,d0				; Are left or right held?
00004E5A 6600                       		bne.s	.ApplySpeed			; If so, branch
00004E5C                            
00004E5C 3028 003A                  		move.w	oGVel(a0),d0			; Get current ground velocity
00004E60 6700                       		beq.s	.ApplySpeed			; If it's already 0, branch
00004E62 6B00                       		bmi.s	.SettleLeft			; Settle left if going left
00004E64                            
00004E64                            .SettleRight:
00004E64 9045                       		sub.w	d5,d0				; Slow down
00004E66 6A00                       		bpl.s	.SetSpeed			; If it's not done, branch
00004E68 7000                       		moveq	#0,d0				; Stop the movement
00004E6A 6000                       		bra.s	.SetSpeed			; Continue
00004E6C                            
00004E6C                            .SettleLeft:
00004E6C D045                       		add.w	d5,d0				; Slow down
00004E6E 6B00                       		bmi.s	.SetSpeed			; If it's not done, branch
00004E70 7000                       		moveq	#0,d0				; Stop the movement
00004E72                            
00004E72                            .SetSpeed:
00004E72 3140 003A                  		move.w	d0,oGVel(a0)			; Set ground velocity
00004E76                            
00004E76                            .ApplySpeed:
00004E76 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
00004E7A 4EB8 1374                  		jsr	CalcSine.w			; Get the sine and cosine
00004E7E C3E8 003A                  		muls.w	oGVel(a0),d1			; Multiply cosine with ground velocity
00004E82 C1E8 003A                  		muls.w	oGVel(a0),d0			; Multiply sine with ground velocity
00004E86 E081                       		asr.l	#8,d1				; Shift the values over
00004E88 E080                       		asr.l	#8,d0				; ''
00004E8A 3141 001C                  		move.w	d1,oXVel(a0)			; Set the X velocity
00004E8E 3140 001E                  		move.w	d0,oYVel(a0)			; Set the Y velocity
00004E92                            
00004E92                            ObjPlayer_CheckWalls:
00004E92 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
00004E96 0200 003F                  		andi.b	#$3F,d0				; Is Sonic on an angle?
00004E9A 6700                       		beq.s	.Skip				; If not, branch
00004E9C 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
00004EA0 0600 0040                  		addi.b	#$40,d0				; Is Sonic on an upwards wall or ceiling?
00004EA4 6B00                       		bmi.s	.End				; If so, branch
00004EA6                            
00004EA6                            .Skip:
00004EA6 7240                       		moveq	#$40,d1				; If going left, make the modifier $40
00004EA8 4A68 003A                  		tst.w	oGVel(a0)			; Check speed
00004EAC 6700                       		beq.s	.End				; Branch if not moving
00004EAE 6B00                       		bmi.s	.CheckPush			; Branch if going left
00004EB0 4441                       		neg.w	d1				; Negate the modifier
00004EB2                            
00004EB2                            .CheckPush:
00004EB2 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
00004EB6 D001                       		add.b	d1,d0				; Add modifier
00004EB8                            		push.w	d0				; Save it
00004EB8 3F00                     M 	move.w	d0,-(sp)
00004EBA 4EB8 2E72                  		jsr	PlayerCalcRoomInFront		; Calculate the distance in front of Sonic
00004EBE                            		pop.w	d0				; Restore angle
00004EBE 301F                     M 	move.w	(sp)+,d0
00004EC0 4A41                       		tst.w	d1				; Is Sonic pushing into anything?
00004EC2 6A00                       		bpl.s	.End				; If not, branch
00004EC4 E141                       		asl.w	#8,d1				; Shift distance inside the collision
00004EC6 0600 0020                  		addi.b	#$20,d0				; Add $20 to the angle
00004ECA 0200 00C0                  		andi.b	#$C0,d0				; Is Sonic pushing on a ceiling?
00004ECE 6700                       		beq.s	.PushCeiling			; If so, branch
00004ED0 0C00 0040                  		cmpi.b	#$40,d0				; Is Sonic pushing on a right wall?
00004ED4 6700                       		beq.s	.PushRightWall			; If so, branch
00004ED6 0C00 0080                  		cmpi.b	#$80,d0				; Is Sonic pushing on a floor?
00004EDA 6700                       		beq.s	.PushFloor			; If so, branch
00004EDC D368 001C                  		add.w	d1,oXVel(a0)			; Push out to the right
00004EE0 4268 003A                  		clr.w	oGVel(a0)			; Stop moving
00004EE4 0828 0000 0028             		btst	#0,oStatus(a0)			; Is Sonic facing right?
00004EEA 6600                       		bne.s	.End				; If not, branch
00004EEC 08E8 0005 0028             		bset	#5,oStatus(a0)			; Start pushing
00004EF2 4E75                       		rts
00004EF4                            
00004EF4                            .PushFloor:
00004EF4 9368 001E                  		sub.w	d1,oYVel(a0)			; Push out upwards
00004EF8 4E75                       		rts
00004EFA                            
00004EFA                            .PushRightWall:
00004EFA 9368 001C                  		sub.w	d1,oXVel(a0)			; Push out to the left
00004EFE 4268 003A                  		clr.w	oGVel(a0)			; Stop moving
00004F02 0828 0000 0028             		btst	#0,oStatus(a0)			; Is Sonic facing left?
00004F08 6700                       		beq.s	.End				; If not, branch
00004F0A 08E8 0005 0028             		bset	#5,oStatus(a0)			; Start pushing
00004F10 4E75                       		rts
00004F12                            
00004F12                            .PushCeiling:
00004F12 D368 001E                  		add.w	d1,oYVel(a0)			; Push out downwards
00004F16                            
00004F16                            .End:
00004F16 4E75                       		rts
00004F18                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004F18                            ; Move left on the ground
00004F18                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004F18                            ObjPlayer_MoveLeft:
00004F18 3028 003A                  		move.w	oGVel(a0),d0			; Get current speed
00004F1C 6700                       		beq.s	.SetFlip			; If not moving yet, branch
00004F1E 6A00                       		bpl.s	.Skid				; If moving right, check for skidding
00004F20                            
00004F20                            .SetFlip:
00004F20 08E8 0000 0028             		bset	#0,oStatus(a0)			; Set flip flag
00004F26 6600                       		bne.s	.MoveLeft			; If it was already set, branch
00004F28 08A8 0005 0028             		bclr	#5,oStatus(a0)			; Stop pushing
00004F2E 117C 0001 0021             		move.b	#1,oPrevAni(a0)			; Reset the animation
00004F34                            
00004F34                            .MoveLeft:
00004F34 9045                       		sub.w	d5,d0				; Subtract acceleration
00004F36 3206                       		move.w	d6,d1				; Get top speed
00004F38 4441                       		neg.w	d1				; Negate it
00004F3A B041                       		cmp.w	d1,d0				; Is Sonic moving faster than the top speed?
00004F3C 6E00                       		bgt.s	.SetSpeed			; If not, branch
00004F3E D045                       		add.w	d5,d0				; Add acceleration back
00004F40 B041                       		cmp.w	d1,d0				; Is Sonic still moving faster than the top speed?
00004F42 6F00                       		ble.s	.SetSpeed			; If not, branch
00004F44 3001                       		move.w	d1,d0				; Cap at the top speed
00004F46                            
00004F46                            .SetSpeed:
00004F46 3140 003A                  		move.w	d0,oGVel(a0)			; Set speed
00004F4A 4228 0020                  		clr.b	oAni(a0)			; Set animation to moving
00004F4E                            
00004F4E                            .End:
00004F4E 4E75                       		rts
00004F50                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004F50                            .Skid:
00004F50 9044                       		sub.w	d4,d0				; Subtract deceleration
00004F52 7200                       		moveq	#0,d1				; The speed in which Sonic stops skidding
00004F54                            
00004F54                            .Compare:
00004F54 B041                       		cmp.w	d1,d0				; Has Sonic gotten to that speed yet?
00004F56 6C00                       		bge.s	.SetSkidSpeed			; If not branch
00004F58 7080                       		moveq	#-$80,d0			; Set speed to -$80
00004F5A                            
00004F5A                            .SetSkidSpeed:
00004F5A 3140 003A                  		move.w	d0,oGVel(a0)			; Set speed
00004F5E 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
00004F62 0600 0020                  		addi.b	#$20,d0				; Shift it
00004F66 0200 00C0                  		andi.b	#$C0,d0				; Is Sonic on a slope?
00004F6A 66E2                       		bne.s	.End				; If so, branch
00004F6C 0C40 0400                  		cmpi.w	#$400,d0			; Is Sonic's speed at least 4 pixels per frame?
00004F70 6DDC                       		blt.s	.End				; If not, branch
00004F72 117C 000D 0020             		move.b	#$D,oAni(a0)			; Set animation to skidding
00004F78 08A8 0000 0028             		bclr	#0,oStatus(a0)			; Clear flip flag
00004F7E                            		playSnd	#sSkid, 2			; Play skid sound
00004F7E 11FC 0083 C4BD           M 	move.b	#sskid,(mqueue+((2)-1)).w
00004F84 4E75                       		rts
00004F86                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004F86                            ; Move right on the ground
00004F86                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004F86                            ObjPlayer_MoveRight:
00004F86 3028 003A                  		move.w	oGVel(a0),d0			; Get current speed
00004F8A 6B00                       		bmi.s	.Skid				; If it's negative, skid
00004F8C 08A8 0000 0028             		bclr	#0,oStatus(a0)			; Clear flip flag
00004F92 6700                       		beq.s	.MoveRight			; Branch if it was already cleared
00004F94 08A8 0005 0028             		bclr	#5,oStatus(a0)			; Stop pushing
00004F9A 117C 0001 0021             		move.b	#1,oPrevAni(a0)			; Reset the animation
00004FA0                            
00004FA0                            .MoveRight:
00004FA0 D045                       		add.w	d5,d0				; Add acceleration
00004FA2 B046                       		cmp.w	d6,d0				; Has Sonic reached the top speed?
00004FA4 6D00                       		blt.s	.SetSpeed			; If not, branch
00004FA6 9045                       		sub.w	d5,d0				; Subtract acceleration back
00004FA8 B046                       		cmp.w	d6,d0				; Is Sonic still going at the top speed?
00004FAA 6C00                       		bge.s	.SetSpeed			; If not, branch
00004FAC 3006                       		move.w	d6,d0				; Cap at top speed
00004FAE                            
00004FAE                            .SetSpeed:
00004FAE 3140 003A                  		move.w	d0,oGVel(a0)			; Set speed
00004FB2 4228 0020                  		clr.b	oAni(a0)			; Set animation to moving
00004FB6                            
00004FB6                            .End:
00004FB6 4E75                       		rts
00004FB8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004FB8                            .Skid:
00004FB8 D044                       		add.w	d4,d0				; Add deceleration
00004FBA 7200                       		moveq	#0,d1				; The speed in which Sonic stops skidding
00004FBC                            
00004FBC                            .Compare:
00004FBC B041                       		cmp.w	d1,d0				; Has Sonic gotten to that speed yet?
00004FBE 6F00                       		ble.s	.SetSkidSpeed			; If not, branch
00004FC0 303C 0080                  		move.w	#$80,d0				; Set speed to $80
00004FC4                            
00004FC4                            .SetSkidSpeed:
00004FC4 3140 003A                  		move.w	d0,oGVel(a0)			; Set speed
00004FC8 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
00004FCC 0600 0020                  		addi.b	#$20,d0				; Shift it
00004FD0 0200 00C0                  		andi.b	#$C0,d0				; Is Sonic on a slope?
00004FD4 66E0                       		bne.s	.End				; If so, branch
00004FD6 0C40 FC00                  		cmpi.w	#-$400,d0			; Is Sonic's speed at least -4 pixels per frame?
00004FDA 6EDA                       		bgt.s	.End				; If not, branch
00004FDC 117C 000D 0020             		move.b	#$D,oAni(a0)			; Set animation to skidding
00004FE2 08E8 0000 0028             		bset	#0,oStatus(a0)			; Set flip flag
00004FE8                            		playSnd	#sSkid, 2			; Play skid sound
00004FE8 11FC 0083 C4BD           M 	move.b	#sskid,(mqueue+((2)-1)).w
00004FEE 4E75                       		rts
00004FF0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004FF0                            ; Do movement while rolling
00004FF0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00004FF0                            ObjPlayer_MoveRoll:
00004FF0 3C28 0034                  		move.w	oTopSpd(a0),d6			; Get top speed
00004FF4 E346                       		asl.w	#1,d6				; ''
00004FF6 3A28 0036                  		move.w	oAcc(a0),d5			; Get acceleration
00004FFA E245                       		asr.w	#1,d5				; ''
00004FFC 3828 0038                  		move.w	oDec(a0),d4			; Get deceleration
00005000 E444                       		asr.w	#2,d4				; ''
00005002                            
00005002 4A28 003F                  		tst.b	oMoveLock(a0)			; Is the move lock timer active?
00005006 6600 0000                  		bne.w	.UpdateSpd			; If so, branch
0000500A                            
0000500A 0838 0002 F8D4             		btst	#2,rCtrlHold.w		; Is left being held?
00005010 6700                       		beq.s	.ChkRight			; If not, branch
00005012 6100 0000                  		bsr.w	ObjPlayer_RollLeft		; Handle left movement
00005016                            
00005016                            .ChkRight:
00005016 0838 0003 F8D4             		btst	#3,rCtrlHold.w		; Is right being held?
0000501C 6700                       		beq.s	.Decelerate			; If not, branch
0000501E 6100 0000                  		bsr.w	ObjPlayer_RollRight		; Handle right movement
00005022                            
00005022                            .Decelerate:
00005022 3028 003A                  		move.w	oGVel(a0),d0			; Get ground velocity
00005026 6700                       		beq.s	.ChkStop			; If Sonic isn't moving, branch
00005028 6B00                       		bmi.s	.DecLeft			; If Sonic is moving left, branch
0000502A                            
0000502A 9045                       		sub.w	d5,d0				; Decelerate
0000502C 6400                       		bcc.s	.SetGVel			; If Sonic hasn't stopped yet, branch
0000502E 7000                       		moveq	#0,d0				; Cap at 0
00005030                            
00005030                            .SetGVel:
00005030 3140 003A                  		move.w	d0,oGVel(a0)			; Set ground velocity
00005034 6000                       		bra.s	.ChkStop			; Continue
00005036                            
00005036                            .DecLeft:
00005036 D045                       		add.w	d5,d0				; Decelerate
00005038 6400                       		bcc.s	.SetGVel2			; If Sonic hasn't stopped yet, branch
0000503A 7000                       		moveq	#0,d0				; Cap at 0
0000503C                            
0000503C                            .SetGVel2:
0000503C 3140 003A                  		move.w	d0,oGVel(a0)			; Set ground velocity
00005040                            
00005040                            .ChkStop:
00005040 4A68 003A                  		tst.w	oGVel(a0)			; Is Sonic still moving?
00005044 6600                       		bne.s	.UpdateSpd			; If so, branch
00005046                            
00005046 4A28 004B                  		tst.b	oBallMode(a0)			; Are we in ball mode?
0000504A 6600                       		bne.s	.KeepRoll			; If so, branch
0000504C 08A8 0002 0028             		bclr	#2,oStatus(a0)			; Stop rolling
00005052 1168 0030 002D             		move.b	oInitColH(a0),oColH(a0)		; Reset collision height
00005058 1168 0031 002C             		move.b	oInitColW(a0),oColW(a0)		; Reset collision width
0000505E 117C 0005 0020             		move.b	#5,oAni(a0)			; Use standing animation
00005064 5B68 0018                  		subq.w	#5,oYPos(a0)			; Align Sonic with the ground
00005068 6000                       		bra.s	.UpdateSpd			; Continue
0000506A                            
0000506A                            .KeepRoll:
0000506A 317C 0400 003A             		move.w	#$400,oGVel(a0)			; Speed up again
00005070 0828 0000 0028             		btst	#0,oStatus(a0)			; Are we facing right?
00005076 6700                       		beq.s	.UpdateSpd			; If so, branch
00005078 4468 003A                  		neg.w	oGVel(a0)			; Go the other way
0000507C                            
0000507C                            .UpdateSpd:
0000507C 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
00005080 4EB8 1374                  		jsr	CalcSine.w			; Get sine and cosine
00005084 C1E8 003A                  		muls.w	oGVel(a0),d0			; Multiply sine with ground velocity
00005088 E080                       		asr.l	#8,d0				; Shift over
0000508A 3140 001E                  		move.w	d0,oYVel(a0)			; Set Y velocity
0000508E C3E8 003A                  		muls.w	oGVel(a0),d1			; Multiply cosine with ground velocity
00005092 E081                       		asr.l	#8,d1				; Shift over
00005094                            
00005094 0C41 1000                  		cmpi.w	#$1000,d1			; Is the speed > $10 pixels per frame?
00005098 6F00                       		ble.s	.ChkLeftSpd			; If not, branch
0000509A 323C 1000                  		move.w	#$1000,d1			; Cap the speed
0000509E                            
0000509E                            .ChkLeftSpd:
0000509E 0C41 F000                  		cmpi.w	#-$1000,d1			; Is the speed < -$10 pixels per frame?
000050A2 6C00                       		bge.s	.SetXVel			; If not, branch
000050A4 323C F000                  		move.w	#-$1000,d1			; Cap the speed
000050A8                            
000050A8                            .SetXVel:
000050A8 3141 001C                  		move.w	d1,oXVel(a0)			; Set X velocity
000050AC 6000 FDE4                  		bra.w	ObjPlayer_CheckWalls		; Check wall collision
000050B0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000050B0                            ; Handle left movement for rolling
000050B0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000050B0                            ObjPlayer_RollLeft:
000050B0 3028 003A                  		move.w	oGVel(a0),d0			; Get ground velocity
000050B4 6700                       		beq.s	.SetLeft			; If Sonic isn't moving, branch
000050B6 6A00                       		bpl.s	.Dec				; If Sonic is moving right, branch
000050B8                            
000050B8                            .SetLeft:
000050B8 08E8 0000 0028             		bset	#0,oStatus(a0)			; Face left
000050BE 117C 0002 0020             		move.b	#2,oAni(a0)			; Use rolling animation
000050C4 4E75                       		rts
000050C6                            
000050C6                            .Dec:
000050C6 9044                       		sub.w	d4,d0				; Decelerate
000050C8 6400                       		bcc.s	.SetGVel			; If Sonic hasn't stopped yet, branch
000050CA 303C FF80                  		move.w	#-$80,d0			; Set new speed
000050CE                            
000050CE                            .SetGVel:
000050CE 3140 003A                  		move.w	d0,oGVel(a0)			; Set ground velocity
000050D2 4E75                       		rts
000050D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000050D4                            ; Handle left movement for rolling
000050D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000050D4                            ObjPlayer_RollRight:
000050D4 3028 003A                  		move.w	oGVel(a0),d0			; Get ground velocity
000050D8 6B00                       		bmi.s	.Dec				; If Sonic is moving left, branch
000050DA 08A8 0000 0028             		bclr	#0,oStatus(a0)			; Face right
000050E0 117C 0002 0020             		move.b	#2,oAni(a0)			; Use rolling animation
000050E6 4E75                       		rts
000050E8                            
000050E8                            .Dec:
000050E8 D044                       		add.w	d4,d0				; Decelerate
000050EA 6400                       		bcc.s	.SetGVel			; If Sonic hasn't stopped yet, branch
000050EC 303C 0080                  		move.w	#$80,d0				; Set new speed
000050F0                            
000050F0                            .SetGVel:
000050F0 3140 003A                  		move.w	d0,oGVel(a0)			; Set ground velocity
000050F4 4E75                       		rts
000050F6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000050F6                            ; Do movement in the air
000050F6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000050F6                            ObjPlayer_MoveAir:
000050F6 3C28 0034                  		move.w	oTopSpd(a0),d6			; Get top speed
000050FA 3A28 0036                  		move.w	oAcc(a0),d5			; Get accleration
000050FE DA45                       		add.w	d5,d5				; Double it
00005100 3028 001C                  		move.w	oXVel(a0),d0			; Get X velocity
00005104                            
00005104 0838 0002 F8D4             		btst	#2,rCtrlHold.w		; Is left being held?
0000510A 6700                       		beq.s	.NotLeft			; If not, branch
0000510C 08E8 0000 0028             		bset	#0,oStatus(a0)			; Face left
00005112 9045                       		sub.w	d5,d0				; Subtract acceleration
00005114 3206                       		move.w	d6,d1				; Get top speed
00005116 4441                       		neg.w	d1				; Negate it
00005118 B041                       		cmp.w	d1,d0				; Has Sonic reached the top speed?
0000511A 6E00                       		bgt.s	.NotLeft			; If not, branch
0000511C D045                       		add.w	d5,d0				; Add acceleration back
0000511E B041                       		cmp.w	d1,d0				; Is Sonic still at top speed?
00005120 6F00                       		ble.s	.NotLeft			; If not, branch
00005122 3001                       		move.w	d1,d0				; Cap at top speed
00005124                            
00005124                            .NotLeft:
00005124 0838 0003 F8D4             		btst	#3,rCtrlHold.w		; Is right being held?
0000512A 6700                       		beq.s	.NotRight			; If not, branch
0000512C 08A8 0000 0028             		bclr	#0,oStatus(a0)			; Face right
00005132 D045                       		add.w	d5,d0				; Add acceleration
00005134 B046                       		cmp.w	d6,d0				; Has Sonic reached the top speed?
00005136 6D00                       		blt.s	.NotRight			; If not, branch
00005138 9045                       		sub.w	d5,d0				; Subtract acceleration back
0000513A B046                       		cmp.w	d6,d0				; Is Sonic still at top speed?
0000513C 6C00                       		bge.s	.NotRight			; If not, branch
0000513E 3006                       		move.w	d6,d0				; Cap at top speed
00005140                            
00005140                            .NotRight:
00005140 3140 001C                  		move.w	d0,oXVel(a0)			; Set X velocity
00005144                            
00005144                            .ResetScr
00005144 0C78 0060 F8CC             		cmpi.w	#(224/2)-16,rCamYPosDist.w	; Is the camera centered vertically?
0000514A 6700                       		beq.s	.DecelerateAtPeak		; If so, branch
0000514C 6400                       		bhs.s	.ScrollUp			; If it's below the center, branch
0000514E 5878 F8CC                  		addq.w	#4,rCamYPosDist.w		; Scroll the camera up
00005152                            
00005152                            .ScrollUp:
00005152 5578 F8CC                  		subq.w	#2,rCamYPosDist.w		; Scroll the camera down
00005156                            
00005156                            .DecelerateAtPeak:
00005156 0C68 FC00 001E             		cmpi.w	#-$400,oYVel(a0)		; Is Sonic at least going -4 pixels per frame up?
0000515C 6500                       		bcs.s	.End				; If not, branch
0000515E 3028 001C                  		move.w	oXVel(a0),d0			; Get X velocity
00005162 3200                       		move.w	d0,d1				; Save it
00005164 EA41                       		asr.w	#5,d1				; Turn it into the acceleration
00005166 6700                       		beq.s	.End				; If it's 0, branch
00005168 6B00                       		bmi.s	.DecLeft			; If it's negative, branch
0000516A                            
0000516A                            .DecRight:
0000516A 9041                       		sub.w	d1,d0				; Subtract accleration
0000516C 6400                       		bcc.s	.DecSetSpeed			; If it's not negative, branch
0000516E 7000                       		moveq	#0,d0				; Cap at 0
00005170 6000                       		bra.s	.DecSetSpeed			; Continue
00005172                            
00005172                            .DecLeft:
00005172 9041                       		sub.w	d1,d0				; Subtract acceleration
00005174 6500                       		bcs.s	.DecSetSpeed			; If it's not positive, branch
00005176 7000                       		moveq	#0,d0				; Cap at 0
00005178                            
00005178                            .DecSetSpeed:
00005178 3140 001C                  		move.w	d0,oXVel(a0)			; Set thhe X velocity
0000517C                            
0000517C                            .End:
0000517C 4E75                       		rts
0000517E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000517E                            ; Handle level boundaries
0000517E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000517E                            ObjPlayer_LvlBound:
0000517E 4A68 001E                  		tst.w	oYVel(a0)
00005182 6A00                       		bpl.s	.XBound
00005184 3228 0018                  		move.w	oYPos(a0),d1
00005188 0641 0010                  		addi.w	#$10,d1
0000518C 3038 F8CA                  		move.w	rMinCamY.w,d0		; Get upper boundary position
00005190 B041                       		cmp.w	d1,d0				; Has Sonic touched the upper boundary?
00005192 6F00                       		ble.s	.XBound				; If so, branch
00005194 3140 0018                  		move.w	d0,oYPos(a0)
00005198 4268 001E                  		clr.w	oYVel(a0)
0000519C 4268 003A                  		clr.w	oGVel(a0)
000051A0                            
000051A0                            .XBound:
000051A0 2228 0014                  		move.l	oXPos(a0),d1			; Get X position
000051A4 3028 001C                  		move.w	oXVel(a0),d0			; Get X velocity
000051A8 48C0                       		ext.l	d0
000051AA E180                       		asl.l	#8,d0				; Shift it
000051AC D280                       		add.l	d0,d1				; Add to X position
000051AE 4841                       		swap	d1				; Get actual X position
000051B0 3038 F8C8                  		move.w	rMinCamX.w,d0		; Get left boundary position
000051B4 0640 0010                  		addi.w	#$10,d0				; ''
000051B8 B041                       		cmp.w	d1,d0				; Has Sonic touched the left boundary?
000051BA 6E00                       		bgt.s	.TouchedSide			; If so, branch
000051BC 3038 F8C0                  		move.w	rMaxCamX.w,d0		; Get max camera X position
000051C0 0640 0128                  		addi.w	#320-24,d0			; Get right boundary position
000051C4 B041                       		cmp.w	d1,d0				; Has Sonic touched the right boundary?
000051C6 6F00                       		ble.s	.TouchedSide			; If so, branch
000051C8                            
000051C8                            .ChkBottom:
000051C8 3038 F8C2                  		move.w	rMaxCamY.w,d0		; Get max camera Y position
000051CC 0640 00E0                  		addi.w	#224,d0				; Get bottom boundary position
000051D0 B068 0018                  		cmp.w	oYPos(a0),d0			; Has Sonic touched the bottom boundary?
000051D4 6D00                       		blt.s	.TouchedBottom			; If so, branch
000051D6 4E75                       		rts
000051D8                            
000051D8                            .TouchedBottom:
000051D8 3038 F8BE                  		move.w	rDestMaxY.w,d0		; Get target max camera Y position
000051DC 3238 F8C2                  		move.w	rMaxCamY.w,d1		; Get current max camera Y position
000051E0 B240                       		cmp.w	d0,d1				; Are they the same?
000051E2 6D00                       		blt.s	.NoKill				; If not, branch
000051E4 6000 0000                  		bra.w	ObjPlayer_GetKilled		; Get Sonic killed
000051E8                            
000051E8                            .NoKill:
000051E8 4E75                       		rts
000051EA                            
000051EA                            .TouchedSide:
000051EA 4268 001C                  		clr.w	oXVel(a0)			; Stop X movement
000051EE 3140 0014                  		move.w	d0,oXPos(a0)			; Move Sonic out of the boundary
000051F2 4228 0016                  		clr.b	oXPos+2(a0)			; Clear the subpixel of the X position
000051F6 4268 003A                  		clr.w	oGVel(a0)			; Stop ground movement
000051FA 60CC                       		bra.s	.ChkBottom			; Continue
000051FC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000051FC                            ; Handle peelout
000051FC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000051FC                            ObjPlayer_Peelout:
000051FC 4A28 0045                  		tst.b	oDashFlag(a0)			; Is Sonic doing the peelout?
00005200 6700                       		beq.s	.ChkUp				; If not, branch
00005202 6B00                       		bmi.s	.ChkLaunch			; If so, branch
00005204 4E75                       		rts
00005206                            
00005206                            .ChkUp:
00005206 0C28 0007 0020             		cmpi.b	#7,oAni(a0)			; Is Sonic looking up?
0000520C 6600 0000                  		bne.w	.End				; If not, branch
00005210 1038 F8D5                  		move.b	rCtrlPress.w,d0		; Get controller bits
00005214 0200 0070                  		andi.b	#$70,d0				; Are A, B, or C pressed?
00005218 6700 0000                  		beq.w	.End				; If not, branch
0000521C                            
0000521C 4228 0020                  		clr.b	oAni(a0)			; Set to peelout charge animation
00005220 4228 0046                  		clr.b	oDashTimer(a0)			; Reset the dash timer
00005224 317C 000C 003A             		move.w	#$C,oGVel(a0)			; Reset ground velocity
0000522A 0828 0000 0028             		btst	#0,oStatus(a0)			; Is Sonic facing left?
00005230 6700                       		beq.s	.SetAni				; If so, branch
00005232 4468 003A                  		neg.w	oGVel(a0)			; Go the other way
00005236                            
00005236                            .SetAni:
00005236                            		playSnd	#sCharge, 2			; Play charge sound
00005236 11FC 009C C4BD           M 	move.b	#scharge,(mqueue+((2)-1)).w
0000523C                            
0000523C 588F                       		addq.l	#4,sp				; Don't return to caller
0000523E 50E8 0045                  		st	oDashFlag(a0)			; Set the peelout flag
00005242 4EF8 32BC                  		jmp	PlayerAnglePos			; Update position and angle along the ground
00005246                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005246                            .ChkLaunch:
00005246 0838 0000 F8D4             		btst	#0,rCtrlHold.w		; Is up being held?
0000524C 6600 0000                  		bne.w	.Charge				; If so, branch
00005250 4228 0045                  		clr.b	oDashFlag(a0)			; Clear the dash flag
00005254                            
00005254 0C28 001E 0046             		cmpi.b	#30,oDashTimer(a0)		; Has Sonic charged up enough?
0000525A 6600                       		bne.s	.StopSound			; If not, branch
0000525C                            
0000525C 4228 0020                  		clr.b	oAni(a0)			; Reset animation
00005260 317C 0C00 003A             		move.w	#$C00,oGVel(a0)			; Set ground velocity
00005266 0828 0006 0028             		btst	#6,oStatus(a0)
0000526C 6700                       		beq.s	.NoWater
0000526E E2E8 003A                  		lsr.w	oGVel(a0)
00005272                            
00005272                            .NoWater:
00005272 0828 0000 0028             		btst	#0,oStatus(a0)			; Is Sonic facing left?
00005278 6700                       		beq.s	.FinishDash			; If not, branch
0000527A 4468 003A                  		neg.w	oGVel(a0)			; Go the other way
0000527E                            
0000527E                            .FinishDash:
0000527E                            		playSnd	#sChargeRelease, 2		; Play charge release sound
0000527E 11FC 009E C4BD           M 	move.b	#schargerelease,(mqueue+((2)-1)).w
00005284                            
00005284 6000                       		bra.s	.DoUpdates			; Continue
00005286                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005286                            .Charge:
00005286 0C28 001E 0046             		cmpi.b	#30,oDashTimer(a0)		; Has Sonic charged enough?
0000528C 6700                       		beq.s	.DoUpdates			; If so, branch
0000528E 5228 0046                  		addq.b	#1,oDashTimer(a0)		; Increment the timer
00005292 0668 0066 003A             		addi.w	#$66,oGVel(a0)			; Increment ground velocity to handle animation and extended camera
00005298 0828 0000 0028             		btst	#0,oStatus(a0)			; Is Sonic facing left?
0000529E 6700                       		beq.s	.DoUpdates			; If so, branch
000052A0 0468 00CC 003A             		subi.w	#$66*2,oGVel(a0)		; Go the other way
000052A6 6000                       		bra.s	.DoUpdates			; Continue
000052A8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000052A8                            .StopSound:
000052A8 4268 003A                  		clr.w	oGVel(a0)			; Stop ground movement
000052AC                            
000052AC                            		playSnd	#sChargeStop, 2			; Play charge stop sound
000052AC 11FC 009D C4BD           M 	move.b	#schargestop,(mqueue+((2)-1)).w
000052B2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000052B2                            .DoUpdates:
000052B2 588F                       		addq.l	#4,sp				; Don't return to caller
000052B4 0C78 0060 F8CC             		cmpi.w	#(224/2)-16,rCamYPosDist.w	; Is the camera centered vertically?
000052BA 6700                       		beq.s	.FinishUpdates			; If so, branch
000052BC 6400                       		bhs.s	.ScrollUp			; If it's below the center, branch
000052BE 5878 F8CC                  		addq.w	#4,rCamYPosDist.w		; Scroll the camera up
000052C2                            
000052C2                            .ScrollUp:
000052C2 5578 F8CC                  		subq.w	#2,rCamYPosDist.w		; Scroll the camera down
000052C6                            
000052C6                            .FinishUpdates:
000052C6 4EF8 32BC                  		jmp	PlayerAnglePos			; Update position and angle along the ground
000052CA                            
000052CA                            .End:
000052CA 4E75                       		rts
000052CC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000052CC                            ; Handle spindash
000052CC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000052CC                            ObjPlayer_Spindash:
000052CC 4A28 0045                  		tst.b	oDashFlag(a0)			; Is Sonic doing the spindash?
000052D0 6700                       		beq.s	.ChkDown			; If not, branch
000052D2 6A00                       		bpl.s	.ChkLaunch			; If so, branch
000052D4 4E75                       		rts
000052D6                            
000052D6                            .ChkDown:
000052D6 0C28 0008 0020             		cmpi.b	#8,oAni(a0)			; Is Sonic ducking?
000052DC 6600 0000                  		bne.w	.End				; If not, branch
000052E0 1038 F8D5                  		move.b	rCtrlPress.w,d0		; Get controller bits
000052E4 0200 0070                  		andi.b	#$70,d0				; Are A, B, or C pressed?
000052E8 6700 0000                  		beq.w	.End				; If not, branch
000052EC                            
000052EC 4228 0046                  		clr.b	oDashTimer(a0)			; Reset the dash timer
000052F0 317C 000C 003A             		move.w	#$C,oGVel(a0)			; Reset ground velocity
000052F6 0828 0000 0028             		btst	#0,oStatus(a0)			; Is Sonic facing left?
000052FC 6700                       		beq.s	.SetAni				; If so, branch
000052FE 4468 003A                  		neg.w	oGVel(a0)			; Go the other way
00005302                            
00005302                            .SetAni:
00005302 117C 000E 002D             		move.b	#$E,oColH(a0)			; Reduce Sonic's hitbox
00005308 117C 0007 002C             		move.b	#7,oColW(a0)			; ''
0000530E 5A68 0018                  		addq.w	#5,oYPos(a0)			; Align Sonic to the ground
00005312 117C 0002 0020             		move.b	#2,oAni(a0)			; Set to spin animation
00005318                            
00005318                            		playSnd	#sCharge, 2			; Play charge sound
00005318 11FC 009C C4BD           M 	move.b	#scharge,(mqueue+((2)-1)).w
0000531E                            
0000531E 588F                       		addq.l	#4,sp				; Don't return to caller
00005320 117C 0001 0045             		move.b	#1,oDashFlag(a0)		; Set the spindash flag
00005326 4EF8 32BC                  		jmp	PlayerAnglePos			; Update position and angle along the ground
0000532A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000532A                            .ChkLaunch:
0000532A 0838 0001 F8D4             		btst	#1,rCtrlHold.w		; Is down being held?
00005330 6600 0000                  		bne.w	.Charge				; If so, branch
00005334 4228 0045                  		clr.b	oDashFlag(a0)			; Clear the dash flag
00005338                            
00005338 0C28 002D 0046             		cmpi.b	#45,oDashTimer(a0)		; Has Sonic charged up enough?
0000533E 6600                       		bne.s	.StopSound			; If not, branch
00005340                            
00005340 08E8 0002 0028             		bset	#2,oStatus(a0)			; Set the roll flag
00005346 317C 0C00 003A             		move.w	#$C00,oGVel(a0)			; Set ground velocity
0000534C 0828 0006 0028             		btst	#6,oStatus(a0)
00005352 6700                       		beq.s	.NoWater
00005354 E2E8 003A                  		lsr.w	oGVel(a0)
00005358                            
00005358                            .NoWater:
00005358 0828 0000 0028             		btst	#0,oStatus(a0)			; Is Sonic facing left?
0000535E 6700                       		beq.s	.FinishDash			; If not, branch
00005360 4468 003A                  		neg.w	oGVel(a0)			; Go the other way
00005364                            
00005364                            .FinishDash:
00005364                            		playSnd	#sChargeRelease, 2		; Play charge release sound
00005364 11FC 009E C4BD           M 	move.b	#schargerelease,(mqueue+((2)-1)).w
0000536A                            
0000536A 6000                       		bra.s	.DoUpdates			; Continue
0000536C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000536C                            .Charge:
0000536C 0C28 002D 0046             		cmpi.b	#45,oDashTimer(a0)		; Has Sonic charged enough?
00005372 6700                       		beq.s	.DoUpdates			; If so, branch
00005374 5228 0046                  		addq.b	#1,oDashTimer(a0)		; Increment the timer
00005378 0668 0046 003A             		addi.w	#$46,oGVel(a0)			; Increment ground velocity to handle animation and extended camera
0000537E 0828 0000 0028             		btst	#0,oStatus(a0)			; Is Sonic facing left?
00005384 6700                       		beq.s	.DoUpdates			; If so, branch
00005386 0468 008C 003A             		subi.w	#$46*2,oGVel(a0)		; Go the other way
0000538C 6000                       		bra.s	.DoUpdates			; Continue
0000538E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000538E                            .StopSound:
0000538E 4268 003A                  		clr.w	oGVel(a0)			; Stop ground movement
00005392 1168 0030 002D             		move.b	oInitColH(a0),oColH(a0)		; Reset collision height
00005398 1168 0031 002C             		move.b	oInitColW(a0),oColW(a0)		; Reset collision width
0000539E 5B68 0018                  		subq.w	#5,oYPos(a0)			; Align Sonic with the ground
000053A2                            
000053A2                            		playSnd	#sChargeStop, 2			; Play charge stop sound
000053A2 11FC 009D C4BD           M 	move.b	#schargestop,(mqueue+((2)-1)).w
000053A8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000053A8                            .DoUpdates:
000053A8 588F                       		addq.l	#4,sp				; Don't return to caller
000053AA 0C78 0060 F8CC             		cmpi.w	#(224/2)-16,rCamYPosDist.w	; Is the camera centered vertically?
000053B0 6700                       		beq.s	.FinishUpdates			; If so, branch
000053B2 6400                       		bhs.s	.ScrollUp			; If it's below the center, branch
000053B4 5878 F8CC                  		addq.w	#4,rCamYPosDist.w		; Scroll the camera up
000053B8                            
000053B8                            .ScrollUp:
000053B8 5578 F8CC                  		subq.w	#2,rCamYPosDist.w		; Scroll the camera down
000053BC                            
000053BC                            .FinishUpdates:
000053BC 4EF8 32BC                  		jmp	PlayerAnglePos			; Update position and angle along the ground
000053C0                            
000053C0                            .End:
000053C0 4E75                       		rts
000053C2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000053C2                            ; Check for jumping
000053C2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000053C2                            ObjPlayer_ChkJump:
000053C2 1038 F8D5                  		move.b	rCtrlPress.w,d0		; Get pressed buttons
000053C6 0200 0070                  		andi.b	#$70,d0				; Are A, B, or C pressed?
000053CA 4A38 C768                  		tst.b	rMoveCheat.w
000053CE 6700                       		beq.s	.NoDebug
000053D0 0200 0060                  		andi.b	#$60,d0				; Are A or C pressed?
000053D4                            
000053D4                            .NoDebug:
000053D4 4A00                       		tst.b	d0
000053D6 6700 0000                  		beq.w	.End				; If not, branch
000053DA                            
000053DA 7000                       		moveq	#0,d0
000053DC 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
000053E0 0600 0080                  		addi.b	#$80,d0				; Shift it to check the ceiling
000053E4 4EB8 2EE4                  		jsr	PlayerCalcRoomOverHead		; Get room over Sonic's head
000053E8 0C41 0006                  		cmpi.w	#6,d1				; Is it at least 6 pixels?
000053EC 6D00 0000                  		blt.w	.End				; If not, branch
000053F0                            
000053F0 343C 0680                  		move.w	#JUMP_HEIGHT,d2			; Standard jump height
000053F4 0828 0006 0028             		btst	#6,oStatus(a0)
000053FA 6700                       		beq.s	.NoWater
000053FC 0442 0300                  		subi.w	#$300,d2
00005400                            
00005400                            .NoWater:
00005400 7000                       		moveq	#0,d0
00005402 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
00005406 0400 0040                  		subi.b	#$40,d0				; Shift it
0000540A 4EB8 1374                  		jsr	CalcSine.w			; Get the sine and cosine
0000540E C3C2                       		muls.w	d2,d1				; Mutliply cosine with jump height
00005410 C1C2                       		muls.w	d2,d0				; Mutliply sine with jump height
00005412 E081                       		asr.l	#8,d1				; Shift the values over
00005414 E080                       		asr.l	#8,d0				; ''
00005416 D368 001C                  		add.w	d1,oXVel(a0)			; Add to X velocity
0000541A D168 001E                  		add.w	d0,oYVel(a0)			; Add to Y velocity
0000541E 0028 0006 0028             		ori.b	#6,oStatus(a0)			; Set "in air" and roll flags
00005424 08A8 0005 0028             		bclr	#5,oStatus(a0)			; Clear "pushing" flag
0000542A 584F                       		addq.w	#4,sp				; Do not return to collaer
0000542C 50E8 0040                  		st	oJumping(a0)			; Set the jumping flag
00005430                            		playSnd	#sLeap, 2			; Play jump sound
00005430 11FC 0082 C4BD           M 	move.b	#sleap,(mqueue+((2)-1)).w
00005436 117C 000E 002D             		move.b	#$E,oColH(a0)			; Reduce Sonic's hitbox
0000543C 117C 0007 002C             		move.b	#7,oColW(a0)			; ''
00005442 5A68 0018                  		addq.w	#5,oYPos(a0)			; Align Sonic to the ground
00005446 117C 0002 0020             		move.b	#2,oAni(a0)			; Set jumping animation
0000544C                            
0000544C                            .End:
0000544C 4E75                       		rts
0000544E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000544E                            ; Handle variable jumping
0000544E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000544E                            ObjPlayer_JumpHeight:
0000544E 4A28 0040                  		tst.b	oJumping(a0)			; Is Sonic jumping?
00005452 6700                       		beq.s	.UpVelCap			; If not, branch
00005454                            
00005454 323C FC00                  		move.w	#-MIN_JMP_HEIGHT,d1		; Standard minimum height
00005458 B268 001E                  		cmp.w	oYVel(a0),d1			; Is Sonic jumping at least hte minimum height?
0000545C 6F00                       		ble.s	.End				; If not, branch
0000545E 1038 F8D4                  		move.b	rCtrlHold.w,d0		; Get held buttons
00005462 0200 0070                  		andi.b	#$70,d0				; Are A, B, or C pressed?
00005466 4A38 C768                  		tst.b	rMoveCheat.w
0000546A 6700                       		beq.s	.NoDebug
0000546C 0200 0060                  		andi.b	#$60,d0				; Are A or C pressed?
00005470                            
00005470                            .NoDebug:
00005470 4A00                       		tst.b	d0
00005472 6600                       		bne.s	.End				; If not, branch
00005474 3141 001E                  		move.w	d1,oYVel(a0)			; Set to minimum height
00005478                            
00005478                            .End:
00005478 4E75                       		rts
0000547A                            
0000547A                            .UpVelCap:
0000547A 4A28 004B                  		tst.b	oBallMode(a0)			; Are we in ball mode?
0000547E 66F8                       		bne.s	.End				; If so, branch
00005480 0C68 F040 001E             		cmpi.w	#-$FC0,oYVel(a0)		; Cap Y velocity at -$FC0 when going up
00005486 6CF0                       		bge.s	.End				; ''
00005488 317C F040 001E             		move.w	#-$FC0,oYVel(a0)		; ''
0000548E 4E75                       		rts
00005490                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005490                            ; Gradually reset Sonic's angle in mid air
00005490                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005490                            ObjPlayer_JumpAngle:
00005490 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
00005494 6700                       		beq.s	ObjPlayer_JumpFlip		; If it's already reset, branch
00005496 6A00                       		bpl.s	.Decrease			; If it's positive, branch
00005498                            
00005498                            .Increase:
00005498 5400                       		addq.b	#2,d0				; Increase angle
0000549A 6B00                       		bmi.s	.SetAngle			; If it's not reset, branch
0000549C 7000                       		moveq	#0,d0				; Reset the angle
0000549E 6000                       		bra.s	.SetAngle
000054A0                            
000054A0                            .Decrease:
000054A0 5500                       		subq.b	#2,d0				; Decrease angle
000054A2 6A00                       		bpl.s	.SetAngle			; If it's not reset, branch
000054A4 7000                       		moveq	#0,d0				; Reset the angle
000054A6                            
000054A6                            .SetAngle:
000054A6 1140 0041                  		move.b	d0,oAngle(a0)			; Set the new angle
000054AA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000054AA                            ; Update Sonic's angle while he's tumbling in the air
000054AA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000054AA                            ObjPlayer_JumpFlip:
000054AA 1028 0047                  		move.b	oFlipAngle(a0),d0		; Get flip angle
000054AE 6700                       		beq.s	.End				; If it's 0, branch
000054B0 4A68 003A                  		tst.w	oFlipDir(a0)			; Is Sonic flipping left?
000054B4 6B00                       		bmi.s	.FlipLeft			; IF so, branch
000054B6                            
000054B6                            .FlipRight:
000054B6 1228 004A                  		move.b	oFlipSpeed(a0),d1		; Get flip speed
000054BA D001                       		add.b	d1,d0				; Add to angle
000054BC 6400                       		bcc.s	.FlipSet			; If it hasn't wrapped over, branch
000054BE 5328 0049                  		subq.b	#1,oFlipRemain(a0)		; Decrement flips remaining
000054C2 6400                       		bcc.s	.FlipSet			; If there are still some left
000054C4 4228 0049                  		clr.b	oFlipRemain(a0)			; Clear flips remaining
000054C8 7000                       		moveq	#0,d0				; Reset angle
000054CA 6000                       		bra.s	.FlipSet			; Continue
000054CC                            
000054CC                            .FlipLeft:
000054CC 4A28 0048                  		tst.b	oFlipTurned(a0)			; Is the flipping inverted?
000054D0 66E4                       		bne.s	.FlipRight			; If so, branch
000054D2 1228 004A                  		move.b	oFlipSpeed(a0),d1		; Get flip speed
000054D6 9001                       		sub.b	d1,d0				; Subtract from angle
000054D8 6400                       		bcc.s	.FlipSet			; If it hasn't wrapped over, branch
000054DA 5328 0049                  		subq.b	#1,oFlipRemain(a0)		; Decrement flips remaining
000054DE 6400                       		bcc.s	.FlipSet			; If there are still some left
000054E0 4228 0049                  		clr.b	oFlipRemain(a0)			; Clear flips remaining
000054E4 7000                       		moveq	#0,d0				; Reset angle
000054E6                            
000054E6                            .FlipSet:
000054E6 1140 0047                  		move.b	d0,oFlipAngle(a0)		; Update the angle
000054EA                            
000054EA                            .End:
000054EA 4E75                       		rts
000054EC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000054EC                            ; Check for rolling
000054EC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000054EC                            ObjPlayer_ChkRoll:
000054EC 3028 003A                  		move.w	oGVel(a0),d0			; Get ground velocity
000054F0 6A00                       		bpl.s	.ChkSpd				; Get absolute value
000054F2 4440                       		neg.w	d0				; ''
000054F4                            
000054F4                            .ChkSpd:
000054F4 0C40 0080                  		cmpi.w	#$80,d0				; Is Sonic going fast enough?
000054F8 6500                       		bcs.s	.NoRoll				; If not, branch
000054FA 1038 F8D4                  		move.b	rCtrlHold.w,d0		; Get held buttons
000054FE 0200 000C                  		andi.b	#$C,d0				; Are left or right held?
00005502 6600                       		bne.s	.NoRoll				; If not, branch
00005504 0838 0001 F8D4             		btst	#1,rCtrlHold.w		; Is down being held?
0000550A 6600                       		bne.s	ObjPlayer_DoRoll			; If so, branch
0000550C                            
0000550C                            .NoRoll:
0000550C 4E75                       		rts
0000550E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000550E                            ; Make Sonic roll
0000550E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000550E                            ObjPlayer_DoRoll:
0000550E 0828 0002 0028             		btst	#2,oStatus(a0)			; Is Sonic already rolling?
00005514 6600                       		bne.s	.End				; If so, branch
00005516 08E8 0002 0028             		bset	#2,oStatus(a0)			; Set roll flag
0000551C                            
0000551C 117C 000E 002D             		move.b	#$E,oColH(a0)			; Reduce Sonic's hitbox
00005522 117C 0007 002C             		move.b	#7,oColW(a0)			; ''
00005528 5A68 0018                  		addq.w	#5,oYPos(a0)			; Align Sonic to the ground
0000552C 117C 0002 0020             		move.b	#2,oAni(a0)			; Set rolling animation
00005532                            
00005532 4A68 003A                  		tst.w	oGVel(a0)			; Is Sonic moving already?
00005536 6600                       		bne.s	.End				; IF not, branch
00005538 317C 0200 003A             		move.w	#$200,oGVel(a0)			; Set speed
0000553E                            
0000553E                            .End:
0000553E 4E75                       		rts
00005540                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005540                            ; Slow Sonic down as he goes up a slope or speed him up when he does down one
00005540                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005540                            ObjPlayer_SlopePush:
00005540 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
00005544 0600 0060                  		addi.b	#$60,d0				; Shift it
00005548 0C00 00C0                  		cmpi.b	#$C0,d0				; Is Sonic on a steep slope or ceiling?
0000554C 6400                       		bcc.s	.End				; If not, branch
0000554E 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
00005552 4EB8 1374                  		jsr	CalcSine.w			; Get the sine of it
00005556 C1FC 0020                  		muls.w	#$20,d0				; Multiple it by $20
0000555A E080                       		asr.l	#8,d0				; Shift it
0000555C 4A68 003A                  		tst.w	oGVel(a0)			; Check speed
00005560 6700                       		beq.s	.End				; If Sonic is not moving, branch
00005562 D168 003A                  		add.w	d0,oGVel(a0)			; Add to ground velocity
00005566                            
00005566                            .End:
00005566 4E75                       		rts
00005568                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005568                            ; Check if Sonic is to fall off a slope
00005568                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005568                            ObjPlayer_FallOffSlope:
00005568 4A28 003F                  		tst.b	oMoveLock(a0)			; Is the move lock timer, active?
0000556C 6600                       		bne.s	.End				; If so, branch
0000556E 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
00005572 0600 0020                  		addi.b	#$20,d0				; Shift it
00005576 0200 00C0                  		andi.b	#$C0,d0				; Get quadrant
0000557A 6700                       		beq.s	.End				; If Sonic is on the floor, branch
0000557C 3028 003A                  		move.w	oGVel(a0),d0			; Get speed
00005580 6A00                       		bpl.s	.ChkSpeed			; If it's already positive, branch
00005582 4440                       		neg.w	d0				; Force it to be positive
00005584                            
00005584                            .ChkSpeed:
00005584 0C40 0280                  		cmpi.w	#$280,d0			; Is Sonic going at least 2.5 pixels per frame?
00005588 6400                       		bcc.s	.End				; If so, branch
0000558A 4268 003A                  		clr.w	oGVel(a0)			; Stop movement
0000558E 08E8 0001 0028             		bset	#1,oStatus(a0)			; Set "in air" flag
00005594 117C 001E 003F             		move.b	#$1E,oMoveLock(a0)		; Set move lock timer
0000559A                            
0000559A                            .End:
0000559A 4E75                       		rts
0000559C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000559C                            ; Affect Sonic's speed on slopes while rolling
0000559C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000559C                            ObjPlayer_RollSlopePush:
0000559C 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
000055A0 0600 0060                  		addi.b	#$60,d0				; ''
000055A4 0C00 00C0                  		cmpi.b	#$C0,d0				; Is Sonic on a steep enough slope?
000055A8 6400                       		bcc.s	.End				; If not, branch
000055AA                            
000055AA 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
000055AE 4EB8 1374                  		jsr	CalcSine.w			; Get sine
000055B2 C1FC 0050                  		muls.w	#$50,d0				; Multiply sine by $50
000055B6 E080                       		asr.l	#8,d0				; Shift over
000055B8                            
000055B8 4A68 003A                  		tst.w	oGVel(a0)			; Is Sonic moving right?
000055BC 6B00                       		bmi.s	.PushLeft			; If not, branch
000055BE 4A40                       		tst.w	d0				; Is the push speed positive?
000055C0 6A00                       		bpl.s	.Push				; If so, branch
000055C2 E480                       		asr.l	#2,d0				; Shift over more
000055C4                            
000055C4                            .Push:
000055C4 D168 003A                  		add.w	d0,oGVel(a0)			; Add push speed
000055C8 4E75                       		rts
000055CA                            
000055CA                            .PushLeft:
000055CA 4A40                       		tst.w	d0				; Is the push speed negative?
000055CC 6B00                       		bmi.s	.Push2				; If so, branch
000055CE E480                       		asr.l	#2,d0				; Shift over more
000055D0                            
000055D0                            .Push2:
000055D0 D168 003A                  		add.w	d0,oGVel(a0)			; Add push speed
000055D4                            
000055D4                            .End:
000055D4 4E75                       		rts
000055D6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000055D6                            ; Check for bouncy floor collision
000055D6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000055D6                            ObjPlayer_ChkBounce:
000055D6 4A38 F8FF                  		tst.b	rFloorActive.w		; Is the floor active?
000055DA 6700 0000                  		beq.w	.End				; If so, branch
000055DE                            
000055DE 0828 0001 0028             		btst	#1,oStatus(a0)			; Is Sonic in the air?
000055E4 6700                       		beq.s	.ChkDown			; If not, branch
000055E6                            
000055E6 4A68 001E                  		tst.w	oYVel(a0)			; Is Sonic falling?
000055EA 6700 0000                  		beq.w	.ChkBounceUp			; If not, branch
000055EE 6B00 0000                  		bmi.w	.ChkBounceUp			; ''
000055F2                            
000055F2                            .ChkDown:
000055F2 3428 0018                  		move.w	oYPos(a0),d2			; Get Y of left sensor
000055F6 1028 002D                  		move.b	oColH(a0),d0			; ''
000055FA 4880                       		ext.w	d0				; ''
000055FC D440                       		add.w	d0,d2				; ''
000055FE 5442                       		addq.w	#2,d2				; ''
00005600 3628 0014                  		move.w	oXPos(a0),d3			; Get X of left sensor
00005604 1028 002C                  		move.b	oColW(a0),d0			; ''
00005608 4880                       		ext.w	d0				; ''
0000560A 9640                       		sub.w	d0,d3				; ''
0000560C 4EB8 384C                  		jsr	Level_FindBlock			; Get the block located there
00005610 3011                       		move.w	(a1),d0				; ''
00005612 0240 03FF                  		andi.w	#$3FF,d0			; ''
00005616 0C40 0080                  		cmpi.w	#$80,d0				; Is the block the bouncy floor?
0000561A 6700                       		beq.s	.Bounce				; If so, branch
0000561C                            
0000561C 3428 0018                  		move.w	oYPos(a0),d2			; Get Y of right sensor
00005620 1028 002D                  		move.b	oColH(a0),d0			; ''
00005624 4880                       		ext.w	d0				; ''
00005626 D440                       		add.w	d0,d2				; ''
00005628 5442                       		addq.w	#2,d2				; ''
0000562A 3628 0014                  		move.w	oXPos(a0),d3			; Get X of right sensor
0000562E 1028 002C                  		move.b	oColW(a0),d0			; ''
00005632 4880                       		ext.w	d0				; ''
00005634 D640                       		add.w	d0,d3				; ''
00005636 4EB8 384C                  		jsr	Level_FindBlock			; Get the block located there
0000563A 3011                       		move.w	(a1),d0				; ''
0000563C 0240 03FF                  		andi.w	#$3FF,d0			; ''
00005640 0C40 0080                  		cmpi.w	#$80,d0				; Is the block the bouncy floor?
00005644 6600                       		bne.s	.End				; If not, branch
00005646                            
00005646                            .Bounce:
00005646 317C EA00 001E             		move.w	#-$1600,oYVel(a0)		; Bounce Sonic up
0000564C 08E8 0001 0028             		bset	#1,oStatus(a0)			; Set in air flag
00005652 4228 0040                  		clr.b	oJumping(a0)			; Clear jump flag
00005656 4228 0046                  		clr.b	oDashTimer(a0)			; Reset dash timer
0000565A 4228 0045                  		clr.b	oDashFlag(a0)			; Reset dash flag
0000565E                            
0000565E                            		playSnd	#sFloorBounce, 2		; Play the floor bounce sound
0000565E 11FC 009B C4BD           M 	move.b	#sfloorbounce,(mqueue+((2)-1)).w
00005664                            
00005664 0828 0002 0028             		btst	#2,oStatus(a0)			; Is Sonic already rolling?
0000566A 6600                       		bne.s	.End				; If so, branch
0000566C 08E8 0002 0028             		bset	#2,oStatus(a0)			; Set roll flag
00005672 117C 000E 002D             		move.b	#$E,oColH(a0)			; Reduce Sonic's hitbox
00005678 117C 0007 002C             		move.b	#7,oColW(a0)			; ''
0000567E 5A68 0018                  		addq.w	#5,oYPos(a0)			; Align Sonic to the ground
00005682 117C 0002 0020             		move.b	#2,oAni(a0)			; Set rolling animation
00005688                            
00005688                            .End:
00005688 4E75                       		rts
0000568A                            
0000568A                            .ChkBounceUp:
0000568A 3428 0018                  		move.w	oYPos(a0),d2			; Get Y of left sensor
0000568E 1028 002D                  		move.b	oColH(a0),d0			; ''
00005692 4880                       		ext.w	d0				; ''
00005694 9440                       		sub.w	d0,d2				; ''
00005696 5542                       		subq.w	#2,d2				; ''
00005698 3628 0014                  		move.w	oXPos(a0),d3			; Get X of left sensor
0000569C 1028 002C                  		move.b	oColW(a0),d0			; ''
000056A0 4880                       		ext.w	d0				; ''
000056A2 9640                       		sub.w	d0,d3				; ''
000056A4 4EB8 384C                  		jsr	Level_FindBlock			; Get the block located there
000056A8 3011                       		move.w	(a1),d0				; ''
000056AA 0240 03FF                  		andi.w	#$3FF,d0			; ''
000056AE 0C40 0080                  		cmpi.w	#$80,d0				; Is the block the bouncy floor?
000056B2 6700                       		beq.s	.BounceUp			; If so, branch
000056B4                            
000056B4 3428 0018                  		move.w	oYPos(a0),d2			; Get Y of right sensor
000056B8 1028 002D                  		move.b	oColH(a0),d0			; ''
000056BC 4880                       		ext.w	d0				; ''
000056BE 9440                       		sub.w	d0,d2				; ''
000056C0 5542                       		subq.w	#2,d2				; ''
000056C2 3628 0014                  		move.w	oXPos(a0),d3			; Get X of right sensor
000056C6 1028 002C                  		move.b	oColW(a0),d0			; ''
000056CA 4880                       		ext.w	d0				; ''
000056CC D640                       		add.w	d0,d3				; ''
000056CE 4EB8 384C                  		jsr	Level_FindBlock			; Get the block located there
000056D2 3011                       		move.w	(a1),d0				; ''
000056D4 0240 03FF                  		andi.w	#$3FF,d0			; ''
000056D8 0C40 0080                  		cmpi.w	#$80,d0				; Is the block the bouncy floor?
000056DC 66AA                       		bne.s	.End				; If not, branch
000056DE                            
000056DE                            .BounceUp:
000056DE 588F                       		addq.l	#4,sp				; Don't return to caller
000056E0                            
000056E0 317C 1600 001E             		move.w	#$1600,oYVel(a0)		; Bounce Sonic up
000056E6 08E8 0001 0028             		bset	#1,oStatus(a0)			; Set in air flag
000056EC 4228 0040                  		clr.b	oJumping(a0)			; Clear jump flag
000056F0 4228 0046                  		clr.b	oDashTimer(a0)			; Reset dash timer
000056F4 4228 0045                  		clr.b	oDashFlag(a0)			; Reset dash flag
000056F8                            
000056F8                            		playSnd	#sFloorBounce, 2		; Play the floor bounce sound
000056F8 11FC 009B C4BD           M 	move.b	#sfloorbounce,(mqueue+((2)-1)).w
000056FE                            
000056FE 0828 0002 0028             		btst	#2,oStatus(a0)			; Is Sonic already rolling?
00005704 6600                       		bne.s	.End2				; If so, branch
00005706 08E8 0002 0028             		bset	#2,oStatus(a0)			; Set roll flag
0000570C 117C 000E 002D             		move.b	#$E,oColH(a0)			; Reduce Sonic's hitbox
00005712 117C 0007 002C             		move.b	#7,oColW(a0)			; ''
00005718 5A68 0018                  		addq.w	#5,oYPos(a0)			; Align Sonic to the ground
0000571C 117C 0002 0020             		move.b	#2,oAni(a0)			; Set rolling animation
00005722                            
00005722                            .End2:
00005722 4E75                       		rts
00005724                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005724                            ; Check for bars to hang on to
00005724                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005724                            ObjPlayer_ChkHang:
00005724 0828 0003 000C             		btst	#3,oFlags(a0)			; Are we already hanging?
0000572A 6600                       		bne.s	.End				; If so, branch
0000572C                            
0000572C 3628 0014                  		move.w	oXPos(a0),d3			; X position
00005730 3428 0018                  		move.w	oYPos(a0),d2			; Y position
00005734 0442 0018                  		subi.w	#$18,d2				; ''
00005738 4EB8 384C                  		jsr	Level_FindBlock			; Get the block located there
0000573C 3011                       		move.w	(a1),d0				; ''
0000573E 0240 03FF                  		andi.w	#$3FF,d0			; ''
00005742 0C40 0081                  		cmpi.w	#$81,d0				; Is the block the bar?
00005746 6600                       		bne.s	.End				; If not, branch
00005748                            
00005748 08A8 0002 0028             		bclr	#2,oStatus(a0)			; Clear roll flag
0000574E 42A8 001C                  		clr.l	oXVel(a0)			; Stop movement
00005752 4268 003A                  		clr.w	oGVel(a0)			; ''
00005756 08E8 0003 000C             		bset	#3,oFlags(a0)			; Set hanging flag
0000575C 117C 000A 0020             		move.b	#$A,oAni(a0)			; Set hanging animation
00005762 117C 0007 004C             		move.b	#7,oHangAniTime(a0)		; Animation timer
00005768 3028 0018                  		move.w	oYPos(a0),d0			; Align with bar
0000576C 0440 0018                  		subi.w	#$18,d0				; ''
00005770 0240 FFF0                  		andi.w	#$FFF0,d0			; ''
00005774 0640 0018                  		addi.w	#$18,d0				; ''
00005778 3140 0018                  		move.w	d0,oYPos(a0)			; ''
0000577C 4228 0041                  		clr.b	oAngle(a0)			; Reset angle
00005780 08A8 0001 000D             		bclr	#1,oRender(a0)			; ''
00005786                            
00005786                            .End:
00005786 4E75                       		rts
00005788                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005788                            ; Hang onto the bars
00005788                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005788                            ObjPlayer_Hang:
00005788 3628 0014                  		move.w	oXPos(a0),d3			; X position
0000578C 3428 0018                  		move.w	oYPos(a0),d2			; Y position
00005790 0442 0018                  		subi.w	#$18,d2				; ''
00005794 4EB8 384C                  		jsr	Level_FindBlock			; Get the block located there
00005798 3011                       		move.w	(a1),d0				; ''
0000579A 0240 03FF                  		andi.w	#$3FF,d0			; ''
0000579E 0C40 0081                  		cmpi.w	#$81,d0				; Is the block the bar?
000057A2 6600                       		bne.s	.FallOff			; If not, branch
000057A4 1038 F8D5                  		move.b	rCtrlPress.w,d0		; Get control press bits
000057A8 0200 0070                  		andi.b	#$70,d0				; Are we jumping off?
000057AC 6700                       		beq.s	.MoveX				; If not, branch
000057AE                            
000057AE                            .FallOff:
000057AE 08A8 0003 000C             		bclr	#3,oFlags(a0)			; Stop hanging
000057B4 0668 0010 0018             		addi.w	#$10,oYPos(a0)			; Fall off
000057BA 1168 0030 002D             		move.b	oInitColH(a0),oColH(a0)		; Reset collision height
000057C0 1168 0031 002C             		move.b	oInitColW(a0),oColW(a0)		; Reset collision width
000057C6 4E75                       		rts
000057C8                            
000057C8                            .MoveX:
000057C8 7002                       		moveq	#2,d0				; X speed
000057CA 0838 0002 F8D4             		btst	#2,rCtrlHold.w		; Are we going left?
000057D0 6700                       		beq.s	.ChkRight			; If not, branch
000057D2 4440                       		neg.w	d0				; Go the other way
000057D4 08E8 0000 0028             		bset	#0,oStatus(a0)			; Face to the left
000057DA 08E8 0000 000D             		bset	#0,oRender(a0)			; ''
000057E0 6000                       		bra.s	.DoMove				; Continue
000057E2                            
000057E2                            .ChkRight:
000057E2 0838 0003 F8D4             		btst	#3,rCtrlHold.w		; Are we going left?
000057E8 6700                       		beq.s	.ResetScr			; If not, branch
000057EA 08A8 0000 0028             		bclr	#0,oStatus(a0)			; Face to the right
000057F0 08A8 0000 000D             		bclr	#0,oRender(a0)			; ''
000057F6                            
000057F6                            .DoMove:
000057F6 D168 0014                  		add.w	d0,oXPos(a0)			; Move
000057FA 5328 004C                  		subq.b	#1,oHangAniTime(a0)		; Decrement animation timer
000057FE 6A00                       		bpl.s	.ResetScr			; If it hasn't run out, branch
00005800 117C 0007 004C             		move.b	#7,oHangAniTime(a0)		; Reset timer
00005806 5228 0022                  		addq.b	#1,oAniFrame(a0)		; Increment animation frame
0000580A 0C28 0004 0022             		cmpi.b	#4,oAniFrame(a0)		; Have we reached the last one?
00005810 6500                       		bcs.s	.ResetScr			; If not, branch
00005812 4228 0022                  		clr.b	oAniFrame(a0)			; Reset animation frame
00005816                            
00005816                            .ResetScr:
00005816 4228 0044                  		clr.b	oScrlDelay(a0)			; Reset scroll delay counter
0000581A 0C78 0060 F8CC             		cmpi.w	#(224/2)-16,rCamYPosDist.w	; Is the camera centered vertically?
00005820 6700                       		beq.s	.End				; If so, branch
00005822 6400                       		bhs.s	.ScrollUp			; If it's below the center, branch
00005824 5878 F8CC                  		addq.w	#4,rCamYPosDist.w		; Scroll the camera up
00005828                            
00005828                            .ScrollUp:
00005828 5578 F8CC                  		subq.w	#2,rCamYPosDist.w		; Scroll the camera down
0000582C                            
0000582C                            .End:
0000582C 4E75                       		rts
0000582E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000582E                            ; Check for electricity
0000582E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000582E                            ObjPlayer_ChkElectric:
0000582E 3628 0014                  		move.w	oXPos(a0),d3			; X position
00005832 3428 0018                  		move.w	oYPos(a0),d2			; Y position
00005836 4EB8 384C                  		jsr	Level_FindBlock			; Get the block located there
0000583A 3011                       		move.w	(a1),d0				; ''
0000583C 0240 03FF                  		andi.w	#$3FF,d0			; ''
00005840                            
00005840 43FA 0000                  		lea	.Blocks(pc),a1			; BLocks to check
00005844 7C02                       		moveq	#2,d6				; ''
00005846                            
00005846                            .ChkBlocks:
00005846 B059                       		cmp.w	(a1)+,d0			; have we touched this block?
00005848 6700                       		beq.s	ObjPlayer_GetHurt		; If so, branch
0000584A 51CE FFFA                  		dbf	d6,.ChkBlocks			; Loop
0000584E 4E75                       		rts
00005850                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005850 0082 0083 0084             .Blocks:	dc.w	$82, $83, $84
00005856                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005856                            ; Get Sonic hurt
00005856                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005856                            ObjPlayer_GetHurt:
00005856                            		displaySprite	2,a0,a1,1		; Add sprite if not already being displayed
00005856 4A68 0008                M 	tst.w	odrawnext(a0)
0000585A 6600                     M 	bne.s	.no_221
0000585C 317C BE6A 0008           M 	move.w	#rdispinput+(2*dsize),odrawnext(a0)
00005862 3278 BE74                M 	move.w	rdispinput+dprev+(2*dsize).w,a1
00005866 3149 000A                M 	move.w	a1,odrawprev(a0)
0000586A 3348 0008                M 	move.w	a0,odrawnext(a1)
0000586E 31C8 BE74                M 	move.w	a0,rdispinput+dprev+(2*dsize).w
00005872                          M .no_221
00005872 4A28 0042                  		tst.b	oInvulTime(a0)			; Are we invulnerable?
00005876 6600 0000                  		bne.w	.End				; If so, branch
0000587A 4A78 F3D4                  		tst.w	rRings.w			; Does Sonic have any rings?
0000587E 6700 0000                  		beq.w	ObjPlayer_GetKilled		; If not, branch
00005882 4EB8 1A1C                  		jsr	FindFreeObj.w
00005886 6700                       		beq.s	.Hurt
00005888 22BC 0000 0000             		move.l	#ObjRingLoss,oAddr(a1)
0000588E 3368 0014 0014             		move.w	oXPos(a0),oXPos(a1)
00005894 3368 0018 0018             		move.w	oYPos(a0),oYPos(a1)
0000589A                            
0000589A                            .Hurt:
0000589A 117C 0008 0025             		move.b	#8,oRoutine(a0)			; Set to hurt routine
000058A0 4EB8 2E38                  		jsr	PlayerResetOnFloorPart2	; Reset Sonic like he would touching the ground
000058A4 4228 0044                  		clr.b	oScrlDelay(a0)			; Reset scroll delay counter
000058A8 08A8 0000 000C             		bclr	#0,oFlags(a0)			; Allow modes
000058AE 08A8 0003 000C             		bclr	#3,oFlags(a0)			; Stop hanging
000058B4 08E8 0001 0028             		bset	#1,oStatus(a0)			; Set the "in air" flag
000058BA 117C 001A 0020             		move.b	#$1A,oAni(a0)			; Set to hurt animation
000058C0 117C 0078 0042             		move.b	#$78,oInvulTime(a0)		; Set invulnerable timer
000058C6                            
000058C6 317C FC00 001E             		move.w	#-$400,oYVel(a0)		; Make Sonic bounce away
000058CC 317C FE00 001C             		move.w	#-$200,oXVel(a0)		; ''
000058D2 0828 0006 0028             		btst	#6,oStatus(a0)			; Is Sonic underwater?
000058D8 6700                       		beq.s	.ChkReverse			; If not, branch
000058DA 317C FE00 001E             		move.w	#-$200,oYVel(a0)		; Make Sonic bounce away slower
000058E0 317C FF00 001C             		move.w	#-$100,oXVel(a0)
000058E6                            
000058E6                            .ChkReverse:
000058E6 3028 0014                  		move.w	oXPos(a0),d0			; Get X position
000058EA B06A 0014                  		cmp.w	oXPos(a2),d0			; Is Sonic left of the object that hurt him?
000058EE 6500                       		bcs.s	.ChkSnd				; If so, branch
000058F0 4468 001C                  		neg.w	oXVel(a0)			; Make Sonic bounce the other way if on the right side
000058F4                            
000058F4                            .ChkSnd:
000058F4 4268 003A                  		clr.w	oGVel(a0)			; Reset ground velocity
000058F8                            
000058F8                            	;	cmpi.l	#ObjSpike,oAddr(a2)		; Did Sonic hit a spike?
000058F8                            	;	beq.s	.End				; If not, branch
000058F8                            		playSnd	#sHurt, 2			; Play hurt sound
000058F8 11FC 0084 C4BD           M 	move.b	#shurt,(mqueue+((2)-1)).w
000058FE                            
000058FE                            .End:
000058FE 70FF                       		moveq	#-1,d0				; Set return status
00005900 4E75                       		rts
00005902                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005902                            ; Hurt routine
00005902                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005902                            ObjPlayer_Hurt:
00005902 4A38 C768                  		tst.b	rMoveCheat.w
00005906 6700                       		beq.s	.NoPlacementEnter
00005908 0838 0004 C741             		btst	#4,rP1Press.w			; Has the B button been pressed?
0000590E 6700                       		beq.s	.NoPlacementEnter		; If not, branch
00005910 11FC 0001 F8D1             		move.b	#1,rDebugMode.w		; Enable debug placement mode
00005916 20BC 0000 0000             		move.l	#DebugPlacement,oAddr(a0)	; Set to debug placement mode
0000591C 4E75                       		rts
0000591E                            
0000591E                            .NoPlacementEnter:
0000591E 4EB8 1D4C                  		jsr	ObjectMove.w			; Allow movement
00005922 0668 0030 001E             		addi.w	#$30,oYVel(a0)			; Apply gravity
00005928 0828 0006 0028             		btst	#6,oStatus(a0)			; Is Sonic underwater?
0000592E 6700                       		beq.s	.NotWater			; If not, branch
00005930 0468 0020 001E             		subi.w	#$20,oYVel(a0)			; Reduce gravity underwater
00005936                            
00005936                            .NotWater:
00005936 117C 001A 0020             		move.b	#$1A,oAni(a0)			; Force the hurt animation
0000593C 6100                       		bsr.s	.ChkStop			; Check if Sonic has hit the ground or the bottom boundary
0000593E                            
0000593E 0C78 0060 F8CC             		cmpi.w	#(224/2)-16,rCamYPosDist.w	; Is the camera centered vertically?
00005944 6700                       		beq.s	.Cont				; If so, branch
00005946 6400                       		bhs.s	.ScrollUp			; If it's below the center, branch
00005948 5878 F8CC                  		addq.w	#4,rCamYPosDist.w		; Scroll the camera up
0000594C                            
0000594C                            .ScrollUp:
0000594C 5578 F8CC                  		subq.w	#2,rCamYPosDist.w		; Scroll the camera down
00005950                            
00005950                            .Cont:
00005950 6100 F82C                  		bsr.w	ObjPlayer_LvlBound		; Handle level boundaries
00005954 6100 0000                  		bsr.w	ObjPlayer_Animate		; Animate sprite
00005958 6000 0000                  		bra.w	ObjPlayer_LoadDPLCs		; Load DPLCs
0000595C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000595C                            .ChkStop:
0000595C 3038 F8C2                  		move.w	rMaxCamY.w,d0		; Get bottom boundary
00005960 0640 00E0                  		addi.w	#224,d0				; ''
00005964 B068 0018                  		cmp.w	oYPos(a0),d0			; Has Sonic hit it?
00005968 6D00                       		blt.s	ObjPlayer_GetKilled		; If so, branch
0000596A                            
0000596A 4EB8 2C42                  		jsr	PlayerChkCollision		; Check for level collision
0000596E 0828 0001 0028             		btst	#1,oStatus(a0)			; Is Sonic still in midair?
00005974 6600                       		bne.s	.End				; If so, branch
00005976                            
00005976 7000                       		moveq	#0,d0
00005978 3140 001E                  		move.w	d0,oYVel(a0)			; Stop Sonic's movement
0000597C 3140 001C                  		move.w	d0,oXVel(a0)			; ''
00005980 3140 003A                  		move.w	d0,oGVel(a0)			; ''
00005984 1140 000C                  		move.b	d0,oFlags(a0)			; Allow Sonic to move
00005988 1140 0020                  		move.b	d0,oAni(a0)			; Reset animation
0000598C 117C 0004 0025             		move.b	#4,oRoutine(a0)			; Set back to main routine
00005992                            
00005992                            .End:
00005992 4E75                       		rts
00005994                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005994                            ; Get Sonic killed
00005994                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005994                            ObjPlayer_GetKilled:
00005994                            		displaySprite	2,a0,a1,1		; Add sprite if not already being displayed
00005994 4A68 0008                M 	tst.w	odrawnext(a0)
00005998 6600                     M 	bne.s	.no_223
0000599A 317C BE6A 0008           M 	move.w	#rdispinput+(2*dsize),odrawnext(a0)
000059A0 3278 BE74                M 	move.w	rdispinput+dprev+(2*dsize).w,a1
000059A4 3149 000A                M 	move.w	a1,odrawprev(a0)
000059A8 3348 0008                M 	move.w	a0,odrawnext(a1)
000059AC 31C8 BE74                M 	move.w	a0,rdispinput+dprev+(2*dsize).w
000059B0                          M .no_223
000059B0 117C 000C 0025             		move.b	#$C,oRoutine(a0)			; Set to the death routine
000059B6 4EB8 2E38                  		jsr	PlayerResetOnFloorPart2	; Reset Sonic like he would touching the ground
000059BA 4228 0044                  		clr.b	oScrlDelay(a0)			; Reset scroll delay counter
000059BE 08E8 0001 0028             		bset	#1,oStatus(a0)			; Set the "in air" flag
000059C4 117C 0018 0020             		move.b	#$18,oAni(a0)			; Set to death animation
000059CA                            
000059CA 317C F900 001E             		move.w	#-$700,oYVel(a0)		; Make Sonic bounce up
000059D0 4268 001C                  		clr.w	oXVel(a0)			; Lock Sonic horizontally
000059D4 4268 003A                  		clr.w	oGVel(a0)			; ''
000059D8 31FC FFFF F8CE             		move.w	#$FFFF,rCamLocked.w		; Lock the camera
000059DE                            
000059DE                            	;	cmpi.l	#ObjSpike,oAddr(a2)		; Did Sonic hit a spike?
000059DE                            	;	beq.s	.End				; If not, branch
000059DE                            		playSnd	#sDeath,2			; Play death sound
000059DE 11FC 0084 C4BD           M 	move.b	#sdeath,(mqueue+((2)-1)).w
000059E4                            
000059E4                            .End:
000059E4 70FF                       		moveq	#-1,d0				; Set return status
000059E6 4E75                       		rts
000059E8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000059E8                            ; Death routine
000059E8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000059E8                            ObjPlayer_Dead:
000059E8 4A38 C768                  		tst.b	rMoveCheat.w
000059EC 6700                       		beq.s	.NoPlacementEnter
000059EE 0838 0004 C741             		btst	#4,rP1Press.w			; Has the B button been pressed?
000059F4 6700                       		beq.s	.NoPlacementEnter		; If not, branch
000059F6 11FC 0001 F8D1             		move.b	#1,rDebugMode.w		; Enable debug placement mode
000059FC 20BC 0000 0000             		move.l	#DebugPlacement,oAddr(a0)	; Set to debug placement mode
00005A02 4E75                       		rts
00005A04                            
00005A04                            .NoPlacementEnter:
00005A04 117C 0018 0020             		move.b	#$18,oAni(a0)			; Force the death animation
00005A0A 0068 8000 000E             		ori.w	#$8000,oVRAM(a0)		; Force high priority
00005A10 6100                       		bsr.s	ObjPlayer_ChkBound		; Check for when Sonic goes off screen
00005A12 4EB8 1D66                  		jsr	ObjectMoveAndFall.w		; Allow movement
00005A16 6100 0000                  		bsr.w	ObjPlayer_Animate		; Animate sprite
00005A1A 6000 0000                  		bra.w	ObjPlayer_LoadDPLCs		; Load DPLCs
00005A1E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005A1E                            ObjPlayer_ChkBound:
00005A1E 3038 F8C2                  		move.w	rMaxCamY.w,d0		; Get bottom boundary
00005A22 0640 0100                  		addi.w	#$100,d0			; ''
00005A26 B068 0018                  		cmp.w	oYPos(a0),d0			; Has Sonic hit it?
00005A2A 6C00                       		bge.s	.End				; If not, branch
00005A2C                            
00005A2C 117C 0010 0025             		move.b	#$10,oRoutine(a0)			; Go to gone routine
00005A32 117C 003C 0043             		move.b	#60,oDeathTimer(a0)		; Set death timer to 1 second
00005A38                            
00005A38                            .End:
00005A38 4E75                       		rts
00005A3A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005A3A                            ; Wait for level reload or game/time over
00005A3A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005A3A                            ObjPlayer_Gone:
00005A3A 4A28 0043                  		tst.b	oDeathTimer(a0)
00005A3E 6700                       		beq.s	.End
00005A40 5328 0043                  		subq.b	#1,oDeathTimer(a0)		; Decrement the death counter
00005A44 6600                       		bne.s	.End				; If it hasn't run out, branch
00005A46 50F8 F8FC                  		st	rLvlReload.w			; Reload the level
00005A4A                            
00005A4A                            .End:
00005A4A 4E75                       		rts
00005A4C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005A4C                            ; Display Sonic's sprite
00005A4C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005A4C                            ObjPlayer_Display:
00005A4C 1028 0042                  		move.b	oInvulTime(a0),d0		; Get invulnerability timer
00005A50 6700                       		beq.s	.Display			; If it's 0, branch
00005A52 5328 0042                  		subq.b	#1,oInvulTime(a0)		; Decrement invulnerability timer
00005A56 E648                       		lsr.w	#3,d0				; Can Sonic's sprite be displayed?
00005A58 6500                       		bcs.s	.Display			; If so, branch
00005A5A                            	removeSprite	a0,a1,1				; Remove sprite if displayed
00005A5A 4A68 0008                M 	tst.w	odrawnext(a0)
00005A5E 6700                     M 	beq.s	.yes_225
00005A60 3268 000A                M 	move.w	odrawprev(a0),a1
00005A64 3368 0008 0008           M 	move.w	odrawnext(a0),odrawnext(a1)
00005A6A 3268 0008                M 	move.w	odrawnext(a0),a1
00005A6E 3368 000A 000A           M 	move.w	odrawprev(a0),odrawprev(a1)
00005A74                          M .no_225
00005A74 42A8 0008                M 	clr.l	odrawnext(a0)
00005A78                          M .yes_225
00005A78 4E75                       		rts
00005A7A                            
00005A7A                            .Display:
00005A7A                            	displaySprite	2,a0,a1,1			; Add sprite if not already being displayed
00005A7A 4A68 0008                M 	tst.w	odrawnext(a0)
00005A7E 6600                     M 	bne.s	.no_226
00005A80 317C BE6A 0008           M 	move.w	#rdispinput+(2*dsize),odrawnext(a0)
00005A86 3278 BE74                M 	move.w	rdispinput+dprev+(2*dsize).w,a1
00005A8A 3149 000A                M 	move.w	a1,odrawprev(a0)
00005A8E 3348 0008                M 	move.w	a0,odrawnext(a1)
00005A92 31C8 BE74                M 	move.w	a0,rdispinput+dprev+(2*dsize).w
00005A96                          M .no_226
00005A96 4E75                       		rts
00005A98                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005A98                            ; Load Sonic's DPLCs
00005A98                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005A98                            ObjPlayer_LoadDPLCs:
00005A98 45F9 0000 0000             		lea	DPLC_ObjPlayer,a2		; DPLCs
00005A9E 383C F000                  		move.w	#$F000,d4			; VRAM location
00005AA2 2C3C 0000 0000             		move.l	#ArtUnc_Sonic,d6		; Art
00005AA8 4EF8 1D0C                  		jmp	LoadObjDPLCs.w			; Load DPLCs
00005AAC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005AAC                            ; Animate Sonic's sprite
00005AAC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005AAC                            ObjPlayer_Animate:
00005AAC 43F9 0000 0000             		lea	Ani_ObjPlayer,a1			; Animation script
00005AB2 7000                       		moveq	#0,d0
00005AB4 1028 0020                  		move.b	oAni(a0),d0			; Get animation ID
00005AB8 B028 0021                  		cmp.b	oPrevAni(a0),d0			; Has it changed?
00005ABC 6700                       		beq.s	.Run				; If not, branch
00005ABE 1140 0021                  		move.b	d0,oPrevAni(a0)			; Save the new ID
00005AC2 4228 0022                  		clr.b	oAniFrame(a0)			; Reset animation
00005AC6 4228 0023                  		clr.b	oAniTimer(a0)			; Reset animation timer
00005ACA 08A8 0005 0028             		bclr	#5,oStatus(a0)			; Clear "pushing" flag
00005AD0                            
00005AD0                            .Run:
00005AD0 D040                       		add.w	d0,d0				; Turn ID into offset
00005AD2 D2F1 0000                  		adda.w	(a1,d0.w),a1			; Get pointer to current animation script
00005AD6 1011                       		move.b	(a1),d0				; Get first byte
00005AD8 6B00                       		bmi.s	.WalkRunAnim			; If this is a special animation, branch
00005ADA 1228 0028                  		move.b	oStatus(a0),d1			; Get status
00005ADE 0201 0001                  		andi.b	#1,d1				; Only get horizontal flip bit
00005AE2 0228 00FC 000D             		andi.b	#$FC,oRender(a0)		; Mask out flip bits in render flags
00005AE8 8328 000D                  		or.b	d1,oRender(a0)			; Set flip bits
00005AEC 5328 0023                  		subq.b	#1,oAniTimer(a0)		; Decrement animation timer
00005AF0 6A00                       		bpl.s	.Wait				; If it hasn't run out, branch
00005AF2 1140 0023                  		move.b	d0,oAniTimer(a0)		; Set new animation timer
00005AF6                            
00005AF6                            .GetFrame:
00005AF6 7200                       		moveq	#0,d1
00005AF8 1228 0022                  		move.b	oAniFrame(a0),d1		; Get current value in the script
00005AFC 1031 1001                  		move.b	1(a1,d1.w),d0			; ''
00005B00 0C00 00FD                  		cmpi.b	#$FD,d0				; Is it a command value?
00005B04 6400                       		bhs.s	.CmdReset			; If so, branch
00005B06                            
00005B06                            .Next:
00005B06 1140 0010                  		move.b	d0,oFrame(a0)			; Set mapping frame ID
00005B0A 5228 0022                  		addq.b	#1,oAniFrame(a0)		; Advance into the animation script
00005B0E                            
00005B0E                            .Wait:
00005B0E 4E75                       		rts
00005B10                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005B10                            .CmdReset:
00005B10 5200                       		addq.b	#1,d0				; Is this flag $FF (reset)?
00005B12 6600                       		bne.s	.CmdJump			; If not, branch
00005B14 4228 0022                  		clr.b	oAniFrame(a0)			; Reset animation
00005B18 1029 0001                  		move.b	1(a1),d0			; Get first frame ID
00005B1C 60E8                       		bra.s	.Next				; Continue
00005B1E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005B1E                            .CmdJump:
00005B1E 5200                       		addq.b	#1,d0				; Is this flag $FE (jump)?
00005B20 6600                       		bne.s	.CmdSetAnim			; If not, branch
00005B22 1031 1002                  		move.b	2(a1,d1.w),d0			; Get jump offset
00005B26 9128 0022                  		sub.b	d0,oAniFrame(a0)		; Go back
00005B2A 9200                       		sub.b	d0,d1				; ''
00005B2C 1031 1001                  		move.b	1(a1,d1.w),d0			; Get new frame ID
00005B30 60D4                       		bra.s	.Next				; Continue
00005B32                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005B32                            .CmdSetAnim:
00005B32 5200                       		addq.b	#1,d0				; Is this flag $FD (set animation ID)?
00005B34 6600                       		bne.s	.CmdEnd				; If not, branch
00005B36 1171 1002 0020             		move.b	2(a1,d1.w),oAni(a0)		; Set new animation ID
00005B3C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005B3C                            .CmdEnd:
00005B3C 4E75                       		rts
00005B3E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005B3E                            .WalkRunAnim:
00005B3E 5328 0023                  		subq.b	#1,oAniTimer(a0)		; Decrement animation timer
00005B42 6ACA                       		bpl.s	.Wait				; If it hasn't run out, branch
00005B44 5200                       		addq.b	#1,d0				; Is the animation walking/running?
00005B46 6600 0000                  		bne.w	.RollAnim			; If not, branch
00005B4A                            
00005B4A 7000                       		moveq	#0,d0
00005B4C 1028 0047                  		move.b	oFlipAngle(a0),d0		; Is Sonic tumbling in the air?
00005B50 6600 0000                  		bne.w	.TumbleAnim			; If so, branch
00005B54                            
00005B54 7200                       		moveq	#0,d1				; Intial flip bits
00005B56 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
00005B5A 6B00                       		bmi.s	.ChkStatus			; If it's negative, branch
00005B5C 6700                       		beq.s	.ChkStatus			; If it's zero, branch
00005B5E 5300                       		subq.b	#1,d0				; Decrement angle if it's positive
00005B60                            
00005B60                            .ChkStatus:
00005B60 1428 0028                  		move.b	oStatus(a0),d2			; Get status
00005B64 0202 0001                  		andi.b	#1,d2				; Is Sonic mirrored horizontally?
00005B68 6600                       		bne.s	.ChkFlip			; If so, branch
00005B6A 4600                       		not.b	d0				; Reverse angle
00005B6C                            
00005B6C                            .ChkFlip:
00005B6C 0600 0010                  		addi.b	#$10,d0				; Shift angle
00005B70 6A00                       		bpl.s	.SetFlags			; If it's positive, branch
00005B72 7203                       		moveq	#3,d1				; Flags to flip Sonic's sprite
00005B74                            
00005B74                            .SetFlags:
00005B74 0228 00FC 000D             		andi.b	#$FC,oRender(a0)		; Mask out flip bits
00005B7A B302                       		eor.b	d1,d2				; Flip
00005B7C 8528 000D                  		or.b	d2,oRender(a0)			; Set in render flags
00005B80                            
00005B80 0828 0005 0028             		btst	#5,oStatus(a0)			; Is Sonic pushing?
00005B86 6600 0000                  		bne.w	.DoPushAnim			; If so, branch
00005B8A                            
00005B8A E808                       		lsr.b	#4,d0				; Divide angle by $10
00005B8C 0200 0006                  		andi.b	#6,d0				; Get angle section
00005B90                            
00005B90 3428 003A                  		move.w	oGVel(a0),d2			; Get Sonic's speed
00005B94 6A00                       		bpl.s	.GetAnim			; If it's already positive, branch
00005B96 4442                       		neg.w	d2				; Force it to be positive
00005B98                            
00005B98                            .GetAnim:
00005B98 43F9 0000 0000             		lea	SonicAni_Sprint,a1		; Sprinting animation
00005B9E 4A00                       		tst.b	d0
00005BA0 6600                       		bne.s	.ChkRun
00005BA2 0C42 0C00                  		cmpi.w	#$C00,d2			; Is Sonic sprinting?
00005BA6 6400                       		bcc.s	.SkipWalk			; If so, branch
00005BA8                            
00005BA8                            .ChkRun:
00005BA8 43F9 0000 0000             		lea	SonicAni_Run,a1			; Running animation
00005BAE 0C42 0600                  		cmpi.w	#$600,d2			; Is Sonic running?
00005BB2 6400                       		bcc.s	.SkipWalk			; If so, branch
00005BB4 43F9 0000 0000             		lea	SonicAni_Walk,a1		; Walking animation
00005BBA 1200                       		move.b	d0,d1				; Multiply angle section ID by 3
00005BBC E209                       		lsr.b	#1,d1				; ''
00005BBE D001                       		add.b	d1,d0				; ''
00005BC0                            
00005BC0                            .SkipWalk:
00005BC0 D000                       		add.b	d0,d0				; Double the offset
00005BC2 1600                       		move.b	d0,d3				; Copy the oofset
00005BC4 4442                       		neg.w	d2				; Get animation speed
00005BC6 0642 0800                  		addi.w	#$800,d2			; ''
00005BCA 6A00                       		bpl.s	.SetTimer			; ''
00005BCC 7400                       		moveq	#0,d2				; ''
00005BCE                            
00005BCE                            .SetTimer:
00005BCE E04A                       		lsr.w	#8,d2				; ''
00005BD0 1142 0023                  		move.b	d2,oAniTimer(a0)		; Set timer
00005BD4 6100 FF20                  		bsr.w	.GetFrame			; Get the next frame
00005BD8 D728 0010                  		add.b	d3,oFrame(a0)			; Add angle offset
00005BDC 4E75                       		rts
00005BDE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005BDE                            .TumbleAnim:
00005BDE 1028 0047                  		move.b	oFlipAngle(a0),d0		; Get flip angle
00005BE2 7200                       		moveq	#0,d1
00005BE4 1428 0028                  		move.b	oStatus(a0),d2			; Get status
00005BE8 0202 0001                  		andi.b	#1,d2				; Are we are facing left?
00005BEC 6600                       		bne.s	.TumbleLeft			; If so, branch
00005BEE                            
00005BEE 0228 00FC 000D             		andi.b	#$FC,oRender(a0)		; Clear flip bits
00005BF4 0600 000B                  		addi.b	#$B,d0				; Get map frame
00005BF8 80FC 0016                  		divu.w	#$16,d0				; ''
00005BFC 0600 0068                  		addi.b	#$68,d0				; ''
00005C00 1140 0010                  		move.b	d0,oFrame(a0)			; Set map frame
00005C04 4228 0023                  		clr.b	oAniTimer(a0)			; Reset animation timer
00005C08 4E75                       		rts
00005C0A                            
00005C0A                            .TumbleLeft:
00005C0A 0228 00FC 000D             		andi.b	#$FC,oRender(a0)		; Clear flip bits
00005C10 4A28 0048                  		tst.b	oFlipTurned(a0)			; Is flipping inverted?
00005C14 6700                       		beq.s	.NotInverted			; If not, branch
00005C16 0028 0001 000D             		ori.b	#1,oRender(a0)			; Face left
00005C1C 0600 000B                  		addi.b	#$B,d0				; Get map frame
00005C20 6000                       		bra.s	.SetLeftFrame			; Continue
00005C22                            
00005C22                            .NotInverted:
00005C22 0028 0003 000D             		ori.b	#3,oRender(a0)			; Face left and be upside down
00005C28 4400                       		neg.b	d0				; Get map frame
00005C2A 0600 008F                  		addi.b	#$8F,d0				; ''
00005C2E                            
00005C2E                            .SetLeftFrame:
00005C2E 80FC 0016                  		divu.w	#$16,d0				; Continue getting map frame
00005C32 0600 0068                  		addi.b	#$68,d0				; ''
00005C36 1140 0010                  		move.b	d0,oFrame(a0)			; Set map frame
00005C3A 4228 0023                  		clr.b	oAniTimer(a0)			; Reset animation timer
00005C3E 4E75                       		rts
00005C40                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005C40                            .RollAnim:
00005C40 5200                       		addq.b	#1,d0				; Is the animation rolling?
00005C42 6600                       		bne.s	.PushAnim			; If not, branch
00005C44                            
00005C44 3428 003A                  		move.w	oGVel(a0),d2			; Get Sonic's speed
00005C48 6A00                       		bpl.s	.GetAnim2			; If it's already negative, branch
00005C4A 4442                       		neg.w	d2				; Force it to be negative
00005C4C                            
00005C4C                            .GetAnim2:
00005C4C 43F9 0000 0000             		lea	SonicAni_Roll2,a1		; Use fast animation
00005C52 0C42 0600                  		cmpi.w	#$600,d2			; Is Sonic rolling fast enough?
00005C56 6400                       		bcc.s	.PrepareTimer			; If so, branch
00005C58 43F9 0000 0000             		lea	SonicAni_Roll,a1		; Use slower animation
00005C5E                            
00005C5E                            .PrepareTimer:
00005C5E 4442                       		neg.w	d2				; Get animation speed
00005C60 0642 0400                  		addi.w	#$400,d2			; ''
00005C64 6A00                       		bpl.s	.SetTimer2			; ''
00005C66 7400                       		moveq	#0,d2				; ''
00005C68                            
00005C68                            .SetTimer2:
00005C68 E04A                       		lsr.w	#8,d2				; ''
00005C6A 1142 0023                  		move.b	d2,oAniTimer(a0)		; Set timer
00005C6E                            
00005C6E 1228 0028                  		move.b	oStatus(a0),d1			; Get status
00005C72 0201 0001                  		andi.b	#1,d1				; Get horizontal flip flag only
00005C76 0228 00FC 000D             		andi.b	#$FC,oRender(a0)		; Clear flip bits in render flags
00005C7C 8328 000D                  		or.b	d1,oRender(a0)			; Set new flip bits
00005C80                            
00005C80 6000 FE74                  		bra.w	.GetFrame			; Get the next frame
00005C84                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005C84                            .PushAnim:
00005C84 5200                       		addq.b	#1,d0				; Is the animation rolling?
00005C86 6600                       		bne.s	.HangAnim			; If not, branch
00005C88                            
00005C88                            .DoPushAnim:
00005C88 3428 003A                  		move.w	oGVel(a0),d2			; Get Sonic's speed
00005C8C 6B00                       		bmi.s	.GetAnim3			; If it's already negative, branch
00005C8E 4442                       		neg.w	d2				; Force it to be negative
00005C90                            
00005C90                            .GetAnim3:
00005C90 0642 0800                  		addi.w	#$800,d2			; Get animation speed
00005C94 6A00                       		bpl.s	.SetTimer3			; ''
00005C96 7400                       		moveq	#0,d2				; ''
00005C98                            
00005C98                            .SetTimer3:
00005C98 EC4A                       		lsr.w	#6,d2				; ''
00005C9A 1142 0023                  		move.b	d2,oAniTimer(a0)		; Set timer
00005C9E 43F9 0000 0000             		lea	SonicAni_Push,a1		; Pushing animation
00005CA4 6000 FE50                  		bra.w	.GetFrame			; Get the next frame
00005CA8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005CA8                            .HangAnim:
00005CA8 7200                       		moveq	#0,d1
00005CAA 1228 0022                  		move.b	oAniFrame(a0),d1		; Get animation frame
00005CAE 1171 1001 0010             		move.b	1(a1,d1.w),oFrame(a0)		; Set map frame
00005CB4 4228 0023                  		clr.b	oAniTimer(a0)			; Clear animation timer
00005CB8 4E75                       		rts
00005CBA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005CBA                            ; Handle debug placement mode
00005CBA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005CBA                            DebugPlacement:
00005CBA 7000                       		moveq	#0,d0
00005CBC 1038 F8D1                  		move.b	rDebugMode.w,d0		; Get debug placement mode routine
00005CC0 0240 0002                  		andi.w	#2,d0				; Only allow 0, 2, 4, and 6
00005CC4 D040                       		add.w	d0,d0				; Double it
00005CC6 4EBB 0000                  		jsr	.Routines(pc,d0.w)		; Go to the correct routine
00005CCA                            	nextObject
00005CCA 3068 0004                M 	movea.w	onext(a0),a0
00005CCE 2250                     M 	move.l	oaddr(a0),a1
00005CD0 4ED1                     M 	jmp	(a1)
00005CD2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005CD2                            .Routines:
00005CD2 6000 0000                  		bra.w	Debug_Init			; Initialization(00*2)
00005CD6 6000 0000                  		bra.w	Debug_Main			; Main		(02*2)
00005CDA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005CDA                            Debug_Init:
00005CDA 5438 F8D1                  		addq.b	#2,rDebugMode.w		; Next routine
00005CDE 4228 0010                  		clr.b	oFrame(a0)			; Reset mapping frame
00005CE2 4228 0020                  		clr.b	oAni(a0)			; Reset animation
00005CE6 4268 003A                  		clr.w	oGVel(a0)			; Reset ground velocity
00005CEA 4278 F8CE                  		clr.w	rCamLocked.w			; Unlock the camera
00005CEE 4228 004B                  		clr.b	oBallMode(a0)			; Reset ball mode
00005CF2 4228 0041                  		clr.b	oAngle(a0)			; Reset angle
00005CF6 117C 0004 0025             		move.b	#4,oRoutine(a0)			; Set routine to main
00005CFC                            
00005CFC 3028 003C                  		move.w	oInteract(a0),d0		; Get object interacted with last
00005D00 6700                       		beq.s	.NoInteract			; If there is none, branch
00005D02 3240                       		movea.w	d0,a1
00005D04 08A9 0003 0028             		bclr	#3,oStatus(a1)			; Clear flags
00005D0A 08A9 0005 0028             		bclr	#5,oStatus(a1)			; ''
00005D10 4268 003C                  		clr.w	oInteract(a0)			; No more interaction
00005D14                            
00005D14                            .NoInteract:
00005D14 4228 000C                  		clr.b	oFlags(a0)			; Reset flags
00005D18 4228 0028                  		clr.b	oStatus(a0)			; Reset status
00005D1C 0228 00FC 000D             		andi.b	#$FC,oRender(a0)		; Mask out flip bits in render flags
00005D22 117C 0001 0010             		move.b	#1,oFrame(a0)			; Display the standing frame
00005D28 6100 FD6E                  		bsr.w	ObjPlayer_LoadDPLCs		; Load DPLCs
00005D2C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005D2C                            Debug_Main:
00005D2C 6100 EE34                  		bsr.w	ObjPlayer_ExtendedCam		; Handle extended camera
00005D30 6100                       		bsr.s	Debug_Control			; Control
00005D32                            	displaySprite	2,a0,a2,1
00005D32 4A68 0008                M 	tst.w	odrawnext(a0)
00005D36 6600                     M 	bne.s	.no_228
00005D38 317C BE6A 0008           M 	move.w	#rdispinput+(2*dsize),odrawnext(a0)
00005D3E 3478 BE74                M 	move.w	rdispinput+dprev+(2*dsize).w,a2
00005D42 314A 000A                M 	move.w	a2,odrawprev(a0)
00005D46 3548 0008                M 	move.w	a0,odrawnext(a2)
00005D4A 31C8 BE74                M 	move.w	a0,rdispinput+dprev+(2*dsize).w
00005D4E                          M .no_228
00005D4E 4E75                       		rts
00005D50                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005D50                            Debug_Control:
00005D50 7006                       		moveq	#6,d0				; Speed
00005D52 0838 0000 C740             		btst	#0,rP1Hold.w			; Is up being held?
00005D58 6700                       		beq.s	.NoUp				; If not, branch
00005D5A 9168 0018                  		sub.w	d0,oYPos(a0)			; Move up
00005D5E                            
00005D5E                            .NoUp:
00005D5E 0838 0001 C740             		btst	#1,rP1Hold.w			; Is down being held?
00005D64 6700                       		beq.s	.NoDown				; If not, branch
00005D66 D168 0018                  		add.w	d0,oYPos(a0)			; Move down
00005D6A                            
00005D6A                            .NoDown:
00005D6A 0838 0002 C740             		btst	#2,rP1Hold.w			; Is left being held?
00005D70 6700                       		beq.s	.NoLeft				; If not, branch
00005D72 9168 0014                  		sub.w	d0,oXPos(a0)			; Move left
00005D76                            
00005D76                            .NoLeft:
00005D76 0838 0003 C740             		btst	#3,rP1Hold.w			; Is right being held?
00005D7C 6700                       		beq.s	.NoRight			; If not, branch
00005D7E D168 0014                  		add.w	d0,oXPos(a0)			; Move right
00005D82                            
00005D82                            .NoRight:
00005D82 0838 0004 C741             		btst	#4,rP1Press.w			; Has the B button been pressed?
00005D88 6700                       		beq.s	.ChkWrap			; If not, branch
00005D8A 7000                       		moveq	#0,d0
00005D8C 11C0 F8D1                  		move.b	d0,rDebugMode.w		; Disable debug placement mode
00005D90 1140 0016                  		move.b	d0,oXPos+2(a0)			; Reset X subpixel
00005D94 1140 001A                  		move.b	d0,oYPos+2(a0)			; Reset Y subpixel
00005D98 3140 001C                  		move.w	d0,oXVel(a0)			; Reset X velocity
00005D9C 3140 001E                  		move.w	d0,oYVel(a0)			; Reset Y velocity
00005DA0 3140 003A                  		move.w	d0,oGVel(a0)			; Reset ground velocity
00005DA4 0228 0001 0028             		andi.b	#1,oStatus(a0)			; Reset status
00005DAA 08E8 0001 0028             		bset	#1,oStatus(a0)			; Set "in air" flag
00005DB0 20BC 0000 4A82             		move.l	#ObjPlayer,oAddr(a0)		; Use normal Sonic object
00005DB6 1168 0030 002D             		move.b	oInitColH(a0),oColH(a0)		; Reset collision height
00005DBC 1168 0031 002C             		move.b	oInitColW(a0),oColW(a0)		; Reset collision width
00005DC2                            
00005DC2                            .ChkWrap:
00005DC2 4E75                       		rts
00005DC4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005DC4                            ; Data
00005DC4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00005DC4                            Map_ObjPlayer:
00005DC4                            		include	"Objects/Player/Mappings.asm"
00005DC4                            ; --------------------------------------------------------------------------------
00005DC4                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
00005DC4                            ; --------------------------------------------------------------------------------
00005DC4                            
00005DC4                            SME_lde97:	
00005DC4 0000 0000                  		dc.w SME_lde97_FC-SME_lde97, SME_lde97_FE-SME_lde97	
00005DC8 0000 0000                  		dc.w SME_lde97_118-SME_lde97, SME_lde97_12C-SME_lde97	
00005DCC 0000 0000                  		dc.w SME_lde97_140-SME_lde97, SME_lde97_154-SME_lde97	
00005DD0 0000 0000                  		dc.w SME_lde97_168-SME_lde97, SME_lde97_182-SME_lde97	
00005DD4 0000 0000                  		dc.w SME_lde97_190-SME_lde97, SME_lde97_19E-SME_lde97	
00005DD8 0000 0000                  		dc.w SME_lde97_1B8-SME_lde97, SME_lde97_1C6-SME_lde97	
00005DDC 0000 0000                  		dc.w SME_lde97_1DA-SME_lde97, SME_lde97_1FA-SME_lde97	
00005DE0 0000 0000                  		dc.w SME_lde97_220-SME_lde97, SME_lde97_23A-SME_lde97	
00005DE4 0000 0000                  		dc.w SME_lde97_25A-SME_lde97, SME_lde97_274-SME_lde97	
00005DE8 0000 0000                  		dc.w SME_lde97_294-SME_lde97, SME_lde97_2AE-SME_lde97	
00005DEC 0000 0000                  		dc.w SME_lde97_2BC-SME_lde97, SME_lde97_2CA-SME_lde97	
00005DF0 0000 0000                  		dc.w SME_lde97_2E4-SME_lde97, SME_lde97_2F2-SME_lde97	
00005DF4 0000 0000                  		dc.w SME_lde97_306-SME_lde97, SME_lde97_32C-SME_lde97	
00005DF8 0000 0000                  		dc.w SME_lde97_352-SME_lde97, SME_lde97_36C-SME_lde97	
00005DFC 0000 0000                  		dc.w SME_lde97_38C-SME_lde97, SME_lde97_3A6-SME_lde97	
00005E00 0000 0000                  		dc.w SME_lde97_3C6-SME_lde97, SME_lde97_3D4-SME_lde97	
00005E04 0000 0000                  		dc.w SME_lde97_3E2-SME_lde97, SME_lde97_3F0-SME_lde97	
00005E08 0000 0000                  		dc.w SME_lde97_3FE-SME_lde97, SME_lde97_418-SME_lde97	
00005E0C 0000 0000                  		dc.w SME_lde97_42C-SME_lde97, SME_lde97_446-SME_lde97	
00005E10 0000 0000                  		dc.w SME_lde97_45A-SME_lde97, SME_lde97_468-SME_lde97	
00005E14 0000 0000                  		dc.w SME_lde97_476-SME_lde97, SME_lde97_484-SME_lde97	
00005E18 0000 0000                  		dc.w SME_lde97_492-SME_lde97, SME_lde97_4AC-SME_lde97	
00005E1C 0000 0000                  		dc.w SME_lde97_4BA-SME_lde97, SME_lde97_4D4-SME_lde97	
00005E20 0000 0000                  		dc.w SME_lde97_4E2-SME_lde97, SME_lde97_4EA-SME_lde97	
00005E24 0000 0000                  		dc.w SME_lde97_4F2-SME_lde97, SME_lde97_4FA-SME_lde97	
00005E28 0000 0000                  		dc.w SME_lde97_502-SME_lde97, SME_lde97_50A-SME_lde97	
00005E2C 0000 0000                  		dc.w SME_lde97_50C-SME_lde97, SME_lde97_50E-SME_lde97	
00005E30 0000 0000                  		dc.w SME_lde97_510-SME_lde97, SME_lde97_512-SME_lde97	
00005E34 0000 0000                  		dc.w SME_lde97_520-SME_lde97, SME_lde97_53A-SME_lde97	
00005E38 0000 0000                  		dc.w SME_lde97_554-SME_lde97, SME_lde97_568-SME_lde97	
00005E3C 0000 0000                  		dc.w SME_lde97_57C-SME_lde97, SME_lde97_590-SME_lde97	
00005E40 0000 0000                  		dc.w SME_lde97_59E-SME_lde97, SME_lde97_5B2-SME_lde97	
00005E44 0000 0000                  		dc.w SME_lde97_5C6-SME_lde97, SME_lde97_5DA-SME_lde97	
00005E48 0000 0000                  		dc.w SME_lde97_5F4-SME_lde97, SME_lde97_60E-SME_lde97	
00005E4C 0000 0000                  		dc.w SME_lde97_610-SME_lde97, SME_lde97_612-SME_lde97	
00005E50 0000 0000                  		dc.w SME_lde97_620-SME_lde97, SME_lde97_634-SME_lde97	
00005E54 0000 0000                  		dc.w SME_lde97_642-SME_lde97, SME_lde97_656-SME_lde97	
00005E58 0000 0000                  		dc.w SME_lde97_658-SME_lde97, SME_lde97_65A-SME_lde97	
00005E5C 0000 0000                  		dc.w SME_lde97_65C-SME_lde97, SME_lde97_67C-SME_lde97	
00005E60 0000 0000                  		dc.w SME_lde97_69C-SME_lde97, SME_lde97_69E-SME_lde97	
00005E64 0000 0000                  		dc.w SME_lde97_6A0-SME_lde97, SME_lde97_6A2-SME_lde97	
00005E68 0000 0000                  		dc.w SME_lde97_6A4-SME_lde97, SME_lde97_6A6-SME_lde97	
00005E6C 0000 0000                  		dc.w SME_lde97_6BA-SME_lde97, SME_lde97_6CE-SME_lde97	
00005E70 0000 0000                  		dc.w SME_lde97_6E2-SME_lde97, SME_lde97_6F6-SME_lde97	
00005E74 0000 0000                  		dc.w SME_lde97_704-SME_lde97, SME_lde97_712-SME_lde97	
00005E78 0000 0000                  		dc.w SME_lde97_720-SME_lde97, SME_lde97_72E-SME_lde97	
00005E7C 0000 0000                  		dc.w SME_lde97_73C-SME_lde97, SME_lde97_73E-SME_lde97	
00005E80 0000 0000                  		dc.w SME_lde97_740-SME_lde97, SME_lde97_742-SME_lde97	
00005E84 0000 0000                  		dc.w SME_lde97_744-SME_lde97, SME_lde97_746-SME_lde97	
00005E88 0000 0000                  		dc.w SME_lde97_748-SME_lde97, SME_lde97_74A-SME_lde97	
00005E8C 0000 0000                  		dc.w SME_lde97_74C-SME_lde97, SME_lde97_74E-SME_lde97	
00005E90 0000 0000                  		dc.w SME_lde97_750-SME_lde97, SME_lde97_752-SME_lde97	
00005E94 0000 0000                  		dc.w SME_lde97_754-SME_lde97, SME_lde97_768-SME_lde97	
00005E98 0000 0000                  		dc.w SME_lde97_77C-SME_lde97, SME_lde97_78A-SME_lde97	
00005E9C 0000 0000                  		dc.w SME_lde97_792-SME_lde97, SME_lde97_7A0-SME_lde97	
00005EA0 0000 0000                  		dc.w SME_lde97_7B4-SME_lde97, SME_lde97_7C8-SME_lde97	
00005EA4 0000 0000                  		dc.w SME_lde97_7DC-SME_lde97, SME_lde97_7EA-SME_lde97	
00005EA8 0000 0000                  		dc.w SME_lde97_7F8-SME_lde97, SME_lde97_80C-SME_lde97	
00005EAC 0000 0000                  		dc.w SME_lde97_81A-SME_lde97, SME_lde97_828-SME_lde97	
00005EB0 0000 0000                  		dc.w SME_lde97_836-SME_lde97, SME_lde97_844-SME_lde97	
00005EB4 0000 0000                  		dc.w SME_lde97_858-SME_lde97, SME_lde97_86C-SME_lde97	
00005EB8 0000 0000                  		dc.w SME_lde97_880-SME_lde97, SME_lde97_89A-SME_lde97	
00005EBC 0000 0000                  		dc.w SME_lde97_8B4-SME_lde97, SME_lde97_8CE-SME_lde97	
00005EC0 0000                       SME_lde97_FC:	dc.b 0, 0	
00005EC2 0004                       SME_lde97_FE:	dc.b 0, 4	
00005EC4 EC08 0000 FFF0             		dc.b $EC, 8, 0, 0, $FF, $F0	
00005ECA F40D 0003 FFF0             		dc.b $F4, $D, 0, 3, $FF, $F0	
00005ED0 0408 000B FFF0             		dc.b 4, 8, 0, $B, $FF, $F0	
00005ED6 0C08 000E FFF8             		dc.b $C, 8, 0, $E, $FF, $F8	
00005EDC 0003                       SME_lde97_118:	dc.b 0, 3	
00005EDE EC09 0000 FFF0             		dc.b $EC, 9, 0, 0, $FF, $F0	
00005EE4 FC09 0006 FFF0             		dc.b $FC, 9, 0, 6, $FF, $F0	
00005EEA 0C08 000C FFF8             		dc.b $C, 8, 0, $C, $FF, $F8	
00005EF0 0003                       SME_lde97_12C:	dc.b 0, 3	
00005EF2 EC09 0000 FFF0             		dc.b $EC, 9, 0, 0, $FF, $F0	
00005EF8 FC09 0006 FFF0             		dc.b $FC, 9, 0, 6, $FF, $F0	
00005EFE 0C08 000C FFF8             		dc.b $C, 8, 0, $C, $FF, $F8	
00005F04 0003                       SME_lde97_140:	dc.b 0, 3	
00005F06 EC09 0000 FFF0             		dc.b $EC, 9, 0, 0, $FF, $F0	
00005F0C FC09 0006 FFF0             		dc.b $FC, 9, 0, 6, $FF, $F0	
00005F12 0C08 000C FFF8             		dc.b $C, 8, 0, $C, $FF, $F8	
00005F18 0003                       SME_lde97_154:	dc.b 0, 3	
00005F1A EC0A 0000 FFF0             		dc.b $EC, $A, 0, 0, $FF, $F0	
00005F20 0408 0009 FFF0             		dc.b 4, 8, 0, 9, $FF, $F0	
00005F26 0C08 000C FFF8             		dc.b $C, 8, 0, $C, $FF, $F8	
00005F2C 0004                       SME_lde97_168:	dc.b 0, 4	
00005F2E EB0D 0000 FFEC             		dc.b $EB, $D, 0, 0, $FF, $EC	
00005F34 FB09 0008 FFEC             		dc.b $FB, 9, 0, 8, $FF, $EC	
00005F3A FB06 000E 0004             		dc.b $FB, 6, 0, $E, 0, 4	
00005F40 0B04 0014 FFEC             		dc.b $B, 4, 0, $14, $FF, $EC	
00005F46 0002                       SME_lde97_182:	dc.b 0, 2	
00005F48 EC0D 0000 FFED             		dc.b $EC, $D, 0, 0, $FF, $ED	
00005F4E FC0E 0008 FFF5             		dc.b $FC, $E, 0, 8, $FF, $F5	
00005F54 0002                       SME_lde97_190:	dc.b 0, 2	
00005F56 ED09 0000 FFF3             		dc.b $ED, 9, 0, 0, $FF, $F3	
00005F5C FD0A 0006 FFF3             		dc.b $FD, $A, 0, 6, $FF, $F3	
00005F62 0004                       SME_lde97_19E:	dc.b 0, 4	
00005F64 EB09 0000 FFF4             		dc.b $EB, 9, 0, 0, $FF, $F4	
00005F6A FB09 0006 FFEC             		dc.b $FB, 9, 0, 6, $FF, $EC	
00005F70 FB06 000C 0004             		dc.b $FB, 6, 0, $C, 0, 4	
00005F76 0B04 0012 FFEC             		dc.b $B, 4, 0, $12, $FF, $EC	
00005F7C 0002                       SME_lde97_1B8:	dc.b 0, 2	
00005F7E EC09 0000 FFF3             		dc.b $EC, 9, 0, 0, $FF, $F3	
00005F84 FC0E 0006 FFEB             		dc.b $FC, $E, 0, 6, $FF, $EB	
00005F8A 0003                       SME_lde97_1C6:	dc.b 0, 3	
00005F8C ED0D 0000 FFEC             		dc.b $ED, $D, 0, 0, $FF, $EC	
00005F92 FD0C 0008 FFF4             		dc.b $FD, $C, 0, 8, $FF, $F4	
00005F98 0509 000C FFF4             		dc.b 5, 9, 0, $C, $FF, $F4	
00005F9E 0005                       SME_lde97_1DA:	dc.b 0, 5	
00005FA0 EB09 0000 FFEB             		dc.b $EB, 9, 0, 0, $FF, $EB	
00005FA6 EB06 0006 0003             		dc.b $EB, 6, 0, 6, 0, 3	
00005FAC FB08 000C FFEB             		dc.b $FB, 8, 0, $C, $FF, $EB	
00005FB2 0309 000F FFF3             		dc.b 3, 9, 0, $F, $FF, $F3	
00005FB8 1300 0015 FFFB             		dc.b $13, 0, 0, $15, $FF, $FB	
00005FBE 0006                       SME_lde97_1FA:	dc.b 0, 6	
00005FC0 EC09 0000 FFEC             		dc.b $EC, 9, 0, 0, $FF, $EC	
00005FC6 EC01 0006 0004             		dc.b $EC, 1, 0, 6, 0, 4	
00005FCC FC0C 0008 FFEC             		dc.b $FC, $C, 0, 8, $FF, $EC	
00005FD2 0409 000C FFF4             		dc.b 4, 9, 0, $C, $FF, $F4	
00005FD8 FC05 0012 000C             		dc.b $FC, 5, 0, $12, 0, $C	
00005FDE F400 0016 0014             		dc.b $F4, 0, 0, $16, 0, $14	
00005FE4 0004                       SME_lde97_220:	dc.b 0, 4	
00005FE6 ED09 0000 FFED             		dc.b $ED, 9, 0, 0, $FF, $ED	
00005FEC ED01 0006 0005             		dc.b $ED, 1, 0, 6, 0, 5	
00005FF2 FD0D 0008 FFF5             		dc.b $FD, $D, 0, 8, $FF, $F5	
00005FF8 0D08 0010 FFFD             		dc.b $D, 8, 0, $10, $FF, $FD	
00005FFE 0005                       SME_lde97_23A:	dc.b 0, 5	
00006000 EB09 0000 FFEB             		dc.b $EB, 9, 0, 0, $FF, $EB	
00006006 EB05 0006 0003             		dc.b $EB, 5, 0, 6, 0, 3	
0000600C FB0D 000A FFF3             		dc.b $FB, $D, 0, $A, $FF, $F3	
00006012 0B08 0012 FFF3             		dc.b $B, 8, 0, $12, $FF, $F3	
00006018 1304 0015 FFFB             		dc.b $13, 4, 0, $15, $FF, $FB	
0000601E 0004                       SME_lde97_25A:	dc.b 0, 4	
00006020 EC09 0000 FFEC             		dc.b $EC, 9, 0, 0, $FF, $EC	
00006026 EC01 0006 0004             		dc.b $EC, 1, 0, 6, 0, 4	
0000602C FC0D 0008 FFF4             		dc.b $FC, $D, 0, 8, $FF, $F4	
00006032 0C08 0010 FFFC             		dc.b $C, 8, 0, $10, $FF, $FC	
00006038 0005                       SME_lde97_274:	dc.b 0, 5	
0000603A ED09 0000 FFED             		dc.b $ED, 9, 0, 0, $FF, $ED	
00006040 ED01 0006 0005             		dc.b $ED, 1, 0, 6, 0, 5	
00006046 FD00 0008 FFED             		dc.b $FD, 0, 0, 8, $FF, $ED	
0000604C FD0D 0009 FFF5             		dc.b $FD, $D, 0, 9, $FF, $F5	
00006052 0D08 0011 FFFD             		dc.b $D, 8, 0, $11, $FF, $FD	
00006058 0004                       SME_lde97_294:	dc.b 0, 4	
0000605A F407 0000 FFEB             		dc.b $F4, 7, 0, 0, $FF, $EB	
00006060 EC09 0008 FFFB             		dc.b $EC, 9, 0, 8, $FF, $FB	
00006066 FC04 000E FFFB             		dc.b $FC, 4, 0, $E, $FF, $FB	
0000606C 0409 0010 FFFB             		dc.b 4, 9, 0, $10, $FF, $FB	
00006072 0002                       SME_lde97_2AE:	dc.b 0, 2	
00006074 F407 0000 FFEC             		dc.b $F4, 7, 0, 0, $FF, $EC	
0000607A EC0B 0008 FFFC             		dc.b $EC, $B, 0, 8, $FF, $FC	
00006080 0002                       SME_lde97_2BC:	dc.b 0, 2	
00006082 F406 0000 FFED             		dc.b $F4, 6, 0, 0, $FF, $ED	
00006088 F40A 0006 FFFD             		dc.b $F4, $A, 0, 6, $FF, $FD	
0000608E 0004                       SME_lde97_2CA:	dc.b 0, 4	
00006090 F406 0000 FFEB             		dc.b $F4, 6, 0, 0, $FF, $EB	
00006096 EC09 0006 FFFB             		dc.b $EC, 9, 0, 6, $FF, $FB	
0000609C FC04 000C FFFB             		dc.b $FC, 4, 0, $C, $FF, $FB	
000060A2 0409 000E FFFB             		dc.b 4, 9, 0, $E, $FF, $FB	
000060A8 0002                       SME_lde97_2E4:	dc.b 0, 2	
000060AA F406 0000 FFEC             		dc.b $F4, 6, 0, 0, $FF, $EC	
000060B0 F40B 0006 FFFC             		dc.b $F4, $B, 0, 6, $FF, $FC	
000060B6 0003                       SME_lde97_2F2:	dc.b 0, 3	
000060B8 F407 0000 FFED             		dc.b $F4, 7, 0, 0, $FF, $ED	
000060BE EC00 0008 FFFD             		dc.b $EC, 0, 0, 8, $FF, $FD	
000060C4 F40A 0009 FFFD             		dc.b $F4, $A, 0, 9, $FF, $FD	
000060CA 0006                       SME_lde97_306:	dc.b 0, 6	
000060CC FD06 0000 FFEB             		dc.b $FD, 6, 0, 0, $FF, $EB	
000060D2 ED04 0006 FFF3             		dc.b $ED, 4, 0, 6, $FF, $F3	
000060D8 F504 0008 FFEB             		dc.b $F5, 4, 0, 8, $FF, $EB	
000060DE F50A 000A FFFB             		dc.b $F5, $A, 0, $A, $FF, $FB	
000060E4 0D00 0013 FFFB             		dc.b $D, 0, 0, $13, $FF, $FB	
000060EA FD00 0014 0013             		dc.b $FD, 0, 0, $14, 0, $13	
000060F0 0006                       SME_lde97_32C:	dc.b 0, 6	
000060F2 FC06 0000 FFEC             		dc.b $FC, 6, 0, 0, $FF, $EC	
000060F8 E408 0006 FFF4             		dc.b $E4, 8, 0, 6, $FF, $F4	
000060FE EC04 0009 FFFC             		dc.b $EC, 4, 0, 9, $FF, $FC	
00006104 F404 000B FFEC             		dc.b $F4, 4, 0, $B, $FF, $EC	
0000610A F40A 000D FFFC             		dc.b $F4, $A, 0, $D, $FF, $FC	
00006110 0C00 0016 FFFC             		dc.b $C, 0, 0, $16, $FF, $FC	
00006116 0004                       SME_lde97_352:	dc.b 0, 4	
00006118 FB06 0000 FFED             		dc.b $FB, 6, 0, 0, $FF, $ED	
0000611E F304 0006 FFED             		dc.b $F3, 4, 0, 6, $FF, $ED	
00006124 EB0A 0008 FFFD             		dc.b $EB, $A, 0, 8, $FF, $FD	
0000612A 0304 0011 FFFD             		dc.b 3, 4, 0, $11, $FF, $FD	
00006130 0005                       SME_lde97_36C:	dc.b 0, 5	
00006132 FD06 0000 FFEB             		dc.b $FD, 6, 0, 0, $FF, $EB	
00006138 ED08 0006 FFF3             		dc.b $ED, 8, 0, 6, $FF, $F3	
0000613E F504 0009 FFEB             		dc.b $F5, 4, 0, 9, $FF, $EB	
00006144 F50D 000B FFFB             		dc.b $F5, $D, 0, $B, $FF, $FB	
0000614A 0508 0013 FFFB             		dc.b 5, 8, 0, $13, $FF, $FB	
00006150 0004                       SME_lde97_38C:	dc.b 0, 4	
00006152 FC06 0000 FFEC             		dc.b $FC, 6, 0, 0, $FF, $EC	
00006158 F404 0006 FFEC             		dc.b $F4, 4, 0, 6, $FF, $EC	
0000615E EC0A 0008 FFFC             		dc.b $EC, $A, 0, 8, $FF, $FC	
00006164 0404 0011 FFFC             		dc.b 4, 4, 0, $11, $FF, $FC	
0000616A 0005                       SME_lde97_3A6:	dc.b 0, 5	
0000616C FB06 0000 FFED             		dc.b $FB, 6, 0, 0, $FF, $ED	
00006172 EB0A 0006 FFFD             		dc.b $EB, $A, 0, 6, $FF, $FD	
00006178 F304 000F FFED             		dc.b $F3, 4, 0, $F, $FF, $ED	
0000617E 0304 0011 FFFD             		dc.b 3, 4, 0, $11, $FF, $FD	
00006184 0B00 0013 FFFD             		dc.b $B, 0, 0, $13, $FF, $FD	
0000618A 0002                       SME_lde97_3C6:	dc.b 0, 2	
0000618C EE09 0000 FFF4             		dc.b $EE, 9, 0, 0, $FF, $F4	
00006192 FE0E 0006 FFEC             		dc.b $FE, $E, 0, 6, $FF, $EC	
00006198 0002                       SME_lde97_3D4:	dc.b 0, 2	
0000619A EE09 0000 FFF4             		dc.b $EE, 9, 0, 0, $FF, $F4	
000061A0 FE0E 0006 FFEC             		dc.b $FE, $E, 0, 6, $FF, $EC	
000061A6 0002                       SME_lde97_3E2:	dc.b 0, 2	
000061A8 EE09 0000 FFF4             		dc.b $EE, 9, 0, 0, $FF, $F4	
000061AE FE0E 0006 FFEC             		dc.b $FE, $E, 0, 6, $FF, $EC	
000061B4 0002                       SME_lde97_3F0:	dc.b 0, 2	
000061B6 EE09 0000 FFF4             		dc.b $EE, 9, 0, 0, $FF, $F4	
000061BC FE0E 0006 FFEC             		dc.b $FE, $E, 0, 6, $FF, $EC	
000061C2 0004                       SME_lde97_3FE:	dc.b 0, 4	
000061C4 EE09 0000 FFEE             		dc.b $EE, 9, 0, 0, $FF, $EE	
000061CA EE01 0006 0006             		dc.b $EE, 1, 0, 6, 0, 6	
000061D0 FE0E 0008 FFF6             		dc.b $FE, $E, 0, 8, $FF, $F6	
000061D6 FE00 0014 FFEE             		dc.b $FE, 0, 0, $14, $FF, $EE	
000061DC 0003                       SME_lde97_418:	dc.b 0, 3	
000061DE EE09 0000 FFEE             		dc.b $EE, 9, 0, 0, $FF, $EE	
000061E4 EE01 0006 0006             		dc.b $EE, 1, 0, 6, 0, 6	
000061EA FE0E 0008 FFF6             		dc.b $FE, $E, 0, 8, $FF, $F6	
000061F0 0004                       SME_lde97_42C:	dc.b 0, 4	
000061F2 EE09 0000 FFEE             		dc.b $EE, 9, 0, 0, $FF, $EE	
000061F8 EE01 0006 0006             		dc.b $EE, 1, 0, 6, 0, 6	
000061FE FE0E 0008 FFF6             		dc.b $FE, $E, 0, 8, $FF, $F6	
00006204 FE00 0014 FFEE             		dc.b $FE, 0, 0, $14, $FF, $EE	
0000620A 0003                       SME_lde97_446:	dc.b 0, 3	
0000620C EE09 0000 FFEE             		dc.b $EE, 9, 0, 0, $FF, $EE	
00006212 EE01 0006 0006             		dc.b $EE, 1, 0, 6, 0, 6	
00006218 FE0E 0008 FFF6             		dc.b $FE, $E, 0, 8, $FF, $F6	
0000621E 0002                       SME_lde97_45A:	dc.b 0, 2	
00006220 F406 0000 FFEE             		dc.b $F4, 6, 0, 0, $FF, $EE	
00006226 F40B 0006 FFFE             		dc.b $F4, $B, 0, 6, $FF, $FE	
0000622C 0002                       SME_lde97_468:	dc.b 0, 2	
0000622E F406 0000 FFEE             		dc.b $F4, 6, 0, 0, $FF, $EE	
00006234 F40B 0006 FFFE             		dc.b $F4, $B, 0, 6, $FF, $FE	
0000623A 0002                       SME_lde97_476:	dc.b 0, 2	
0000623C F406 0000 FFEE             		dc.b $F4, 6, 0, 0, $FF, $EE	
00006242 F40B 0006 FFFE             		dc.b $F4, $B, 0, 6, $FF, $FE	
00006248 0002                       SME_lde97_484:	dc.b 0, 2	
0000624A F406 0000 FFEE             		dc.b $F4, 6, 0, 0, $FF, $EE	
00006250 F40B 0006 FFFE             		dc.b $F4, $B, 0, 6, $FF, $FE	
00006256 0004                       SME_lde97_492:	dc.b 0, 4	
00006258 FA06 0000 FFEE             		dc.b $FA, 6, 0, 0, $FF, $EE	
0000625E F204 0006 FFEE             		dc.b $F2, 4, 0, 6, $FF, $EE	
00006264 EA0B 0008 FFFE             		dc.b $EA, $B, 0, 8, $FF, $FE	
0000626A 0A00 0014 FFFE             		dc.b $A, 0, 0, $14, $FF, $FE	
00006270 0002                       SME_lde97_4AC:	dc.b 0, 2	
00006272 F207 0000 FFEE             		dc.b $F2, 7, 0, 0, $FF, $EE	
00006278 EA0B 0008 FFFE             		dc.b $EA, $B, 0, 8, $FF, $FE	
0000627E 0004                       SME_lde97_4BA:	dc.b 0, 4	
00006280 FA06 0000 FFEE             		dc.b $FA, 6, 0, 0, $FF, $EE	
00006286 F204 0006 FFEE             		dc.b $F2, 4, 0, 6, $FF, $EE	
0000628C EA0B 0008 FFFE             		dc.b $EA, $B, 0, 8, $FF, $FE	
00006292 0A00 0014 FFFE             		dc.b $A, 0, 0, $14, $FF, $FE	
00006298 0002                       SME_lde97_4D4:	dc.b 0, 2	
0000629A F207 0000 FFEE             		dc.b $F2, 7, 0, 0, $FF, $EE	
000062A0 EA0B 0008 FFFE             		dc.b $EA, $B, 0, 8, $FF, $FE	
000062A6 0001                       SME_lde97_4E2:	dc.b 0, 1	
000062A8 F00F 0000 FFF0             		dc.b $F0, $F, 0, 0, $FF, $F0	
000062AE 0001                       SME_lde97_4EA:	dc.b 0, 1	
000062B0 F00F 0000 FFF0             		dc.b $F0, $F, 0, 0, $FF, $F0	
000062B6 0001                       SME_lde97_4F2:	dc.b 0, 1	
000062B8 F00F 0000 FFF0             		dc.b $F0, $F, 0, 0, $FF, $F0	
000062BE 0001                       SME_lde97_4FA:	dc.b 0, 1	
000062C0 F00F 0000 FFF0             		dc.b $F0, $F, 0, 0, $FF, $F0	
000062C6 0001                       SME_lde97_502:	dc.b 0, 1	
000062C8 F00F 0000 FFF0             		dc.b $F0, $F, 0, 0, $FF, $F0	
000062CE 0000                       SME_lde97_50A:	dc.b 0, 0	
000062D0 0000                       SME_lde97_50C:	dc.b 0, 0	
000062D2 0000                       SME_lde97_50E:	dc.b 0, 0	
000062D4 0000                       SME_lde97_510:	dc.b 0, 0	
000062D6 0002                       SME_lde97_512:	dc.b 0, 2	
000062D8 ED09 0000 FFF0             		dc.b $ED, 9, 0, 0, $FF, $F0	
000062DE FD0E 0006 FFF0             		dc.b $FD, $E, 0, 6, $FF, $F0	
000062E4 0004                       SME_lde97_520:	dc.b 0, 4	
000062E6 ED09 0000 FFF0             		dc.b $ED, 9, 0, 0, $FF, $F0	
000062EC FD0D 0006 FFF0             		dc.b $FD, $D, 0, 6, $FF, $F0	
000062F2 0D04 000E 0000             		dc.b $D, 4, 0, $E, 0, 0	
000062F8 0500 0010 FFE8             		dc.b 5, 0, 0, $10, $FF, $E8	
000062FE 0004                       SME_lde97_53A:	dc.b 0, 4	
00006300 F404 0000 FFFC             		dc.b $F4, 4, 0, 0, $FF, $FC	
00006306 FC0D 0002 FFF4             		dc.b $FC, $D, 0, 2, $FF, $F4	
0000630C 0C08 000A FFF4             		dc.b $C, 8, 0, $A, $FF, $F4	
00006312 0400 000D FFEC             		dc.b 4, 0, 0, $D, $FF, $EC	
00006318 0003                       SME_lde97_554:	dc.b 0, 3	
0000631A EC08 0800 FFE8             		dc.b $EC, 8, 8, 0, $FF, $E8	
00006320 F402 0803 0000             		dc.b $F4, 2, 8, 3, 0, 0	
00006326 F40F 0806 FFE0             		dc.b $F4, $F, 8, 6, $FF, $E0	
0000632C 0003                       SME_lde97_568:	dc.b 0, 3	
0000632E EC0E 0800 FFE8             		dc.b $EC, $E, 8, 0, $FF, $E8	
00006334 040D 080C FFE0             		dc.b 4, $D, 8, $C, $FF, $E0	
0000633A 0C00 1814 0000             		dc.b $C, 0, $18, $14, 0, 0	
00006340 0003                       SME_lde97_57C:	dc.b 0, 3	
00006342 F40D 0000 FFFC             		dc.b $F4, $D, 0, 0, $FF, $FC	
00006348 FC05 0008 FFEC             		dc.b $FC, 5, 0, 8, $FF, $EC	
0000634E 0408 000C FFFC             		dc.b 4, 8, 0, $C, $FF, $FC	
00006354 0002                       SME_lde97_590:	dc.b 0, 2	
00006356 F40A 0000 FFE8             		dc.b $F4, $A, 0, 0, $FF, $E8	
0000635C F40A 0800 0000             		dc.b $F4, $A, 8, 0, 0, 0	
00006362 0003                       SME_lde97_59E:	dc.b 0, 3	
00006364 F40D 0000 FFE4             		dc.b $F4, $D, 0, 0, $FF, $E4	
0000636A FC00 0008 0004             		dc.b $FC, 0, 0, 8, 0, 4	
00006370 040C 0009 FFEC             		dc.b 4, $C, 0, 9, $FF, $EC	
00006376 0003                       SME_lde97_5B2:	dc.b 0, 3	
00006378 F40D 0000 FFFC             		dc.b $F4, $D, 0, 0, $FF, $FC	
0000637E FC05 0008 FFEC             		dc.b $FC, 5, 0, 8, $FF, $EC	
00006384 0408 000C FFFC             		dc.b 4, 8, 0, $C, $FF, $FC	
0000638A 0003                       SME_lde97_5C6:	dc.b 0, 3	
0000638C E80B 0000 FFF0             		dc.b $E8, $B, 0, 0, $FF, $F0	
00006392 0804 000C FFF8             		dc.b 8, 4, 0, $C, $FF, $F8	
00006398 1000 000E FFF8             		dc.b $10, 0, 0, $E, $FF, $F8	
0000639E 0004                       SME_lde97_5DA:	dc.b 0, 4	
000063A0 F80E 0000 FFE8             		dc.b $F8, $E, 0, 0, $FF, $E8	
000063A6 0005 000C 0008             		dc.b 0, 5, 0, $C, 0, 8	
000063AC F800 0010 0008             		dc.b $F8, 0, 0, $10, 0, 8	
000063B2 F000 0011 FFF8             		dc.b $F0, 0, 0, $11, $FF, $F8	
000063B8 0004                       SME_lde97_5F4:	dc.b 0, 4	
000063BA F80E 0000 FFE8             		dc.b $F8, $E, 0, 0, $FF, $E8	
000063C0 0005 000C 0008             		dc.b 0, 5, 0, $C, 0, 8	
000063C6 F800 0010 0008             		dc.b $F8, 0, 0, $10, 0, 8	
000063CC F000 0011 FFF8             		dc.b $F0, 0, 0, $11, $FF, $F8	
000063D2 0000                       SME_lde97_60E:	dc.b 0, 0	
000063D4 0000                       SME_lde97_610:	dc.b 0, 0	
000063D6 0002                       SME_lde97_612:	dc.b 0, 2	
000063D8 ED0A 0000 FFF3             		dc.b $ED, $A, 0, 0, $FF, $F3	
000063DE 050D 0009 FFEB             		dc.b 5, $D, 0, 9, $FF, $EB	
000063E4 0003                       SME_lde97_620:	dc.b 0, 3	
000063E6 EC0A 0000 FFF3             		dc.b $EC, $A, 0, 0, $FF, $F3	
000063EC 0408 0009 FFF3             		dc.b 4, 8, 0, 9, $FF, $F3	
000063F2 0C04 000C FFF3             		dc.b $C, 4, 0, $C, $FF, $F3	
000063F8 0002                       SME_lde97_634:	dc.b 0, 2	
000063FA ED0A 0000 FFF3             		dc.b $ED, $A, 0, 0, $FF, $F3	
00006400 050D 0009 FFEB             		dc.b 5, $D, 0, 9, $FF, $EB	
00006406 0003                       SME_lde97_642:	dc.b 0, 3	
00006408 EC0A 0000 FFF3             		dc.b $EC, $A, 0, 0, $FF, $F3	
0000640E 0408 0009 FFF3             		dc.b 4, 8, 0, 9, $FF, $F3	
00006414 0C04 000C FFF3             		dc.b $C, 4, 0, $C, $FF, $F3	
0000641A 0000                       SME_lde97_656:	dc.b 0, 0	
0000641C 0000                       SME_lde97_658:	dc.b 0, 0	
0000641E 0000                       SME_lde97_65A:	dc.b 0, 0	
00006420 0005                       SME_lde97_65C:	dc.b 0, 5	
00006422 E80D 0000 FFEC             		dc.b $E8, $D, 0, 0, $FF, $EC	
00006428 E801 0008 000C             		dc.b $E8, 1, 0, 8, 0, $C	
0000642E F809 000A FFF4             		dc.b $F8, 9, 0, $A, $FF, $F4	
00006434 080C 0010 FFF4             		dc.b 8, $C, 0, $10, $FF, $F4	
0000643A 1000 0014 FFF4             		dc.b $10, 0, 0, $14, $FF, $F4	
00006440 0005                       SME_lde97_67C:	dc.b 0, 5	
00006442 E80D 0000 FFEC             		dc.b $E8, $D, 0, 0, $FF, $EC	
00006448 E801 0008 000C             		dc.b $E8, 1, 0, 8, 0, $C	
0000644E F809 000A FFF4             		dc.b $F8, 9, 0, $A, $FF, $F4	
00006454 080C 0010 FFF4             		dc.b 8, $C, 0, $10, $FF, $F4	
0000645A 1000 0014 FFF4             		dc.b $10, 0, 0, $14, $FF, $F4	
00006460 0000                       SME_lde97_69C:	dc.b 0, 0	
00006462 0000                       SME_lde97_69E:	dc.b 0, 0	
00006464 0000                       SME_lde97_6A0:	dc.b 0, 0	
00006466 0000                       SME_lde97_6A2:	dc.b 0, 0	
00006468 0000                       SME_lde97_6A4:	dc.b 0, 0	
0000646A 0003                       SME_lde97_6A6:	dc.b 0, 3	
0000646C F40D 0800 FFE4             		dc.b $F4, $D, 8, 0, $FF, $E4	
00006472 FC05 0808 0004             		dc.b $FC, 5, 8, 8, 0, 4	
00006478 0408 080C FFEC             		dc.b 4, 8, 8, $C, $FF, $EC	
0000647E 0003                       SME_lde97_6BA:	dc.b 0, 3	
00006480 F40D 0800 FFFC             		dc.b $F4, $D, 8, 0, $FF, $FC	
00006486 FC00 0808 FFF4             		dc.b $FC, 0, 8, 8, $FF, $F4	
0000648C 040C 0809 FFF4             		dc.b 4, $C, 8, 9, $FF, $F4	
00006492 0003                       SME_lde97_6CE:	dc.b 0, 3	
00006494 F00E 0000 FFEC             		dc.b $F0, $E, 0, 0, $FF, $EC	
0000649A F801 000C 000C             		dc.b $F8, 1, 0, $C, 0, $C	
000064A0 080C 000E FFF4             		dc.b 8, $C, 0, $E, $FF, $F4	
000064A6 0003                       SME_lde97_6E2:	dc.b 0, 3	
000064A8 EB09 0000 FFF4             		dc.b $EB, 9, 0, 0, $FF, $F4	
000064AE FB0E 0006 FFEC             		dc.b $FB, $E, 0, 6, $FF, $EC	
000064B4 0301 0012 000C             		dc.b 3, 1, 0, $12, 0, $C	
000064BA 0002                       SME_lde97_6F6:	dc.b 0, 2	
000064BC F00F 0000 FFEC             		dc.b $F0, $F, 0, 0, $FF, $EC	
000064C2 F802 0010 000C             		dc.b $F8, 2, 0, $10, 0, $C	
000064C8 0002                       SME_lde97_704:	dc.b 0, 2	
000064CA F40F 0000 FFF4             		dc.b $F4, $F, 0, 0, $FF, $F4	
000064D0 FC02 0010 FFEC             		dc.b $FC, 2, 0, $10, $FF, $EC	
000064D6 0002                       SME_lde97_712:	dc.b 0, 2	
000064D8 F40F 0000 FFF4             		dc.b $F4, $F, 0, 0, $FF, $F4	
000064DE FC02 0010 FFEC             		dc.b $FC, 2, 0, $10, $FF, $EC	
000064E4 0002                       SME_lde97_720:	dc.b 0, 2	
000064E6 F40F 0000 FFF4             		dc.b $F4, $F, 0, 0, $FF, $F4	
000064EC FC02 0010 FFEC             		dc.b $FC, 2, 0, $10, $FF, $EC	
000064F2 0002                       SME_lde97_72E:	dc.b 0, 2	
000064F4 F40F 0000 FFF5             		dc.b $F4, $F, 0, 0, $FF, $F5	
000064FA FC01 0010 FFED             		dc.b $FC, 1, 0, $10, $FF, $ED	
00006500 0000                       SME_lde97_73C:	dc.b 0, 0	
00006502 0000                       SME_lde97_73E:	dc.b 0, 0	
00006504 0000                       SME_lde97_740:	dc.b 0, 0	
00006506 0000                       SME_lde97_742:	dc.b 0, 0	
00006508 0000                       SME_lde97_744:	dc.b 0, 0	
0000650A 0000                       SME_lde97_746:	dc.b 0, 0	
0000650C 0000                       SME_lde97_748:	dc.b 0, 0	
0000650E 0000                       SME_lde97_74A:	dc.b 0, 0	
00006510 0000                       SME_lde97_74C:	dc.b 0, 0	
00006512 0000                       SME_lde97_74E:	dc.b 0, 0	
00006514 0000                       SME_lde97_750:	dc.b 0, 0	
00006516 0000                       SME_lde97_752:	dc.b 0, 0	
00006518 0003                       SME_lde97_754:	dc.b 0, 3	
0000651A E409 0000 FFF0             		dc.b $E4, 9, 0, 0, $FF, $F0	
00006520 F40B 0006 FFF0             		dc.b $F4, $B, 0, 6, $FF, $F0	
00006526 F401 0012 0008             		dc.b $F4, 1, 0, $12, 0, 8	
0000652C 0003                       SME_lde97_768:	dc.b 0, 3	
0000652E E50B 0000 FFF0             		dc.b $E5, $B, 0, 0, $FF, $F0	
00006534 F401 000C 0008             		dc.b $F4, 1, 0, $C, 0, 8	
0000653A 0505 000E FFF8             		dc.b 5, 5, 0, $E, $FF, $F8	
00006540 0002                       SME_lde97_77C:	dc.b 0, 2	
00006542 EC0B 0000 FFF1             		dc.b $EC, $B, 0, 0, $FF, $F1	
00006548 FC01 000C 0009             		dc.b $FC, 1, 0, $C, 0, 9	
0000654E 0001                       SME_lde97_78A:	dc.b 0, 1	
00006550 EE0F 0000 FFF0             		dc.b $EE, $F, 0, 0, $FF, $F0	
00006556 0002                       SME_lde97_792:	dc.b 0, 2	
00006558 F20B 0000 FFF0             		dc.b $F2, $B, 0, 0, $FF, $F0	
0000655E FA01 000C 0008             		dc.b $FA, 1, 0, $C, 0, 8	
00006564 0003                       SME_lde97_7A0:	dc.b 0, 3	
00006566 F40B 0000 FFF0             		dc.b $F4, $B, 0, 0, $FF, $F0	
0000656C E401 000C 0000             		dc.b $E4, 1, 0, $C, 0, 0	
00006572 F401 000E 0008             		dc.b $F4, 1, 0, $E, 0, 8	
00006578 0003                       SME_lde97_7B4:	dc.b 0, 3	
0000657A E509 0000 FFF0             		dc.b $E5, 9, 0, 0, $FF, $F0	
00006580 F50B 0006 FFF0             		dc.b $F5, $B, 0, 6, $FF, $F0	
00006586 ED03 0012 0008             		dc.b $ED, 3, 0, $12, 0, 8	
0000658C 0003                       SME_lde97_7C8:	dc.b 0, 3	
0000658E F40B 0000 FFF0             		dc.b $F4, $B, 0, 0, $FF, $F0	
00006594 F401 000C 0008             		dc.b $F4, 1, 0, $C, 0, 8	
0000659A E405 000E FFF8             		dc.b $E4, 5, 0, $E, $FF, $F8	
000065A0 0002                       SME_lde97_7DC:	dc.b 0, 2	
000065A2 ED0B 0000 FFF0             		dc.b $ED, $B, 0, 0, $FF, $F0	
000065A8 F501 000C 0008             		dc.b $F5, 1, 0, $C, 0, 8	
000065AE 0002                       SME_lde97_7EA:	dc.b 0, 2	
000065B0 F10B 0000 FFF8             		dc.b $F1, $B, 0, 0, $FF, $F8	
000065B6 F401 000C FFF0             		dc.b $F4, 1, 0, $C, $FF, $F0	
000065BC 0003                       SME_lde97_7F8:	dc.b 0, 3	
000065BE F40B 0000 FFF0             		dc.b $F4, $B, 0, 0, $FF, $F0	
000065C4 F401 000C 0008             		dc.b $F4, 1, 0, $C, 0, 8	
000065CA E405 000E FFF1             		dc.b $E4, 5, 0, $E, $FF, $F1	
000065D0 0002                       SME_lde97_80C:	dc.b 0, 2	
000065D2 F10F 0000 FFF0             		dc.b $F1, $F, 0, 0, $FF, $F0	
000065D8 E105 0010 FFF0             		dc.b $E1, 5, 0, $10, $FF, $F0	
000065DE 0002                       SME_lde97_81A:	dc.b 0, 2	
000065E0 EC0E 0000 FFEC             		dc.b $EC, $E, 0, 0, $FF, $EC	
000065E6 0409 000C FFF4             		dc.b 4, 9, 0, $C, $FF, $F4	
000065EC 0002                       SME_lde97_828:	dc.b 0, 2	
000065EE EC0B 0000 FFF4             		dc.b $EC, $B, 0, 0, $FF, $F4	
000065F4 0C08 000C FFF4             		dc.b $C, 8, 0, $C, $FF, $F4	
000065FA 0002                       SME_lde97_836:	dc.b 0, 2	
000065FC EC0B 0000 FFF4             		dc.b $EC, $B, 0, 0, $FF, $F4	
00006602 0C08 000C FFF4             		dc.b $C, 8, 0, $C, $FF, $F4	
00006608 0003                       SME_lde97_844:	dc.b 0, 3	
0000660A E80E 0000 FFF0             		dc.b $E8, $E, 0, 0, $FF, $F0	
00006610 0008 000C FFF0             		dc.b 0, 8, 0, $C, $FF, $F0	
00006616 0809 000F FFF8             		dc.b 8, 9, 0, $F, $FF, $F8	
0000661C 0003                       SME_lde97_858:	dc.b 0, 3	
0000661E E80E 0000 FFF0             		dc.b $E8, $E, 0, 0, $FF, $F0	
00006624 0009 000C FFF0             		dc.b 0, 9, 0, $C, $FF, $F0	
0000662A 100C 0012 FFF0             		dc.b $10, $C, 0, $12, $FF, $F0	
00006630 0003                       SME_lde97_86C:	dc.b 0, 3	
00006632 E80E 0000 FFF0             		dc.b $E8, $E, 0, 0, $FF, $F0	
00006638 0009 000C FFF0             		dc.b 0, 9, 0, $C, $FF, $F0	
0000663E 1004 0012 FFF0             		dc.b $10, 4, 0, $12, $FF, $F0	
00006644 0004                       SME_lde97_880:	dc.b 0, 4	
00006646 EC0E 0800 FFF0             		dc.b $EC, $E, 8, 0, $FF, $F0	
0000664C FC01 080C 0010             		dc.b $FC, 1, 8, $C, 0, $10	
00006652 0408 080E FFF8             		dc.b 4, 8, 8, $E, $FF, $F8	
00006658 0C04 0811 0000             		dc.b $C, 4, 8, $11, 0, 0	
0000665E 0004                       SME_lde97_89A:	dc.b 0, 4	
00006660 EC0E 0000 FFF8             		dc.b $EC, $E, 0, 0, $FF, $F8	
00006666 FC01 000C FFF0             		dc.b $FC, 1, 0, $C, $FF, $F0	
0000666C 0408 000E FFF8             		dc.b 4, 8, 0, $E, $FF, $F8	
00006672 0C04 0011 FFF8             		dc.b $C, 4, 0, $11, $FF, $F8	
00006678 0004                       SME_lde97_8B4:	dc.b 0, 4	
0000667A FC0E 1000 FFF8             		dc.b $FC, $E, $10, 0, $FF, $F8	
00006680 F401 100C FFF0             		dc.b $F4, 1, $10, $C, $FF, $F0	
00006686 F408 100E FFF8             		dc.b $F4, 8, $10, $E, $FF, $F8	
0000668C EC04 1011 FFF8             		dc.b $EC, 4, $10, $11, $FF, $F8	
00006692 0004                       SME_lde97_8CE:	dc.b 0, 4	
00006694 FC0E 1800 FFF0             		dc.b $FC, $E, $18, 0, $FF, $F0	
0000669A F401 180C 0010             		dc.b $F4, 1, $18, $C, 0, $10	
000066A0 F408 180E FFF8             		dc.b $F4, 8, $18, $E, $FF, $F8	
000066A6 EC04 1811 0000             		dc.b $EC, 4, $18, $11, 0, 0	
000066AC                            		even
000066AC                            		even
000066AC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000066AC                            DPLC_ObjPlayer:
000066AC                            		include	"Objects/Player/DPLCs.asm"
000066AC                            ; --------------------------------------------------------------------------------
000066AC                            ; Dynamic Pattern Loading Cues - output from SonMapEd - Sonic 3 & Knuckles format; --------------------------------------------------------------------------------
000066AC                            
000066AC                            SME_CfLJT:	
000066AC 0000 0000                  		dc.w SME_CfLJT_FC-SME_CfLJT, SME_CfLJT_FE-SME_CfLJT	
000066B0 0000 0000                  		dc.w SME_CfLJT_108-SME_CfLJT, SME_CfLJT_110-SME_CfLJT	
000066B4 0000 0000                  		dc.w SME_CfLJT_118-SME_CfLJT, SME_CfLJT_120-SME_CfLJT	
000066B8 0000 0000                  		dc.w SME_CfLJT_128-SME_CfLJT, SME_CfLJT_132-SME_CfLJT	
000066BC 0000 0000                  		dc.w SME_CfLJT_138-SME_CfLJT, SME_CfLJT_13E-SME_CfLJT	
000066C0 0000 0000                  		dc.w SME_CfLJT_148-SME_CfLJT, SME_CfLJT_14E-SME_CfLJT	
000066C4 0000 0000                  		dc.w SME_CfLJT_156-SME_CfLJT, SME_CfLJT_162-SME_CfLJT	
000066C8 0000 0000                  		dc.w SME_CfLJT_170-SME_CfLJT, SME_CfLJT_17A-SME_CfLJT	
000066CC 0000 0000                  		dc.w SME_CfLJT_186-SME_CfLJT, SME_CfLJT_190-SME_CfLJT	
000066D0 0000 0000                  		dc.w SME_CfLJT_19C-SME_CfLJT, SME_CfLJT_1A6-SME_CfLJT	
000066D4 0000 0000                  		dc.w SME_CfLJT_1AC-SME_CfLJT, SME_CfLJT_1B2-SME_CfLJT	
000066D8 0000 0000                  		dc.w SME_CfLJT_1BC-SME_CfLJT, SME_CfLJT_1C2-SME_CfLJT	
000066DC 0000 0000                  		dc.w SME_CfLJT_1CA-SME_CfLJT, SME_CfLJT_1D8-SME_CfLJT	
000066E0 0000 0000                  		dc.w SME_CfLJT_1E6-SME_CfLJT, SME_CfLJT_1F0-SME_CfLJT	
000066E4 0000 0000                  		dc.w SME_CfLJT_1FC-SME_CfLJT, SME_CfLJT_206-SME_CfLJT	
000066E8 0000 0000                  		dc.w SME_CfLJT_212-SME_CfLJT, SME_CfLJT_218-SME_CfLJT	
000066EC 0000 0000                  		dc.w SME_CfLJT_21E-SME_CfLJT, SME_CfLJT_224-SME_CfLJT	
000066F0 0000 0000                  		dc.w SME_CfLJT_22A-SME_CfLJT, SME_CfLJT_234-SME_CfLJT	
000066F4 0000 0000                  		dc.w SME_CfLJT_23C-SME_CfLJT, SME_CfLJT_246-SME_CfLJT	
000066F8 0000 0000                  		dc.w SME_CfLJT_24E-SME_CfLJT, SME_CfLJT_254-SME_CfLJT	
000066FC 0000 0000                  		dc.w SME_CfLJT_25A-SME_CfLJT, SME_CfLJT_260-SME_CfLJT	
00006700 0000 0000                  		dc.w SME_CfLJT_266-SME_CfLJT, SME_CfLJT_270-SME_CfLJT	
00006704 0000 0000                  		dc.w SME_CfLJT_276-SME_CfLJT, SME_CfLJT_280-SME_CfLJT	
00006708 0000 0000                  		dc.w SME_CfLJT_286-SME_CfLJT, SME_CfLJT_28A-SME_CfLJT	
0000670C 0000 0000                  		dc.w SME_CfLJT_28E-SME_CfLJT, SME_CfLJT_292-SME_CfLJT	
00006710 0000 0000                  		dc.w SME_CfLJT_296-SME_CfLJT, SME_CfLJT_29A-SME_CfLJT	
00006714 0000 0000                  		dc.w SME_CfLJT_29C-SME_CfLJT, SME_CfLJT_29E-SME_CfLJT	
00006718 0000 0000                  		dc.w SME_CfLJT_2A0-SME_CfLJT, SME_CfLJT_2A2-SME_CfLJT	
0000671C 0000 0000                  		dc.w SME_CfLJT_2A8-SME_CfLJT, SME_CfLJT_2B2-SME_CfLJT	
00006720 0000 0000                  		dc.w SME_CfLJT_2BC-SME_CfLJT, SME_CfLJT_2C4-SME_CfLJT	
00006724 0000 0000                  		dc.w SME_CfLJT_2CC-SME_CfLJT, SME_CfLJT_2D4-SME_CfLJT	
00006728 0000 0000                  		dc.w SME_CfLJT_2D8-SME_CfLJT, SME_CfLJT_2E0-SME_CfLJT	
0000672C 0000 0000                  		dc.w SME_CfLJT_2E8-SME_CfLJT, SME_CfLJT_2F0-SME_CfLJT	
00006730 0000 0000                  		dc.w SME_CfLJT_2FA-SME_CfLJT, SME_CfLJT_304-SME_CfLJT	
00006734 0000 0000                  		dc.w SME_CfLJT_306-SME_CfLJT, SME_CfLJT_308-SME_CfLJT	
00006738 0000 0000                  		dc.w SME_CfLJT_30E-SME_CfLJT, SME_CfLJT_316-SME_CfLJT	
0000673C 0000 0000                  		dc.w SME_CfLJT_31C-SME_CfLJT, SME_CfLJT_324-SME_CfLJT	
00006740 0000 0000                  		dc.w SME_CfLJT_326-SME_CfLJT, SME_CfLJT_328-SME_CfLJT	
00006744 0000 0000                  		dc.w SME_CfLJT_32A-SME_CfLJT, SME_CfLJT_336-SME_CfLJT	
00006748 0000 0000                  		dc.w SME_CfLJT_342-SME_CfLJT, SME_CfLJT_344-SME_CfLJT	
0000674C 0000 0000                  		dc.w SME_CfLJT_346-SME_CfLJT, SME_CfLJT_348-SME_CfLJT	
00006750 0000 0000                  		dc.w SME_CfLJT_34A-SME_CfLJT, SME_CfLJT_34C-SME_CfLJT	
00006754 0000 0000                  		dc.w SME_CfLJT_354-SME_CfLJT, SME_CfLJT_35C-SME_CfLJT	
00006758 0000 0000                  		dc.w SME_CfLJT_364-SME_CfLJT, SME_CfLJT_36C-SME_CfLJT	
0000675C 0000 0000                  		dc.w SME_CfLJT_372-SME_CfLJT, SME_CfLJT_378-SME_CfLJT	
00006760 0000 0000                  		dc.w SME_CfLJT_37E-SME_CfLJT, SME_CfLJT_384-SME_CfLJT	
00006764 0000 0000                  		dc.w SME_CfLJT_38A-SME_CfLJT, SME_CfLJT_38C-SME_CfLJT	
00006768 0000 0000                  		dc.w SME_CfLJT_38E-SME_CfLJT, SME_CfLJT_390-SME_CfLJT	
0000676C 0000 0000                  		dc.w SME_CfLJT_392-SME_CfLJT, SME_CfLJT_394-SME_CfLJT	
00006770 0000 0000                  		dc.w SME_CfLJT_396-SME_CfLJT, SME_CfLJT_398-SME_CfLJT	
00006774 0000 0000                  		dc.w SME_CfLJT_39A-SME_CfLJT, SME_CfLJT_39C-SME_CfLJT	
00006778 0000 0000                  		dc.w SME_CfLJT_39E-SME_CfLJT, SME_CfLJT_3A0-SME_CfLJT	
0000677C 0000 0000                  		dc.w SME_CfLJT_3A2-SME_CfLJT, SME_CfLJT_3AA-SME_CfLJT	
00006780 0000 0000                  		dc.w SME_CfLJT_3B2-SME_CfLJT, SME_CfLJT_3B8-SME_CfLJT	
00006784 0000 0000                  		dc.w SME_CfLJT_3BC-SME_CfLJT, SME_CfLJT_3C2-SME_CfLJT	
00006788 0000 0000                  		dc.w SME_CfLJT_3CA-SME_CfLJT, SME_CfLJT_3D2-SME_CfLJT	
0000678C 0000 0000                  		dc.w SME_CfLJT_3DA-SME_CfLJT, SME_CfLJT_3E0-SME_CfLJT	
00006790 0000 0000                  		dc.w SME_CfLJT_3E6-SME_CfLJT, SME_CfLJT_3EE-SME_CfLJT	
00006794 0000 0000                  		dc.w SME_CfLJT_3F4-SME_CfLJT, SME_CfLJT_3FA-SME_CfLJT	
00006798 0000 0000                  		dc.w SME_CfLJT_400-SME_CfLJT, SME_CfLJT_406-SME_CfLJT	
0000679C 0000 0000                  		dc.w SME_CfLJT_40E-SME_CfLJT, SME_CfLJT_416-SME_CfLJT	
000067A0 0000 0000                  		dc.w SME_CfLJT_41E-SME_CfLJT, SME_CfLJT_428-SME_CfLJT	
000067A4 0000 0000                  		dc.w SME_CfLJT_432-SME_CfLJT, SME_CfLJT_43C-SME_CfLJT	
000067A8 0000                       SME_CfLJT_FC:	dc.b 0, 0	
000067AA 0004 2000 7003 200B 200E   SME_CfLJT_FE:	dc.b 0, 4, $20, 0, $70, 3, $20, $B, $20, $E	
000067B4 0003 5011 5017 201D        SME_CfLJT_108:	dc.b 0, 3, $50, $11, $50, $17, $20, $1D	
000067BC 0003 5020 5017 201D        SME_CfLJT_110:	dc.b 0, 3, $50, $20, $50, $17, $20, $1D	
000067C4 0003 5020 5017 2026        SME_CfLJT_118:	dc.b 0, 3, $50, $20, $50, $17, $20, $26	
000067CC 0003 8029 200B 200E        SME_CfLJT_120:	dc.b 0, 3, $80, $29, $20, $B, $20, $E	
000067D4 0004 7032 503A 5040 1046   SME_CfLJT_128:	dc.b 0, 4, $70, $32, $50, $3A, $50, $40, $10, $46	
000067DE 0002 7032 B048             SME_CfLJT_132:	dc.b 0, 2, $70, $32, $B0, $48	
000067E4 0002 5054 805A             SME_CfLJT_138:	dc.b 0, 2, $50, $54, $80, $5A	
000067EA 0004 5054 5063 5069 106F   SME_CfLJT_13E:	dc.b 0, 4, $50, $54, $50, $63, $50, $69, $10, $6F	
000067F4 0002 5054 B071             SME_CfLJT_148:	dc.b 0, 2, $50, $54, $B0, $71	
000067FA 0003 7032 307D 5081        SME_CfLJT_14E:	dc.b 0, 3, $70, $32, $30, $7D, $50, $81	
00006802 0005 5087 508D 2093 5096+  SME_CfLJT_156:	dc.b 0, 5, $50, $87, $50, $8D, $20, $93, $50, $96, 0, $9C	
0000680E 0006 5087 109D 309F 50A3+  SME_CfLJT_162:	dc.b 0, 6, $50, $87, $10, $9D, $30, $9F, $50, $A3, $30, $A9, 0, $AD	
0000681C 0004 50AE 10B4 70B6 20BE   SME_CfLJT_170:	dc.b 0, 4, $50, $AE, $10, $B4, $70, $B6, $20, $BE	
00006826 0005 50C1 30C7 70CB 20D3+  SME_CfLJT_17A:	dc.b 0, 5, $50, $C1, $30, $C7, $70, $CB, $20, $D3, $10, $D6	
00006832 0004 50C1 10D8 70DA 20E2   SME_CfLJT_186:	dc.b 0, 4, $50, $C1, $10, $D8, $70, $DA, $20, $E2	
0000683C 0005 5087 109D 0093 70E5+  SME_CfLJT_190:	dc.b 0, 5, $50, $87, $10, $9D, 0, $93, $70, $E5, $20, $ED	
00006848 0004 70F0 50F8 10FE 5100   SME_CfLJT_19C:	dc.b 0, 4, $70, $F0, $50, $F8, $10, $FE, $51, 0	
00006852 0002 70F0 B106             SME_CfLJT_1A6:	dc.b 0, 2, $70, $F0, $B1, 6	
00006858 0002 5112 8118             SME_CfLJT_1AC:	dc.b 0, 2, $51, $12, $81, $18	
0000685E 0004 5112 5121 1127 5129   SME_CfLJT_1B2:	dc.b 0, 4, $51, $12, $51, $21, $11, $27, $51, $29	
00006868 0002 5112 B12F             SME_CfLJT_1BC:	dc.b 0, 2, $51, $12, $B1, $2F	
0000686E 0003 70F0 0106 813B        SME_CfLJT_1C2:	dc.b 0, 3, $70, $F0, 1, 6, $81, $3B	
00006876 0006 5144 114A 114C 814E+  SME_CfLJT_1CA:	dc.b 0, 6, $51, $44, $11, $4A, $11, $4C, $81, $4E, 1, $57, 1, $58	
00006884 0006 5144 2159 115C 115E+  SME_CfLJT_1D8:	dc.b 0, 6, $51, $44, $21, $59, $11, $5C, $11, $5E, $81, $60, 1, $57	
00006892 0004 5169 116F 8171 117A   SME_CfLJT_1E6:	dc.b 0, 4, $51, $69, $11, $6F, $81, $71, $11, $7A	
0000689C 0005 517C 2182 1185 7187+  SME_CfLJT_1F0:	dc.b 0, 5, $51, $7C, $21, $82, $11, $85, $71, $87, $21, $8F	
000068A8 0004 517C 1192 8194 119D   SME_CfLJT_1FC:	dc.b 0, 4, $51, $7C, $11, $92, $81, $94, $11, $9D	
000068B2 0005 5144 819F 115E 11A8+  SME_CfLJT_206:	dc.b 0, 5, $51, $44, $81, $9F, $11, $5E, $11, $A8, 1, $57	
000068BE 0002 51AA B1B0             SME_CfLJT_212:	dc.b 0, 2, $51, $AA, $B1, $B0	
000068C4 0002 5054 B1BC             SME_CfLJT_218:	dc.b 0, 2, $50, $54, $B1, $BC	
000068CA 0002 51AA B1C8             SME_CfLJT_21E:	dc.b 0, 2, $51, $AA, $B1, $C8	
000068D0 0002 5054 B1D4             SME_CfLJT_224:	dc.b 0, 2, $50, $54, $B1, $D4	
000068D6 0004 51E0 11E6 B1E8 01F4   SME_CfLJT_22A:	dc.b 0, 4, $51, $E0, $11, $E6, $B1, $E8, 1, $F4	
000068E0 0003 51F5 11FB B1FD        SME_CfLJT_234:	dc.b 0, 3, $51, $F5, $11, $FB, $B1, $FD	
000068E8 0004 51E0 1209 B20B 01F4   SME_CfLJT_23C:	dc.b 0, 4, $51, $E0, $12, 9, $B2, $B, 1, $F4	
000068F2 0003 51F5 11FB B217        SME_CfLJT_246:	dc.b 0, 3, $51, $F5, $11, $FB, $B2, $17	
000068FA 0002 5223 B229             SME_CfLJT_24E:	dc.b 0, 2, $52, $23, $B2, $29	
00006900 0002 5112 B235             SME_CfLJT_254:	dc.b 0, 2, $51, $12, $B2, $35	
00006906 0002 5223 B241             SME_CfLJT_25A:	dc.b 0, 2, $52, $23, $B2, $41	
0000690C 0002 5112 B24D             SME_CfLJT_260:	dc.b 0, 2, $51, $12, $B2, $4D	
00006912 0004 5259 125F B261 026D   SME_CfLJT_266:	dc.b 0, 4, $52, $59, $12, $5F, $B2, $61, 2, $6D	
0000691C 0002 726E B276             SME_CfLJT_270:	dc.b 0, 2, $72, $6E, $B2, $76	
00006922 0004 5259 1282 B284 026D   SME_CfLJT_276:	dc.b 0, 4, $52, $59, $12, $82, $B2, $84, 2, $6D	
0000692C 0002 726E B290             SME_CfLJT_280:	dc.b 0, 2, $72, $6E, $B2, $90	
00006932 0001 F29C                  SME_CfLJT_286:	dc.b 0, 1, $F2, $9C	
00006936 0001 F2AC                  SME_CfLJT_28A:	dc.b 0, 1, $F2, $AC	
0000693A 0001 F2BC                  SME_CfLJT_28E:	dc.b 0, 1, $F2, $BC	
0000693E 0001 F2CC                  SME_CfLJT_292:	dc.b 0, 1, $F2, $CC	
00006942 0001 F2DC                  SME_CfLJT_296:	dc.b 0, 1, $F2, $DC	
00006946 0000                       SME_CfLJT_29A:	dc.b 0, 0	
00006948 0000                       SME_CfLJT_29C:	dc.b 0, 0	
0000694A 0000                       SME_CfLJT_29E:	dc.b 0, 0	
0000694C 0000                       SME_CfLJT_2A0:	dc.b 0, 0	
0000694E 0002 52EC B2F2             SME_CfLJT_2A2:	dc.b 0, 2, $52, $EC, $B2, $F2	
00006954 0004 52FE 7304 130C 030E   SME_CfLJT_2A8:	dc.b 0, 4, $52, $FE, $73, 4, $13, $C, 3, $E	
0000695E 0004 130F 7311 2319 031C   SME_CfLJT_2B2:	dc.b 0, 4, $13, $F, $73, $11, $23, $19, 3, $1C	
00006968 0003 231D 2320 F323        SME_CfLJT_2BC:	dc.b 0, 3, $23, $1D, $23, $20, $F3, $23	
00006970 0003 B333 733F 0071        SME_CfLJT_2C4:	dc.b 0, 3, $B3, $33, $73, $3F, 0, $71	
00006978 0003 7347 334F 2353        SME_CfLJT_2CC:	dc.b 0, 3, $73, $47, $33, $4F, $23, $53	
00006980 0001 8356                  SME_CfLJT_2D4:	dc.b 0, 1, $83, $56	
00006984 0003 735F 0367 3368        SME_CfLJT_2D8:	dc.b 0, 3, $73, $5F, 3, $67, $33, $68	
0000698C 0003 736C 3374 2378        SME_CfLJT_2E0:	dc.b 0, 3, $73, $6C, $33, $74, $23, $78	
00006994 0003 B37B 1387 0389        SME_CfLJT_2E8:	dc.b 0, 3, $B3, $7B, $13, $87, 3, $89	
0000699C 0004 B38A 3396 039A 039B   SME_CfLJT_2F0:	dc.b 0, 4, $B3, $8A, $33, $96, 3, $9A, 3, $9B	
000069A6 0004 B39C 33A8 03AC 03AD   SME_CfLJT_2FA:	dc.b 0, 4, $B3, $9C, $33, $A8, 3, $AC, 3, $AD	
000069B0 0000                       SME_CfLJT_304:	dc.b 0, 0	
000069B2 0000                       SME_CfLJT_306:	dc.b 0, 0	
000069B4 0002 83AE 73B7             SME_CfLJT_308:	dc.b 0, 2, $83, $AE, $73, $B7	
000069BA 0003 83BF 23C8 13CB        SME_CfLJT_30E:	dc.b 0, 3, $83, $BF, $23, $C8, $13, $CB	
000069C2 0002 83CD 73D6             SME_CfLJT_316:	dc.b 0, 2, $83, $CD, $73, $D6	
000069C8 0003 83BF 23DE 13E1        SME_CfLJT_31C:	dc.b 0, 3, $83, $BF, $23, $DE, $13, $E1	
000069D0 0000                       SME_CfLJT_324:	dc.b 0, 0	
000069D2 0000                       SME_CfLJT_326:	dc.b 0, 0	
000069D4 0000                       SME_CfLJT_328:	dc.b 0, 0	
000069D6 0005 73E3 13EB 53ED 33F3+  SME_CfLJT_32A:	dc.b 0, 5, $73, $E3, $13, $EB, $53, $ED, $33, $F3, 3, $F7	
000069E2 0005 73F8 13EB 5400 33F3+  SME_CfLJT_336:	dc.b 0, 5, $73, $F8, $13, $EB, $54, 0, $33, $F3, 3, $F7	
000069EE 0000                       SME_CfLJT_342:	dc.b 0, 0	
000069F0 0000                       SME_CfLJT_344:	dc.b 0, 0	
000069F2 0000                       SME_CfLJT_346:	dc.b 0, 0	
000069F4 0000                       SME_CfLJT_348:	dc.b 0, 0	
000069F6 0000                       SME_CfLJT_34A:	dc.b 0, 0	
000069F8 0003 7347 334F 2353        SME_CfLJT_34C:	dc.b 0, 3, $73, $47, $33, $4F, $23, $53	
00006A00 0003 735F 0367 3368        SME_CfLJT_354:	dc.b 0, 3, $73, $5F, 3, $67, $33, $68	
00006A08 0003 B406 1412 3414        SME_CfLJT_35C:	dc.b 0, 3, $B4, 6, $14, $12, $34, $14	
00006A10 0003 5418 B41E 106D        SME_CfLJT_364:	dc.b 0, 3, $54, $18, $B4, $1E, $10, $6D	
00006A18 0002 F42A 243A             SME_CfLJT_36C:	dc.b 0, 2, $F4, $2A, $24, $3A	
00006A1E 0002 F43D 244D             SME_CfLJT_372:	dc.b 0, 2, $F4, $3D, $24, $4D	
00006A24 0002 F450 2460             SME_CfLJT_378:	dc.b 0, 2, $F4, $50, $24, $60	
00006A2A 0002 F463 2473             SME_CfLJT_37E:	dc.b 0, 2, $F4, $63, $24, $73	
00006A30 0002 F476 1486             SME_CfLJT_384:	dc.b 0, 2, $F4, $76, $14, $86	
00006A36 0000                       SME_CfLJT_38A:	dc.b 0, 0	
00006A38 0000                       SME_CfLJT_38C:	dc.b 0, 0	
00006A3A 0000                       SME_CfLJT_38E:	dc.b 0, 0	
00006A3C 0000                       SME_CfLJT_390:	dc.b 0, 0	
00006A3E 0000                       SME_CfLJT_392:	dc.b 0, 0	
00006A40 0000                       SME_CfLJT_394:	dc.b 0, 0	
00006A42 0000                       SME_CfLJT_396:	dc.b 0, 0	
00006A44 0000                       SME_CfLJT_398:	dc.b 0, 0	
00006A46 0000                       SME_CfLJT_39A:	dc.b 0, 0	
00006A48 0000                       SME_CfLJT_39C:	dc.b 0, 0	
00006A4A 0000                       SME_CfLJT_39E:	dc.b 0, 0	
00006A4C 0000                       SME_CfLJT_3A0:	dc.b 0, 0	
00006A4E 0003 5488 B48E 149A        SME_CfLJT_3A2:	dc.b 0, 3, $54, $88, $B4, $8E, $14, $9A	
00006A56 0003 B49C 14A8 34AA        SME_CfLJT_3AA:	dc.b 0, 3, $B4, $9C, $14, $A8, $34, $AA	
00006A5E 0002 B4AE 14BA             SME_CfLJT_3B2:	dc.b 0, 2, $B4, $AE, $14, $BA	
00006A64 0001 F4BC                  SME_CfLJT_3B8:	dc.b 0, 1, $F4, $BC	
00006A68 0002 B4CC 14D8             SME_CfLJT_3BC:	dc.b 0, 2, $B4, $CC, $14, $D8	
00006A6E 0003 B4DA 14E6 14E8        SME_CfLJT_3C2:	dc.b 0, 3, $B4, $DA, $14, $E6, $14, $E8	
00006A76 0003 54EA B4F0 34FC        SME_CfLJT_3CA:	dc.b 0, 3, $54, $EA, $B4, $F0, $34, $FC	
00006A7E 0003 B500 150C 350E        SME_CfLJT_3D2:	dc.b 0, 3, $B5, 0, $15, $C, $35, $E	
00006A86 0002 B512 151E             SME_CfLJT_3DA:	dc.b 0, 2, $B5, $12, $15, $1E	
00006A8C 0002 B520 152C             SME_CfLJT_3E0:	dc.b 0, 2, $B5, $20, $15, $2C	
00006A92 0003 B52E 153A 353C        SME_CfLJT_3E6:	dc.b 0, 3, $B5, $2E, $15, $3A, $35, $3C	
00006A9A 0002 F540 3550             SME_CfLJT_3EE:	dc.b 0, 2, $F5, $40, $35, $50	
00006AA0 0002 B554 5560             SME_CfLJT_3F4:	dc.b 0, 2, $B5, $54, $55, $60	
00006AA6 0002 B566 2572             SME_CfLJT_3FA:	dc.b 0, 2, $B5, $66, $25, $72	
00006AAC 0002 B575 2581             SME_CfLJT_400:	dc.b 0, 2, $B5, $75, $25, $81	
00006AB2 0003 B584 2590 5593        SME_CfLJT_406:	dc.b 0, 3, $B5, $84, $25, $90, $55, $93	
00006ABA 0003 B599 55A5 35AB        SME_CfLJT_40E:	dc.b 0, 3, $B5, $99, $55, $A5, $35, $AB	
00006AC2 0003 B5AF 55BB 15C1        SME_CfLJT_416:	dc.b 0, 3, $B5, $AF, $55, $BB, $15, $C1	
00006ACA 0004 B5C3 15CF 25D1 15D4   SME_CfLJT_41E:	dc.b 0, 4, $B5, $C3, $15, $CF, $25, $D1, $15, $D4	
00006AD4 0004 B5C3 15CF 25D1 15D4   SME_CfLJT_428:	dc.b 0, 4, $B5, $C3, $15, $CF, $25, $D1, $15, $D4	
00006ADE 0004 B5C3 15CF 25D1 15D4   SME_CfLJT_432:	dc.b 0, 4, $B5, $C3, $15, $CF, $25, $D1, $15, $D4	
00006AE8 0004 B5C3 15CF 25D1 15D4   SME_CfLJT_43C:	dc.b 0, 4, $B5, $C3, $15, $CF, $25, $D1, $15, $D4	
00006AF2                            		even
00006AF2                            		even
00006AF2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006AF2                            Ani_ObjPlayer:
00006AF2                            		include	"Objects/Player/Animations.asm"
00006AF2                            ; ---------------------------------------------------------------------------
00006AF2                            ; Animation script - Sonic
00006AF2                            ; ---------------------------------------------------------------------------
00006AF2                            SonicAniData:
00006AF2 0000                       		dc.w SonicAni_Walk-SonicAniData
00006AF4 0000                       		dc.w SonicAni_Run-SonicAniData
00006AF6 0000                       		dc.w SonicAni_Roll-SonicAniData
00006AF8 0000                       		dc.w SonicAni_Roll2-SonicAniData
00006AFA 0000                       		dc.w SonicAni_Push-SonicAniData
00006AFC 0000                       		dc.w SonicAni_Wait-SonicAniData
00006AFE 0000                       		dc.w SonicAni_Balance-SonicAniData
00006B00 0000                       		dc.w SonicAni_LookUp-SonicAniData
00006B02 0000                       		dc.w SonicAni_Duck-SonicAniData
00006B04 0000                       		dc.w SonicAni_Sprint-SonicAniData
00006B06 0000                       		dc.w SonicAni_Hang-SonicAniData
00006B08 0000                       		dc.w SonicAni_Seizure-SonicAniData
00006B0A 0000                       		dc.w SonicAni_Blank-SonicAniData
00006B0C 0000                       		dc.w SonicAni_Skid-SonicAniData
00006B0E 0000                       		dc.w SonicAni_Float1-SonicAniData
00006B10 0000                       		dc.w SonicAni_Float2-SonicAniData
00006B12 0000                       		dc.w SonicAni_Spring-SonicAniData
00006B14 0000                       		dc.w SonicAni_Blank-SonicAniData
00006B16 0000                       		dc.w SonicAni_Blank-SonicAniData
00006B18 0000                       		dc.w SonicAni_Blank-SonicAniData
00006B1A 0000                       		dc.w SonicAni_Blank-SonicAniData
00006B1C 0000                       		dc.w SonicAni_Bubble-SonicAniData
00006B1E 0000                       		dc.w SonicAni_Blank-SonicAniData
00006B20 0000                       		dc.w SonicAni_Drown-SonicAniData
00006B22 0000                       		dc.w SonicAni_Death-SonicAniData
00006B24 0000                       		dc.w SonicAni_Blank-SonicAniData
00006B26 0000                       		dc.w SonicAni_Hurt-SonicAniData
00006B28 0000                       		dc.w SonicAni_Slide-SonicAniData
00006B2A 0000                       		dc.w SonicAni_Blank-SonicAniData
00006B2C 0000                       		dc.w SonicAni_Float3-SonicAniData
00006B2E 0000                       		dc.w SonicAni_Float4-SonicAniData
00006B30 0100 FD00                  SonicAni_Blank:		dc.b 1, 0, $FD, 0
00006B34 FF08 090A 0B06 07FF        SonicAni_Walk:		dc.b $FF, $08, $09, $0A, $0B, $06, $07, $FF
00006B3C FF1E 1F20 21FF FFFF        SonicAni_Run:		dc.b $FF, $1E, $1F, $20, $21, $FF, $FF,	$FF
00006B44 FF58 595A 5BFF FFFF        SonicAni_Sprint:	dc.b $FF, $58, $59, $5A, $5B, $FF, $FF, $FF
00006B4C FE2E 2F30 3132 FFFF        SonicAni_Roll:		dc.b $FE, $2E, $2F, $30, $31, $32, $FF,	$FF
00006B54 FE2E 2F32 3031 32FF        SonicAni_Roll2:		dc.b $FE, $2E, $2F, $32, $30, $31, $32,	$FF
00006B5C FD45 4647 48FF FFFF        SonicAni_Push:		dc.b $FD, $45, $46, $47, $48, $FF, $FF,	$FF
00006B64 1701 0101 0101 0101 0101+  SonicAni_Wait:		dc.b $17, 1, 1,	1, 1, 1, 1, 1, 1, 1, 1,	1, 1, 3, 2, 2, 2, 3, 4, $FE, 2, 0
00006B7A 1F3A 3BFF                  SonicAni_Balance:	dc.b $1F, $3A, $3B, $FF
00006B7E 3F05 FF00                  SonicAni_LookUp:	dc.b $3F, 5, $FF, 0
00006B82 3F39 FF00                  SonicAni_Duck:		dc.b $3F, $39, $FF, 0
00006B86 0737 38FF                  SonicAni_Skid:		dc.b 7,	$37, $38, $FF
00006B8A 073C 3FFF                  SonicAni_Float1:	dc.b 7,	$3C, $3F, $FF
00006B8E 073C 3D53 3E54 FF00        SonicAni_Float2:	dc.b 7,	$3C, $3D, $53, $3E, $54, $FF, 0
00006B96 2F40 FD00                  SonicAni_Spring:	dc.b $2F, $40, $FD, 0
00006B9A FC78 7978 77FF             SonicAni_Hang:		dc.b $FC, $78, $79, $78, $77, $FF
00006BA0 0B56 560A 0BFD 0000        SonicAni_Bubble:	dc.b $B, $56, $56, $A, $B, $FD,	0, 0
00006BA8 2F4C FF00                  SonicAni_Drown:		dc.b $2F, $4C, $FF, 0
00006BAC 034D FF00                  SonicAni_Death:		dc.b 3,	$4D, $FF, 0
00006BB0 0355 FF00                  SonicAni_Hurt:		dc.b 3,	$55, $FF, 0
00006BB4 0755 57FF                  SonicAni_Slide:		dc.b 7, $55, $57, $FF
00006BB8 033C 3D53 3E54 FF00        SonicAni_Float3:	dc.b 3,	$3C, $3D, $53, $3E, $54, $FF, 0
00006BC0 033C FD00                  SonicAni_Float4:	dc.b 3,	$3C, $FD, 0
00006BC4 027A 7B7C 7DFF             SonicAni_Seizure:	dc.b 2, $7A, $7B, $7C, $7D, $FF
00006BCA                            		even
00006BCA                            		even
00006BCA                            ; =========================================================================================================================================================
00006BCA                            		include	"Objects/Ring/Code.asm"		; Ring loss object
00006BCA                            ; =========================================================================================================================================================
00006BCA                            ; Water surface object
00006BCA                            ; =========================================================================================================================================================
00006BCA                            		rsset	oLvlSSTs
00006BCA                            
00006BCA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006BCA                            ObjRingLoss:
00006BCA 2248                       		movea.l	a0,a1
00006BCC 7A00                       		moveq	#0,d5
00006BCE 3A38 F3D4                  		move.w	rRings.w,d5
00006BD2 7020                       		moveq	#32,d0
00006BD4 BA40                       		cmp.w	d0,d5
00006BD6 6500                       		bcs.s	.BelowMax
00006BD8 3A00                       		move.w	d0,d5
00006BDA                            
00006BDA                            .BelowMax:
00006BDA 5345                       		subq.w	#1,d5
00006BDC 47F9 0000 0000             		lea	ObjLostRing_Speeds,a3
00006BE2 6000                       		bra.s	.MakeRings
00006BE4                            
00006BE4                            .Loop:
00006BE4 4EB8 1A1C                  		jsr	FindFreeObj.w
00006BE8 6700                       		beq.s	.ResetCounter
00006BEA                            
00006BEA                            .MakeRings:
00006BEA 22BC 0000 0000             		move.l	#ObjLostRing,oAddr(a1)
00006BF0 3368 0014 0014             		move.w	oXPos(a0),oXPos(a1)
00006BF6 3368 0018 0018             		move.w	oYPos(a0),oYPos(a1)
00006BFC 237C 0000 0000 0010        		move.l	#Map_ObjLostRing,oMap(a1)	; Mappings
00006C04 337C 26B4 000E             		move.w	#$26B4,oVRAM(a1)		; Tile properties
00006C0A 137C 0004 000D             		move.b	#4,oRender(a1)			; Render flags
00006C10                            	displaySprite	3,a1,a2,0			; Priority
00006C10 337C BE72 0008           M 	move.w	#rdispinput+(3*dsize),odrawnext(a1)
00006C16 3478 BE7C                M 	move.w	rdispinput+dprev+(3*dsize).w,a2
00006C1A 334A 000A                M 	move.w	a2,odrawprev(a1)
00006C1E 3549 0008                M 	move.w	a1,odrawnext(a2)
00006C22 31C9 BE7C                M 	move.w	a1,rdispinput+dprev+(3*dsize).w
00006C26                          M .no_229
00006C26 137C 0008 0017             		move.b	#8,oDrawW(a1)			; Sprite width
00006C2C 137C 0008 001B             		move.b	#8,oDrawH(a1)			; Sprite height
00006C32 137C 0008 002C             		move.b	#8,oColW(a1)			; Collision width
00006C38 137C 0008 002D             		move.b	#8,oColH(a1)			; Collision height
00006C3E 335B 001C                  		move.w	(a3)+,oXVel(a1)
00006C42 335B 001E                  		move.w	(a3)+,oYVel(a1)
00006C46 51CD FF9C                  		dbf	d5,.Loop
00006C4A 11FC 00FF F3D9             		move.b	#-1,rRLossAniT.w
00006C50                            
00006C50                            .ResetCounter:
00006C50 4278 F3D4                  		clr.w	rRings.w
00006C54 11FC 0001 F8F3             		move.b	#1,rUpdateRings.w
00006C5A                            		playSnd	#sRingLoss, 2
00006C5A 11FC 008D C4BD           M 	move.b	#sringloss,(mqueue+((2)-1)).w
00006C60                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006C60                            ObjLostRing:
00006C60 4EB8 1D4C                  		jsr	ObjectMove.w
00006C64 0668 0018 001E             		addi.w	#$18,oYVel(a0)
00006C6A 6B00                       		bmi.s	.ChkCol
00006C6C 1038 C759                  		move.b	(rFrameCnt+3).w,d0
00006C70 D048                       		add.w	a0,d0
00006C72 0200 0006                  		andi.b	#6,d0
00006C76 6600                       		bne.s	.ChkCol
00006C78 4EB8 305C                  		jsr	ObjCheckFloorDist
00006C7C 4A41                       		tst.w	d1
00006C7E 6A00                       		bpl.s	.ChkCol
00006C80 D368 0018                  		add.w	d1,oYPos(a0)
00006C84 3028 001E                  		move.w	oYVel(a0),d0
00006C88 E440                       		asr.w	#2,d0
00006C8A 9168 001E                  		sub.w	d0,oYVel(a0)
00006C8E 4468 001E                  		neg.w	oYVel(a0)
00006C92                            
00006C92                            .ChkCol:
00006C92 43FA 0000                  		lea	.RangeData(pc),a1		; Range data
00006C96 3478 F86C                  		movea.w	rPlayer1Addr.w,a2		; Player object
00006C9A 4EB8 1D86                  		jsr	CheckObjInRange.w		; Is the player in range?
00006C9E 4A40                       		tst.w	d0				; ''
00006CA0 6700                       		beq.s	.ChkDel				; If not, branch
00006CA2 0C2A 0069 0042             		cmpi.b	#105,oInvulTime(a2)
00006CA8 6400                       		bhs.s	.ChkDel
00006CAA 6000                       		bra.s	ObjLostRing_Collect
00006CAC                            
00006CAC                            .ChkDel:
00006CAC 4A38 F3D9                  		tst.b	rRLossAniT.w
00006CB0 6700 0000                  		beq.w	ObjLostRing_Delete
00006CB4 3038 F8C2                  		move.w	rMaxCamY.w,d0		; Get max camera Y position
00006CB8 0640 00E0                  		addi.w	#224,d0				; Get bottom boundary position
00006CBC B068 0018                  		cmp.w	oYPos(a0),d0			; Have we touched the bottom boundary?
00006CC0 6D00                       		blt.s	ObjLostRing_Delete		; If so, branch
00006CC2                            	nextObject
00006CC2 3068 0004                M 	movea.w	onext(a0),a0
00006CC6 2250                     M 	move.l	oaddr(a0),a1
00006CC8 4ED1                     M 	jmp	(a1)
00006CCA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006CCA                            .RangeData:
00006CCA FFF0 0020                  		dc.w	-$10, $20
00006CCE FFF0 0020                  		dc.w	-$10, $20
00006CD2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006CD2                            ObjLostRing_Collect:
00006CD2                            	removeSprite	a0,a1,0
00006CD2 3268 000A                M 	move.w	odrawprev(a0),a1
00006CD6 3368 0008 0008           M 	move.w	odrawnext(a0),odrawnext(a1)
00006CDC 3268 0008                M 	move.w	odrawnext(a0),a1
00006CE0 3368 000A 000A           M 	move.w	odrawprev(a0),odrawprev(a1)
00006CE6                          M .no_232
00006CE6 42A8 0008                M 	clr.l	odrawnext(a0)
00006CEA                          M .yes_232
00006CEA                            	displaySprite	1,a0,a1,0
00006CEA 317C BE62 0008           M 	move.w	#rdispinput+(1*dsize),odrawnext(a0)
00006CF0 3278 BE6C                M 	move.w	rdispinput+dprev+(1*dsize).w,a1
00006CF4 3149 000A                M 	move.w	a1,odrawprev(a0)
00006CF8 3348 0008                M 	move.w	a0,odrawnext(a1)
00006CFC 31C8 BE6C                M 	move.w	a0,rdispinput+dprev+(1*dsize).w
00006D00                          M .no_233
00006D00 4EB8 3F66                  		jsr	CollectRing
00006D04 20BC 0000 0000             		move.l	#ObjLostRing_Sparkle,(a0)
00006D0A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006D0A                            ObjLostRing_Sparkle:
00006D0A 43F9 0000 0000             		lea	Ani_ObjRing,a1
00006D10 4EB8 1C66                  		jsr	AnimateObject.w
00006D14 4A28 0025                  		tst.b	oRoutine(a0)
00006D18 6600                       		bne.s	ObjLostRing_Delete
00006D1A                            	nextObject
00006D1A 3068 0004                M 	movea.w	onext(a0),a0
00006D1E 2250                     M 	move.l	oaddr(a0),a1
00006D20 4ED1                     M 	jmp	(a1)
00006D22                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006D22                            ObjLostRing_Delete:
00006D22 4EB8 1A72                  		jsr	DeleteObject.w
00006D26                            	nextObject
00006D26 3068 0004                M 	movea.w	onext(a0),a0
00006D2A 2250                     M 	move.l	oaddr(a0),a1
00006D2C 4ED1                     M 	jmp	(a1)
00006D2E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006D2E                            ; Ring Spawn Array
00006D2E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006D2E                            ObjLostRing_Speeds:
00006D2E FF3C FC14 00C4 FC14 FDC8+  		dc.w	$FF3C,$FC14,$00C4,$FC14,$FDC8,$FCB0,$0238,$FCB0
00006D3E FCB0 FDC8 0350 FDC8 FC14+  		dc.w	$FCB0,$FDC8,$0350,$FDC8,$FC14,$FF3C,$03EC,$FF3C
00006D4E FC14 00C4 03EC 00C4 FCB0+  		dc.w	$FC14,$00C4,$03EC,$00C4,$FCB0,$0238,$0350,$0238
00006D5E FDC8 0350 0238 0350 FF3C+  		dc.w	$FDC8,$0350,$0238,$0350,$FF3C,$03EC,$00C4,$03EC
00006D6E FF9E FE0A 0062 FE0A FEE4+  		dc.w	$FF9E,$FE0A,$0062,$FE0A,$FEE4,$FE58,$011C,$FE58
00006D7E FE58 FEE4 01A8 FEE4 FE0A+  		dc.w	$FE58,$FEE4,$01A8,$FEE4,$FE0A,$FF9E,$01F6,$FF9E
00006D8E FE0A 0062 01F6 0062 FE58+  		dc.w	$FE0A,$0062,$01F6,$0062,$FE58,$011C,$01A8,$011C
00006D9E FEE4 01A8 011C 01A8 FF9E+  		dc.w	$FEE4,$01A8,$011C,$01A8,$FF9E,$01F6,$0062,$01F6
00006DAE                            		even
00006DAE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006DAE                            ; Data
00006DAE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006DAE                            Map_ObjLostRing:
00006DAE                            		include	"Objects/Ring/Mappings.asm"
00006DAE                            ; --------------------------------------------------------------------------------
00006DAE                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
00006DAE                            ; --------------------------------------------------------------------------------
00006DAE                            
00006DAE                            SME_k4ulR:	
00006DAE 0000 0000                  		dc.w SME_k4ulrA-SME_k4ulR, SME_k4ulrC-SME_k4ulR	
00006DB2 0000 0000                  		dc.w SME_k4ulr14-SME_k4ulR, SME_k4ulr1C-SME_k4ulR	
00006DB6 0000                       		dc.w SME_k4ulr24-SME_k4ulR	
00006DB8 0001                       SME_k4ulrA:	dc.b 0, 1	
00006DBA F805 0000 FFF8             		dc.b $F8, 5, 0, 0, $FF, $F8
00006DC0 0001                       SME_k4ulrC:	dc.b 0, 1	
00006DC2 F805 1804 FFF8             		dc.b $F8, 5, $18, 4, $FF, $F8	
00006DC8 0001                       SME_k4ulr14:	dc.b 0, 1	
00006DCA F805 1804 FFF8             		dc.b $F8, 5, $18, 4, $FF, $F8	
00006DD0 0001                       SME_k4ulr1C:	dc.b 0, 1	
00006DD2 F805 0804 FFF8             		dc.b $F8, 5, 8, 4, $FF, $F8	
00006DD8 0001                       SME_k4ulr24:	dc.b 0, 1	
00006DDA F805 1004 FFF8             		dc.b $F8, 5, $10, 4, $FF, $F8	
00006DE0                            		even
00006DE0                            		even
00006DE0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006DE0                            Ani_ObjRing:
00006DE0 0000                       		dc.w	.Ani0-Ani_ObjRing
00006DE2 0501 0203 04FC             .Ani0:		dc.b	5, 1, 2, 3, 4, $FC
00006DE8                            		even
00006DE8                            ; =========================================================================================================================================================
00006DE8                            		include	"Objects/Explosion/Code.asm"	; Explosion object
00006DE8                            ; =========================================================================================================================================================
00006DE8                            ; Explosion object
00006DE8                            ; =========================================================================================================================================================
00006DE8 =00000003                  EXPLODE_ANI	EQU	3
00006DE8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006DE8                            ObjBossExplode:
00006DE8                            		playSnd	#sBomb, 2			; Play explosion sound
00006DE8 11FC 0099 C4BD           M 	move.b	#sbomb,(mqueue+((2)-1)).w
00006DEE 6000                       		bra.s	ObjExplosion_Init		; Continue
00006DF0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006DF0                            ObjExplosion:
00006DF0                            		playSnd	#sBreakItem, 2			; Play explosion sound
00006DF0 11FC 009A C4BD           M 	move.b	#sbreakitem,(mqueue+((2)-1)).w
00006DF6                            
00006DF6                            ObjExplosion_Init:
00006DF6 20BC 0000 0000             		move.l	#ObjExplosion_Main,oAddr(a0)	; Next routine
00006DFC 117C 0004 000D             		move.b	#4,oRender(a0)			; Render flags
00006E02 317C 86C0 000E             		move.w	#$86C0,oVRAM(a0)		; Tile properties
00006E08 217C 0000 0000 0010        		move.l	#Map_ObjExplosion,oMap(a0)	; Mappings
00006E10                            	displaySprite	1,a0,a1,0			; Priority
00006E10 317C BE62 0008           M 	move.w	#rdispinput+(1*dsize),odrawnext(a0)
00006E16 3278 BE6C                M 	move.w	rdispinput+dprev+(1*dsize).w,a1
00006E1A 3149 000A                M 	move.w	a1,odrawprev(a0)
00006E1E 3348 0008                M 	move.w	a0,odrawnext(a1)
00006E22 31C8 BE6C                M 	move.w	a0,rdispinput+dprev+(1*dsize).w
00006E26                          M .no_238
00006E26 117C 000C 0017             		move.b	#$C,oDrawW(a0)			; Sprite width
00006E2C 117C 000C 001B             		move.b	#$C,oDrawH(a0)			; Sprite height
00006E32 117C 0003 0023             		move.b	#EXPLODE_ANI,oAniTimer(a0)	; Animation timer
00006E38 4228 0010                  		clr.b	oFrame(a0)			; Mapping frame
00006E3C                            		
00006E3C                            ObjExplosion_Main:
00006E3C 5328 0023                  		subq.b	#1,oAniTimer(a0)		; Decrement animation timer
00006E40 6A00                       		bpl.s	.Display			; If it hasn't run out, branch
00006E42 117C 0003 0023             		move.b	#EXPLODE_ANI,oAniTimer(a0)	; Reset animation timer
00006E48 5228 0010                  		addq.b	#1,oFrame(a0)			; Next frame
00006E4C 0C28 0005 0010             		cmpi.b	#5,oFrame(a0)			; Has it reached the last frame?
00006E52 6600                       		bne.s	.Display			; If not, branch
00006E54 4EB8 1A72                  		jsr	DeleteObject.w
00006E58                            		
00006E58                            .Display:
00006E58                            	nextObject
00006E58 3068 0004                M 	movea.w	onext(a0),a0
00006E5C 2250                     M 	move.l	oaddr(a0),a1
00006E5E 4ED1                     M 	jmp	(a1)
00006E60                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006E60                            ; Data
00006E60                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006E60                            Map_ObjExplosion:
00006E60                            		include	"Objects/Explosion/Mappings.asm"
00006E60                            ; --------------------------------------------------------------------------------
00006E60                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
00006E60                            ; --------------------------------------------------------------------------------
00006E60                            
00006E60                            SME_PS_OI:	
00006E60 0000 0000                  		dc.w SME_PS_OI_A-SME_PS_OI, SME_PS_OI_12-SME_PS_OI	
00006E64 0000 0000                  		dc.w SME_PS_OI_1A-SME_PS_OI, SME_PS_OI_22-SME_PS_OI	
00006E68 0000                       		dc.w SME_PS_OI_3C-SME_PS_OI	
00006E6A 0001                       SME_PS_OI_A:	dc.b 0, 1	
00006E6C F809 0000 FFF4             		dc.b $F8, 9, 0, 0, $FF, $F4	
00006E72 0001                       SME_PS_OI_12:	dc.b 0, 1	
00006E74 F00F 0020 FFF0             		dc.b $F0, $F, 0, $20, $FF, $F0	
00006E7A 0001                       SME_PS_OI_1A:	dc.b 0, 1	
00006E7C F00F 0030 FFF0             		dc.b $F0, $F, 0, $30, $FF, $F0	
00006E82 0004                       SME_PS_OI_22:	dc.b 0, 4	
00006E84 EC0A 0006 FFEC             		dc.b $EC, $A, 0, 6, $FF, $EC	
00006E8A EC05 000F 0004             		dc.b $EC, 5, 0, $F, 0, 4	
00006E90 0405 180F FFEC             		dc.b 4, 5, $18, $F, $FF, $EC	
00006E96 FC0A 1806 FFFC             		dc.b $FC, $A, $18, 6, $FF, $FC	
00006E9C 0004                       SME_PS_OI_3C:	dc.b 0, 4	
00006E9E EC0A 0013 FFEC             		dc.b $EC, $A, 0, $13, $FF, $EC	
00006EA4 EC05 001C 0004             		dc.b $EC, 5, 0, $1C, 0, 4	
00006EAA 0405 181C FFEC             		dc.b 4, 5, $18, $1C, $FF, $EC	
00006EB0 FC0A 1813 FFFC             		dc.b $FC, $A, $18, $13, $FF, $FC	
00006EB6                            		even
00006EB6                            		even
00006EB6                            ; =========================================================================================================================================================
00006EB6                            		include	"Objects/Water Surface/Code.asm"	; Water surface object
00006EB6                            ; =========================================================================================================================================================
00006EB6                            ; Water surface object
00006EB6                            ; =========================================================================================================================================================
00006EB6                            		rsset	oLvlSSTs
00006EB6 =00000030                  oSurfPause	rs.b	1			; Animation stop flag
00006EB6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006EB6                            ObjWaterSurface:
00006EB6 20BC 0000 0000             		move.l	#ObjWaterSurface_Main,oAddr(a0)	; Next routine
00006EBC 217C 0000 0000 0010        		move.l	#Map_ObjWaterSurface,oMap(a0)	; Mappings
00006EC4 317C 8690 000E             		move.w	#$8690,oVRAM(a0)		; Tile properties
00006ECA 117C 0004 000D             		move.b	#4,oRender(a0)			; Render flags
00006ED0                            	displaySprite	0,a0,a1,0			; Priority
00006ED0 317C BE5A 0008           M 	move.w	#rdispinput+(0*dsize),odrawnext(a0)
00006ED6 3278 BE64                M 	move.w	rdispinput+dprev+(0*dsize).w,a1
00006EDA 3149 000A                M 	move.w	a1,odrawprev(a0)
00006EDE 3348 0008                M 	move.w	a0,odrawnext(a1)
00006EE2 31C8 BE64                M 	move.w	a0,rdispinput+dprev+(0*dsize).w
00006EE6                          M .no_240
00006EE6 117C 0080 0017             		move.b	#$80,oDrawW(a0)			; Sprite width
00006EEC 117C 0020 001B             		move.b	#$20,oDrawH(a0)			; Sprite height
00006EF2                            
00006EF2                            ObjWaterSurface_Main:
00006EF2 3238 F8F6                  		move.w	rWaterLvl.w,d1		; Get water height
00006EF6 5D41                       		subq.w	#6,d1				; Shift it
00006EF8 3141 0018                  		move.w	d1,oYPos(a0)			; Set Y position
00006EFC                            
00006EFC 4A28 0030                  		tst.b	oSurfPause(a0)			; Is the animation paused?
00006F00 6600                       		bne.s	.ChkUnpause			; If so, branch
00006F02 0838 0007 C741             		btst	#7,rP1Press.w			; Has the start button been pressed?
00006F08 6700                       		beq.s	.Animate			; If not, branch
00006F0A 5628 0010                  		addq.b	#3,oFrame(a0)			; Use different frames
00006F0E 50E8 0030                  		st	oSurfPause(a0)			; Pause the animation
00006F12 6000                       		bra.s	.Animate			; Continue
00006F14                            
00006F14                            .ChkUnpause:
00006F14 4A38 C75C                  		tst.b	rPauseFlag.w			; Is the game paused?
00006F18 6600                       		bne.s	.Animate			; If so, branch
00006F1A 4228 0030                  		clr.b	oSurfPause(a0)			; Resume animation
00006F1E 5728 0010                  		subq.b	#3,oFrame(a0)			; Use normal frames
00006F22                            
00006F22                            .Animate:
00006F22 43FA 0000                  		lea	.AniScript(pc),a1		; Get animation script
00006F26 7200                       		moveq	#0,d1
00006F28 1228 0022                  		move.b	oAniFrame(a0),d1		; Get animation script frame
00006F2C 1171 1000 0010             		move.b	(a1,d1.w),oFrame(a0)		; Set mapping frame
00006F32 5228 0022                  		addq.b	#1,oAniFrame(a0)		; Next frame in animation script
00006F36 0228 003F 0022             		andi.b	#$3F,oAniFrame(a0)		; Loop in necessary
00006F3C                            	nextObject
00006F3C 3068 0004                M 	movea.w	onext(a0),a0
00006F40 2250                     M 	move.l	oaddr(a0),a1
00006F42 4ED1                     M 	jmp	(a1)
00006F44                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006F44                            .AniScript:
00006F44 0001 0001 0001 0001 0001+  		dc.b	0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1
00006F54 0102 0102 0102 0102 0102+  		dc.b	1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2
00006F64 0201 0201 0201 0201 0201+  		dc.b	2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1
00006F74 0100 0100 0100 0100 0100+  		dc.b	1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1
00006F84 00                         		even
00006F84                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006F84                            ; Data
00006F84                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00006F84                            Map_ObjWaterSurface:
00006F84                            		include	"Objects/Water Surface/Mappings.asm"
00006F84                            MapConv_obj1B:
00006F84 0000                       	dc.w	byte_11178-MapConv_obj1B
00006F86 0000                       	dc.w	byte_11188-MapConv_obj1B
00006F88 0000                       	dc.w	byte_11198-MapConv_obj1B
00006F8A 0000                       	dc.w	byte_111A8-MapConv_obj1B
00006F8C 0000                       	dc.w	byte_111C7-MapConv_obj1B
00006F8E 0000                       	dc.w	byte_111E6-MapConv_obj1B
00006F90                            
00006F90 0003                       byte_11178:	dc.w 3
00006F92 FD0D 0000 FFA0             	dc.w $FD0D, 0, $FFA0
00006F98 FD0D 0000 FFE0             	dc.w $FD0D, 0, $FFE0
00006F9E FD0D 0000 0020             	dc.w $FD0D, 0, $20
00006FA4                            
00006FA4 0003                       byte_11188:	dc.w 3
00006FA6 FD0D 0008 FFA0             	dc.w $FD0D, 8, $FFA0
00006FAC FD0D 0008 FFE0             	dc.w $FD0D, 8, $FFE0
00006FB2 FD0D 0008 0020             	dc.w $FD0D, 8, $20
00006FB8                            
00006FB8 0003                       byte_11198:	dc.w 3
00006FBA FD0D 0800 FFA0             	dc.w $FD0D, $800, $FFA0
00006FC0 FD0D 0800 FFE0             	dc.w $FD0D, $800, $FFE0
00006FC6 FD0D 0800 0020             	dc.w $FD0D, $800, $20
00006FCC                            
00006FCC 0006                       byte_111A8:	dc.w 6
00006FCE FD0D 0000 FFA0             	dc.w $FD0D, 0, $FFA0
00006FD4 FD0D 0000 FFC0             	dc.w $FD0D, 0, $FFC0
00006FDA FD0D 0000 FFE0             	dc.w $FD0D, 0, $FFE0
00006FE0 FD0D 0000 0000             	dc.w $FD0D, 0, 0
00006FE6 FD0D 0000 0020             	dc.w $FD0D, 0, $20
00006FEC FD0D 0000 0040             	dc.w $FD0D, 0, $40
00006FF2                            
00006FF2 0006                       byte_111C7:	dc.w 6
00006FF4 FD0D 0008 FFA0             	dc.w $FD0D, 8, $FFA0
00006FFA FD0D 0008 FFC0             	dc.w $FD0D, 8, $FFC0
00007000 FD0D 0008 FFE0             	dc.w $FD0D, 8, $FFE0
00007006 FD0D 0008 0000             	dc.w $FD0D, 8, 0
0000700C FD0D 0008 0020             	dc.w $FD0D, 8, $20
00007012 FD0D 0008 0040             	dc.w $FD0D, 8, $40
00007018                            
00007018 0006                       byte_111E6:	dc.w 6
0000701A FD0D 0800 FFA0             	dc.w $FD0D, $800, $FFA0
00007020 FD0D 0800 FFC0             	dc.w $FD0D, $800, $FFC0
00007026 FD0D 0800 FFE0             	dc.w $FD0D, $800, $FFE0
0000702C FD0D 0800 0000             	dc.w $FD0D, $800, 0
00007032 FD0D 0800 0020             	dc.w $FD0D, $800, $20
00007038 FD0D 0800 0040             	dc.w $FD0D, $800, $40
0000703E                            
0000703E                            	even
0000703E                            		even
0000703E                            ; =========================================================================================================================================================
0000703E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000703E                            		include	"Objects/Monitor/Code.asm"	; Monitor object
0000703E                            ; =========================================================================================================================================================
0000703E                            ; Monitor object
0000703E                            ; =========================================================================================================================================================
0000703E                            		rsset	oLvlSSTs
0000703E =00000030                  oMonFall	rs.b	1				; Fall flag
0000703E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000703E                            ObjMonitor:
0000703E 20BC 0000 0000             		move.l	#ObjMonitorMain,oAddr(a0)
00007044 117C 000E 002D             		move.b	#$E,oColH(a0)
0000704A 117C 000E 002C             		move.b	#$E,oColW(a0)
00007050 217C 0000 0000 0010        		move.l	#Map_ObjMonitor,oMap(a0)
00007058 317C 0588 000E             		move.w	#$588,oVRAM(a0)
0000705E 117C 0004 000D             		move.b	#4,oRender(a0)
00007064                            	displaySprite	3,a0,a1,0			; Priority
00007064 317C BE72 0008           M 	move.w	#rdispinput+(3*dsize),odrawnext(a0)
0000706A 3278 BE7C                M 	move.w	rdispinput+dprev+(3*dsize).w,a1
0000706E 3149 000A                M 	move.w	a1,odrawprev(a0)
00007072 3348 0008                M 	move.w	a0,odrawnext(a1)
00007076 31C8 BE7C                M 	move.w	a0,rdispinput+dprev+(3*dsize).w
0000707A                          M .no_242
0000707A 117C 000F 0017             		move.b	#$F,oDrawW(a0)
00007080 117C 000F 001B             		move.b	#$F,oDrawH(a0)
00007086 3028 0026                  		move.w	oRespawn(a0),d0
0000708A 6700                       		beq.s	ObjMonitorNotBroken
0000708C 3440                       		movea.w	d0,a2
0000708E 0812 0000                  		btst	#0,(a2)				; has monitor been broken?
00007092 6700                       		beq.s	ObjMonitorNotBroken		; if not, branch
00007094 117C 0007 0010             		move.b	#7,oFrame(a0)		; use broken monitor frame
0000709A 20BC 0000 0000             		move.l	#ObjMonitorCheckActive,oAddr(a0)
000070A0                            	nextObject
000070A0 3068 0004                M 	movea.w	onext(a0),a0
000070A4 2250                     M 	move.l	oaddr(a0),a1
000070A6 4ED1                     M 	jmp	(a1)
000070A8                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000070A8                            ObjMonitorNotBroken:
000070A8 117C 0006 002A             		move.b	#6,oColType(a0)
000070AE 1168 0024 0020             		move.b	oSubtype(a0),oAni(a0)
000070B4                            
000070B4                            ObjMonitorMain:
000070B4 6100                       		bsr.s	ObjMonitorFall
000070B6 323C 0019                  		move.w	#$19,d1
000070BA 343C 0010                  		move.w	#$10,d2
000070BE 3602                       		move.w	d2,d3
000070C0 3828 0014                  		move.w	oXPos(a0),d4
000070C4 3278 F86C                  		movea.w	rPlayer1Addr.w,a1
000070C8 6100                       		bsr.s	SolidObject_Monitor
000070CA                            
000070CA 3038 F8C2                  		move.w	rMaxCamY.w,d0
000070CE 0640 00E0                  		addi.w	#$E0,d0
000070D2 B068 0018                  		cmp.w	oYPos(a0),d0
000070D6 6D00                       		blt.s	ObjMonitorDelete
000070D8                            
000070D8 4EB8 47BA                  		jsr	AddToColResponse
000070DC 43FA 0000                  		lea	Ani_ObjMonitor(pc),a1
000070E0 4EB8 1C66                  		jsr	AnimateObject.w
000070E4 4EB8 2024                  		jsr	CheckObjActive.w
000070E8                            	nextObject
000070E8 3068 0004                M 	movea.w	onext(a0),a0
000070EC 2250                     M 	move.l	oaddr(a0),a1
000070EE 4ED1                     M 	jmp	(a1)
000070F0                            
000070F0                            ObjMonitorDelete:
000070F0 4EB8 1A72                  		jsr	DeleteObject.w
000070F4                            	nextObject
000070F4 3068 0004                M 	movea.w	onext(a0),a0
000070F8 2250                     M 	move.l	oaddr(a0),a1
000070FA 4ED1                     M 	jmp	(a1)
000070FC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000070FC                            ObjMonitorAnimate:
000070FC 0C28 0007 0010             		cmpi.b	#7,oFrame(a0)
00007102 6500                       		bcs.s	.NotBroken
00007104 20BC 0000 0000             		move.l	#ObjMonitorCheckActive,oAddr(a0)
0000710A                            
0000710A                            .NotBroken:
0000710A 43FA 0000                  		lea	Ani_ObjMonitor(pc),a1
0000710E 4EB8 1C66                  		jsr	AnimateObject.w
00007112                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00007112                            ObjMonitorCheckActive:
00007112 4EB8 2024                  		jsr	CheckObjActive.w
00007116                            	nextObject
00007116 3068 0004                M 	movea.w	onext(a0),a0
0000711A 2250                     M 	move.l	oaddr(a0),a1
0000711C 4ED1                     M 	jmp	(a1)
0000711E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000711E                            ObjMonitorFall:
0000711E 1028 0030                  		move.b	oMonFall(a0),d0
00007122 6700                       		beq.s	.End
00007124 4EB8 1D66                  		jsr	ObjectMoveAndFall.w
00007128 4A68 001E                  		tst.w	oYVel(a0)
0000712C 6B00                       		bmi.s	.End
0000712E 4EB8 305C                  		jsr	ObjCheckFloorDist
00007132 4A41                       		tst.w	d1
00007134 6700                       		beq.s	.InGround
00007136 6A00                       		bpl.s	.End
00007138                            
00007138                            .InGround:
00007138 D368 0018                  		add.w	d1,oYPos(a0)
0000713C 4268 001E                  		clr.w	oYVel(a0)
00007140 4228 0030                  		clr.b	oMonFall(a0)
00007144                            
00007144                            .End:
00007144 4E75                       		rts
00007146                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00007146                            SolidObject_Monitor:
00007146 0828 0003 0028             		btst	#cStandBit,oStatus(a0)
0000714C 6600                       		bne.s	ObjMonitorChkOverEdge
0000714E 0C29 0002 0020             		cmpi.b	#2,oAni(a1)
00007154 6700                       		beq.s	.End
00007156 0C29 0017 0020             		cmpi.b	#$17,oAni(a1)		; check if in drowning animation
0000715C 6600                       		bne.s	.SetSolid
0000715E                            
0000715E                            .End:
0000715E 4E75                       		rts
00007160                            
00007160                            .SetSolid:
00007160 4EF8 42EC                  		jmp	SolidObject_ChkCollision
00007164                            
00007164                            ObjMonitorChkOverEdge:
00007164 3401                       		move.w	d1,d2
00007166 D442                       		add.w	d2,d2
00007168 0829 0001 0028             		btst	#1,oStatus(a1)
0000716E 6600                       		bne.s	.NotOnMonitor
00007170 3029 0014                  		move.w	oXPos(a1),d0
00007174 9068 0014                  		sub.w	oXPos(a0),d0
00007178 D041                       		add.w	d1,d0
0000717A 6B00                       		bmi.s	.NotOnMonitor
0000717C B042                       		cmp.w	d2,d0
0000717E 6500                       		blo.s	ObjMonitorCharStandOn
00007180                            
00007180                            .NotOnMonitor:
00007180 08A9 0003 0028             		bclr	#cStandBit,oStatus(a1)
00007186 08E9 0001 0028             		bset	#1,oStatus(a1)
0000718C 08A8 0003 0028             		bclr	#cStandBit,oStatus(a0)
00007192 7800                       		moveq	#0,d4
00007194 4E75                       		rts
00007196                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00007196                            ObjMonitorCharStandOn:
00007196 3404                       		move.w	d4,d2
00007198 4EB8 4616                  		jsr	PlayerMoveOnPtfm
0000719C 7800                       		moveq	#0,d4
0000719E 4E75                       		rts
000071A0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000071A0                            ObjMonitorBreakOpen:
000071A0                            		playSnd	#sBreakItem, 2			; Play destroy sound
000071A0 11FC 009A C4BD           M 	move.b	#sbreakitem,(mqueue+((2)-1)).w
000071A6                            		
000071A6 1028 0028                  		move.b	oStatus(a0),d0
000071AA 0200 0028                  		andi.b	#cStand|cPush,d0
000071AE 6700                       		beq.s	ObjMonitorSpawnIcon
000071B0 3278 F86C                  		movea.w	rPlayer1Addr.w,a1
000071B4 0229 00D7 0028             		andi.b	#$D7,oStatus(a1)
000071BA 0029 0002 0028             		ori.b	#2,oStatus(a1)
000071C0                            
000071C0                            ObjMonitorSpawnIcon:
000071C0 4228 0028                  		clr.b	oStatus(a0)
000071C4 117C 0000 002A             		move.b	#0,oColType(a0)
000071CA 4EB8 1A1C                  		jsr	FindFreeObj.w
000071CE 6700                       		beq.s	.SkipIconCreation
000071D0 22BC 0000 0000             		move.l	#ObjMonitorContents,oAddr(a1)		; load monitor contents	object
000071D6 3368 0014 0014             		move.w	oXPos(a0),oXPos(a1)
000071DC 3368 0018 0018             		move.w	oYPos(a0),oYPos(a1)
000071E2 1368 0020 0020             		move.b	oAni(a0),oAni(a1)
000071E8 1368 000D 000D             		move.b	oRender(a0),oRender(a1)
000071EE 1368 0028 0028             		move.b	oStatus(a0),oStatus(a1)
000071F4                            
000071F4                            .SkipIconCreation:
000071F4 4EB8 1A1C                  		jsr	FindFreeObj.w
000071F8 6700                       		beq.s	.SkipExplosionCreation
000071FA 22BC 0000 6DF0             		move.l	#ObjExplosion,oAddr(a1)			; load explosion object
00007200 3368 0014 0014             		move.w	oXPos(a0),oXPos(a1)
00007206 3368 0018 0018             		move.w	oYPos(a0),oYPos(a1)
0000720C                            
0000720C                            .SkipExplosionCreation:
0000720C 3028 0026                  		move.w	oRespawn(a0),d0
00007210 6700                       		beq.s	.NotRemembered
00007212 3440                       		movea.w	d0,a2
00007214 08D2 0000                  		bset	#0,(a2)
00007218                            
00007218                            .NotRemembered:
00007218 117C 0006 0020             		move.b	#6,oAni(a0)
0000721E 20BC 0000 70FC             		move.l	#ObjMonitorAnimate,oAddr(a0)
00007224                            	nextObject
00007224 3068 0004                M 	movea.w	onext(a0),a0
00007228 2250                     M 	move.l	oaddr(a0),a1
0000722A 4ED1                     M 	jmp	(a1)
0000722C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000722C                            ; Contents of monitor object
0000722C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000722C                            ObjMonitorContents:
0000722C 7000                       		moveq	#0,d0
0000722E 1028 0025                  		move.b	oRoutine(a0),d0
00007232 4EBB 0000                  		jsr	ObjMonitorContents_Index(pc,d0.w)
00007236                            	nextObject
00007236 3068 0004                M 	movea.w	onext(a0),a0
0000723A 2250                     M 	move.l	oaddr(a0),a1
0000723C 4ED1                     M 	jmp	(a1)
0000723E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000723E                            ObjMonitorContents_Index:
0000723E 6000                       		bra.s	ObjMonitorContents_Main
00007240 6000                       		bra.s	ObjMonitorContents_Move
00007242 6000 0000                  		bra.w	ObjMonitorContents_Delete
00007246                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00007246                            ObjMonitorContents_Main:
00007246 5428 0025                  		addq.b	#2,oRoutine(a0)
0000724A 317C 8588 000E             		move.w	#$8588,oVRAM(a0)
00007250 117C 0024 000D             		move.b	#$24,oRender(a0)
00007256                            	displaySprite	3,a0,a1,0			; Priority
00007256 317C BE72 0008           M 	move.w	#rdispinput+(3*dsize),odrawnext(a0)
0000725C 3278 BE7C                M 	move.w	rdispinput+dprev+(3*dsize).w,a1
00007260 3149 000A                M 	move.w	a1,odrawprev(a0)
00007264 3348 0008                M 	move.w	a0,odrawnext(a1)
00007268 31C8 BE7C                M 	move.w	a0,rdispinput+dprev+(3*dsize).w
0000726C                          M .no_250
0000726C 117C 0008 0017             		move.b	#8,oDrawW(a0)
00007272 117C 0008 001B             		move.b	#8,oDrawH(a0)
00007278 317C FD00 001E             		move.w	#-$300,oYVel(a0)
0000727E 7000                       		moveq	#0,d0
00007280 1028 0020                  		move.b	oAni(a0),d0
00007284 5200                       		addq.b	#1,d0
00007286 227C 0000 0000             		movea.l	#Map_ObjMonitor,a1
0000728C D000                       		add.b	d0,d0
0000728E D2F1 0000                  		adda.w	(a1,d0.w),a1
00007292 5449                       		addq.w	#2,a1
00007294 2149 0010                  		move.l	a1,oMap(a0)
00007298                            
00007298 1028 0020                  		move.b	oAni(a0),d0
0000729C 5200                       		addq.b	#1,d0
0000729E 1140 0010                  		move.b	d0,oFrame(a0)
000072A2                            
000072A2                            ObjMonitorContents_Move:
000072A2 4A68 001E                  		tst.w	oYVel(a0)			; is object moving?
000072A6 6A00 0000                  		bpl.w	ObjMonitorContents_GetType	; if not, branch
000072AA 4EB8 1D4C                  		jsr	ObjectMove.w
000072AE 0668 0018 001E             		addi.w	#$18,oYVel(a0)			; reduce object	speed
000072B4 4E75                       		rts
000072B6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000072B6                            ObjMonitorContents_GetType:
000072B6 5428 0025                  		addq.b	#2,oRoutine(a0)
000072BA 117C 001D 0023             		move.b	#29,oAniTimer(a0)
000072C0 1028 0020                  		move.b	oAni(a0),d0
000072C4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000072C4 0C00 0001                  		cmpi.b	#1,d0
000072C8 6600                       		bne.s	.ChkRings
000072CA                            		push.l	a0
000072CA 2F08                     M 	move.l	a0,-(sp)
000072CC 2448                       		movea.l	a0,a2
000072CE 3078 F86C                  		movea.w	rPlayer1Addr.w,a0
000072D2 4EB8 5856                  		jsr	ObjPlayer_GetHurt
000072D6                            		pop.l	a0
000072D6 205F                     M 	move.l	(sp)+,a0
000072D8 4E75                       		rts
000072DA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000072DA                            .ChkRings:
000072DA 0C00 0002                  		cmpi.b	#2,d0
000072DE 6600                       		bne.s	.Display
000072E0 0678 000A F3D4             		addi.w	#10,rRings.w 				; add 10 rings to the number of rings you have
000072E6 0038 0001 F8F3             		ori.b	#1,rUpdateRings.w 			; update the ring counter
000072EC                            		playSnd	#sRing, 2				; Play ring sound
000072EC 11FC 008C C4BD           M 	move.b	#sring,(mqueue+((2)-1)).w
000072F2                            
000072F2                            .Display:
000072F2 4E75                       		rts
000072F4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000072F4                            ObjMonitorContents_Delete:
000072F4 5328 0023                  		subq.b	#1,oAniTimer(a0)
000072F8 6A00                       		bpl.s	.NoDelete
000072FA 4EF8 1A72                  		jmp	DeleteObject.w
000072FE                            
000072FE                            .NoDelete:
000072FE 4E75                       		rts
00007300                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00007300                            ; Data
00007300                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00007300                            Map_ObjMonitor:
00007300                            		include	"Objects/Monitor/Mappings.asm"
00007300                            ; --------------------------------------------------------------------------------
00007300                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
00007300                            ; --------------------------------------------------------------------------------
00007300                            
00007300                            SME_7TKK1:	
00007300 0000 0000                  		dc.w SME_7TKK1_10-SME_7TKK1, SME_7TKK1_18-SME_7TKK1	
00007304 0000 0000                  		dc.w SME_7TKK1_26-SME_7TKK1, SME_7TKK1_34-SME_7TKK1	
00007308 0000 0000                  		dc.w SME_7TKK1_42-SME_7TKK1, SME_7TKK1_50-SME_7TKK1	
0000730C 0000 0000                  		dc.w SME_7TKK1_5E-SME_7TKK1, SME_7TKK1_6C-SME_7TKK1	
00007310 0001                       SME_7TKK1_10:	dc.b 0, 1	
00007312 EF0F 0000 FFF0             		dc.b $EF, $F, 0, 0, $FF, $F0	
00007318 0002                       SME_7TKK1_18:	dc.b 0, 2	
0000731A F505 0018 FFF8             		dc.b $F5, 5, 0, $18, $FF, $F8	
00007320 EF0F 0000 FFF0             		dc.b $EF, $F, 0, 0, $FF, $F0	
00007326 0002                       SME_7TKK1_26:	dc.b 0, 2	
00007328 F505 001C FFF8             		dc.b $F5, 5, 0, $1C, $FF, $F8	
0000732E EF0F 0000 FFF0             		dc.b $EF, $F, 0, 0, $FF, $F0	
00007334 0002                       SME_7TKK1_34:	dc.b 0, 2	
00007336 F505 2020 FFF8             		dc.b $F5, 5, $20, $20, $FF, $F8	
0000733C EF0F 0000 FFF0             		dc.b $EF, $F, 0, 0, $FF, $F0	
00007342 0002                       SME_7TKK1_42:	dc.b 0, 2	
00007344 F505 0024 FFF8             		dc.b $F5, 5, 0, $24, $FF, $F8	
0000734A EF0F 0000 FFF0             		dc.b $EF, $F, 0, 0, $FF, $F0	
00007350 0002                       SME_7TKK1_50:	dc.b 0, 2	
00007352 F505 0028 FFF8             		dc.b $F5, 5, 0, $28, $FF, $F8	
00007358 EF0F 0000 FFF0             		dc.b $EF, $F, 0, 0, $FF, $F0	
0000735E 0002                       SME_7TKK1_5E:	dc.b 0, 2	
00007360 F505 002C FFF8             		dc.b $F5, 5, 0, $2C, $FF, $F8	
00007366 EF0F 0000 FFF0             		dc.b $EF, $F, 0, 0, $FF, $F0	
0000736C 0001                       SME_7TKK1_6C:	dc.b 0, 1	
0000736E FF0D 0010 FFF0             		dc.b $FF, $D, 0, $10, $FF, $F0	
00007374                            		even
00007374                            Ani_ObjMonitor:
00007374                            		include	"Objects/Monitor/Animations.asm"
00007374                            ; ---------------------------------------------------------------------------
00007374                            ; Animation script - monitors
00007374                            ; ---------------------------------------------------------------------------
00007374 0000                       		dc.w .Static-Ani_ObjMonitor
00007376 0000                       		dc.w .Eggman-Ani_ObjMonitor
00007378 0000                       		dc.w .Rings-Ani_ObjMonitor
0000737A 0000                       		dc.w .Shoes-Ani_ObjMonitor
0000737C 0000                       		dc.w .Shield-Ani_ObjMonitor
0000737E 0000                       		dc.w .Stars-Ani_ObjMonitor
00007380 0000                       		dc.w .Destroyed-Ani_ObjMonitor
00007382 0100 01FF 00               .Static:	dc.b 1, 0, 1, $FF, 0
00007387 0100 0202 0102 02FF 00     .Eggman:	dc.b 1, 0, 2, 2, 1, 2, 2, $FF, 0
00007390 0100 0303 0103 03FF 00     .Rings:		dc.b 1, 0, 3, 3, 1, 3, 3, $FF, 0
00007399 0100 0404 0104 04FF 00     .Shoes:		dc.b 1, 0, 4, 4, 1, 4, 4, $FF, 0
000073A2 0100 0505 0105 05FF 00     .Shield:	dc.b 1, 0, 5, 5, 1, 5, 5, $FF, 0
000073AB 0100 0606 0106 06FF 00     .Stars:		dc.b 1, 0, 6, 6, 1, 6, 6, $FF, 0
000073B4 0100 0107 FE01 00          .Destroyed:	dc.b 1, 0, 1, 7, $FE, 1, 0
000073BC 00                         		even
000073BC                            ; =========================================================================================================================================================
000073BC                            		include	"Objects/Spikes/Code.asm"		; Spike object
000073BC                            ; ===========================================================================
000073BC                            ; Spike object
000073BC                            ; ===========================================================================
000073BC                            		rsset	oLvlSSTs
000073BC =00000030                  oSpikeX		rs.w	1
000073BC =00000032                  oSpikeY		rs.w	1
000073BC =00000034                  oSpkMvOff	rs.w	1
000073BC =00000036                  oSpkMvState	rs.w	1
000073BC =00000038                  oSpkMvTime	rs.w	1
000073BC                            ; ===========================================================================
000073BC                            ObjSpike:
000073BC 7000                       		moveq	#0,d0
000073BE 1028 0025                  		move.b	oRoutine(a0),d0
000073C2 4EBB 0000                  		jsr	ObjSpike_Index(pc,d0.w)
000073C6                            	nextObject
000073C6 3068 0004                M 	movea.w	onext(a0),a0
000073CA 2250                     M 	move.l	oaddr(a0),a1
000073CC 4ED1                     M 	jmp	(a1)
000073CE                            ; ===========================================================================
000073CE                            ObjSpike_Index:
000073CE 6000 0000                  		bra.w ObjSpike_Init
000073D2 6000 0000                  		bra.w ObjSpike_Upright
000073D6 6000 0000                  		bra.w ObjSpike_Sideways
000073DA 6000 0000                  		bra.w ObjSpike_UpsideDown
000073DE                            ; ===========================================================================
000073DE                            ;ObjSpike_InitData:
000073DE                            ;		dc.b $10,$10	; 0	- Upright or ceiling spikes
000073DE                            ;		dc.b $10,$10	; 2	- Sideways spikes
000073DE                            ; ===========================================================================
000073DE                            ObjSpike_Init:
000073DE 5828 0025                  		addq.b	#4,oRoutine(a0)
000073E2 217C 0000 0000 0010        		move.l	#Map_ObjSpike,oMap(a0)
000073EA 317C 06A8 000E             		move.w	#$6A8,oVRAM(a0)
000073F0 0028 0004 000D             		ori.b	#4,oRender(a0)
000073F6                            	displaySprite	4,a0,a1,0			; Priority
000073F6 317C BE7A 0008           M 	move.w	#rdispinput+(4*dsize),odrawnext(a0)
000073FC 3278 BE84                M 	move.w	rdispinput+dprev+(4*dsize).w,a1
00007400 3149 000A                M 	move.w	a1,odrawprev(a0)
00007404 3348 0008                M 	move.w	a0,odrawnext(a1)
00007408 31C8 BE84                M 	move.w	a0,rdispinput+dprev+(4*dsize).w
0000740C                          M .no_255
0000740C 1028 0024                  		move.b	oSubtype(a0),d0
00007410 0228 000F 0024             		andi.b	#$F,oSubtype(a0)
00007416 0240 00F0                  		andi.w	#$F0,d0
0000741A 7210                       		moveq	#$10,d1
0000741C 1141 0017                  		move.b	d1,oDrawW(a0)
00007420 1141 002C                  		move.b	d1,oColW(a0)
00007424 1141 001B                  		move.b	d1,oDrawH(a0)
00007428 1141 002D                  		move.b	d1,oColH(a0)
0000742C E848                       		lsr.w	#4,d0
0000742E 1140 0010                  		move.b	d0,oFrame(a0)
00007432 0C00 0001                  		cmpi.b	#1,d0
00007436 6600                       		bne.s	.ChkUpsideDown
00007438 5828 0025                  		addq.b	#4,oRoutine(a0)
0000743C 317C 06AC 000E             		move.w	#$6AC,oVRAM(a0)
00007442                            
00007442                            .ChkUpsideDown:
00007442 0828 0001 0028             		btst	#1,oStatus(a0)
00007448 6700                       		beq.s	.SavePos
0000744A 117C 000C 0025             		move.b	#$C,oRoutine(a0)
00007450                            
00007450                            .SavePos:
00007450 3168 0014 0030             		move.w	oXPos(a0),oSpikeX(a0)
00007456 3168 0018 0032             		move.w	oYPos(a0),oSpikeY(a0)
0000745C                            
0000745C 6100 0000                  		bsr.w	MoveSpikes		; make the object move
00007460 0C28 0001 0010             		cmpi.b	#1,oFrame(a0)		; is object type $1x ?
00007466 6700                       		beq.s	ObjSpike_SideWays	; if yes, branch
00007468                            ; ===========================================================================
00007468                            ; Upright spikes
00007468                            ; ===========================================================================
00007468                            ObjSpike_Upright:
00007468 6100 0000                  		bsr.w	MoveSpikes
0000746C 7200                       		moveq	#0,d1
0000746E 1228 0017                  		move.b	oDrawW(a0),d1
00007472 0641 000B                  		addi.w	#$B,d1
00007476 7400                       		moveq	#0,d2
00007478 1428 001B                  		move.b	oDrawH(a0),d2
0000747C 3602                       		move.w	d2,d3
0000747E 5243                       		addq.w	#1,d3
00007480 3828 0014                  		move.w	oXPos(a0),d4
00007484 4EB8 419A                  		jsr	SolidObject
00007488 0828 0003 0028             		btst	#cStandBit,oStatus(a0)
0000748E 6700                       		beq.s	ObjSpike_UprightEnd
00007490 3278 F86C                  		movea.w	rPlayer1Addr.w,a1
00007494 6100 0000                  		bsr.w	Touch_ChkHurt2
00007498                            
00007498                            ObjSpike_UprightEnd:
00007498 3028 0030                  		move.w	oSpikeX(a0),d0
0000749C 4EF8 2024                  		jmp	CheckObjActive.w
000074A0                            ; ===========================================================================
000074A0                            ; Sideways spikes
000074A0                            ; ===========================================================================
000074A0                            ObjSpike_Sideways:
000074A0 3F28 0014                  		move.w	oXPos(a0),-(sp)	
000074A4 6100 0000                  		bsr.w	MoveSpikes
000074A8 7200                       		moveq	#0,d1
000074AA 1228 0017                  		move.b	oDrawW(a0),d1
000074AE 0641 000B                  		addi.w	#$B,d1
000074B2 7400                       		moveq	#0,d2
000074B4 1428 001B                  		move.b	oDrawH(a0),d2
000074B8 3602                       		move.w	d2,d3
000074BA 5243                       		addq.w	#1,d3
000074BC 381F                       		move.w	(sp)+,d4
000074BE 4EB8 419A                  		jsr	SolidObject
000074C2 0806 0000                  		btst	#cTouchSideBit,d6
000074C6 6700                       		beq.s	ObjSpike_SidewaysEnd
000074C8 3278 F86C                  		movea.w	rPlayer1Addr.w,a1
000074CC 6100 0000                  		bsr.w	Touch_ChkHurt2
000074D0                            
000074D0                            ObjSpike_SidewaysEnd:
000074D0 3028 0030                  		move.w	oSpikeX(a0),d0
000074D4 4EF8 2024                  		jmp	CheckObjActive.w
000074D8                            ; ===========================================================================
000074D8                            ; Upside down spikes
000074D8                            ; ===========================================================================
000074D8                            ObjSpike_UpsideDown:
000074D8 6100 0000                  		bsr.w	MoveSpikes
000074DC 7200                       		moveq	#0,d1
000074DE 1228 0017                  		move.b	oDrawW(a0),d1
000074E2 0641 000B                  		addi.w	#$B,d1
000074E6 7400                       		moveq	#0,d2
000074E8 1428 001B                  		move.b	oDrawH(a0),d2
000074EC 3602                       		move.w	d2,d3
000074EE 5243                       		addq.w	#1,d3
000074F0 3828 0014                  		move.w	oXPos(a0),d4
000074F4 4EB8 419A                  		jsr	SolidObject
000074F8 0806 0002                  		btst	#cTouchBtmBit,d6
000074FC 6700                       		beq.s	ObjSpike_UpsideDownEnd
000074FE 3278 F86C                  		movea.w	rPlayer1Addr.w,a1
00007502 6100 0000                  		bsr.w	Touch_ChkHurt2
00007506                            
00007506                            ObjSpike_UpsideDownEnd:
00007506 3028 0030                  		move.w	oSpikeX(a0),d0
0000750A 4EF8 2024                  		jmp	CheckObjActive.w
0000750E                            ; ===========================================================================
0000750E                            Touch_ChkHurt2:
0000750E 4A29 0042                  		tst.b	oInvulTime(a1)			; is Sonic invincible?
00007512 6600                       		bne.s	.End				; if yes, branch
00007514 0C29 0008 0025             		cmpi.b	#8,oRoutine(a1)
0000751A 6700                       		beq.s	.End
0000751C 2629 0018                  		move.l	oYPos(a1),d3
00007520 3029 001E                  		move.w	oYVel(a1),d0
00007524 48C0                       		ext.l	d0
00007526 E180                       		asl.l	#8,d0
00007528 9680                       		sub.l	d0,d3
0000752A 2343 0018                  		move.l	d3,oYPos(a1)
0000752E 2448                       		movea.l	a0,a2
00007530 2049                       		movea.l	a1,a0
00007532 4EB8 5856                  		jsr	ObjPlayer_GetHurt
00007536 204A                       		movea.l	a2,a0
00007538                            
00007538                            .End:
00007538 4E75                       		rts
0000753A                            ; ===========================================================================
0000753A                            MoveSpikes:	
0000753A 7000                       		moveq	#0,d0
0000753C 1028 0024                  		move.b	oSubtype(a0),d0
00007540 D040                       		add.w	d0,d0
00007542 4EFB 0000                  		jmp	MoveSpikes_Behaviors(pc,d0.w)
00007546                            ; ===========================================================================
00007546                            MoveSpikes_Behaviors:
00007546 6000                       		bra.s MoveSpikes_Still
00007548 6000                       		bra.s MoveSpikes_Vertical
0000754A 6000                       		bra.s MoveSpikes_Horizontal
0000754C                            ; ===========================================================================
0000754C                            MoveSpikes_Still:
0000754C 4E75                       		rts			; don't move the object
0000754E                            ; ===========================================================================
0000754E                            MoveSpikes_Vertical:
0000754E 6100 0000                  		bsr.w	MoveSpikes_Delay
00007552 7000                       		moveq	#0,d0
00007554 1028 0034                  		move.b	oSpkMvOff(a0),d0
00007558 D068 0032                  		add.w	oSpikeY(a0),d0
0000755C 3140 0018                  		move.w	d0,oYPos(a0)	; move the object vertically
00007560 4E75                       		rts
00007562                            ; ===========================================================================
00007562                            MoveSpikes_Horizontal:
00007562 6100 0000                  		bsr.w	MoveSpikes_Delay
00007566 7000                       		moveq	#0,d0
00007568 1028 0034                  		move.b	oSpkMvOff(a0),d0
0000756C D068 0030                  		add.w	oSpikeX(a0),d0
00007570 3140 0014                  		move.w	d0,oXPos(a0)	; move the object horizontally
00007574 4E75                       		rts
00007576                            ; ===========================================================================
00007576                            MoveSpikes_Delay:
00007576 4A68 0038                  		tst.w	oSpkMvTime(a0)		; is time delay	= zero?
0000757A 6700                       		beq.s	MoveSpikes_ChkDir		; if yes, branch
0000757C 5368 0038                  		subq.w	#1,oSpkMvTime(a0)	; subtract 1 from time delay
00007580 6600                       		bne.s	locret_CFE6
00007582 4A28 000D                  		tst.b	oRender(a0)
00007586 6A00                       		bpl.s	locret_CFE6
00007588                            		playSnd	#sSpikeMove, 2		; Play spike move sound
00007588 11FC 008B C4BD           M 	move.b	#sspikemove,(mqueue+((2)-1)).w
0000758E 6000                       		bra.s	locret_CFE6
00007590                            ; ===========================================================================
00007590                            MoveSpikes_ChkDir:
00007590 4A68 0036                  		tst.w	oSpkMvState(a0)
00007594 6700                       		beq.s	MoveSpikes_Retract
00007596 0468 0800 0034             		subi.w	#$800,oSpkMvOff(a0)
0000759C 6400                       		bcc.s	locret_CFE6
0000759E 317C 0000 0034             		move.w	#0,oSpkMvOff(a0)
000075A4 317C 0000 0036             		move.w	#0,oSpkMvState(a0)
000075AA 317C 003C 0038             		move.w	#60,oSpkMvTime(a0)	; set time delay to 1 second
000075B0 6000                       		bra.s	locret_CFE6
000075B2                            ; ===========================================================================
000075B2                            MoveSpikes_Retract:
000075B2 0668 0800 0034             		addi.w	#$800,oSpkMvOff(a0)
000075B8 0C68 2000 0034             		cmpi.w	#$2000,oSpkMvOff(a0)
000075BE 6500                       		bcs.s	locret_CFE6
000075C0 317C 2000 0034             		move.w	#$2000,oSpkMvOff(a0)
000075C6 317C 0001 0036             		move.w	#1,oSpkMvState(a0)
000075CC 317C 003C 0038             		move.w	#60,oSpkMvTime(a0)	; set time delay to 1 second
000075D2                            
000075D2                            locret_CFE6:
000075D2 4E75                       		rts
000075D4                            ; ===========================================================================
000075D4                            ; Spike object mappings
000075D4                            ; ===========================================================================
000075D4                            Map_ObjSpike:
000075D4                            	include "Objects/Spikes/Mappings.asm"
000075D4                            ; --------------------------------------------------------------------------------
000075D4                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
000075D4                            ; --------------------------------------------------------------------------------
000075D4                            
000075D4                            SME_5AG23:	
000075D4 0000 0000                  		dc.w SME_5AG23_4-SME_5AG23, SME_5AG23_1E-SME_5AG23	
000075D8 0004                       SME_5AG23_4:	dc.b 0, 4	
000075DA F003 0000 FFF0             		dc.b $F0, 3, 0, 0, $FF, $F0	
000075E0 F003 0000 FFF8             		dc.b $F0, 3, 0, 0, $FF, $F8	
000075E6 F003 0000 0000             		dc.b $F0, 3, 0, 0, 0, 0	
000075EC F003 0000 0008             		dc.b $F0, 3, 0, 0, 0, 8	
000075F2 0004                       SME_5AG23_1E:	dc.b 0, 4	
000075F4 F00C 0000 FFF0             		dc.b $F0, $C, 0, 0, $FF, $F0	
000075FA F80C 0000 FFF0             		dc.b $F8, $C, 0, 0, $FF, $F0	
00007600 000C 0000 FFF0             		dc.b 0, $C, 0, 0, $FF, $F0	
00007606 080C 0000 FFF0             		dc.b 8, $C, 0, 0, $FF, $F0	
0000760C                            		even
0000760C                            ; ===========================================================================
0000760C                            		include	"Objects/Spring/Code.asm"		; Spring object
0000760C                            ; =========================================================================================================================================================
0000760C                            ; Spring object
0000760C                            ; =========================================================================================================================================================
0000760C                            		rsset	oLvlSSTs
0000760C =00000030                  oSprSpd		rs.w	1				; Spring strength
0000760C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000760C                            ObjSpring:
0000760C 217C 0000 0000 0010        		move.l	#Map_ObjSpring,oMap(a0)		; Mappings
00007614 317C 05BA 000E             		move.w	#$5BA,oVRAM(a0)			; Tile properties
0000761A 0028 0004 000D             		ori.b	#4,oRender(a0)			; Render flags
00007620 117C 0010 0017             		move.b	#$10,oDrawW(a0)			; Sprite width
00007626 117C 0008 001B             		move.b	#8,oDrawH(a0)			; Sprite height
0000762C 117C 000E 002C             		move.b	#$1C/2,oColW(a0)		; Collision width
00007632                            	displaySprite	4,a0,a1,0			; Priority
00007632 317C BE7A 0008           M 	move.w	#rdispinput+(4*dsize),odrawnext(a0)
00007638 3278 BE84                M 	move.w	rdispinput+dprev+(4*dsize).w,a1
0000763C 3149 000A                M 	move.w	a1,odrawprev(a0)
00007640 3348 0008                M 	move.w	a0,odrawnext(a1)
00007644 31C8 BE84                M 	move.w	a0,rdispinput+dprev+(4*dsize).w
00007648                          M .no_257
00007648                            		
00007648 1028 0024                  		move.b	oSubtype(a0),d0			; Get subtype
0000764C E648                       		lsr.w	#3,d0				; Turn into offset
0000764E 0240 000E                  		andi.w	#$E,d0				; ''
00007652 4EFB 0000                  		jmp	.Subtypes(pc,d0.w)		; Jump to it
00007656                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00007656                            .Subtypes:
00007656 6000                       		bra.s .Init_Up				; Up
00007658 6000                       		bra.s .Init_Horizontal			; Horizontal
0000765A 6000                       		bra.s .Init_Down			; Down
0000765C 6000                       		bra.s .Init_DiagonallyUp		; Diagonally up
0000765E 6000                       		bra.s .Init_DiagonallyDown		; Diagonally down
00007660                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00007660                            .Init_Horizontal:
00007660 117C 0002 0020             		move.b	#2,oAni(a0)			; Animation
00007666 117C 0002 0010             		move.b	#2,oFrame(a0)			; Mapping frame
0000766C 317C 05CA 000E             		move.w	#$5CA,oVRAM(a0)			; Tile properties
00007672 117C 0008 0017             		move.b	#8,oDrawW(a0)			; Sprite width
00007678 117C 0010 001B             		move.b	#$10,oDrawH(a0)			; Sprite height
0000767E 117C 000E 002C             		move.b	#$1C/2,oColW(a0)		; Collision width
00007684 20BC 0000 0000             		move.l	#ObjSpring_Horizontal,oAddr(a0)	; Next routine
0000768A 6000                       		bra.s	.Init_Common			; Continue
0000768C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000768C                            .Init_Down:
0000768C 08E8 0001 0028             		bset	#1,oStatus(a0)			; Flip vertically
00007692 20BC 0000 0000             		move.l	#ObjSpring_Down,oAddr(a0)	; Next routine
00007698 6000                       		bra.s	.Init_Common			; Continue
0000769A                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0000769A                            .Init_DiagonallyUp:
0000769A 117C 0004 0020             		move.b	#4,oAni(a0)			; Animation
000076A0 117C 0004 0010             		move.b	#4,oFrame(a0)			; Map frame
000076A6 317C 05D9 000E             		move.w	#$5D9,oVRAM(a0)			; Tile properties
000076AC 20BC 0000 0000             		move.l	#ObjSpring_DiagonallyUp,oAddr(a0); Next routine
000076B2 6000                       		bra.s	.Init_Common			; Continue
000076B4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000076B4                            .Init_DiagonallyDown:
000076B4 117C 0004 0020             		move.b	#4,oAni(a0)			; Animation
000076BA 117C 0006 0010             		move.b	#6,oFrame(a0)			; Map frame
000076C0 317C 05D9 000E             		move.w	#$5D9,oVRAM(a0)			; Tile properties
000076C6 08E8 0001 0028             		bset	#1,oStatus(a0)			; Flip vertically
000076CC 20BC 0000 0000             		move.l	#ObjSpring_DiagonallyDown,oAddr(a0); Next routine
000076D2 6000                       		bra.s	.Init_Common			; Continue
000076D4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000076D4                            .Init_Up:
000076D4 20BC 0000 0000             		move.l	#ObjSpring_Up,oAddr(a0)		; Next routine
000076DA                            
000076DA                            .Init_Common:
000076DA 1028 0024                  		move.b	oSubtype(a0),d0			; Get subtype
000076DE 0240 0002                  		andi.w	#2,d0				; Turn into offset
000076E2 317B 0000 0030             		move.w	.Strengths(pc,d0.w),oSprSpd(a0)	; Get spring strength
000076E8 0800 0001                  		btst	#1,d0				; Is the spring supposed to be yellow?
000076EC 6700                       		beq.s	.NotYellow			; If not, branch
000076EE 08E8 0005 000E             		bset	#5,oVRAM(a0)			; Make the spring yellow
000076F4                            
000076F4                            .NotYellow:
000076F4                            	nextObject
000076F4 3068 0004                M 	movea.w	onext(a0),a0
000076F8 2250                     M 	move.l	oaddr(a0),a1
000076FA 4ED1                     M 	jmp	(a1)
000076FC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000076FC                            .Strengths:
000076FC F000                       		dc.w	-$1000				; Strength of red spring
000076FE F600                       		dc.w	-$A00				; Strength of yellow spring
00007700                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00007700                            ObjSpring_Up:
00007700 323C 001A                  		move.w	#27-1,d1			; Width
00007704 343C 0008                  		move.w	#16/2,d2			; Height
00007708 3602                       		move.w	d2,d3				; ''
0000770A 3828 0014                  		move.w	oXPos(a0),d4			; X position
0000770E 4EB8 41EA                  		jsr	SolidObject_Always		; Set object as solid
00007712 0828 0003 0028             		btst	#cStandBit,oStatus(a0)		; Has the player touched the top of the of spring?
00007718 6700                       		beq.s	.Display			; If not, branch
0000771A 6100                       		bsr.s	.Bounce				; Bounce the player up
0000771C                            
0000771C                            .Display:
0000771C 43FA 0000                  		lea	Ani_ObjSpring(pc),a1		; Animate sprite
00007720 4EB8 1C66                  		jsr	AnimateObject.w			; ''
00007724 4EB8 2024                  		jsr	CheckObjActive.w		; Display sprite
00007728                            	nextObject
00007728 3068 0004                M 	movea.w	onext(a0),a0
0000772C 2250                     M 	move.l	oaddr(a0),a1
0000772E 4ED1                     M 	jmp	(a1)
00007730                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00007730                            .Bounce:
00007730 317C 0100 0020             		move.w	#$100,oAni(a0)			; Reset animation
00007736 5069 0018                  		addq.w	#8,oYPos(a1)			; Align player to spring
0000773A 3368 0030 001E             		move.w	oSprSpd(a0),oYVel(a1)		; Set the player's Y velocity
00007740 08E9 0001 0028             		bset	#1,oStatus(a1)			; Set the player's "in air" flag
00007746 08A9 0003 0028             		bclr	#cStandBit,oStatus(a1)		; Make the player no longer be on the spring
0000774C 4229 0040                  		clr.b	oJumping(a1)			; Clear the player's jump flag
00007750 137C 0010 0020             		move.b	#$10,oAni(a1)			; Set the player's animation to the spring animation
00007756 137C 0004 0025             		move.b	#4,oRoutine(a1)			; Reset the player's routine
0000775C                            		
0000775C 1028 0024                  		move.b	oSubtype(a0),d0			; Get subtype
00007760 6A00                       		bpl.s	.ChkPath1			; Branch if the player can still move horizontally
00007762 4269 001C                  		clr.w	oXVel(a1)			; Stop the player's X movement
00007766                            
00007766                            .ChkPath1:
00007766 0200 000C                  		andi.b	#$C,d0				; Only get path swap bits
0000776A 0C00 0004                  		cmpi.b	#4,d0				; Does the player need to switch to path 1?
0000776E 6600                       		bne.s	.ChkPath2			; If not, branch
00007770 137C 000C 0032             		move.b	#$C,oTopSolid(a1)		; Switch to path 1
00007776 137C 000D 0033             		move.b	#$D,oLRBSolid(a1)		; ''
0000777C                            
0000777C                            .ChkPath2:
0000777C 0C00 0008                  		cmpi.b	#8,d0				; Does the player need to switch to path 2?
00007780 6600                       		bne.s	.PlaySound			; If not, branch
00007782 137C 000E 0032             		move.b	#$E,oTopSolid(a1)		; Switch to path 2
00007788 137C 000F 0033             		move.b	#$F,oLRBSolid(a1)		; ''
0000778E                            
0000778E                            .PlaySound:
0000778E                            		playSnd	#sSpring, 2			; Play spring sound
0000778E 11FC 008E C4BD           M 	move.b	#sspring,(mqueue+((2)-1)).w
00007794 4E75                       		rts
00007796                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00007796                            ObjSpring_Horizontal:
00007796 323C 0013                  		move.w	#20-1,d1			; Width
0000779A 343C 000E                  		move.w	#28/2,d2			; Height
0000779E 3602                       		move.w	d2,d3				; ''
000077A0 3828 0014                  		move.w	oXPos(a0),d4			; X position
000077A4 4EB8 41EA                  		jsr	SolidObject_Always		; Set object as solid
000077A8 0806 0000                  		btst	#cTouchSideBit,d6		; Has the player touched the side of the spring?
000077AC 6700                       		beq.s	.Display			; If not, branch
000077AE 1228 0028                  		move.b	oStatus(a0),d1			; Get status
000077B2 3028 0014                  		move.w	oXPos(a0),d0			; Get which side of the spring the player is facing
000077B6 9069 0014                  		sub.w	oXPos(a1),d0			; ''
000077BA 6500                       		bcs.s	.NoFlip				; If the player is on the left side of the spring, branch
000077BC 0A01 0001                  		eori.b	#1,d1				; Flip so that we check for the other side of the spring
000077C0                            
000077C0                            .NoFlip:
000077C0 0201 0001                  		andi.b	#1,d1				; Is the player touching the bouncy side of the spring?
000077C4 6600                       		bne.s	.Display			; If not, branch
000077C6 6100                       		bsr.s	.Bounce				; Bounce the player
000077C8                            
000077C8                            .Display:
000077C8 43FA 0000                  		lea	Ani_ObjSpring(pc),a1		; Animate sprite
000077CC 4EB8 1C66                  		jsr	AnimateObject.w			; ''
000077D0 4EB8 2024                  		jsr	CheckObjActive.w		; Display sprite
000077D4                            	nextObject
000077D4 3068 0004                M 	movea.w	onext(a0),a0
000077D8 2250                     M 	move.l	oaddr(a0),a1
000077DA 4ED1                     M 	jmp	(a1)
000077DC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000077DC                            .Bounce:	
000077DC 317C 0300 0020             		move.w	#$300,oAni(a0)			; Reset animation
000077E2 5069 0014                  		addq.w	#8,oXPos(a1)			; Align player to spring
000077E6 3368 0030 001C             		move.w	oSprSpd(a0),oXVel(a1)		; Set the player's X velocity
000077EC 08E9 0000 0028             		bset	#0,oStatus(a1)			; Make the player face the left
000077F2 0828 0000 0028             		btst	#0,oStatus(a0)			; Is this spring facing the left?
000077F8 6600                       		bne.s	.SetMoveLock			; If so, branch
000077FA 08A9 0000 0028             		bclr	#0,oStatus(a1)			; Make the player face the right
00007800 0469 0010 0014             		subi.w	#$10,oXPos(a1)			; Align player to spring
00007806 4469 001C                  		neg.w	oXVel(a1)			; Move the player to the right
0000780A                            
0000780A                            .SetMoveLock:
0000780A 137C 000F 003F             		move.b	#$F,oMoveLock(a1)		; Lock the player's movement for a bit
00007810 3369 001C 003A             		move.w	oXVel(a1),oGVel(a1)		; Set the player's ground velocity
00007816                            		
00007816 0829 0002 0028             		btst	#2,oStatus(a1)			; Is the player jumping?
0000781C 6600                       		bne.s	.ChkYStop			; If so, branch
0000781E 4229 0020                  		clr.b	oAni(a1)			; Set the animation to the walking animation
00007822                            		
00007822                            .ChkYStop:
00007822 1028 0024                  		move.b	oSubtype(a0),d0			; Get subtype
00007826 6A00                       		bpl.s	.ChkPath1			; Branch if the player can still move vertically
00007828 4269 001C                  		clr.w	oXVel(a1)			; Stop the player's Y movement
0000782C                            
0000782C                            .ChkPath1:
0000782C 0200 000C                  		andi.b	#$C,d0				; Only get path swap bits
00007830 0C00 0004                  		cmpi.b	#4,d0				; Does the player need to switch to path 1?
00007834 6600                       		bne.s	.ChkPath2			; If not, branch
00007836 137C 000C 0032             		move.b	#$C,oTopSolid(a1)		; Switch to path 1
0000783C 137C 000D 0033             		move.b	#$D,oLRBSolid(a1)		; ''
00007842                            
00007842                            .ChkPath2:
00007842 0C00 0008                  		cmpi.b	#8,d0				; Does the player need to switch to path 2?
00007846 6600                       		bne.s	.PlaySound			; If not, branch
00007848 137C 000E 0032             		move.b	#$E,oTopSolid(a1)		; Switch to path 2
0000784E 137C 000F 0033             		move.b	#$F,oLRBSolid(a1)		; ''
00007854                            
00007854                            .PlaySound:
00007854 08A8 0005 0028             		bclr	#cPushBit,oStatus(a0)		; Clear "push" flags
0000785A 08A9 0005 0028             		bclr	#cPushBit,oStatus(a1)		; ''
00007860                            		playSnd	#sSpring, 2			; Play spring sound
00007860 11FC 008E C4BD           M 	move.b	#sspring,(mqueue+((2)-1)).w
00007866 4E75                       		rts
00007868                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00007868                            ObjSpring_Down:
00007868 323C 0012                  		move.w	#19-1,d1			; Width
0000786C 343C 0008                  		move.w	#16/2,d2			; Height
00007870 3602                       		move.w	d2,d3				; ''
00007872 3828 0014                  		move.w	oXPos(a0),d4			; X position
00007876 4EB8 41EA                  		jsr	SolidObject_Always		; Set object as solid
0000787A 0C44 FFFE                  		cmpi.w	#-2,d4				; Has the player touched the bottom of the spring?
0000787E 6600                       		bne.s	.Display			; If not, branch
00007880 6100                       		bsr.s	.Bounce				; Bounce the player
00007882                            
00007882                            .Display:
00007882 43FA 0000                  		lea	Ani_ObjSpring(pc),a1		; Animate sprite
00007886 4EB8 1C66                  		jsr	AnimateObject.w			; ''
0000788A 4EB8 2024                  		jsr	CheckObjActive.w		; Display sprite
0000788E                            	nextObject
0000788E 3068 0004                M 	movea.w	onext(a0),a0
00007892 2250                     M 	move.l	oaddr(a0),a1
00007894 4ED1                     M 	jmp	(a1)
00007896                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00007896                            .Bounce:
00007896 317C 0100 0020             		move.w	#$100,oAni(a0)			; Reset animation
0000789C 5169 0018                  		subq.w	#8,oYPos(a1)			; Align player with the spring
000078A0 3368 0030 001E             		move.w	oSprSpd(a0),oYVel(a1)		; Set the player's Y velocity
000078A6 4469 001E                  		neg.w	oYVel(a1)			; Move the player down
000078AA                            		
000078AA 1028 0024                  		move.b	oSubtype(a0),d0			; Get subtype
000078AE 6A00                       		bpl.s	.ChkPath1			; Branch if the player can still move horizontally
000078B0 4269 001C                  		clr.w	oXVel(a1)			; Stop the player's X movement
000078B4                            
000078B4                            .ChkPath1:
000078B4 0200 000C                  		andi.b	#$C,d0				; Only get path swap bits
000078B8 0C00 0004                  		cmpi.b	#4,d0				; Does the player need to switch to path 1?
000078BC 6600                       		bne.s	.ChkPath2			; If not, branch
000078BE 137C 000C 0032             		move.b	#$C,oTopSolid(a1)		; Switch to path 1
000078C4 137C 000D 0033             		move.b	#$D,oLRBSolid(a1)		; ''
000078CA                            
000078CA                            .ChkPath2:
000078CA 0C00 0008                  		cmpi.b	#8,d0				; Does the player need to switch to path 2?
000078CE 6600                       		bne.s	.PlaySound			; If not, branch
000078D0 137C 000E 0032             		move.b	#$E,oTopSolid(a1)		; Switch to path 2
000078D6 137C 000F 0033             		move.b	#$F,oLRBSolid(a1)		; ''
000078DC                            
000078DC                            .PlaySound:
000078DC 08E9 0001 0028             		bset	#1,oStatus(a1)			; Set the player's "in air" flag
000078E2 08A9 0003 0028             		bclr	#cStandBit,oStatus(a1)		; Make the player no longer be on the spring
000078E8 137C 0004 0025             		move.b	#4,oRoutine(a1)			; Reset the player's routine
000078EE                            		playSnd	#sSpring, 2			; Play spring sound
000078EE 11FC 008E C4BD           M 	move.b	#sspring,(mqueue+((2)-1)).w
000078F4 4E75                       		rts
000078F6                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000078F6                            ObjSpring_DiagonallyUp:
000078F6 323C 0019                  		move.w	#26-1,d1			; Width
000078FA 343C 0010                  		move.w	#32/2,d2			; Height
000078FE 3828 0014                  		move.w	oXPos(a0),d4			; X position
00007902 45FA 0000                  		lea	.SlopeData(pc),a2		; Slope Data
00007906 4EB8 423A                  		jsr	SlopedSolid			; Set object as a solid slope
0000790A                            		
0000790A 0828 0003 0028             		btst	#cStandBit,oStatus(a0)		; Has the player touched the spring?
00007910 6700                       		beq.s	.End				; If not, branch
00007912 6100                       		bsr.s	.Bounce				; Bounce the player
00007914                            
00007914                            .End:
00007914 43FA 0000                  		lea	Ani_ObjSpring(pc),a1		; Animate sprite
00007918 4EB8 1C66                  		jsr	AnimateObject.w			; ''
0000791C 4EB8 2024                  		jsr	CheckObjActive.w		; Display sprite
00007920                            	nextObject
00007920 3068 0004                M 	movea.w	onext(a0),a0
00007924 2250                     M 	move.l	oaddr(a0),a1
00007926 4ED1                     M 	jmp	(a1)
00007928                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00007928                            .Bounce:
00007928 0828 0000 0028             		btst	#0,oStatus(a0)			; Is the spring facing left?
0000792E 6600                       		bne.s	.FaceLeft			; If so, branch
00007930 3028 0014                  		move.w	oXPos(a0),d0			; Get X position
00007934 5940                       		subq.w	#4,d0				; Subtract 4
00007936 B069 0014                  		cmp.w	oXPos(a1),d0			; Is the player
0000793A 6500                       		blo.s	.DoBounce
0000793C 4E75                       		rts
0000793E                            
0000793E                            .FaceLeft:
0000793E 3028 0014                  		move.w	oXPos(a0),d0
00007942 5840                       		addq.w	#4,d0
00007944 B069 0014                  		cmp.w	oXPos(a1),d0
00007948 6400                       		bhs.s	.DoBounce
0000794A 4E75                       		rts
0000794C                            
0000794C                            .DoBounce:
0000794C 317C 0500 0020             		move.w	#$500,oAni(a0)
00007952 3368 0030 001E             		move.w	oSprSpd(a0),oYVel(a1)
00007958 3368 0030 001C             		move.w	oSprSpd(a0),oXVel(a1)
0000795E 5C69 0018                  		addq.w	#6,oYPos(a1)
00007962 5C69 0014                  		addq.w	#6,oXPos(a1)
00007966 08E9 0000 0028             		bset	#0,oStatus(a1)
0000796C 0828 0000 0028             		btst	#0,oStatus(a0)
00007972 6600                       		bne.s	.SetAni
00007974 08A9 0000 0028             		bclr	#0,oStatus(a1)
0000797A 0469 000C 0014             		subi.w	#$C,oXPos(a1)
00007980 4469 001C                  		neg.w	oXVel(a1)
00007984                            
00007984                            .SetAni:
00007984 08E9 0001 0028             		bset	#1,oStatus(a1)
0000798A 08A9 0003 0028             		bclr	#3,oStatus(a1)
00007990 137C 0010 0020             		move.b	#$10,oAni(a1)
00007996 137C 0004 0025             		move.b	#4,oRoutine(a1)
0000799C                            
0000799C 1028 0024                  		move.b	oSubtype(a0),d0
000079A0 0200 000C                  		andi.b	#$C,d0				; Only get path swap bits
000079A4 0C00 0004                  		cmpi.b	#4,d0				; Does the player need to switch to path 1?
000079A8 6600                       		bne.s	.ChkPath2			; If not, branch
000079AA 137C 000C 0032             		move.b	#$C,oTopSolid(a1)		; Switch to path 1
000079B0 137C 000D 0033             		move.b	#$D,oLRBSolid(a1)		; ''
000079B6                            
000079B6                            .ChkPath2:
000079B6 0C00 0008                  		cmpi.b	#8,d0				; Does the player need to switch to path 2?
000079BA 6600                       		bne.s	.PlaySound			; If not, branch
000079BC 137C 000E 0032             		move.b	#$E,oTopSolid(a1)		; Switch to path 2
000079C2 137C 000F 0033             		move.b	#$F,oLRBSolid(a1)		; ''
000079C8                            
000079C8                            .PlaySound:
000079C8                            		playSnd	#sSpring, 2			; Play spring sound
000079C8 11FC 008E C4BD           M 	move.b	#sspring,(mqueue+((2)-1)).w
000079CE 4E75                       		rts
000079D0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000079D0                            .SlopeData:
000079D0 1010 1010 1010 10          		dc.b	$10, $10, $10, $10, $10, $10, $10
000079D7 1010 1010 100E 0C          		dc.b	$10, $10, $10, $10, $10, $0E, $0C
000079DE 0A08 0604 0200 FE          		dc.b	$0A, $08, $06, $04, $02, $00, $FE
000079E5 FCFC FCFC FCFC FC          		dc.b	$FC, $FC, $FC, $FC, $FC, $FC, $FC
000079EC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000079EC                            ObjSpring_DiagonallyDown:
000079EC 323C 0019                  		move.w	#26-1,d1			; Width
000079F0 343C 0010                  		move.w	#32/2,d2
000079F4 3828 0014                  		move.w	oXPos(a0),d4
000079F8 45FA 0000                  		lea	.SlopeData(pc),a2
000079FC 4EB8 423A                  		jsr	SlopedSolid			; Set object as a solid slope
00007A00 0C44 FFFE                  		cmpi.w	#-2,d4				; Has the player touched the spring?
00007A04 6600                       		bne.s	.End				; If not, branch
00007A06 6100                       		bsr.s	.Bounce				; Bounce the player
00007A08                            
00007A08                            .End:
00007A08 43FA 0000                  		lea	Ani_ObjSpring(pc),a1		; Animate sprite
00007A0C 4EB8 1C66                  		jsr	AnimateObject.w			; ''
00007A10 4EB8 2024                  		jsr	CheckObjActive.w		; Display sprite
00007A14                            	nextObject
00007A14 3068 0004                M 	movea.w	onext(a0),a0
00007A18 2250                     M 	move.l	oaddr(a0),a1
00007A1A 4ED1                     M 	jmp	(a1)
00007A1C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00007A1C                            .Bounce:
00007A1C 317C 0500 0020             		move.w	#$500,oAni(a0)
00007A22 3368 0030 001E             		move.w	oSprSpd(a0),oYVel(a1)
00007A28 4469 001E                  		neg.w	oYVel(a1)
00007A2C 3368 0030 001C             		move.w	oSprSpd(a0),oXVel(a1)
00007A32 5C69 0018                  		addq.w	#6,oYPos(a1)
00007A36 5C69 0014                  		addq.w	#6,oXPos(a1)
00007A3A 08E9 0000 0028             		bset	#0,oStatus(a1)
00007A40 0828 0000 0028             		btst	#0,oStatus(a0)
00007A46 6600                       		bne.s	.SetAni
00007A48 08A9 0000 0028             		bclr	#0,oStatus(a1)
00007A4E 0469 000C 0014             		subi.w	#$C,oXPos(a1)
00007A54 4469 001C                  		neg.w	oXVel(a1)
00007A58                            
00007A58                            .SetAni:
00007A58 08E9 0001 0028             		bset	#1,oStatus(a1)
00007A5E 08A9 0003 0028             		bclr	#3,oStatus(a1)
00007A64 137C 0004 0025             		move.b	#4,oRoutine(a1)
00007A6A                            
00007A6A 1028 0024                  		move.b	oSubtype(a0),d0
00007A6E 0200 000C                  		andi.b	#$C,d0				; Only get path swap bits
00007A72 0C00 0004                  		cmpi.b	#4,d0				; Does the player need to switch to path 1?
00007A76 6600                       		bne.s	.ChkPath2			; If not, branch
00007A78 137C 000C 0032             		move.b	#$C,oTopSolid(a1)		; Switch to path 1
00007A7E 137C 000D 0033             		move.b	#$D,oLRBSolid(a1)		; ''
00007A84                            
00007A84                            .ChkPath2:
00007A84 0C00 0008                  		cmpi.b	#8,d0				; Does the player need to switch to path 2?
00007A88 6600                       		bne.s	.PlaySound			; If not, branch
00007A8A 137C 000E 0032             		move.b	#$E,oTopSolid(a1)		; Switch to path 2
00007A90 137C 000F 0033             		move.b	#$F,oLRBSolid(a1)		; ''
00007A96                            
00007A96                            .PlaySound:
00007A96                            		playSnd	#sSpring, 2			; Play spring sound
00007A96 11FC 008E C4BD           M 	move.b	#sspring,(mqueue+((2)-1)).w
00007A9C 4E75                       		rts
00007A9E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00007A9E                            .SlopeData:
00007A9E F4F0 F0F0 F0F0 F0          		dc.b	$F4, $F0, $F0, $F0, $F0, $F0, $F0
00007AA5 F0F0 F0F0 F0F2 F4          		dc.b	$F0, $F0, $F0, $F0, $F0, $F2, $F4
00007AAC F6F8 FAFC FE00 02          		dc.b	$F6, $F8, $FA, $FC, $FE, $00, $02
00007AB3 0404 0404 0404 04          		dc.b	$04, $04, $04, $04, $04, $04, $04
00007ABA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00007ABA                            ; Data
00007ABA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00007ABA                            Ani_ObjSpring:
00007ABA                            		include	"Objects/Spring/Animations.asm"
00007ABA                            ; ---------------------------------------------------------------------------
00007ABA                            ; Animation script - springs
00007ABA                            ; ---------------------------------------------------------------------------
00007ABA 0000                       		dc.w byte_18FEE-Ani_ObjSpring
00007ABC 0000                       		dc.w byte_18FF1-Ani_ObjSpring
00007ABE 0000                       		dc.w byte_18FFD-Ani_ObjSpring
00007AC0 0000                       		dc.w byte_19000-Ani_ObjSpring
00007AC2 0000                       		dc.w byte_1900C-Ani_ObjSpring
00007AC4 0000                       		dc.w byte_1900F-Ani_ObjSpring
00007AC6                            byte_18FEE:
00007AC6 0F00 FF                    		dc.b  $F, 0, $FF
00007ACA 00                         		even
00007ACA                            byte_18FF1:
00007ACA 0001 0101 0101 01FD 00     		dc.b 0, 1, 1, 1, 1, 1, 1, $FD, 0
00007AD4 00                         		even
00007AD4                            byte_18FFD:
00007AD4 0F02 FF                    		dc.b $F, 2, $FF
00007AD8 00                         		even
00007AD8                            byte_19000:
00007AD8 0003 0303 0303 03FD 02     		dc.b 0, 3, 3, 3, 3, 3, 3, $FD, 2
00007AE2 00                         		even
00007AE2                            byte_1900C:
00007AE2 0F04 FF                    		dc.b $F, 4, $FF
00007AE6 00                         		even
00007AE6                            byte_1900F:
00007AE6 0005 0505 0505 05FD 04     		dc.b 0, 5, 5, 5, 5, 5, 5, $FD, 4
00007AF0 00                         		even
00007AF0                            Map_ObjSpring:
00007AF0                            		include	"Objects/Spring/Mappings.asm"
00007AF0                            ; --------------------------------------------------------------------------------
00007AF0                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
00007AF0                            ; --------------------------------------------------------------------------------
00007AF0                            
00007AF0                            SME_q_6K9:	
00007AF0 0000 0000                  		dc.w SME_q_6K9_E-SME_q_6K9, SME_q_6K9_1C-SME_q_6K9	
00007AF4 0000 0000                  		dc.w SME_q_6K9_3C-SME_q_6K9, SME_q_6K9_44-SME_q_6K9	
00007AF8 0000 0000                  		dc.w SME_q_6K9_70-SME_q_6K9, SME_q_6K9_7E-SME_q_6K9	
00007AFC 0000                       		dc.w SME_q_6K9_9E-SME_q_6K9	
00007AFE 0002                       SME_q_6K9_E:	dc.b 0, 2	
00007B00 F80C 0000 FFF0             		dc.b $F8, $C, 0, 0, $FF, $F0	
00007B06 000C 0004 FFF0             		dc.b 0, $C, 0, 4, $FF, $F0	
00007B0C 0005                       SME_q_6K9_1C:	dc.b 0, 5	
00007B0E E00C 0000 FFF0             		dc.b $E0, $C, 0, 0, $FF, $F0	
00007B14 E804 0008 FFF8             		dc.b $E8, 4, 0, 8, $FF, $F8	
00007B1A F004 000A FFF8             		dc.b $F0, 4, 0, $A, $FF, $F8	
00007B20 F804 000A FFF8             		dc.b $F8, 4, 0, $A, $FF, $F8	
00007B26 000C 000C FFF0             		dc.b 0, $C, 0, $C, $FF, $F0	
00007B2C 0001                       SME_q_6K9_3C:	dc.b 0, 1	
00007B2E E807 0000 FFF7             		dc.b $E8, 7, 0, 0, $FF, $F7	
00007B34 0007                       SME_q_6K9_44:	dc.b 0, 7	
00007B36 E803 0004 0017             		dc.b $E8, 3, 0, 4, 0, $17	
00007B3C F001 0008 000F             		dc.b $F0, 1, 0, 8, 0, $F	
00007B42 F001 000A 0007             		dc.b $F0, 1, 0, $A, 0, 7	
00007B48 F001 000A FFFF             		dc.b $F0, 1, 0, $A, $FF, $FF	
00007B4E F001 000C FFF7             		dc.b $F0, 1, 0, $C, $FF, $F7	
00007B54 E800 000E FFF7             		dc.b $E8, 0, 0, $E, $FF, $F7	
00007B5A 0000 100E FFF7             		dc.b 0, 0, $10, $E, $FF, $F7	
00007B60 0002                       SME_q_6K9_70:	dc.b 0, 2	
00007B62 F20B 0000 FFF0             		dc.b $F2, $B, 0, 0, $FF, $F0	
00007B68 FA02 000C 0008             		dc.b $FA, 2, 0, $C, 0, 8	
00007B6E 0005                       SME_q_6K9_7E:	dc.b 0, 5	
00007B70 E20B 000F 0000             		dc.b $E2, $B, 0, $F, 0, 0	
00007B76 EA02 001B 0018             		dc.b $EA, 2, 0, $1B, 0, $18	
00007B7C F201 201E FFF8             		dc.b $F2, 1, $20, $1E, $FF, $F8	
00007B82 FA00 0020 FFF0             		dc.b $FA, 0, 0, $20, $FF, $F0	
00007B88 0209 0021 FFF0             		dc.b 2, 9, 0, $21, $FF, $F0	
00007B8E 0002                       SME_q_6K9_9E:	dc.b 0, 2	
00007B90 020B 1000 FFF0             		dc.b 2, $B, $10, 0, $FF, $F0	
00007B96 0202 100C 0008             		dc.b 2, 2, $10, $C, 0, 8	
00007B9C                            		even
00007B9C                            ; =========================================================================================================================================================
00007B9C                            		include	"Objects/Checkpoint/Code.asm"	; Checkpoint object
00007B9C                            ; =========================================================================================================================================================
00007B9C                            ; Checkpoint object
00007B9C                            ; =========================================================================================================================================================
00007B9C                            		rsset	oLvlSSTs
00007B9C =00000030                  oDongleX	rs.w	1				; Ball dongle X
00007B9C =00000032                  oDongleY	rs.w	1				; Ball dongle Y
00007B9C =00000034                  oDongleTime	rs.w	1				; Ball dongle timer
00007B9C =00000036                  oDonglePar	rs.w	1				; Ball dongle parent
00007B9C                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00007B9C                            ObjCheckpoint:
00007B9C 7000                       		moveq	#0,d0
00007B9E 1028 0025                  		move.b	oRoutine(a0),d0			; Get routine ID
00007BA2 4EBB 0000                  		jsr	.Index(pc,d0.w)			; Jump to it
00007BA6                            	nextObject
00007BA6 3068 0004                M 	movea.w	onext(a0),a0
00007BAA 2250                     M 	move.l	oaddr(a0),a1
00007BAC 4ED1                     M 	jmp	(a1)
00007BAE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00007BAE                            .Index:
00007BAE 6000 0000                  		bra.w	ObjChkpoint_Init
00007BB2 6000 0000                  		bra.w	ObjChkpoint_Main
00007BB6 6000 0000                  		bra.w	ObjChkpoint_Animate
00007BBA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00007BBA                            ObjChkpoint_Init:
00007BBA 5828 0025                  		addq.b	#4,oRoutine(a0)			; Next routine
00007BBE                            		
00007BBE 217C 0000 0000 0010        		move.l	#Map_ObjChkpoint,oMap(a0)	; Mappings
00007BC6 317C 057E 000E             		move.w	#$57E,oVRAM(a0)			; Tile properties
00007BCC 117C 0004 000D             		move.b	#4,oRender(a0)			; Render flags
00007BD2 117C 0008 0017             		move.b	#8,oDrawW(a0)			; Sprite width
00007BD8 117C 0020 001B             		move.b	#$20,oDrawH(a0)			; Sprite height
00007BDE                            	displaySprite	5,a0,a1,0			; Priority
00007BDE 317C BE82 0008           M 	move.w	#rdispinput+(5*dsize),odrawnext(a0)
00007BE4 3278 BE8C                M 	move.w	rdispinput+dprev+(5*dsize).w,a1
00007BE8 3149 000A                M 	move.w	a1,odrawprev(a0)
00007BEC 3348 0008                M 	move.w	a0,odrawnext(a1)
00007BF0 31C8 BE8C                M 	move.w	a0,rdispinput+dprev+(5*dsize).w
00007BF4                          M .no_270
00007BF4                            		
00007BF4 3028 0026                  		move.w	oRespawn(a0),d0			; Get respawn table address
00007BF8 3440                       		movea.w	d0,a2				; ''
00007BFA 0812 0000                  		btst	#0,(a2)				; Is it already set?
00007BFE 6600                       		bne.s	.AlreadySet			; If so, branch
00007C00                            
00007C00 1228 0024                  		move.b	oSubtype(a0),d1			; Get checkpoint ID
00007C04 B238 C7AE                  		cmp.b	rLastChkpoint.w,d1		; Has a later checkpoint already been hit?
00007C08 6E00                       		bgt.s	ObjChkpoint_Main		; If not, branch
00007C0A                            
00007C0A                            .AlreadySet:
00007C0A 08D2 0000                  		bset	#0,(a2)				; Mark as set
00007C0E 117C 0002 0020             		move.b	#2,oAni(a0)			; ''
00007C14                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00007C14                            ObjChkpoint_Main:
00007C14 4A38 F8D1                  		tst.b	rDebugMode.w			; Are we in debug placement mode?
00007C18 6600 0000                  		bne.w	ObjChkpoint_Animate		; If so, branch
00007C1C                            		
00007C1C 3278 F86C                  		movea.w	rPlayer1Addr.w,a1		; Player object
00007C20 1238 C7AE                  		move.b	rLastChkpoint.w,d1		; Get last checkpoint hit
00007C24 B228 0024                  		cmp.b	oSubtype(a0),d1			; Has a later checkpoint already been hit?
00007C28 6400 0000                  		bhs.w	.ChkSetAnim			; If so, branch
00007C2C                            
00007C2C 3029 0014                  		move.w	oXPos(a1),d0			; Get player's X position
00007C30 9068 0014                  		sub.w	oXPos(a0),d0			; Get delta X from current position
00007C34 5040                       		addq.w	#8,d0				; Add 8
00007C36 0C40 0010                  		cmpi.w	#$10,d0				; Is the player within horizontal boundaries?
00007C3A 6400 0000                  		bcc.w	ObjChkpoint_Animate		; If not, branch
00007C3E 3029 0018                  		move.w	oYPos(a1),d0			; Get player's Y position
00007C42 9068 0018                  		sub.w	oYPos(a0),d0			; Get delta Y from current position
00007C46 0640 0040                  		addi.w	#$40,d0				; Add $40
00007C4A 0C40 0068                  		cmpi.w	#$68,d0				; Is the player within vertical boundaries?
00007C4E 6400 0000                  		bcc.w	ObjChkpoint_Animate		; If not, branch
00007C52                            		
00007C52                            		playSnd	#sCheckpoint, 2			; Play checkpoint sound
00007C52 11FC 008A C4BD           M 	move.b	#scheckpoint,(mqueue+((2)-1)).w
00007C58                            
00007C58 4EB8 1A1C                  		jsr	FindFreeObj.w			; Find a free object slot
00007C5C 6700                       		beq.s	.SetPoint			; If there is none, branch
00007C5E 22BC 0000 0000             		move.l	#ObjChkPoint_Dongle,oAddr(a1)	; Load the checkpoint ball dongle object
00007C64 3368 0014 0030             		move.w	oXPos(a0),oDongleX(a1)		; Dongle X
00007C6A 3368 0018 0032             		move.w	oYPos(a0),oDongleY(a1)		; Dongle Y
00007C70 0469 0014 0032             		subi.w	#$14,oDongleY(a1)		; ''
00007C76 2368 0010 0010             		move.l	oMap(a0),oMap(a1)		; Mappings
00007C7C 3368 000E 000E             		move.w	oVRAM(a0),oVRAM(a1)		; Tile properties
00007C82 137C 0004 000D             		move.b	#4,oRender(a1)			; Render flags
00007C88 137C 0008 0017             		move.b	#8,oDrawW(a1)			; Sprite width
00007C8E 137C 0008 001B             		move.b	#8,oDrawH(a1)			; Sprite height
00007C94                            	displaySprite	4,a1,a2,0			; Priority
00007C94 337C BE7A 0008           M 	move.w	#rdispinput+(4*dsize),odrawnext(a1)
00007C9A 3478 BE84                M 	move.w	rdispinput+dprev+(4*dsize).w,a2
00007C9E 334A 000A                M 	move.w	a2,odrawprev(a1)
00007CA2 3549 0008                M 	move.w	a1,odrawnext(a2)
00007CA6 31C9 BE84                M 	move.w	a1,rdispinput+dprev+(4*dsize).w
00007CAA                          M .no_272
00007CAA 137C 0002 0010             		move.b	#2,oFrame(a1)			; Map frame
00007CB0 337C 0020 0034             		move.w	#$20,oDongleTime(a1)		; Dongle timer
00007CB6 3348 0036                  		move.w	a0,oDonglePar(a1)		; Dongle parent
00007CBA                            
00007CBA                            .SetPoint:
00007CBA 3028 0026                  		move.w	oRespawn(a0),d0			; Get respawn table address
00007CBE 3440                       		movea.w	d0,a2				; ''
00007CC0 08D2 0000                  		bset	#0,(a2)				; Mark as set
00007CC4                            		
00007CC4 117C 0001 0020             		move.b	#1,oAni(a0)			; Use dongling animation
00007CCA 11E8 0024 C7AE             		move.b	oSubtype(a0),rLastChkpoint.w	; Set checkpoint ID
00007CD0                            
00007CD0 5828 0025                  		addq.b	#4,oRoutine(a0)
00007CD4 4879 0000 0000             		pea	ObjChkpoint_Animate		; Animate
00007CDA 4EF8 47CC                  		jmp	Level_SaveInfo			; Save data
00007CDE                            		
00007CDE                            .ChkSetAnim:
00007CDE 5828 0025                  		addq.b	#4,oRoutine(a0)
00007CE2 4A28 0020                  		tst.b	oAni(a0)			; Are we still unset?
00007CE6 6600                       		bne.s	ObjChkpoint_Animate		; If not, branch
00007CE8 117C 0002 0020             		move.b	#2,oAni(a0)			; Use the set animation
00007CEE                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------		
00007CEE                            ObjChkpoint_Animate:
00007CEE 43F9 0000 0000             		lea	Ani_ObjChkpoint,a1		; Animate
00007CF4 4EB8 1C66                  		jsr	AnimateObject.w			; ''
00007CF8 4EF8 2024                  		jmp	CheckObjActive.w		; Display
00007CFC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------		
00007CFC                            ; Ball dongle object
00007CFC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------		
00007CFC                            ObjChkPoint_Dongle:
00007CFC 5368 0034                  		subq.w	#1,oDongleTime(a0)		; Decrement timer
00007D00 6A00                       		bpl.s	.MoveDongle			; If it hasn't run out, branch
00007D02 3268 0036                  		movea.w	oDonglePar(a0),a1		; Get parent
00007D06 137C 0002 0020             		move.b	#2,oAni(a1)			; Set set animation for parent
00007D0C 4229 0010                  		clr.b	oFrame(a1)			; Reset map frame for parent
00007D10 4EB8 1A72                  		jsr	DeleteObject.w			; Delete ourselves
00007D14                            	nextObject
00007D14 3068 0004                M 	movea.w	onext(a0),a0
00007D18 2250                     M 	move.l	oaddr(a0),a1
00007D1A 4ED1                     M 	jmp	(a1)
00007D1C                            
00007D1C                            .MoveDongle:
00007D1C 1028 0041                  		move.b	oAngle(a0),d0			; Get angle
00007D20 0428 0010 0041             		subi.b	#$10,oAngle(a0)			; Decrement angle
00007D26 0400 0040                  		subi.b	#$40,d0				; Subtract $40
00007D2A 4EB8 1374                  		jsr	CalcSine.w			; Get sine and cosine
00007D2E C3FC 0C00                  		muls.w	#$C00,d1			; Multiply cosine with $C00
00007D32 4841                       		swap	d1				; Get high word
00007D34 D268 0030                  		add.w	oDongleX(a0),d1			; Add dongle X
00007D38 3141 0014                  		move.w	d1,oXPos(a0)			; Set actual X
00007D3C C1FC 0C00                  		muls.w	#$C00,d0			; Multiply sine with $C00
00007D40 4840                       		swap	d0				; Get high word
00007D42 D068 0032                  		add.w	oDongleY(a0),d0			; Add dongle X
00007D46 3140 0018                  		move.w	d0,oYPos(a0)			; Set actual X
00007D4A 4EB8 2024                  		jsr	CheckObjActive.w		; Display
00007D4E                            	nextObject
00007D4E 3068 0004                M 	movea.w	onext(a0),a0
00007D52 2250                     M 	move.l	oaddr(a0),a1
00007D54 4ED1                     M 	jmp	(a1)
00007D56                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00007D56                            ; Data
00007D56                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00007D56                            Ani_ObjChkpoint:
00007D56 0000                       		dc.w	.Ani0-Ani_ObjChkpoint
00007D58 0000                       		dc.w	.Ani1-Ani_ObjChkpoint
00007D5A 0000                       		dc.w	.Ani2-Ani_ObjChkpoint
00007D5C 0F00 FF                    .Ani0:		dc.b	$F, 0, $FF
00007D60 00                         		even
00007D60 0F01 FF                    .Ani1:		dc.b	$F, 1, $FF
00007D64 00                         		even
00007D64 0300 04FF                  .Ani2:		dc.b	3, 0, 4, $FF
00007D68                            		even
00007D68                            Map_ObjChkpoint:
00007D68                            		include	"Objects/Checkpoint/Mappings.asm"
00007D68                            ; --------------------------------------------------------------------------------
00007D68                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
00007D68                            ; --------------------------------------------------------------------------------
00007D68                            
00007D68                            SME_JjCUP:	
00007D68 0000 0000                  		dc.w SME_JjCUP_A-SME_JjCUP, SME_JjCUP_24-SME_JjCUP	
00007D6C 0000 0000                  		dc.w SME_JjCUP_38-SME_JjCUP, SME_JjCUP_40-SME_JjCUP	
00007D70 0000                       		dc.w SME_JjCUP_48-SME_JjCUP	
00007D72 0004                       SME_JjCUP_A:	dc.b 0, 4	
00007D74 E801 2004 FFFC             		dc.b $E8, 1, $20, 4, $FF, $FC	
00007D7A F803 2006 FFF8             		dc.b $F8, 3, $20, 6, $FF, $F8	
00007D80 F803 2806 0000             		dc.b $F8, 3, $28, 6, 0, 0	
00007D86 D805 0000 FFF8             		dc.b $D8, 5, 0, 0, $FF, $F8	
00007D8C 0003                       SME_JjCUP_24:	dc.b 0, 3	
00007D8E E801 2004 FFFC             		dc.b $E8, 1, $20, 4, $FF, $FC	
00007D94 F803 2006 FFF8             		dc.b $F8, 3, $20, 6, $FF, $F8	
00007D9A F803 2806 0000             		dc.b $F8, 3, $28, 6, 0, 0	
00007DA0 0001                       SME_JjCUP_38:	dc.b 0, 1	
00007DA2 F805 0000 FFF8             		dc.b $F8, 5, 0, 0, $FF, $F8	
00007DA8 0001                       SME_JjCUP_40:	dc.b 0, 1	
00007DAA F805 2000 FFF8             		dc.b $F8, 5, $20, 0, $FF, $F8	
00007DB0 0004                       SME_JjCUP_48:	dc.b 0, 4	
00007DB2 E801 2004 FFFC             		dc.b $E8, 1, $20, 4, $FF, $FC	
00007DB8 F803 2006 FFF8             		dc.b $F8, 3, $20, 6, $FF, $F8	
00007DBE F803 2806 0000             		dc.b $F8, 3, $28, 6, 0, 0	
00007DC4 D805 2000 FFF8             		dc.b $D8, 5, $20, 0, $FF, $F8	
00007DCA                            		even
00007DCA                            ; =========================================================================================================================================================
00007DCA                            		include	"Objects/Wall Spring/Code.asm"	; Wall spring object
00007DCA                            ; =========================================================================================================================================================
00007DCA                            ; Wall spring object
00007DCA                            ; =========================================================================================================================================================
00007DCA                            ObjWallSpring:
00007DCA 20BC 0000 0000             		move.l	#ObjWallSpring_Main,oAddr(a0)	; Next routine
00007DD0                            	;	move.l	#Map_ObjWallSpring,oMap(a0)	; Mappings
00007DD0                            	;	clr.w	oVRAM(a0)			; Tile properties
00007DD0                            	;	ori.b	#4,oRender(a0)			; Render flags
00007DD0                            	;	move.w	#rSprInput+$200,oPrio(a0)	; Priority
00007DD0                            	;	move.b	#8,oDrawW(a0)			; Sprite width
00007DD0                            	;	move.b	#$40,oDrawH(a0)			; Sprite height
00007DD0 117C 0008 002C             		move.b	#8,oColW(a0)			; Collision width
00007DD6 117C 0040 002D             		move.b	#$40,oColH(a0)			; Collision height
00007DDC                            
00007DDC 1028 0024                  		move.b	oSubtype(a0),d0			; Get subtype
00007DE0 E808                       		lsr.b	#4,d0				; Get map frame
00007DE2 0200 0007                  		andi.b	#7,d0				; ''
00007DE6 1140 0010                  		move.b	d0,oFrame(a0)			; Set map frame
00007DEA 6700                       		beq.s	ObjWallSpring_Main		; If it was 0, branch
00007DEC                            	;	move.b	#$80,oDrawH(a0)			; Larger sprite height
00007DEC 117C 0080 002D             		move.b	#$80,oColH(a0)			; Larger collision height
00007DF2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00007DF2                            ObjWallSpring_Main:
00007DF2 7208                       		moveq	#8,d1				; Width
00007DF4 7400                       		moveq	#0,d2
00007DF6 1428 002D                  		move.b	oColH(a0),d2			; Height
00007DFA 3602                       		move.w	d2,d3				; ''
00007DFC 5243                       		addq.w	#1,d3				; ''
00007DFE 3828 0014                  		move.w	oXPos(a0),d4			; X position
00007E02 4EB8 41EA                  		jsr	SolidObject_Always		; Make us solid
00007E06                            
00007E06 0806 0000                  		btst	#cTouchSideBit,d6		; Has Sonic touched the side of the spring?
00007E0A 6700                       		beq.s	.Display			; If not, branch
00007E0C 08E9 0001 0028             		bset	#1,oStatus(a1)			; Set in air
00007E12 1228 0028                  		move.b	oStatus(a0),d1			; Get status
00007E16 3028 0014                  		move.w	oXPos(a0),d0			; Get distance between us and Sonic
00007E1A 9069 0014                  		sub.w	oXPos(a1),d0			; ''
00007E1E 6500                       		bcs.s	.ChkXStat			; If Sonic is towards the right of the spring, branch
00007E20 0A01 0001                  		eori.b	#1,d1				; Go the other way
00007E24                            
00007E24                            .ChkXStat:
00007E24 0201 0001                  		andi.b	#1,d1				; Has Sonic touched the front of spring?
00007E28 6600                       		bne.s	.Display			; If not, branch
00007E2A 6100                       		bsr.s	.Bounce
00007E2C                            
00007E2C                            .Display:
00007E2C 4EB8 2024                  		jsr	CheckObjActive.w		; Delete if inactive
00007E30                            	nextObject
00007E30 3068 0004                M 	movea.w	onext(a0),a0
00007E34 2250                     M 	move.l	oaddr(a0),a1
00007E36 4ED1                     M 	jmp	(a1)
00007E38                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00007E38                            .Bounce:
00007E38 0C29 000C 0025             		cmpi.b	#$C,oRoutine(a1)			; Is Sonic dead?
00007E3E 6500                       		blo.s	.DoBounce			; If not, branch
00007E40 4E75                       		rts
00007E42                            
00007E42                            .DoBounce:
00007E42 137C 0004 0025             		move.b	#4,oRoutine(a1)			; Make Sonic not hurt if he is
00007E48 337C F800 001C             		move.w	#-$800,oXVel(a1)		; Bounce left
00007E4E 337C F800 001E             		move.w	#-$800,oYVel(a1)		; Bounce up
00007E54 08E9 0000 0028             		bset	#0,oStatus(a1)			; Face left
00007E5A 0828 0000 0028             		btst	#0,oStatus(a0)			; Are we facing left?
00007E60 6600                       		bne.s	.MoveLock			; If so, branch
00007E62 08A9 0000 0028             		bclr	#0,oStatus(a1)			; Face right
00007E68 4469 001C                  		neg.w	oXVel(a1)			; Go right
00007E6C                            
00007E6C                            .MoveLock:
00007E6C 137C 000F 003F             		move.b	#$F,oMoveLock(a1)		; Set move lock timer
00007E72 0829 0002 0028             		btst	#2,oStatus(a1)			; Was Sonic jumping?
00007E78 6600                       		bne.s	.ChkNoYVel			; If so, branch
00007E7A 4229 0020                  		clr.b	oAni(a1)			; Reset animation
00007E7E                            
00007E7E                            .ChkNoYVel:
00007E7E 1028 0024                  		move.b	oSubtype(a0),d0			; Get subtype
00007E82 6A00                       		bpl.s	.ChkFlip			; If Sonic should still bounce up, branch
00007E84 4229 001E                  		clr.b	oYVel(a1)			; Stop Y velocity
00007E88                            
00007E88                            .ChkFlip:
00007E88 0800 0000                  		btst	#0,d0				; Should Sonic tumble?
00007E8C 6700                       		beq.s	.PlaySnd			; If not, branch
00007E8E 337C 0001 003A             		move.w	#1,oFlipDir(a1)			; Set flip direction
00007E94 137C 0001 0047             		move.b	#1,oFlipAngle(a1)		; Set flip angle
00007E9A 4229 0020                  		clr.b	oAni(a1)			; Reset animation
00007E9E 137C 0001 0049             		move.b	#1,oFlipRemain(a1)		; Set flips remaining
00007EA4 137C 0008 004A             		move.b	#8,oFlipSpeed(a1)		; Set flip speed
00007EAA 0800 0001                  		btst	#1,d0				; Should Sonic do 3 flips?
00007EAE 6600                       		bne.s	.ChkDir				; If not, branch
00007EB0 137C 0003 0049             		move.b	#3,oFlipRemain(a1)		; Do 3 flips isntead
00007EB6                            
00007EB6                            .ChkDir:
00007EB6 0829 0000 0028             		btst	#0,oStatus(a1)			; Was Sonic facing left?
00007EBC 6700                       		beq.s	.PlaySnd			; If not, branch
00007EBE 4429 0047                  		neg.b	oFlipAngle(a1)			; Flip the other way
00007EC2 4469 003A                  		neg.w	oFlipDir(a1)			; ''
00007EC6                            
00007EC6                            .PlaySnd:
00007EC6 08A8 0005 0028             		bclr	#cPushBit,oStatus(a0)		; Stop pushing
00007ECC 08A9 0005 0028             		bclr	#cPushBit,oStatus(a1)		; ''
00007ED2                            		playSnd	#sSpring, 2			; Play spring sound
00007ED2 11FC 008E C4BD           M 	move.b	#sspring,(mqueue+((2)-1)).w
00007ED8 4E75                       		rts
00007EDA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00007EDA                            ; Data
00007EDA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00007EDA                            Map_ObjWallSpring:
00007EDA                            		include	"Objects/Wall Spring/Mappings.asm"
00007EDA                            ; --------------------------------------------------------------------------------
00007EDA                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
00007EDA                            ; --------------------------------------------------------------------------------
00007EDA                            
00007EDA                            SME_ReVf5:	
00007EDA 0000 0000                  		dc.w SME_ReVf5_4-SME_ReVf5, SME_ReVf5_12-SME_ReVf5	
00007EDE 0002                       SME_ReVf5_4:	dc.b 0, 2	
00007EE0 C005 0034 FFF8             		dc.b $C0, 5, 0, $34, $FF, $F8	
00007EE6 3005 0034 FFF8             		dc.b $30, 5, 0, $34, $FF, $F8	
00007EEC 0002                       SME_ReVf5_12:	dc.b 0, 2	
00007EEE 8005 0034 FFF8             		dc.b $80, 5, 0, $34, $FF, $F8	
00007EF4 7005 0034 FFF8             		dc.b $70, 5, 0, $34, $FF, $F8	
00007EFA                            		even
00007EFA                            		even
00007EFA                            ; =========================================================================================================================================================
00007EFA                            		include	"Objects/Ball Mode/Code.asm"	; Ball mode switch object
00007EFA                            ; =========================================================================================================================================================
00007EFA                            ; Ball mode enable/disable object
00007EFA                            ; =========================================================================================================================================================
00007EFA                            		rsset	oLvlSSTs
00007EFA =00000030                  oBModeTouch	rs.b	1				; Touched flag
00007EFA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00007EFA                            ObjBallMode:
00007EFA                            	;	move.l	#ObjBallMode_Main,oAddr(a0)	; Next routine
00007EFA                            	;	move.l	#Map_ObjMonitor,oMap(a0)	; Mappings
00007EFA                            	;	clr.w	oVRAM(a0)			; Tile properties
00007EFA                            	;	ori.b	#4,oRender(a0)			; Render flags
00007EFA                            	;	move.w	#rSprInput+$280,oPrio(a0)	; Priority
00007EFA                            	;	move.b	#$10,oDrawW(a0)			; Sprite width
00007EFA                            	;	move.b	#$10,oDrawH(a0)			; Sprite height
00007EFA                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00007EFA                            ObjBallMode_Main:
00007EFA 43FA 0000                  		lea	.RangeData(pc),a1		; Range data
00007EFE 3478 F86C                  		movea.w	rPlayer1Addr.w,a2		; Player object
00007F02 4EB8 1D86                  		jsr	CheckObjInRange.w		; Is the player in range?
00007F06 4A40                       		tst.w	d0				; ''
00007F08 6700                       		beq.s	.NotTouched			; If not, branch
00007F0A                            
00007F0A 08AA 0002 000C             		bclr	#2,oFlags(a2)
00007F10                            		
00007F10 4A28 0024                  		tst.b	oSubtype(a0)			; Should we force Sonic out of ball mode?
00007F14 6B00                       		bmi.s	.NoBallMode			; If so, branch
00007F16 6600                       		bne.s	.BallMode			; Branch if we should force Sonic in to ball mode
00007F18                            
00007F18 4A28 0030                  		tst.b	oBModeTouch(a0)			; Have we already been touched?
00007F1C 6600                       		bne.s	.End				; If so, branch
00007F1E 50E8 0030                  		st	oBModeTouch(a0)			; Touched
00007F22                            
00007F22 462A 004B                  		not.b	oBallMode(a2)			; Switch ball mode for Sonic
00007F26 6700                       		beq.s	.End				; If it's not set, branch
00007F28                            
00007F28                            .MakeSonicRoll:
00007F28 2248                       		movea.l	a0,a1				; Save a0
00007F2A 204A                       		movea.l	a2,a0				; Make Sonic roll
00007F2C 4EB8 550E                  		jsr	ObjPlayer_DoRoll			; ''
00007F30 2049                       		movea.l	a1,a0				; Restore a0
00007F32                            	nextObject
00007F32 3068 0004                M 	movea.w	onext(a0),a0
00007F36 2250                     M 	move.l	oaddr(a0),a1
00007F38 4ED1                     M 	jmp	(a1)
00007F3A                            
00007F3A                            .NotTouched:
00007F3A 4228 0030                  		clr.b	oBModeTouch(a0)			; Not touched
00007F3E                            	nextObject
00007F3E 3068 0004                M 	movea.w	onext(a0),a0
00007F42 2250                     M 	move.l	oaddr(a0),a1
00007F44 4ED1                     M 	jmp	(a1)
00007F46                            
00007F46                            .BallMode:
00007F46 50EA 004B                  		st	oBallMode(a2)			; Get in to ball mode
00007F4A 60DC                       		bra.s	.MakeSonicRoll			; ''
00007F4C                            
00007F4C                            .NoBallMode:
00007F4C 422A 004B                  		clr.b	oBallMode(a2)			; Get out of ball mode
00007F50                            
00007F50                            .End:
00007F50                            	nextObject
00007F50 3068 0004                M 	movea.w	onext(a0),a0
00007F54 2250                     M 	move.l	oaddr(a0),a1
00007F56 4ED1                     M 	jmp	(a1)
00007F58                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00007F58                            .RangeData:
00007F58 FFF0 0020                  		dc.w	-$10, $20
00007F5C FFF0 0020                  		dc.w	-$10, $20
00007F60                            ; =========================================================================================================================================================
00007F60                            		include	"Objects/Bumper/Code.asm"		; Bumper object
00007F60                            ; =========================================================================================================================================================
00007F60                            ; Water surface object
00007F60                            ; =========================================================================================================================================================
00007F60                            		rsset	oLvlSSTs
00007F60                            
00007F60                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00007F60                            ObjBumper:
00007F60 20BC 0000 0000             		move.l	#ObjBumperMain,oAddr(a0)	; Next routine
00007F66 217C 0000 0000 0010        		move.l	#Map_ObjBumper,oMap(a0)		; Mappings
00007F6E 317C 035B 000E             		move.w	#$35B,oVRAM(a0)			; Tile properties
00007F74 117C 0004 000D             		move.b	#4,oRender(a0)			; Render flags
00007F7A                            	displaySprite	1,a0,a1,0			; Priority
00007F7A 317C BE62 0008           M 	move.w	#rdispinput+(1*dsize),odrawnext(a0)
00007F80 3278 BE6C                M 	move.w	rdispinput+dprev+(1*dsize).w,a1
00007F84 3149 000A                M 	move.w	a1,odrawprev(a0)
00007F88 3348 0008                M 	move.w	a0,odrawnext(a1)
00007F8C 31C8 BE6C                M 	move.w	a0,rdispinput+dprev+(1*dsize).w
00007F90                          M .no_280
00007F90 7210                       		moveq	#$10,d1
00007F92 1141 0017                  		move.b	d1,oDrawW(a0)
00007F96 1141 002C                  		move.b	d1,oColW(a0)
00007F9A 1141 001B                  		move.b	d1,oDrawH(a0)
00007F9E 1141 002D                  		move.b	d1,oColH(a0)
00007FA2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00007FA2                            ObjBumperMain:
00007FA2 4A38 F8D1                  		tst.b	rDebugMode.w
00007FA6 6600 0000                  		bne.w	.Display
00007FAA                            
00007FAA 43FA 0000                  		lea	.RangeData(pc),a1		; Range data
00007FAE 3478 F86C                  		movea.w	rPlayer1Addr.w,a2		; Player object
00007FB2 0C2A 000C 0025             		cmpi.b	#$C,oRoutine(a2)
00007FB8 6400 0000                  		bcc.w	.Display
00007FBC 4EB8 1D86                  		jsr	CheckObjInRange.w		; Is the player in range?
00007FC0 4A40                       		tst.w	d0				; ''
00007FC2 6700                       		beq.s	.Display			; If not, branch
00007FC4                            
00007FC4 3228 0014                  		move.w	oXPos(a0),d1
00007FC8 3428 0018                  		move.w	oYPos(a0),d2
00007FCC 926A 0014                  		sub.w	oXPos(a2),d1
00007FD0 946A 0018                  		sub.w	oYPos(a2),d2
00007FD4 4EB8 1786                  		jsr	CalcArcTan.w
00007FD8 1238 C759                  		move.b	(rFrameCnt+3).w,d1
00007FDC 0241 0003                  		andi.w	#3,d1
00007FE0 D041                       		add.w	d1,d0
00007FE2 4EB8 1374                  		jsr	CalcSine.w
00007FE6 C3FC F900                  		muls.w	#-$700,d1
00007FEA E081                       		asr.l	#8,d1
00007FEC 3541 001C                  		move.w	d1,oXVel(a2)
00007FF0 C1FC F900                  		muls.w	#-$700,d0
00007FF4 E080                       		asr.l	#8,d0
00007FF6 3540 001E                  		move.w	d0,oYVel(a2)
00007FFA 0C2A 0008 0025             		cmpi.b	#8,oRoutine(a2)
00008000 6600                       		bne.s	.NotHurt
00008002 157C 0002 0020             		move.b	#2,oAni(a2)
00008008 5A6A 0018                  		addq.w	#5,oYPos(a2)
0000800C 157C 000E 002D             		move.b	#$E,oColH(a2)
00008012 157C 0007 002C             		move.b	#7,oColW(a2)
00008018 08EA 0002 0028             		bset	#2,oStatus(a2)
0000801E                            
0000801E                            .NotHurt:
0000801E 157C 0004 0025             		move.b	#4,oRoutine(a2)
00008024 08EA 0001 0028             		bset	#1,oStatus(a2)
0000802A 08AA 0005 0028             		bclr	#5,oStatus(a2)
00008030 422A 0040                  		clr.b	oJumping(a2)
00008034 117C 0001 0020             		move.b	#1,oAni(a0)
0000803A                            		playSnd	#sBumper, 2
0000803A 11FC 0091 C4BD           M 	move.b	#sbumper,(mqueue+((2)-1)).w
00008040                            
00008040                            .Display:
00008040 43FA 0000                  		lea	Ani_ObjBumper(pc),a1
00008044 4EB8 1C66                  		jsr	AnimateObject.w
00008048 4EB8 2024                  		jsr	CheckObjActive.w		; Display
0000804C 4EB8 47BA                  		jsr	AddToColResponse		; Allow collision
00008050                            	nextObject
00008050 3068 0004                M 	movea.w	onext(a0),a0
00008054 2250                     M 	move.l	oaddr(a0),a1
00008056 4ED1                     M 	jmp	(a1)
00008058                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00008058                            .RangeData:
00008058 FFE8 0030                  		dc.w	-$18, $30
0000805C FFE8 0030                  		dc.w	-$18, $30
00008060                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00008060                            ; Data
00008060                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00008060                            Map_ObjBumper:
00008060                            		include	"Objects/Bumper/Mappings.asm"
00008060                            ; --------------------------------------------------------------------------------
00008060                            ; Sprite mappings - output from SonMapEd - Sonic 3 & Knuckles format
00008060                            ; --------------------------------------------------------------------------------
00008060                            
00008060                            SME_3VuTU:	
00008060 0000 0000                  		dc.w SME_3VuTU_6-SME_3VuTU, SME_3VuTU_E-SME_3VuTU	
00008064 0000                       		dc.w SME_3VuTU_16-SME_3VuTU	
00008066 0001                       SME_3VuTU_6:	dc.b 0, 1	
00008068 F00F 0000 FFF0             		dc.b $F0, $F, 0, 0, $FF, $F0	
0000806E 0001                       SME_3VuTU_E:	dc.b 0, 1	
00008070 F40A 0029 FFF4             		dc.b $F4, $A, 0, $29, $FF, $F4	
00008076 0004                       SME_3VuTU_16:	dc.b 0, 4	
00008078 EC0F 0010 FFEC             		dc.b $EC, $F, 0, $10, $FF, $EC	
0000807E EC03 0020 000C             		dc.b $EC, 3, 0, $20, 0, $C	
00008084 0C0C 0024 FFEC             		dc.b $C, $C, 0, $24, $FF, $EC	
0000808A 0C00 0028 000C             		dc.b $C, 0, 0, $28, 0, $C	
00008090                            		even
00008090                            		even
00008090                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00008090                            Ani_ObjBumper:
00008090 0000                       		dc.w	.Ani0-Ani_ObjBumper
00008092 0000                       		dc.w	.Ani1-Ani_ObjBumper
00008094 0500 FF00                  .Ani0:		dc.b	5, 0, $FF, 0
00008098 0501 0201 02FD 00          .Ani1:		dc.b	5, 1, 2, 1, 2, $FD, 0
000080A0 00                         		even
000080A0                            ; =========================================================================================================================================================
000080A0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000080A0                            ; Unused/Temporary
000080A0                            ;		include	"Objects/Slicer/Code.asm"		; Slicer object
000080A0                            ;		include	"Objects/Shellcracker/Code.asm"	; Shellcracker object
000080A0                            ;		include	"Objects/Asteron/Code.asm"	; Asteron object
000080A0                            ;		include	"Objects/Boss - WFZ/Code.asm"	; WFZ boss object
000080A0                            ;		include	"Objects/Harpoon/Code.asm"	; Harpoon object
000080A0                            ;		include	"Objects/CNZ Barrel/Code.asm"	; CNZ barrel object
000080A0                            ;		include	"Objects/Diamond/Code.asm"	; Diamond object
000080A0                            ;		include	"Objects/Orbinaut/Code.asm"	; Orbinaut object
000080A0                            
000080A0                            ; =========================================================================================================================================================
000080A0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000080A0                            ; Object Art
000080A0                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000080A0                            ArtUnc_Sonic:
000080A0                            		incbin	"Graphics/Sprites/Sonic/Art.unc"
00013B60                            		even
00013B60                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00013B60                            ArtKosM_Bumper:
00013B60                            		incbin	"Graphics/Sprites/Bumper/Art.kosm"
00013E2E 00                         		even
00013E2E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00013E2E                            ArtKosM_Chkpoint:
00013E2E                            		incbin	"Graphics/Sprites/Checkpoint/Art.kosm"
00013F2E 00                         		even
00013F2E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00013F2E                            ArtKosM_DrownCnt:
00013F2E                            		incbin	"Graphics/Sprites/Drown Countdown/Art.kosm"
00014500 00                         		even
00014500                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00014500                            ArtKosM_Explosion:
00014500                            		incbin	"Graphics/Sprites/Explosion/Art.kosm"
00014992                            		even
00014992                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00014992                            ArtKosM_Monitor:
00014992                            		incbin	"Graphics/Sprites/Monitor/Art.kosm"
00014CB4 00                         		even
00014CB4                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00014CB4                            ArtUnc_Ring:
00014CB4                            		incbin	"Graphics/Sprites/Ring/Art - Ring.unc"
000150B4                            		even
000150B4                            
000150B4                            ArtKosM_RingSparkle:
000150B4                            		incbin	"Graphics/Sprites/Ring/Art - Sparkle.kosm"
00015100 00                         		even
00015100                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00015100                            ArtKosM_SpikesN:
00015100                            		incbin	"Graphics/Sprites/Spikes/Art - Normal.kosm"
00015140                            		even
00015140                            
00015140                            ArtKosM_SpikesS:
00015140                            		incbin	"Graphics/Sprites/Spikes/Art - Sideways.kosm"
00015182 00                         		even
00015182                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00015182                            ArtKosM_SpringH:
00015182                            		incbin	"Graphics/Sprites/Spring/Art - Horizontal.kosm"
0001525E 00                         		even
0001525E                            
0001525E                            ArtKosM_SpringV:
0001525E                            		incbin	"Graphics/Sprites/Spring/Art - Vertical.kosm"
00015344 00                         		even
00015344                            
00015344                            ArtKosM_SpringD:
00015344                            		incbin	"Graphics/Sprites/Spring/Art - Diagonal.kosm"
0001555E 00                         		even
0001555E                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001555E                            ArtKosM_WaterSplash:
0001555E                            		incbin	"Graphics/Sprites/Water Splash/Art.kosm"
00015D72                            		even
00015D72                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00015D72                            ArtKosM_WaterSurface:
00015D72                            		incbin	"Graphics/Sprites/Water Surface/Art.kosm"
00015ECC                            		even
00015ECC                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00015ECC                            ArtKosM_HUD:
00015ECC                            		incbin	"Graphics/Sprites/HUD/Art - HUD Base.kosm"
00015F42                            		even
00015F42                            
00015F42                            ArtUnc_HUDNumbers:
00015F42                            		incbin	"Graphics/Sprites/HUD/Art - HUD Numbers.unc"
000161C2 0000 0000 0000 0000 0000+  		dcb.l	16, 0
00016202                            		even
00016202                            
00016202                            ; =========================================================================================================================================================
00016202                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00016202                            ; Level data
00016202                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
00016202                            ; Wacky Workbench Zone
00016202                            
00016202                            WWZ_Layout:
00016202                            		incbin	"Zones/Wacky Workbench/Layout.bin"
000163E0                            		even
000163E0                            WWZ_Objects:
000163E0                            		incbin	"Zones/Wacky Workbench/Objects.bin"
0001659C                            		even
0001659C                            WWZ_Rings:
0001659C                            		incbin	"Zones/Wacky Workbench/Rings.bin"
0001686C                            		even
0001686C                            WWZ_Collision:
0001686C 0000 0000 0000 0000 0000+  		dc.l	.ColData, .Angles, .Heights, .HeightsR
0001687C                            .ColData:
0001687C                            		incbin	"Zones/Wacky Workbench/Collision.bin"
00016E7C                            		even
00016E7C                            .Angles:
00016E7C                            		incbin	"Zones/Wacky Workbench/Angle Values.bin"
00016F7C                            		even
00016F7C                            .Heights:
00016F7C                            		incbin	"Zones/Wacky Workbench/Height Values.bin"
00017F7C                            		even
00017F7C                            .HeightsR:
00017F7C                            		incbin	"Zones/Wacky Workbench/Height Values (Rotated).bin"
00018F7C                            		even
00018F7C                            WWZ_Chunks:
00018F7C                            		incbin	"Zones/Wacky Workbench/Chunks.bin"
000199CC                            		even
000199CC                            WWZ_Blocks:
000199CC                            		incbin	"Zones/Wacky Workbench/Blocks.bin"
0001A092                            		even
0001A092                            WWZ_Pal:
0001A092 007F                       		dc.w	$100>>1-1
0001A094                            		incbin	"Graphics/Palettes/Wacky Workbench/Normal.pal"
0001A114                            		incbin	"Graphics/Palettes/Wacky Workbench/Water.pal"
0001A194                            		even
0001A194                            WWZ_Tiles:
0001A194                            		incbin	"Graphics/Tilesets/Wacky Workbench/Tiles.kosm"
0001B8C2                            		even
0001B8C2                            ;		dc.w	$FFFF, 0, 0
0001B8C2                            ArtUnc_Electricity:
0001B8C2                            		incbin	"Graphics/Tilesets/Wacky Workbench/Electricity.unc"
0001BCC2                            		even
0001BCC2                            ArtUnc_ElectricOrbs:
0001BCC2                            		incbin	"Graphics/Tilesets/Wacky Workbench/Electric Orbs.unc"
0001BEC2                            		even
0001BEC2                            ArtUnc_Sirens:
0001BEC2                            		incbin	"Graphics/Tilesets/Wacky Workbench/Sirens.unc"
0001C0C2                            		even
0001C0C2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001C0C2                            
0001C0C2                            ; =========================================================================================================================================================
0001C0C2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001C0C2                            ; Sound driver
0001C0C2                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
0001C0C2                            		include	"Sound/amps/code/68k.asm"
0001C0C2                            	opt oz+					; enable zero-offset optimization
0001C0C2                            	opt l.					; local lables are dots
0001C0C2                            	opt ae+					; enable automatic even's
0001C0C2                            
0001C0C2                            	include "Sound/amps/code/routines.asm"	; include macro'd routines
0001C0C2                            ; ===========================================================================
0001C0C2                            ; ---------------------------------------------------------------------------
0001C0C2                            ; Note timout handler macro
0001C0C2                            ; ---------------------------------------------------------------------------
0001C0C2                            
0001C0C2                            dNoteToutHandler	macro
0001C0C2                            		tst.b	cNoteTimeCur(a5)	; check if timer is 0
0001C0C2                            		beq.s	.endt			; if is, do not timeout
0001C0C2                            		subq.b	#1,cNoteTimeCur(a5)	; decrease delay by 1
0001C0C2                            		bne.s	.endt			; if still not 0, branch
0001C0C2                                endm
0001C0C2                            ; ===========================================================================
0001C0C2                            ; ---------------------------------------------------------------------------
0001C0C2                            ; Note timout handler macro for DAC
0001C0C2                            ; ---------------------------------------------------------------------------
0001C0C2                            
0001C0C2                            dNoteToutDAC	macro
0001C0C2                            	dNoteToutHandler			; include timeout handler
0001C0C2                            		moveq	#0,d0			; play stop sample
0001C0C2                            		bra.w	dNoteOnDAC2		; ''
0001C0C2                            .endt
0001C0C2                                endm
0001C0C2                            ; ===========================================================================
0001C0C2                            ; ---------------------------------------------------------------------------
0001C0C2                            ; Note timout handler macro for FM
0001C0C2                            ; ---------------------------------------------------------------------------
0001C0C2                            
0001C0C2                            dNoteToutFM	macro
0001C0C2                            	dNoteToutHandler			; include timeout handler
0001C0C2                            		bset	#cfbRest,(a5)		; set track to resting
0001C0C2                            		bsr.w	dKeyOffFM		; key off FM
0001C0C2                            		bra.\0	.next			; jump to next track
0001C0C2                            .endt
0001C0C2                                endm
0001C0C2                            ; ===========================================================================
0001C0C2                            ; ---------------------------------------------------------------------------
0001C0C2                            ; Note timout handler macro for PSG
0001C0C2                            ; ---------------------------------------------------------------------------
0001C0C2                            
0001C0C2                            dNoteToutPSG	macro
0001C0C2                            	dNoteToutHandler			; include timeout handler
0001C0C2                            		bset	#cfbRest,(a5)		; set track to resting
0001C0C2                            		bsr.w	dMutePSGmus		; mute PSG channel
0001C0C2                            		bra.s	.next			; jump to next track
0001C0C2                            .endt
0001C0C2                                endm
0001C0C2                            ; ===========================================================================
0001C0C2                            ; ---------------------------------------------------------------------------
0001C0C2                            ; Macro for calculating the current frequency (without modulation) into d6.
0001C0C2                            ; Used if user wants to add extra pitch effects such as pitch slides.
0001C0C2                            ; ---------------------------------------------------------------------------
0001C0C2                            
0001C0C2                            dCalcFreq	macro
0001C0C2                            		move.b	cDetune(a5),d6		; get detune value to d6
0001C0C2                            		ext.w	d6			; extend to word
0001C0C2                            		add.w	cFreq(a5),d6		; add channel base frequency to it
0001C0C2                                endm
0001C0C2                            ; ===========================================================================
0001C0C2                            ; ---------------------------------------------------------------------------
0001C0C2                            ; Macro for generating frequency modulation code
0001C0C2                            ; ---------------------------------------------------------------------------
0001C0C2                            
0001C0C2                            dModulate	macro jump,loop,type
0001C0C2                            		btst	#cfbMod,(a5)		; check if modulation is active
0001C0C2                            		beq.s	.noret			; if not, update volume and return
0001C0C2                            		tst.b	cModDelay(a5)		; check if there is delay left
0001C0C2                            		beq.s	.started		; if not, modulate!
0001C0C2                            		subq.b	#1,cModDelay(a5)	; decrease delay
0001C0C2                            .noret
0001C0C2                            	if narg>0
0001C0C2                            		if narg=3
0001C0C2                            			if type<2
0001C0C2                            				bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0001C0C2                            				beq.s	.noupdatevol		; if not, skip
0001C0C2                            				jsr	dUpdateVolFM(pc)	; update FM volume
0001C0C2                            			.noupdatevol:
0001C0C2                            			endif
0001C0C2                            			if type>=4
0001C0C2                            				bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0001C0C2                            				beq.s	.noupdatevol		; if not, skip
0001C0C2                            				jsr	dUpdateVolDAC(pc)	; update DAC volume
0001C0C2                            			.noupdatevol:
0001C0C2                            			endif
0001C0C2                            			if \type<>5
0001C0C2                            				dbf	d7,\loop		; loop for all channels
0001C0C2                            			endif
0001C0C2                            		endif
0001C0C2                            		bra.w	\jump			; jump to next routine
0001C0C2                            	else
0001C0C2                            		bra.s	.endm			; jump to the next .endm routine
0001C0C2                            	endif
0001C0C2                            .started
0001C0C2                            		subq.b	#1,cModSpeed(a5)	; decrease modulation speed counter
0001C0C2                            		bne.s	.noret			; if there's still delay left, update vol and return
0001C0C2                            		movea.l	cMod(a5),a1		; get modulation data offset to a1
0001C0C2                            		move.b	1(a1),cModSpeed(a5)	; reset modulation speed counter
0001C0C2                            		tst.b	cModCount(a5)		; check if this was the last step
0001C0C2                            		bne.s	.norev			; if was not, do not reverse
0001C0C2                            		move.b	3(a1),cModCount(a5)	; reset steps counter
0001C0C2                            		neg.b	cModStep(a5)		; negate step amount
0001C0C2                            .norev
0001C0C2                            		subq.b	#1,cModCount(a5)	; decrease step counter
0001C0C2                            		move.b	cModStep(a5),d5		; get step offset into d5
0001C0C2                            		ext.w	d5			; extend to word
0001C0C2                            		add.w	cModFreq(a5),d5		; add modulation frequency to it
0001C0C2                            		move.w	d5,cModFreq(a5)		; save as the modulation frequency
0001C0C2                            		add.w	d5,d6			; add to channel base frequency
0001C0C2                                endm
0001C0C2                            ; ===========================================================================
0001C0C2                            ; ---------------------------------------------------------------------------
0001C0C2                            ; Macro for processing the tracker
0001C0C2                            ; ---------------------------------------------------------------------------
0001C0C2                            
0001C0C2                            dDoTracker	macro
0001C0C2                            		movea.l	cData(a5),a4		; grab tracker address
0001C0C2                            	if safe=1
0001C0C2                            		AMPS_Debug_TrackUpd		; check if this address is valid
0001C0C2                            	endif
0001C0C2                            .data
0001C0C2                            		moveq	#0,d5
0001C0C2                            		move.b	(a4)+,d5		; get a byte from tracker
0001C0C2                            		cmpi.b	#$E0,d5			; is this a command?
0001C0C2                            		blo.s	.notcomm		; if not, continue
0001C0C2                            		jsr	dCommands(pc)		; run the condition flag
0001C0C2                            		bra.s	.data			; for most commands, use this branch to loop
0001C0C2                            		bra.s	.next			; however, for example sStop will make us return here.
0001C0C2                            .notcomm
0001C0C2                                endm
0001C0C2                            ; ===========================================================================
0001C0C2                            ; ---------------------------------------------------------------------------
0001C0C2                            ; Macro for playing a note, and setting up for it (software updates only)
0001C0C2                            ; ---------------------------------------------------------------------------
0001C0C2                            
0001C0C2                            dProcNote	macro sfx, psg
0001C0C2                            		move.l	a4,cData(a5)		; save tracker address
0001C0C2                            		move.b	cLastDur(a5),cDuration(a5); copy stored duration
0001C0C2                            		btst	#cfbHold,(a5)		; check if we are holding
0001C0C2                            		bne.s	.endpn			; if we are, branch
0001C0C2                            	if sfx=0
0001C0C2                            		move.b	cNoteTimeMain(a5),cNoteTimeCur(a5); copy note timeout value
0001C0C2                            	endif
0001C0C2                            	if psg<>0
0001C0C2                            		clr.b	cEnvPos(a5)		; clear envelope position if PSG channel
0001C0C2                            	endif
0001C0C2                            		btst	#cfbMod,(a5)		; check if modulation is enabled
0001C0C2                            		beq.s	.endpn			; if not, branch
0001C0C2                            		movea.l	cMod(a5),a1		; get modulation data address
0001C0C2                            		move.b	(a1)+,cModDelay(a5)	; copy delay
0001C0C2                            		move.b	(a1)+,cModSpeed(a5)	; copy speed
0001C0C2                            		move.b	(a1)+,cModStep(a5)	; copy step offset
0001C0C2                            		move.b	(a1),d0			; get number of steps
0001C0C2                            		lsr.b	#1,d0			; halve it
0001C0C2                            		move.b	d0,cModCount(a5)	; save as the current number of steps
0001C0C2                            		clr.w	cModFreq(a5)		; clear frequency offset
0001C0C2                            .endpn
0001C0C2                                endm
0001C0C2                            ; ===========================================================================
0001C0C2                            ; ---------------------------------------------------------------------------
0001C0C2                            ; Macro for processing a note in DAC channel
0001C0C2                            ; ---------------------------------------------------------------------------
0001C0C2                            
0001C0C2                            dTrackNoteDAC	macro
0001C0C2                            		btst	#cfbMode,(a5)		; check if we are on pitch mode
0001C0C2                            		bne.s	.pitch			; if so, load pitch
0001C0C2                            		move.b	d5,cSample(a5)		; else, save as a sample
0001C0C2                            		bra.s	.cont
0001C0C2                            .pitch
0001C0C2                            		subi.b	#$80,d5			; sub $80 from the note (notes start at $80)
0001C0C2                            		bne.s	.noprest		; branch if note wasnt $80 (rest)
0001C0C2                            		moveq	#0,d0			; play stop sample
0001C0C2                            		bsr.w	dNoteOnDAC2		; ''
0001C0C2                            		moveq	#-$80,d6		; tell the code we are resting
0001C0C2                            		bra.s	.cont
0001C0C2                            .noprest
0001C0C2                            		add.b	cPitch(a5),d5		; add pitch offset to note
0001C0C2                            		add.w	d5,d5			; double offset (each entry is a word)
0001C0C2                            		lea	dFreqDAC(pc),a1		; load DAC frequency table to a1
0001C0C2                            		move.w	(a1,d5.w),cFreq(a5)	; load and save the requested frequency
0001C0C2                            .cont
0001C0C2                                endm
0001C0C2                            ; ===========================================================================
0001C0C2                            ; ---------------------------------------------------------------------------
0001C0C2                            ; Macro for doing keying-on FM channel
0001C0C2                            ; ---------------------------------------------------------------------------
0001C0C2                            
0001C0C2                            dKeyOnFM	macro
0001C0C2                            		btst	#cfbHold,(a5)		; check if note is held
0001C0C2                            		bne.s	.k			; if so, do not note on
0001C0C2                            		btst	#cfbRest,(a5)		; check if channel is resting
0001C0C2                            		bne.s	.k			; if so, do not note on
0001C0C2                            	if narg=0
0001C0C2                            		btst	#cfbInt,(a5)		; check if overridden by sfx
0001C0C2                            		bne.s	.k			; if so, do not note on
0001C0C2                            	endif
0001C0C2                            		moveq	#$28,d0			; YM command: Key on
0001C0C2                            		move.b	cType(a5),d1		; get channel type bits
0001C0C2                            		ori.b	#$F0,d1			; turn all FM operators on
0001C0C2                            		bsr.w	WriteYM_Pt1		; send note-on event
0001C0C2                            .k
0001C0C2                                endm
0001C0C2                            ; ===========================================================================
0001C0C2                            ; ---------------------------------------------------------------------------
0001C0C2                            ; Macro for processing a note in PSG channel
0001C0C2                            ; ---------------------------------------------------------------------------
0001C0C2                            
0001C0C2                            dGetFreqPSG	macro
0001C0C2                            		subi.b	#$81,d5			; sub $81 from the note (notes start at $80)
0001C0C2                            		bhs.s	.norest			; branch if note wasnt $80 (rest)
0001C0C2                            		bset	#cfbRest,(a5)		; set channel to resting
0001C0C2                            		move.w	#-1,cFreq(a5)		; set invalid PSG frequency
0001C0C2                            		jsr	dMutePSGmus(pc)		; mute this PSG channel
0001C0C2                            		bra.s	.freqgot
0001C0C2                            .norest
0001C0C2                            		add.b	cPitch(a5),d5		; add pitch offset to note
0001C0C2                            		andi.w	#$7F,d5			; keep within $80 notes
0001C0C2                            		add.w	d5,d5			; double offset (each entry is a word)
0001C0C2                            		move.w	(a6,d5.w),cFreq(a5)	; load and save the requested frequency
0001C0C2                            	if safe=1
0001C0C2                            		AMPS_Debug_NotePSG		; check if the note was valid
0001C0C2                            	endif
0001C0C2                            .freqgot
0001C0C2                                endm
0001C0C2                            ; ===========================================================================
0001C0C2                            	include "Sound/amps/code/debug.asm"	; debug data blob
0001C0C2                            ; ===========================================================================
0001C0C2                            ; ---------------------------------------------------------------------------
0001C0C2                            ; Routine for loading the Dual PCM driver into Z80 RAM
0001C0C2                            ; ---------------------------------------------------------------------------
0001C0C2                            
0001C0C2                            LoadDualPCM:
0001C0C2 33FC 0100 00A1 1100        		move.w	#$0100,$A11100		; request Z80 stop
0001C0CA 33FC 0100 00A1 1200        		move.w	#$0100,$A11200		; Z80 reset off
0001C0D2                            
0001C0D2 41F9 0000 0000             		lea	DualPCM,a0		; load Dual PCM address into a0
0001C0D8 43F9 00A0 0000             		lea	dZ80,a1			; load Z80 RAM address into a1
0001C0DE 323C 0000                  		move.w	#DualPCM_sz-1,d1	; get lenght counter for dbf into d1
0001C0E2                            
0001C0E2                            .z80
0001C0E2 0839 0000 00A1 1100        		btst	#$00,$A11100		; check if Z80 has stopped
0001C0EA 66F6                       		bne.s	.z80			; if not, wait more
0001C0EC                            
0001C0EC                            .load
0001C0EC 12D8                       		move.b	(a0)+,(a1)+		; copy the Dual PCM driver into Z80 RAM
0001C0EE 51C9 FFFC                  		dbf	d1,.load		; write every single byte
0001C0F2                            
0001C0F2 41FA 0000                  		lea	SampleList(pc),a0	; load address for the stop sample data into a0
0001C0F6 43F9 0000 0000             		lea	dZ80+MuteSample,a1	; load address in Dual PCM to write into a1
0001C0FC                            
0001C0FC                            	rept 6
0001C0FC                            		move.b	(a0)+,(a1)+		; copy all required data
0001C0FC                            	endr
0001C0FC 12D8                     M 	move.b	(a0)+,(a1)+
0001C0FE 12D8                     M 	move.b	(a0)+,(a1)+
0001C100 12D8                     M 	move.b	(a0)+,(a1)+
0001C102 12D8                     M 	move.b	(a0)+,(a1)+
0001C104 12D8                     M 	move.b	(a0)+,(a1)+
0001C106 12D8                     M 	move.b	(a0)+,(a1)+
0001C108                            
0001C108 7002                       		moveq	#2,d0			; set flush timer for 60hz systems
0001C10A 0838 0006 C744             		btst	#6,rHWVersion.w	; is this a PAL Mega Drive?
0001C110 6700                       		beq.s	.ntsc			; if not, branch
0001C112 7003                       		moveq	#3,d0			; set flush timer for 50hz systems
0001C114                            .ntsc
0001C114 13C0 0000 0000             		move.b	d0,dZ80+YM_FlushTimer+2	; save flush timer
0001C11A                            
0001C11A 33FC 0000 00A1 1200        		move.w	#$0000,$A11200		; request Z80 reset
0001C122 727F                       		moveq	#$7F,d1			; wait for a little bit
0001C124 51C9 FFFE                  		dbf	d1,*			; we can't check for reset, so we need to delay
0001C128                            
0001C128 33FC 0000 00A1 1100        		move.w	#$0000,$A11100		; enable Z80
0001C130 33FC 0100 00A1 1200        		move.w	#$0100,$A11200		; Z80 reset off
0001C138 4E75                       		rts
0001C13A                            ; ---------------------------------------------------------------------------
0001C13A                            ; Play DAC
0001C13A                            ; ---------------------------------------------------------------------------
0001C13A                            
0001C13A                            PlayDAC2:
0001C13A 43F9 0000 0000             		lea	dZ80+PCM2_Sample,a1	; load addresses for PCM 1
0001C140                            	StopZ80					; wait for Z80 to stop
0001C140 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001C148                          M 	waitz80stop
0001C148 0839 0000 00A1 1100      M .wait_284:	btst	#0,z80_bus_req
0001C150 66F6                     M 	bne.s	.wait_284
0001C152                            	rept 12
0001C152                            		move.b	(a3)+,(a1)+		; send sample data to Dual PCM
0001C152                            	endr
0001C152 12DB                     M 	move.b	(a3)+,(a1)+
0001C154 12DB                     M 	move.b	(a3)+,(a1)+
0001C156 12DB                     M 	move.b	(a3)+,(a1)+
0001C158 12DB                     M 	move.b	(a3)+,(a1)+
0001C15A 12DB                     M 	move.b	(a3)+,(a1)+
0001C15C 12DB                     M 	move.b	(a3)+,(a1)+
0001C15E 12DB                     M 	move.b	(a3)+,(a1)+
0001C160 12DB                     M 	move.b	(a3)+,(a1)+
0001C162 12DB                     M 	move.b	(a3)+,(a1)+
0001C164 12DB                     M 	move.b	(a3)+,(a1)+
0001C166 12DB                     M 	move.b	(a3)+,(a1)+
0001C168 12DB                     M 	move.b	(a3)+,(a1)+
0001C16A 101B                       		move.b	(a3)+,d0
0001C16C 5200                       		addq.b	#1,d0
0001C16E 13C0 0000 0000             		move.b	d0,dZ80+PCM2_PitchHigh+1
0001C174 13DB 0000 0000             		move.b	(a3)+,dZ80+PCM2_PitchLow+1
0001C17A 13FC 00D2 0000 0000        		move.b	#$D2,dZ80+PCM2_ChangePitch; change "JP C" to "JP NC"
0001C182                            
0001C182 13FC 00DA 0000 0000        		move.b	#$DA,dZ80+PCM2_NewRET	; activate sample switch (change instruction)
0001C18A                            	StartZ80				; enable Z80 execution
0001C18A 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001C192 4E75                       		rts
0001C194                            
0001C194                            ; ---------------------------------------------------------------------------
0001C194                            
0001C194                            PlayDAC1:
0001C194 43F9 0000 0000             		lea	dZ80+PCM1_Sample,a1	; load addresses for PCM 1
0001C19A                            	StopZ80					; wait for Z80 to stop
0001C19A 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001C1A2                          M 	waitz80stop
0001C1A2 0839 0000 00A1 1100      M .wait_287:	btst	#0,z80_bus_req
0001C1AA 66F6                     M 	bne.s	.wait_287
0001C1AC                            	rept 12
0001C1AC                            		move.b	(a3)+,(a1)+		; send sample data to Dual PCM
0001C1AC                            	endr
0001C1AC 12DB                     M 	move.b	(a3)+,(a1)+
0001C1AE 12DB                     M 	move.b	(a3)+,(a1)+
0001C1B0 12DB                     M 	move.b	(a3)+,(a1)+
0001C1B2 12DB                     M 	move.b	(a3)+,(a1)+
0001C1B4 12DB                     M 	move.b	(a3)+,(a1)+
0001C1B6 12DB                     M 	move.b	(a3)+,(a1)+
0001C1B8 12DB                     M 	move.b	(a3)+,(a1)+
0001C1BA 12DB                     M 	move.b	(a3)+,(a1)+
0001C1BC 12DB                     M 	move.b	(a3)+,(a1)+
0001C1BE 12DB                     M 	move.b	(a3)+,(a1)+
0001C1C0 12DB                     M 	move.b	(a3)+,(a1)+
0001C1C2 12DB                     M 	move.b	(a3)+,(a1)+
0001C1C4 101B                       		move.b	(a3)+,d0
0001C1C6 5200                       		addq.b	#1,d0
0001C1C8 13C0 0000 0000             		move.b	d0,dZ80+PCM1_PitchHigh+1
0001C1CE 13DB 0000 0000             		move.b	(a3)+,dZ80+PCM1_PitchLow+1
0001C1D4 13FC 00D2 0000 0000        		move.b	#$D2,dZ80+PCM1_ChangePitch; change "JP C" to "JP NC"
0001C1DC                            
0001C1DC 13FC 00DA 0000 0000        		move.b	#$DA,dZ80+PCM1_NewRET	; activate sample switch (change instruction)
0001C1E4                            	StartZ80				; enable Z80 execution
0001C1E4 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001C1EC 4E75                       		rts
0001C1EE                            ; ===========================================================================
0001C1EE                            ; ---------------------------------------------------------------------------
0001C1EE                            ; Handle Dual PCM YM Cue correctly
0001C1EE                            ; ---------------------------------------------------------------------------
0001C1EE                            
0001C1EE                            UpdateAMPS:
0001C1EE                            	StopZ80					; wait for Z80 to stop
0001C1EE 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001C1F6                          M 	waitz80stop
0001C1F6 0839 0000 00A1 1100      M .wait_290:	btst	#0,z80_bus_req
0001C1FE 66F6                     M 	bne.s	.wait_290
0001C200 1039 0000 0000             		move.b	dZ80+YM_Buffer,d0	; load current cue buffer in use
0001C206                            	StartZ80				; enable Z80 execution
0001C206 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001C20E                            
0001C20E 207C 0000 0000             		move.l	#dZ80+YM_Buffer1,a0	; set the cue address to buffer 1
0001C214 4A00                       		tst.b	d0			; check buffer to use
0001C216 6600                       		bne.s	.gotbuffer		; if Z80 is reading buffer 2, branch
0001C218 D0FC 0000                  		add.w	#YM_Buffer2-YM_Buffer1,a0; set the cue address to buffer 2
0001C21C                            
0001C21C                            .gotbuffer
0001C21C 6100                       		bsr.s	dUpdateAllAMPS		; process the driver
0001C21E                            
0001C21E                            	StopZ80					; wait for Z80 to stop
0001C21E 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001C226                          M 	waitz80stop
0001C226 0839 0000 00A1 1100      M .wait_293:	btst	#0,z80_bus_req
0001C22E 66F6                     M 	bne.s	.wait_293
0001C230 50D0                       		st	(a0)			; make sure cue is marked as completed
0001C232                            	StartZ80				; enable Z80 execution
0001C232 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001C23A                            
0001C23A                            dPaused:
0001C23A 4E75                       		rts
0001C23C                            ; ===========================================================================
0001C23C                            ; ---------------------------------------------------------------------------
0001C23C                            ; Main routine for updating the AMPS driver
0001C23C                            ; ---------------------------------------------------------------------------
0001C23C                            
0001C23C                            dUpdateAllAMPS:
0001C23C 4EBA 0000                  		jsr	dPlaySnd(pc)		; check if any music needs playing
0001C240 4A38 C4A6                  		tst.b	mFlags.w		; is music paused?
0001C244 6BF4                       		bmi.s	dPaused			; if yes, branch
0001C246                            ; ---------------------------------------------------------------------------
0001C246                            ; This is the new fading feature I created, to make custom fading
0001C246                            ; types easier to program. You can define series of 3 bytes, each
0001C246                            ; representing FM, PSG and DAC volumes. Each group of 3 is executed
0001C246                            ; once per frame. If the first value in a frame is a command flag,
0001C246                            ; instead its code is executed. Additionally, no fade program may
0001C246                            ; appear before ROM offset $10000, or else it will never be executed.
0001C246                            ; ---------------------------------------------------------------------------
0001C246                            
0001C246 4A38 C4B5                  .notempo	tst.b	mFadeAddr+1.w		; check if a fade program is already executing
0001C24A 6700                       		beq.s	.chkregion		; branch if not
0001C24C                            
0001C24C 2278 C4B4                  		move.l	mFadeAddr.w,a1		; get the fade porogram address to a1
0001C250 56B8 C4B4                  		addq.l	#3,mFadeAddr.w		; set the fade address to next group
0001C254                            
0001C254 7220                       		moveq	#(1<<cfbVol),d1		; prepare volume update to d1
0001C256 7000                       		moveq	#0,d0
0001C258 1019                       		move.b	(a1)+,d0		; get FM/command byte from fade data
0001C25A 6A00                       		bpl.s	.nofadeend		; branch if this is not a command
0001C25C                            
0001C25C 45FA 0000                  		lea	dFadeCommands-$80(pc),a2; load fade commands pointer table to a2
0001C260 4EB2 0000                  		jsr	(a2,d0.w)		; run the fade command code
0001C264 4238 C4B5                  		clr.b	mFadeAddr+1.w		; mark the fade program as completed
0001C268 6000                       		bra.s	.chkregion		; go check the region
0001C26A                            
0001C26A                            .nofadeend
0001C26A B038 C4B4                  		cmp.b	mMasterVolFM.w,d0	; check if volume did not change
0001C26E 6700                       		beq.s	.fadedac		; if did not, branch
0001C270 11C0 C4B4                  		move.b	d0,mMasterVolFM.w	; save the new volume
0001C274 4EBA 0000                  		jsr	dReqVolUpFM(pc)		; go request volume update for FM
0001C278                            
0001C278                            .fadedac
0001C278 1019                       		move.b	(a1)+,d0		; get DAC volume byte from fade data
0001C27A B038 C4C0                  		cmp.b	mMasterVolDAC.w,d0	; check if volume did not change
0001C27E 6700                       		beq.s	.fadepsg		; if did not, branch
0001C280 11C0 C4C0                  		move.b	d0,mMasterVolDAC.w	; save new volume
0001C284                            
0001C284 =FFFFC4C4                  .ch =	mDAC1					; start at DAC1
0001C284                            	rept Mus_DAC				; do for all music DAC channels
0001C284                            		or.b	d1,.ch.w		; tell the channel to update its volume
0001C284                            .ch =		.ch+cSize			; go to next channel
0001C284                            	endr
0001C284 8338 C4C4                M 	or.b	d1,.ch.w
0001C288 =FFFFC4F0                M .ch	=	.ch+csize
0001C288 8338 C4F0                M 	or.b	d1,.ch.w
0001C28C =FFFFC51C                M .ch	=	.ch+csize
0001C28C 8338 C67C                  		or.b	d1,mSFXDAC1.w		; tell SFX DAC1 to update its volume
0001C290                            
0001C290                            .fadepsg
0001C290 1019                       		move.b	(a1)+,d0		; get PSG volume byte from fade data
0001C292 B038 C4BF                  		cmp.b	mMasterVolPSG.w,d0	; check if volume did not change
0001C296 6700                       		beq.s	.chkregion		; if did not, branch
0001C298 11C0 C4BF                  		move.b	d0,mMasterVolPSG.w	; save new volume
0001C29C                            
0001C29C =FFFFC5F8                  .ch =	mPSG1					; start at PSG1
0001C29C                            	rept Mus_PSG				; do for all music PSG channels
0001C29C                            		or.b	d1,.ch.w		; tell the channel to update its volume
0001C29C                            .ch =		.ch+cSize			; go to next channel
0001C29C                            	endr
0001C29C 8338 C5F8                M 	or.b	d1,.ch.w
0001C2A0 =FFFFC624                M .ch	=	.ch+csize
0001C2A0 8338 C624                M 	or.b	d1,.ch.w
0001C2A4 =FFFFC650                M .ch	=	.ch+csize
0001C2A4 8338 C650                M 	or.b	d1,.ch.w
0001C2A8 =FFFFC67C                M .ch	=	.ch+csize
0001C2A8                            
0001C2A8 =FFFFC6EC                  .ch =	mSFXPSG1				; start at SFX PSG1
0001C2A8                            	rept SFX_PSG				; do for all SFX PSG channels
0001C2A8                            		or.b	d1,.ch.w		; tell the channel to update its volume
0001C2A8                            .ch =		.ch+cSizeSFX			; go to next channel
0001C2A8                            	endr
0001C2A8 8338 C6EC                M 	or.b	d1,.ch.w
0001C2AC =FFFFC708                M .ch	=	.ch+csizesfx
0001C2AC 8338 C708                M 	or.b	d1,.ch.w
0001C2B0 =FFFFC724                M .ch	=	.ch+csizesfx
0001C2B0 8338 C724                M 	or.b	d1,.ch.w
0001C2B4 =FFFFC740                M .ch	=	.ch+csizesfx
0001C2B4                            ; ---------------------------------------------------------------------------
0001C2B4                            ; Since PAL Mega Drive's run slower than NTSC, if we want the music to
0001C2B4                            ; sound consistent, we need to run the sound driver 1.2 times as fast
0001C2B4                            ; on PAL systems. This will cause issues with some songs that rely on
0001C2B4                            ; game engine to seem "in sync". Because of that, I added a flag to
0001C2B4                            ; disable the PAL fix (much like in Sonic 2's driver). Unlike the fix
0001C2B4                            ; in SMPS drivers (and Sonic 3 and above), this fix will make the music
0001C2B4                            ; play at the exact right speed, instead of slightly too slow.
0001C2B4                            ; ---------------------------------------------------------------------------
0001C2B4                            
0001C2B4 0838 0006 C744             .chkregion	btst	#6,rHWVersion.w	; is this PAL system?
0001C2BA 6700                       		beq.s	.driver			; if not, branch
0001C2BC 5338 C4A7                  		subq.b	#1,mCtrPal.w		; decrease PAL frame counter
0001C2C0 6E00                       		bgt.s	.driver			; if hasn't become 0 (or lower!), branch
0001C2C2                            
0001C2C2 0838 0003 C4A6             		btst	#mfbNoPAL,mFlags.w	; check if we have disabled the PAL fix
0001C2C8 6600                       		bne.s	.nofix			; if yes, run music and SFX
0001C2CA 6100                       		bsr.s	.nosfx			; run the sound driver
0001C2CC                            
0001C2CC                            .nofix
0001C2CC 11FC 0005 C4A7             		move.b	#6-1,mCtrPal.w		; reset counter
0001C2D2                            .driver
0001C2D2 6100 0000                  		bsr.w	dAMPSdoSFX		; run SFX this time
0001C2D6                            
0001C2D6                            .nosfx		; continue to run sound driver again
0001C2D6                            ; ---------------------------------------------------------------------------
0001C2D6                            ; There are 2 methods of handling tempo adjustments in SMPS,
0001C2D6                            ; overflow (where a value is added to the accumulator, and when it
0001C2D6                            ; range overflows, tick of delay is added), and counter (where a
0001C2D6                            ; counter is copied to the tempo, which is then decreased each frame,
0001C2D6                            ; until it becomes 0, after which a tick of delay is added). AMPS
0001C2D6                            ; supports these both too, because there is no single right answer,
0001C2D6                            ; and users may prefer one over the other. The overflow method is
0001C2D6                            ; really good for low values, as it provides very fine control over
0001C2D6                            ; the tempo, but at high ranges it gets worse. Meanwhile the counter
0001C2D6                            ; method isn't as good for small values, but for large value it works
0001C2D6                            ; better. You may choose this setting in the macro.asm file,
0001C2D6                            ; ---------------------------------------------------------------------------
0001C2D6                            
0001C2D6 1038 C4BA                  		move.b	mTempo.w,d0		; get tempo to d0
0001C2DA D138 C4BB                  		add.b	d0,mTempoCur.w		; add to accumulator
0001C2DE 6400                       		bcc.s	dAMPSdoAll		; if carry clear, branch
0001C2E0                            
0001C2E0                            
0001C2E0 =FFFFC4D0                  .ch =	mDAC1+cDuration				; start at DAC1 duration
0001C2E0                            	rept Mus_Ch				; loop through all music channels
0001C2E0                            		addq.b	#1,.ch.w		; add 1 to duration
0001C2E0                            .ch =		.ch+cSize			; go to next channel
0001C2E0                            	endr
0001C2E0 5238 C4D0                M 	addq.b	#1,.ch.w
0001C2E4 =FFFFC4FC                M .ch	=	.ch+csize
0001C2E4 5238 C4FC                M 	addq.b	#1,.ch.w
0001C2E8 =FFFFC528                M .ch	=	.ch+csize
0001C2E8 5238 C528                M 	addq.b	#1,.ch.w
0001C2EC =FFFFC554                M .ch	=	.ch+csize
0001C2EC 5238 C554                M 	addq.b	#1,.ch.w
0001C2F0 =FFFFC580                M .ch	=	.ch+csize
0001C2F0 5238 C580                M 	addq.b	#1,.ch.w
0001C2F4 =FFFFC5AC                M .ch	=	.ch+csize
0001C2F4 5238 C5AC                M 	addq.b	#1,.ch.w
0001C2F8 =FFFFC5D8                M .ch	=	.ch+csize
0001C2F8 5238 C5D8                M 	addq.b	#1,.ch.w
0001C2FC =FFFFC604                M .ch	=	.ch+csize
0001C2FC 5238 C604                M 	addq.b	#1,.ch.w
0001C300 =FFFFC630                M .ch	=	.ch+csize
0001C300 5238 C630                M 	addq.b	#1,.ch.w
0001C304 =FFFFC65C                M .ch	=	.ch+csize
0001C304 5238 C65C                M 	addq.b	#1,.ch.w
0001C308 =FFFFC688                M .ch	=	.ch+csize
0001C308                            ; ===========================================================================
0001C308                            ; ---------------------------------------------------------------------------
0001C308                            ; Process music DAC channels
0001C308                            ; ---------------------------------------------------------------------------
0001C308                            
0001C308                            dAMPSdoAll:
0001C308 4DFA 0000                  		lea	SampleList(pc),a6	; get SampleList to a6 for quick access
0001C30C 4BF8 C498                  		lea	mDAC1-cSize.w,a5	; get DAC1 channel RAM address into a5
0001C310 7E01                       		moveq	#Mus_DAC-1,d7		; get total number of DAC channels to d7
0001C312                            
0001C312                            dAMPSdoDAC:
0001C312 DAFC 002C                  		add.w	#cSize,a5		; go to the next channel (first time its mDAC1!)
0001C316 4A15                       		tst.b	(a5)			; check if channel is running a tracker
0001C318 6A00 0000                  		bpl.w	.next			; if not, branch
0001C31C 532D 000C                  		subq.b	#1,cDuration(a5)	; decrease note duration
0001C320 6700 0000                  		beq.w	.update			; if timed out, update channel
0001C324                            	dNoteToutDAC	 			; handle DAC-specific note timeout behavior
0001C324                          M 	dnotetouthandler
0001C324 4A2D 001C                M 	tst.b	cnotetimecur(a5)
0001C328 6700                     M 	beq.s	.endt
0001C32A 532D 001C                M 	subq.b	#1,cnotetimecur(a5)
0001C32E 6600                     M 	bne.s	.endt
0001C330 7000                     M 	moveq	#0,d0
0001C332 6000 0000                M 	bra.w	dnoteondac2
0001C336                          M .endt
0001C336                            
0001C336                            	dCalcFreq				; calculate channel base frequency
0001C336 1C2D 0007                M 	move.b	cdetune(a5),d6
0001C33A 4886                     M 	ext.w	d6
0001C33C DC6D 000E                M 	add.w	cfreq(a5),d6
0001C340                            	dModulate dAMPSdoFM, dAMPSdoDAC, 4	; run modulation code
0001C340 0815 0003                M 	btst	#cfbmod,(a5)
0001C344 6700                     M 	beq.s	.noret
0001C346 4A2D 0010                M 	tst.b	cmoddelay(a5)
0001C34A 6700                     M 	beq.s	.started
0001C34C 532D 0010                M 	subq.b	#1,cmoddelay(a5)
0001C350                          M .noret
0001C350 0895 0005                M 	bclr	#cfbvol,(a5)
0001C354 6700                     M 	beq.s	.noupdatevol
0001C356 4EBA 0000                M 	jsr	dupdatevoldac(pc)
0001C35A                          M 	.noupdatevol:
0001C35A 51CF FFB6                M 	dbf	d7,dampsdodac
0001C35E 6000 0000                M 	bra.w	dampsdofm
0001C362                          M .started
0001C362 532D 0016                M 	subq.b	#1,cmodspeed(a5)
0001C366 66E8                     M 	bne.s	.noret
0001C368 226D 0010                M 	movea.l	cmod(a5),a1
0001C36C 1B69 0001 0016           M 	move.b	1(a1),cmodspeed(a5)
0001C372 4A2D 0018                M 	tst.b	cmodcount(a5)
0001C376 6600                     M 	bne.s	.norev
0001C378 1B69 0003 0018           M 	move.b	3(a1),cmodcount(a5)
0001C37E 442D 0017                M 	neg.b	cmodstep(a5)
0001C382                          M .norev
0001C382 532D 0018                M 	subq.b	#1,cmodcount(a5)
0001C386 1A2D 0017                M 	move.b	cmodstep(a5),d5
0001C38A 4885                     M 	ext.w	d5
0001C38C DA6D 0014                M 	add.w	cmodfreq(a5),d5
0001C390 3B45 0014                M 	move.w	d5,cmodfreq(a5)
0001C394 DC45                     M 	add.w	d5,d6
0001C396 6100 0000                  		bsr.w	dUpdateFreqDAC		; if frequency needs changing, do it
0001C39A                            
0001C39A 0895 0005                  		bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0001C39E 6700                       		beq.s	.next			; if not, skip
0001C3A0 6100 0000                  		bsr.w	dUpdateVolDAC		; update DAC volume
0001C3A4                            
0001C3A4                            .next
0001C3A4 51CF FF6C                  		dbf	d7,dAMPSdoDAC		; make sure to run all the channels
0001C3A8 4EFA 0000                  		jmp	dAMPSdoFM(pc)		; after that, process music FM channels
0001C3AC                            
0001C3AC                            .update
0001C3AC 0215 00FB                  		and.b	#$FF-(1<<cfbHold),(a5)	; clear hold flag
0001C3B0                            	dDoTracker				; process tracker
0001C3B0 286D 0002                M 	movea.l	cdata(a5),a4
0001C3B4                          M .data
0001C3B4 7A00                     M 	moveq	#0,d5
0001C3B6 1A1C                     M 	move.b	(a4)+,d5
0001C3B8 0C05 00E0                M 	cmpi.b	#$e0,d5
0001C3BC 6500                     M 	blo.s	.notcomm
0001C3BE 4EBA 0000                M 	jsr	dcommands(pc)
0001C3C2 60F0                     M 	bra.s	.data
0001C3C4 60DE                     M 	bra.s	.next
0001C3C6                          M .notcomm
0001C3C6 7C00                       		moveq	#0,d6			; clear rest flag
0001C3C8 4A05                       		tst.b	d5			; check if note is being played
0001C3CA 6A00                       		bpl.s	.timer			; if not, it must be a timer. Branch
0001C3CC                            
0001C3CC                            	dTrackNoteDAC				; calculate frequency or update sample
0001C3CC 0815 0000                M 	btst	#cfbmode,(a5)
0001C3D0 6600                     M 	bne.s	.pitch
0001C3D2 1B45 000B                M 	move.b	d5,csample(a5)
0001C3D6 6000                     M 	bra.s	.cont
0001C3D8                          M .pitch
0001C3D8 0405 0080                M 	subi.b	#$80,d5
0001C3DC 6600                     M 	bne.s	.noprest
0001C3DE 7000                     M 	moveq	#0,d0
0001C3E0 6100 0000                M 	bsr.w	dnoteondac2
0001C3E4 7C80                     M 	moveq	#-$80,d6
0001C3E6 6000                     M 	bra.s	.cont
0001C3E8                          M .noprest
0001C3E8 DA2D 0008                M 	add.b	cpitch(a5),d5
0001C3EC DA45                     M 	add.w	d5,d5
0001C3EE 43FA 0000                M 	lea	dfreqdac(pc),a1
0001C3F2 3B71 5000 000E           M 	move.w	(a1,d5.w),cfreq(a5)
0001C3F8                          M .cont
0001C3F8 1A1C                       		move.b	(a4)+,d5		; check if next note is a timer
0001C3FA 6A00                       		bpl.s	.timer			; if yes, handle timer
0001C3FC 534C                       		subq.w	#1,a4			; else, undo the increment
0001C3FE 6000                       		bra.s	.pcnote			; do not calculate duration
0001C400                            
0001C400                            .timer
0001C400 4EBA 0000                  		jsr	dCalcDuration(pc)	; calculate duration
0001C404                            .pcnote
0001C404                            	dProcNote 0, 0				; reset necessary channel memory
0001C404 2B4C 0002                M 	move.l	a4,cdata(a5)
0001C408 1B6D 000D 000C           M 	move.b	clastdur(a5),cduration(a5)
0001C40E 0815 0002                M 	btst	#cfbhold,(a5)
0001C412 6600                     M 	bne.s	.endpn
0001C414 1B6D 001D 001C           M 	move.b	cnotetimemain(a5),cnotetimecur(a5)
0001C41A 0815 0003                M 	btst	#cfbmod,(a5)
0001C41E 6700                     M 	beq.s	.endpn
0001C420 226D 0010                M 	movea.l	cmod(a5),a1
0001C424 1B59 0010                M 	move.b	(a1)+,cmoddelay(a5)
0001C428 1B59 0016                M 	move.b	(a1)+,cmodspeed(a5)
0001C42C 1B59 0017                M 	move.b	(a1)+,cmodstep(a5)
0001C430 1011                     M 	move.b	(a1),d0
0001C432 E208                     M 	lsr.b	#1,d0
0001C434 1B40 0018                M 	move.b	d0,cmodcount(a5)
0001C438 426D 0014                M 	clr.w	cmodfreq(a5)
0001C43C                          M .endpn
0001C43C                            
0001C43C 4A06                       		tst.b	d6			; check if channel was resting
0001C43E 6B00                       		bmi.s	.noplay			; if yes, we do not want to note on anymore
0001C440 6100                       		bsr.s	dNoteOnDAC		; do hardware note-on behavior
0001C442                            
0001C442 51CF FECE                  .noplay		dbf	d7,dAMPSdoDAC		; make sure to run all the channels
0001C446 4EFA 0000                  		jmp	dAMPSdoFM(pc)		; after that, process FM channels
0001C44A                            ; ===========================================================================
0001C44A                            ; ---------------------------------------------------------------------------
0001C44A                            ; Write DAC sample information to Dual PCM
0001C44A                            ; ---------------------------------------------------------------------------
0001C44A                            
0001C44A                            dNoteOnDAC2:
0001C44A 0815 0001                  		btst	#cfbInt,(a5)		; is the channel interrupted by SFX?
0001C44E 6700                       		beq.s	dNoteOnDAC3		; if not, process note
0001C450 4E75                       		rts
0001C452                            
0001C452                            dNoteOnDAC:
0001C452 0815 0001                  		btst	#cfbInt,(a5)		; is the channel interrupted by SFX?
0001C456 6600                       		bne.s	locret_dNoteOnDAC4	; if so, do not note on or update frequency
0001C458                            
0001C458 7000                       		moveq	#0,d0			; make sure the upper byte is clear
0001C45A 102D 000B                  		move.b	cSample(a5),d0		; get sample ID to d0
0001C45E 0A00 0080                  		eor.b	#$80,d0			; this allows us to have the full $100 range safely
0001C462 0815 0002                  		btst	#cfbHold,(a5)		; check if note is held
0001C466 6600 0000                  		bne.w	dUpdateFreqOffDAC2	; if so, only update frequency
0001C46A                            
0001C46A                            dNoteOnDAC3:
0001C46A E948                       		lsl.w	#4,d0			; multiply sample ID by $10 (size of each entry)
0001C46C 47F6 0000                  		lea	(a6,d0.w),a3		; get sample data to a3
0001C470                            
0001C470 487A 0000                  		pea	dUpdateFreqOffDAC(pc)	; update frequency after loading sample
0001C474 082D 0002 0001             		btst	#ctbPt2,cType(a5)	; check if this channel is DAC1
0001C47A 6700                       		beq.s	dNoteWriteDAC1		; if is, branch
0001C47C                            ; ---------------------------------------------------------------------------
0001C47C                            ; This code is for updating the note to Dual PCM. We have tracker commands
0001C47C                            ; for also playing notes on DAC channels, which is why the code seems a
0001C47C                            ; little weird.
0001C47C                            ; ---------------------------------------------------------------------------
0001C47C                            
0001C47C                            dNoteWriteDAC2:
0001C47C 43F9 0000 0000             		lea	dZ80+PCM2_Sample,a1	; load addresses for PCM 1
0001C482 45F9 0000 0000             		lea	dZ80+PCM2_NewRET,a2	; ''
0001C488 6000                       		bra.s	dNoteOnDAC4
0001C48A                            
0001C48A                            dNoteWriteDAC1:
0001C48A                            
0001C48A 43F9 0000 0000             		lea	dZ80+PCM1_Sample,a1	; load addresses for PCM 2
0001C490 45F9 0000 0000             		lea	dZ80+PCM1_NewRET,a2	; ''
0001C496                            
0001C496                            dNoteOnDAC4:
0001C496                            	StopZ80					; wait for Z80 to stop
0001C496 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001C49E                          M 	waitz80stop
0001C49E 0839 0000 00A1 1100      M .wait_303:	btst	#0,z80_bus_req
0001C4A6 66F6                     M 	bne.s	.wait_303
0001C4A8                            	rept 12
0001C4A8                            		move.b	(a3)+,(a1)+		; send sample data to Dual PCM
0001C4A8                            	endr
0001C4A8 12DB                     M 	move.b	(a3)+,(a1)+
0001C4AA 12DB                     M 	move.b	(a3)+,(a1)+
0001C4AC 12DB                     M 	move.b	(a3)+,(a1)+
0001C4AE 12DB                     M 	move.b	(a3)+,(a1)+
0001C4B0 12DB                     M 	move.b	(a3)+,(a1)+
0001C4B2 12DB                     M 	move.b	(a3)+,(a1)+
0001C4B4 12DB                     M 	move.b	(a3)+,(a1)+
0001C4B6 12DB                     M 	move.b	(a3)+,(a1)+
0001C4B8 12DB                     M 	move.b	(a3)+,(a1)+
0001C4BA 12DB                     M 	move.b	(a3)+,(a1)+
0001C4BC 12DB                     M 	move.b	(a3)+,(a1)+
0001C4BE 12DB                     M 	move.b	(a3)+,(a1)+
0001C4C0                            
0001C4C0 14BC 00DA                  		move.b	#$DA,(a2)		; activate sample switch (change instruction)
0001C4C4                            	StartZ80				; enable Z80 execution
0001C4C4 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001C4CC                            
0001C4CC                            locret_dNoteOnDAC4:
0001C4CC 4E75                       		rts
0001C4CE                            ; ===========================================================================
0001C4CE                            ; ---------------------------------------------------------------------------
0001C4CE                            ; Write DAC frequency to Dual PCM
0001C4CE                            ; ---------------------------------------------------------------------------
0001C4CE                            
0001C4CE                            dUpdateFreqOffDAC2:
0001C4CE E948                       		lsl.w	#4,d0			; multiply sample ID by $10 (size of each entry)
0001C4D0 47F6 000C                  		lea	$0C(a6,d0.w),a3		; get sample pitch to a3
0001C4D4                            
0001C4D4                            dUpdateFreqOffDAC:
0001C4D4 3C2D 000E                  		move.w	cFreq(a5),d6		; get channel base frequency to d6
0001C4D8 DC5B                       		add.w	(a3)+,d6		; add sample frequency offset to d6
0001C4DA                            
0001C4DA 102D 0007                  		move.b	cDetune(a5),d0		; get detune value
0001C4DE 4880                       		ext.w	d0			; extend to word
0001C4E0 DC40                       		add.w	d0,d6			; add it to d6
0001C4E2                            
0001C4E2 0815 0003                  		btst	#cfbMod,(a5)		; check if channel is modulating
0001C4E6 6700                       		beq.s	dUpdateFreqDAC3		; if not, branch
0001C4E8 DC6D 0014                  		add.w	cModFreq(a5),d6		; add modulation frequency offset to d6
0001C4EC 6000                       		bra.s	dUpdateFreqDAC3
0001C4EE                            
0001C4EE                            dUpdateFreqDAC:
0001C4EE 0815 0001                  		btst	#cfbInt,(a5)		; is the channel interrupted by SFX?
0001C4F2 6600                       		bne.s	locret_UpdFreqDAC	; if so, branch
0001C4F4                            
0001C4F4                            dUpdateFreqDAC2:
0001C4F4 7000                       		moveq	#0,d0			; make sure the upper byte is clear
0001C4F6 102D 000B                  		move.b	cSample(a5),d0		; get sample ID to d0
0001C4FA 0A00 0080                  		eor.b	#$80,d0			; this allows us to have the full $100 range safely
0001C4FE E948                       		lsl.w	#4,d0			; multiply ID by $10 (size of each entry)
0001C500 DC76 000C                  		add.w	$0C(a6,d0.w),d6		; add sample frequency offset to d6
0001C504                            
0001C504                            dUpdateFreqDAC3:
0001C504                            
0001C504 1006                       		move.b	d6,d0			; copy the frequency to d0
0001C506 E04E                       		lsr.w	#8,d6			; get the upper byte to the lower byte
0001C508 082D 0002 0001             		btst	#ctbPt2,cType(a5)	; check if DAC1
0001C50E 6700                       		beq.s	dFreqDAC1		; if is, branch
0001C510                            
0001C510                            	StopZ80					; wait for Z80 to stop
0001C510 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001C518                          M 	waitz80stop
0001C518 0839 0000 00A1 1100      M .wait_306:	btst	#0,z80_bus_req
0001C520 66F6                     M 	bne.s	.wait_306
0001C522 13C6 0000 0000             		move.b	d6,dZ80+PCM2_PitchHigh+1
0001C528 13C0 0000 0000             		move.b	d0,dZ80+PCM2_PitchLow+1
0001C52E 13FC 00D2 0000 0000        		move.b	#$D2,dZ80+PCM2_ChangePitch; change "JP C" to "JP NC"
0001C536                            	StartZ80				; enable Z80 execution
0001C536 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001C53E                            
0001C53E                            locret_UpdFreqDAC;
0001C53E 4E75                       		rts
0001C540                            
0001C540                            dFreqDAC1:
0001C540                            	StopZ80					; wait for Z80 to stop
0001C540 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001C548                          M 	waitz80stop
0001C548 0839 0000 00A1 1100      M .wait_309:	btst	#0,z80_bus_req
0001C550 66F6                     M 	bne.s	.wait_309
0001C552 13C6 0000 0000             		move.b	d6,dZ80+PCM1_PitchHigh+1
0001C558 13C0 0000 0000             		move.b	d0,dZ80+PCM1_PitchLow+1
0001C55E 13FC 00D2 0000 0000        		move.b	#$D2,dZ80+PCM1_ChangePitch; change "JP C" to "JP NC"
0001C566                            	StartZ80				; enable Z80 execution
0001C566 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001C56E 4E75                       		rts
0001C570                            ; ===========================================================================
0001C570                            ; ---------------------------------------------------------------------------
0001C570                            ; Routine to multiply duration by tick rate
0001C570                            ; We actually use a dbf loop instead of mulu, because 2 rounds
0001C570                            ; around the loop will be faster than a single mulu instruction
0001C570                            ; ---------------------------------------------------------------------------
0001C570                            
0001C570                            dCalcDuration:
0001C570 7000                       		moveq	#0,d0			; clear duration
0001C572 7200                       		moveq	#0,d1			; clear upper bytes (for dbf)
0001C574 122D 000A                  		move.b	cTick(a5),d1		; get tick multiplier to d1
0001C578                            
0001C578 D005                       .multiply	add.b	d5,d0			; add duration value to d0
0001C57A 51C9 FFFC                  		dbf	d1,.multiply		; multiply by tick rate
0001C57E                            
0001C57E 1B40 000D                  		move.b	d0,cLastDur(a5)		; save as the new duration
0001C582 4E75                       		rts				; get copied to duration by later code
0001C584                            ; ===========================================================================
0001C584                            ; ---------------------------------------------------------------------------
0001C584                            ; Process SFX DAC channels
0001C584                            ; ---------------------------------------------------------------------------
0001C584                            
0001C584                            dAMPSdoSFX:
0001C584 4BF8 C660                  		lea	mSFXDAC1-cSizeSFX.w,a5	; get SFX DAC1 channel RAM address into a5
0001C588                            
0001C588                            dAMPSdoDACSFX:
0001C588 DAFC 001C                  		add.w	#cSizeSFX,a5		; go to the next channel
0001C58C 4A15                       		tst.b	(a5)			; check if channel is running a tracker
0001C58E 6A00                       		bpl.s	.next			; if not, branch
0001C590                            
0001C590 4DFA 0000                  		lea	SampleList(pc),a6	; get SampleList to a6 for quick access
0001C594 532D 000C                  		subq.b	#1,cDuration(a5)	; decrease note duration
0001C598 6700 0000                  		beq.w	.update			; if timed out, update channel
0001C59C                            
0001C59C                            	dCalcFreq				; calculate channel base frequency
0001C59C 1C2D 0007                M 	move.b	cdetune(a5),d6
0001C5A0 4886                     M 	ext.w	d6
0001C5A2 DC6D 000E                M 	add.w	cfreq(a5),d6
0001C5A6                            	dModulate dAMPSdoFMSFX, dAMPSdoDAC, 5	; run modulation code
0001C5A6 0815 0003                M 	btst	#cfbmod,(a5)
0001C5AA 6700                     M 	beq.s	.noret
0001C5AC 4A2D 0010                M 	tst.b	cmoddelay(a5)
0001C5B0 6700                     M 	beq.s	.started
0001C5B2 532D 0010                M 	subq.b	#1,cmoddelay(a5)
0001C5B6                          M .noret
0001C5B6 0895 0005                M 	bclr	#cfbvol,(a5)
0001C5BA 6700                     M 	beq.s	.noupdatevol
0001C5BC 4EBA 0000                M 	jsr	dupdatevoldac(pc)
0001C5C0                          M 	.noupdatevol:
0001C5C0 6000 0000                M 	bra.w	dampsdofmsfx
0001C5C4                          M .started
0001C5C4 532D 0016                M 	subq.b	#1,cmodspeed(a5)
0001C5C8 66EC                     M 	bne.s	.noret
0001C5CA 226D 0010                M 	movea.l	cmod(a5),a1
0001C5CE 1B69 0001 0016           M 	move.b	1(a1),cmodspeed(a5)
0001C5D4 4A2D 0018                M 	tst.b	cmodcount(a5)
0001C5D8 6600                     M 	bne.s	.norev
0001C5DA 1B69 0003 0018           M 	move.b	3(a1),cmodcount(a5)
0001C5E0 442D 0017                M 	neg.b	cmodstep(a5)
0001C5E4                          M .norev
0001C5E4 532D 0018                M 	subq.b	#1,cmodcount(a5)
0001C5E8 1A2D 0017                M 	move.b	cmodstep(a5),d5
0001C5EC 4885                     M 	ext.w	d5
0001C5EE DA6D 0014                M 	add.w	cmodfreq(a5),d5
0001C5F2 3B45 0014                M 	move.w	d5,cmodfreq(a5)
0001C5F6 DC45                     M 	add.w	d5,d6
0001C5F8 6100 FEFA                  		bsr.w	dUpdateFreqDAC2		; if frequency needs changing, do it
0001C5FC                            
0001C5FC 0895 0005                  		bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0001C600 6700                       		beq.s	.next			; if not, skip
0001C602 6100 0000                  		bsr.w	dUpdateVolDAC2		; update DAC volume
0001C606                            
0001C606                            .next
0001C606 4EFA 0000                  		jmp	dAMPSdoFMSFX(pc)	; after that, process SFX FM channels
0001C60A                            
0001C60A                            .update
0001C60A 0215 00FB                  		and.b	#$FF-(1<<cfbHold),(a5)	; clear hold flag
0001C60E                            	dDoTracker				; process tracker
0001C60E 286D 0002                M 	movea.l	cdata(a5),a4
0001C612                          M .data
0001C612 7A00                     M 	moveq	#0,d5
0001C614 1A1C                     M 	move.b	(a4)+,d5
0001C616 0C05 00E0                M 	cmpi.b	#$e0,d5
0001C61A 6500                     M 	blo.s	.notcomm
0001C61C 4EBA 0000                M 	jsr	dcommands(pc)
0001C620 60F0                     M 	bra.s	.data
0001C622 60E2                     M 	bra.s	.next
0001C624                          M .notcomm
0001C624 7C00                       		moveq	#0,d6			; clear rest flag
0001C626 4A05                       		tst.b	d5			; check if note is being played
0001C628 6A00                       		bpl.s	.timer			; if not, it must be a timer. Branch
0001C62A                            
0001C62A                            	dTrackNoteDAC				; calculate frequency or update sample
0001C62A 0815 0000                M 	btst	#cfbmode,(a5)
0001C62E 6600                     M 	bne.s	.pitch
0001C630 1B45 000B                M 	move.b	d5,csample(a5)
0001C634 6000                     M 	bra.s	.cont
0001C636                          M .pitch
0001C636 0405 0080                M 	subi.b	#$80,d5
0001C63A 6600                     M 	bne.s	.noprest
0001C63C 7000                     M 	moveq	#0,d0
0001C63E 6100 FE0A                M 	bsr.w	dnoteondac2
0001C642 7C80                     M 	moveq	#-$80,d6
0001C644 6000                     M 	bra.s	.cont
0001C646                          M .noprest
0001C646 DA2D 0008                M 	add.b	cpitch(a5),d5
0001C64A DA45                     M 	add.w	d5,d5
0001C64C 43FA 0000                M 	lea	dfreqdac(pc),a1
0001C650 3B71 5000 000E           M 	move.w	(a1,d5.w),cfreq(a5)
0001C656                          M .cont
0001C656 1A1C                       		move.b	(a4)+,d5		; check if next note is a timer
0001C658 6A00                       		bpl.s	.timer			; if yes, handle timer
0001C65A 534C                       		subq.w	#1,a4			; else, undo the increment
0001C65C 6000                       		bra.s	.pcnote			; do not calculate duration
0001C65E                            
0001C65E                            .timer
0001C65E 4EBA FF10                  		jsr	dCalcDuration(pc)	; calculate duration
0001C662                            .pcnote
0001C662                            	dProcNote 1, 0				; reset necessary channel memory
0001C662 2B4C 0002                M 	move.l	a4,cdata(a5)
0001C666 1B6D 000D 000C           M 	move.b	clastdur(a5),cduration(a5)
0001C66C 0815 0002                M 	btst	#cfbhold,(a5)
0001C670 6600                     M 	bne.s	.endpn
0001C672 0815 0003                M 	btst	#cfbmod,(a5)
0001C676 6700                     M 	beq.s	.endpn
0001C678 226D 0010                M 	movea.l	cmod(a5),a1
0001C67C 1B59 0010                M 	move.b	(a1)+,cmoddelay(a5)
0001C680 1B59 0016                M 	move.b	(a1)+,cmodspeed(a5)
0001C684 1B59 0017                M 	move.b	(a1)+,cmodstep(a5)
0001C688 1011                     M 	move.b	(a1),d0
0001C68A E208                     M 	lsr.b	#1,d0
0001C68C 1B40 0018                M 	move.b	d0,cmodcount(a5)
0001C690 426D 0014                M 	clr.w	cmodfreq(a5)
0001C694                          M .endpn
0001C694 4A06                       		tst.b	d6			; check if channel was resting
0001C696 6B00                       		bmi.s	.noplay			; if yes, we do not want to note on anymore
0001C698 6100 FDB8                  		bsr.w	dNoteOnDAC		; do hardware note-on behavior
0001C69C                            
0001C69C                            .noplay
0001C69C 4EFA 0000                  		jmp	dAMPSdoFMSFX(pc)	; after that, process SFX FM channels
0001C6A0                            ; ===========================================================================
0001C6A0                            ; ---------------------------------------------------------------------------
0001C6A0                            ; Write DAC volume to Dual PCM
0001C6A0                            ; ---------------------------------------------------------------------------
0001C6A0                            
0001C6A0                            dUpdateVolDAC:
0001C6A0 0815 0001                  		btst	#cfbInt,(a5)		; is the channel interrupted by SFX?
0001C6A4 6600                       		bne.s	locret_VolDAC		; if yes, do not update
0001C6A6                            
0001C6A6                            dUpdateVolDAC2:
0001C6A6 162D 0009                  		move.b	cVolume(a5),d3		; get channel volume to d3
0001C6AA D638 C4C0                  		add.b	mMasterVolDAC.w,d3	; add master volume to it
0001C6AE 6A00                       		bpl.s	.gotvol			; if positive (in range), branch
0001C6B0 7680                       		moveq	#$FFFFFF80,d3		; force volume to mute ($80 is the last valid volume)
0001C6B2                            
0001C6B2                            .gotvol
0001C6B2                            	StopZ80					; wait for Z80 to stop
0001C6B2 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001C6BA                          M 	waitz80stop
0001C6BA 0839 0000 00A1 1100      M .wait_317:	btst	#0,z80_bus_req
0001C6C2 66F6                     M 	bne.s	.wait_317
0001C6C4 13FC 00D2 0000 0000        		move.b	#$D2,dZ80+PCM_ChangeVolume; set volume change flag
0001C6CC                            
0001C6CC 082D 0002 0001             		btst	#ctbPt2,cType(a5)	; check if this channel is DAC1
0001C6D2 6700                       		beq.s	.dac1			; if is, branch
0001C6D4 13C3 0000 0000             		move.b	d3,dZ80+PCM2_Volume+1	; save volume for PCM 1
0001C6DA                            	StartZ80				; enable Z80 execution
0001C6DA 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001C6E2 4E75                       		rts
0001C6E4                            
0001C6E4                            .dac1
0001C6E4 13C3 0000 0000             		move.b	d3,dZ80+PCM1_Volume+1	; save volume for PCM 2
0001C6EA                            	StartZ80				; enable Z80 execution
0001C6EA 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001C6F2                            
0001C6F2                            locret_VolDAC:
0001C6F2 4E75                       		rts
0001C6F4                            ; ===========================================================================
0001C6F4                            ; ---------------------------------------------------------------------------
0001C6F4                            ; Routine for unpausing the sound driver
0001C6F4                            ; ---------------------------------------------------------------------------
0001C6F4                            
0001C6F4                            dPlaySnd_Unpause:
0001C6F4 08B8 0007 C4A6             		bclr	#mfbPaused,mFlags.w	; unpause music
0001C6FA 67F6                       		beq.s	locret_VolDAC		; if was already unpaused, skip
0001C6FC                            ; ---------------------------------------------------------------------------
0001C6FC                            ; The following code will reset the panning values for each running
0001C6FC                            ; channel. It also makes sure that the channel is not interrupted
0001C6FC                            ; by sound effects, and that each running sound effect channel gets
0001C6FC                            ; updated. We do not handle key on's, since that could potentially
0001C6FC                            ; cause issues if notes are half-done. The next time tracker plays
0001C6FC                            ; notes, they start being audible again.
0001C6FC                            ; ---------------------------------------------------------------------------
0001C6FC                            
0001C6FC 4BF8 C51C                  		lea	mFM1.w,a5		; start from FM1 channel
0001C700 7804                       		moveq	#Mus_FM-1,d4		; load the number of music FM channels to d4
0001C702 762C                       		moveq	#cSize,d3		; get the size of each music channel to d3
0001C704                            
0001C704                            .musloop
0001C704 4A15                       		tst.b	(a5)			; check if the channel is running a tracker
0001C706 6A00                       		bpl.s	.skipmus		; if not, do not update
0001C708 0815 0001                  		btst	#cfbInt,(a5)		; is the channel interrupted by SFX?
0001C70C 6600                       		bne.s	.skipmus		; if is, do not update
0001C70E                            
0001C70E 70B4                       		moveq	#$FFFFFFB4,d0		; YM address: Panning and LFO
0001C710 122D 0006                  		move.b	cPanning(a5),d1		; read panning and LFO value from channel
0001C714 4EBA 0000                  		jsr	WriteChYM(pc)		; write to appropriate YM register
0001C718                            
0001C718                            .skipmus
0001C718 DAC3                       		adda.w	d3,a5			; go to next channel
0001C71A 51CC FFE8                  		dbf	d4,.musloop		; repeat for all music FM channels
0001C71E                            
0001C71E 4BF8 C698                  		lea	mSFXFM3.w,a5		; start from SFX FM1 channel
0001C722 7802                       		moveq	#SFX_FM-1,d4		; load the number of SFX FM channels to d4
0001C724 761C                       		moveq	#cSizeSFX,d3		; get the size of each SFX channel to d3
0001C726                            
0001C726                            .sfxloop
0001C726 4A15                       		tst.b	(a5)			; check if the channel is running a tracker
0001C728 6A00                       		bpl.s	.skipsfx		; if not, do not update
0001C72A                            
0001C72A 70B4                       		moveq	#$FFFFFFB4,d0		; YM address: Panning and LFO
0001C72C 122D 0006                  		move.b	cPanning(a5),d1		; read panning and LFO value from channel
0001C730 4EBA 0000                  		jsr	WriteChYM(pc)		; write to appropriate YM register
0001C734                            
0001C734                            .skipsfx
0001C734 DAC3                       		adda.w  d3,a5			; go to next channel
0001C736 51CC FFEE                  		dbf     d4,.sfxloop		; repeat for all SFX FM channels
0001C73A                            ; ---------------------------------------------------------------------------
0001C73A                            ; Since the DAC channels have or based panning behavior, we need this
0001C73A                            ; piece of code to update its panning
0001C73A                            ; ---------------------------------------------------------------------------
0001C73A                            
0001C73A 1238 C4CA                  		move.b	mDAC1+cPanning.w,d1	; read panning value from music DAC1
0001C73E 0838 0001 C4C4             		btst	#cfbInt,mDAC1+cFlags.w	; check if music DAC1 is interrupted by SFX
0001C744 6700                       		beq.s	.nodacsfx		; if not, use music DAC1 panning
0001C746 1238 C682                  		move.b	mSFXDAC1+cPanning.w,d1	; read panning value from SFX DAC1
0001C74A                            
0001C74A                            .nodacsfx
0001C74A 8238 C4F6                  		or.b	mDAC2+cPanning.w,d1	; or the panning value from music DAC2
0001C74E 70B6                       		moveq	#$FFFFFFB4+2,d0		; YM address: Panning and LFO (FM3/6)
0001C750 4EFA 0000                  		jmp	WriteYM_Pt2(pc)		; write to part 2 channel
0001C754                            ; ===========================================================================
0001C754                            ; ---------------------------------------------------------------------------
0001C754                            ; Routine for pausing the sound driver
0001C754                            ; ---------------------------------------------------------------------------
0001C754                            
0001C754                            dPlaySnd_Pause:
0001C754 08F8 0007 C4A6             		bset	#mfbPaused,mFlags.w	; pause music
0001C75A 6696                       		bne.s	locret_VolDAC		; if was already paused, skip
0001C75C                            ; ---------------------------------------------------------------------------
0001C75C                            ; The following code will set channel panning to none for all FM channels.
0001C75C                            ; This will ensure they are muted while we are pausing.
0001C75C                            ; ---------------------------------------------------------------------------
0001C75C                            
0001C75C 7602                       		moveq	#3-1,d3			; 3 channels per YM2616 "part"
0001C75E 70B4                       		moveq	#$FFFFFFB4,d0		; YM address: Panning and LFO
0001C760 7200                       		moveq	#0,d1			; pan to neither speaker and remove LFO
0001C762                            
0001C762                            .muteFM
0001C762 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to part 1 channel
0001C766 4EBA 0000                  		jsr	WriteYM_Pt2(pc)		; write to part 2 channel
0001C76A 5200                       		addq.b	#1,d0			; go to next FM channel
0001C76C 51CB FFF4                  		dbf	d3,.muteFM		; write each 3 channels per part
0001C770                            ; ---------------------------------------------------------------------------
0001C770                            ; The following code will key off all FM channels. There is a special
0001C770                            ; behavior in that, we must write all channels into part 1, and we
0001C770                            ; control the channel we are writing in the data portion.
0001C770                            ; 4 bits are reserved for which operators are active (in this case,
0001C770                            ; none), and 3 bits are reserved for the channel we want to affect.
0001C770                            ; ---------------------------------------------------------------------------
0001C770                            
0001C770 7028                       		moveq	#$28,d0			; YM address: Key on/off
0001C772 7602                       		moveq	#%00000010,d3		; turn keys off, and start from YM channel 3
0001C774                            
0001C774                            .note
0001C774 1203                       		move.b	d3,d1			; copy value into d1
0001C776 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to part 1 channel
0001C77A 5801                       		addq.b	#4,d1			; set this to part 2 channel
0001C77C 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to part 2 channel
0001C780 51CB FFF2                  		dbf	d3,.note		; loop for all 3 channel groups
0001C784                            
0001C784 4EBA 0000                  		jsr	dMutePSG(pc)		; mute all PSG channels
0001C788                            	; continue to mute all DAC channels
0001C788                            ; ===========================================================================
0001C788                            ; ---------------------------------------------------------------------------
0001C788                            ; Routine for muting all DAC channels
0001C788                            ; ---------------------------------------------------------------------------
0001C788                            
0001C788                            dMuteDAC:
0001C788                            	StopZ80					; wait for Z80 to stop
0001C788 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001C790                          M 	waitz80stop
0001C790 0839 0000 00A1 1100      M .wait_321:	btst	#0,z80_bus_req
0001C798 66F6                     M 	bne.s	.wait_321
0001C79A 45FA 0000                  		lea	SampleList(pc),a2	; load address for the stop sample data into a2
0001C79E 43F9 0000 0000             		lea	dZ80+PCM1_Sample,a1	; load addresses for PCM 1 sample to a1
0001C7A4                            
0001C7A4                            	rept 12
0001C7A4                            		move.b	(a2)+,(a1)+		; send sample data to Dual PCM
0001C7A4                            	endr
0001C7A4 12DA                     M 	move.b	(a2)+,(a1)+
0001C7A6 12DA                     M 	move.b	(a2)+,(a1)+
0001C7A8 12DA                     M 	move.b	(a2)+,(a1)+
0001C7AA 12DA                     M 	move.b	(a2)+,(a1)+
0001C7AC 12DA                     M 	move.b	(a2)+,(a1)+
0001C7AE 12DA                     M 	move.b	(a2)+,(a1)+
0001C7B0 12DA                     M 	move.b	(a2)+,(a1)+
0001C7B2 12DA                     M 	move.b	(a2)+,(a1)+
0001C7B4 12DA                     M 	move.b	(a2)+,(a1)+
0001C7B6 12DA                     M 	move.b	(a2)+,(a1)+
0001C7B8 12DA                     M 	move.b	(a2)+,(a1)+
0001C7BA 12DA                     M 	move.b	(a2)+,(a1)+
0001C7BC                            
0001C7BC 13FC 00CA 0000 0000        		move.b	#$CA,dZ80+PCM1_NewRET	; activate sample switch (change instruction)
0001C7C4                            
0001C7C4 45FA 0000                  		lea	SampleList(pc),a2	; load address for the stop sample data into a2
0001C7C8 43F9 0000 0000             		lea	dZ80+PCM2_Sample,a1	; load addresses for PCM 2 sample to a1
0001C7CE                            
0001C7CE                            	rept 12
0001C7CE                            		move.b	(a2)+,(a1)+		; send sample data to Dual PCM
0001C7CE                            	endr
0001C7CE 12DA                     M 	move.b	(a2)+,(a1)+
0001C7D0 12DA                     M 	move.b	(a2)+,(a1)+
0001C7D2 12DA                     M 	move.b	(a2)+,(a1)+
0001C7D4 12DA                     M 	move.b	(a2)+,(a1)+
0001C7D6 12DA                     M 	move.b	(a2)+,(a1)+
0001C7D8 12DA                     M 	move.b	(a2)+,(a1)+
0001C7DA 12DA                     M 	move.b	(a2)+,(a1)+
0001C7DC 12DA                     M 	move.b	(a2)+,(a1)+
0001C7DE 12DA                     M 	move.b	(a2)+,(a1)+
0001C7E0 12DA                     M 	move.b	(a2)+,(a1)+
0001C7E2 12DA                     M 	move.b	(a2)+,(a1)+
0001C7E4 12DA                     M 	move.b	(a2)+,(a1)+
0001C7E6                            
0001C7E6 13FC 00CA 0000 0000        		move.b	#$CA,dZ80+PCM2_NewRET	; activate sample switch (change instruction)
0001C7EE                            	StartZ80				; enable Z80 execution
0001C7EE 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001C7F6                            
0001C7F6                            locret_MuteDAC:
0001C7F6 4E75                       		rts
0001C7F8                            ; ===========================================================================
0001C7F8                            ; ---------------------------------------------------------------------------
0001C7F8                            ; Subroutine to play any queued music tracks, sound effects or commands
0001C7F8                            ; ---------------------------------------------------------------------------
0001C7F8                            
0001C7F8                            dPlaySnd:
0001C7F8 4DF8 C4BC                  		lea	mQueue.w,a6		; get address to the sound queue
0001C7FC 7E00                       		moveq	#0,d7
0001C7FE 1E1E                       		move.b	(a6)+,d7		; get sound ID for this slot
0001C800 6600                       		bne.s	.found			; if nonzero, a sound is queued
0001C802 1E1E                       		move.b	(a6)+,d7		; get sound ID for this slot
0001C804 6600                       		bne.s	.found			; if nonzero, a sound is queued
0001C806 1E1E                       		move.b	(a6)+,d7		; get sound ID for this slot
0001C808 67EC                       		beq.s	locret_MuteDAC		; if 0, no sounds were queued, return
0001C80A                            
0001C80A                            .found
0001C80A 422E FFFF                  		clr.b	-1(a6)			; clear the slot we are processing
0001C80E 0C07 0082                  		cmpi.b	#SFXoff,d7		; check if this sound was a sound effect
0001C812 6400 0000                  		bhs.w	dPlaySnd_SFX		; if so, handle it
0001C816 0C07 000A                  		cmpi.b	#MusOff,d7		; check if this sound was a command
0001C81A 6500 0000                  		blo.w	dPlaySnd_Comm		; if so, handle it
0001C81E                            	; it was music, handle it below
0001C81E                            ; ===========================================================================
0001C81E                            ; ---------------------------------------------------------------------------
0001C81E                            ; Subroutine to play a queued music track
0001C81E                            ; ---------------------------------------------------------------------------
0001C81E                            
0001C81E                            dPlaySnd_Music:
0001C81E 4EBA 0000                  		jsr	dStopMusic(pc)		; mute hardware and reset all driver memory
0001C822 4EBA 0000                  		jsr	dResetVolume(pc)	; reset volumes and end any fades
0001C826                            ; ---------------------------------------------------------------------------
0001C826                            ; To save few cycles, we don't directly substract the music offset from
0001C826                            ; the ID, and instead offset the table position. In practice this will
0001C826                            ; have the same effect, but saves us 8 cycles overall.
0001C826                            ; ---------------------------------------------------------------------------
0001C826                            
0001C826 49FA 0000                  		lea	MusicIndex-(MusOff*4)(pc),a4; get music pointer table with an offset
0001C82A DE47                       		add.w	d7,d7			; quadruple music ID
0001C82C DE47                       		add.w	d7,d7			; since each entry is 4 bytes in size
0001C82E 11F4 7000 C4B9             		move.b	(a4,d7.w),mTempoSpeed.w	; load speed shoes tempo from the unused 8 bits
0001C834 2874 7000                  		movea.l	(a4,d7.w),a4		; get music header pointer from the table
0001C838                            
0001C838                            
0001C838 264C                       		move.l	a4,a3			; copy pointer to a3
0001C83A 584C                       		addq.w	#4,a4			; go to DAC1 data section
0001C83C                            
0001C83C 7000                       		moveq	#0,d0
0001C83E 102B 0001                  		move.b	1(a3),d0		; load song tempo to d0
0001C842 11C0 C4B8                  		move.b	d0,mTempoMain.w		; save as regular tempo
0001C846 0838 0001 C4A6             		btst	#mfbSpeed,mFlags.w	; check if speed shoes flag was set
0001C84C 6700                       		beq.s	.tempogot		; if not, use main tempo
0001C84E 1038 C4B9                  		move.b	mTempoSpeed.w,d0	; load speed shoes tempo to d0 instead
0001C852                            
0001C852                            .tempogot
0001C852 11C0 C4BA                  		move.b	d0,mTempo.w		; save as the current tempo
0001C856 11C0 C4BB                  		move.b	d0,mTempoCur.w		; copy into the accumulator/counter
0001C85A 0238 00F7 C4A6             		and.b	#$FF-(1<<mfbNoPAL),mFlags.w; enable PAL fix
0001C860                            ; ---------------------------------------------------------------------------
0001C860                            ; If the 7th bit (msb) of tick multiplier is set, PAL fix gets
0001C860                            ; disabled. I know, very weird place to put it, but we dont have
0001C860                            ; much free room in the song header
0001C860                            ; ---------------------------------------------------------------------------
0001C860                            
0001C860 1813                       		move.b	(a3),d4			; load the tick multiplier to d4
0001C862 6A00                       		bpl.s	.noPAL			; branch if the loaded value was positive
0001C864 0244 007F                  		and.w	#$7F,d4			; keep value in range
0001C868 0038 0008 C4A6             		or.b	#1<<mfbNoPAL,mFlags.w	; disable PAL fix
0001C86E                            
0001C86E                            .noPAL
0001C86E 74A0                       		moveq	#$FFFFFF00|(1<<cfbRun)|(1<<cfbVol),d2; prepare running tracker and volume flags into d2
0001C870 72C0                       		moveq	#$FFFFFFC0,d1		; prepare panning value of centre to d1
0001C872 7C2C                       		moveq	#cSize,d6		; prepare channel size to d6
0001C874 7A01                       		moveq	#1,d5			; prepare duration of 0 frames to d5
0001C876                            
0001C876 43F8 C4C4                  		lea	mDAC1.w,a1		; start from DAC1 channel
0001C87A 45FA 0000                  		lea	dDACtypeVals(pc),a2	; prepare DAC (and FM) type value list into a2
0001C87E 7E01                       		moveq	#2-1,d7			; always run for 2 DAC channels
0001C880 363C 0100                  		move.w	#$100,d3		; prepare default DAC frequency
0001C884                            
0001C884                            .loopDAC
0001C884 1282                       		move.b	d2,(a1)			; save channel flags
0001C886 135A 0001                  		move.b	(a2)+,cType(a1)		; load channel type from list
0001C88A 1344 000A                  		move.b	d4,cTick(a1)		; set channel tick multiplier
0001C88E 1346 001E                  		move.b	d6,cStack(a1)		; reset channel stack pointer
0001C892 1341 0006                  		move.b	d1,cPanning(a1)		; reset panning to centre
0001C896 1345 000C                  		move.b	d5,cDuration(a1)	; reset channel duration
0001C89A 3343 000E                  		move.w	d3,cFreq(a1)		; reset channel base frequency
0001C89E                            
0001C89E 7000                       		moveq	#0,d0
0001C8A0 301C                       		move.w	(a4)+,d0		; load tracker offset to d0
0001C8A2 D08B                       		add.l	a3,d0			; add music header offset to d0
0001C8A4 2340 0002                  		move.l	d0,cData(a1)		; save as the tracker address of the channel
0001C8A8                            
0001C8A8 135C 0009                  		move.b	(a4)+,cVolume(a1)	; load channel volume
0001C8AC 135C 000B                  		move.b	(a4)+,cSample(a1)	; load channel sample ID
0001C8B0 6700                       		beq.s	.sampmode		; if 0, we are in sample mode
0001C8B2 08D1 0000                  		bset	#cfbMode,(a1)		; if not 0, enable pitch mode
0001C8B6                            
0001C8B6                            .sampmode
0001C8B6 D2C6                       		add.w	d6,a1			; go to the next channel
0001C8B8 51CF FFCA                  		dbf	d7,.loopDAC		; repeat for all DAC channels
0001C8BC                            
0001C8BC 7E00                       		moveq	#0,d7
0001C8BE 7481                       		moveq	#$FFFFFF00|(1<<cfbRun)|(1<<cfbRest),d2; prepare running tracker and channel rest flags
0001C8C0 1E2B 0002                  		move.b	2(a3),d7		; load the FM channel count to d7
0001C8C4 6B00                       		bmi.s	.doPSG			; if no FM channels are loaded, branch
0001C8C6                            
0001C8C6                            .loopFM
0001C8C6 1282                       		move.b	d2,(a1)			; save channel flags
0001C8C8 135A 0001                  		move.b	(a2)+,cType(a1)		; load channel type from list
0001C8CC 1344 000A                  		move.b	d4,cTick(a1)		; set channel tick multiplier
0001C8D0 1346 001E                  		move.b	d6,cStack(a1)		; reset channel stack pointer
0001C8D4 1341 0006                  		move.b	d1,cPanning(a1)		; reset panning to centre
0001C8D8 1345 000C                  		move.b	d5,cDuration(a1)	; reset channel duration
0001C8DC                            
0001C8DC 7000                       		moveq	#0,d0
0001C8DE 301C                       		move.w	(a4)+,d0		; load tracker offset to d0
0001C8E0 D08B                       		add.l	a3,d0			; add music header offset to d0
0001C8E2 2340 0002                  		move.l	d0,cData(a1)		; save as the tracker address of the channel
0001C8E6                            
0001C8E6 335C 0008                  		move.w	(a4)+,cPitch(a1)	; load pitch offset and channel volume
0001C8EA D2C6                       		adda.w	d6,a1			; go to the next channel
0001C8EC 51CF FFD8                  		dbf	d7,.loopFM		; repeat for all FM channels
0001C8F0                            
0001C8F0                            .doPSG
0001C8F0 7E00                       		moveq	#0,d7
0001C8F2 1E2B 0003                  		move.b	3(a3),d7		; load the FM channel count to d7
0001C8F6 6B00                       		bmi.s	.intSFX			; if no PSG channels are loaded, branch
0001C8F8                            ; ---------------------------------------------------------------------------
0001C8F8                            ; The reason why we delay PSG by 1 extra frame, is because of Dual PCM.
0001C8F8                            ; It adds a delay of 1 frame to DAC and FM due to the YMCue, and PCM
0001C8F8                            ; buffering to avoid quality loss from DMA's. This means that, since PSG
0001C8F8                            ; is controlled by the 68000, we would be off by a single frame without
0001C8F8                            ; this fix.
0001C8F8                            ; ---------------------------------------------------------------------------
0001C8F8                            
0001C8F8 7A02                       		moveq	#2,d5			; prepare duration of 1 frames to d5
0001C8FA 45FA 0000                  		lea	dPSGtypeVals(pc),a2	; prepare PSG type value list into a2
0001C8FE 43F8 C5F8                  		lea	mPSG1.w,a1		; start from PSG1 channel
0001C902                            
0001C902                            .loopPSG
0001C902 1282                       		move.b	d2,(a1)			; save channel flags
0001C904 135A 0001                  		move.b	(a2)+,cType(a1)		; load channel type from list
0001C908 1344 000A                  		move.b	d4,cTick(a1)		; set channel tick multiplier
0001C90C 1346 001E                  		move.b	d6,cStack(a1)		; reset channel stack pointer
0001C910 1345 000C                  		move.b	d5,cDuration(a1)	; reset channel duration
0001C914                            
0001C914 7000                       		moveq	#0,d0
0001C916 301C                       		move.w	(a4)+,d0		; load tracker offset to d0
0001C918 D08B                       		add.l	a3,d0			; add music header offset to d0
0001C91A 2340 0002                  		move.l	d0,cData(a1)		; save as the tracker address of the channel
0001C91E                            
0001C91E 335C 0008                  		move.w	(a4)+,cPitch(a1)	; load pitch offset and channel volume
0001C922 135C 0007                  		move.b	(a4)+,cDetune(a1)	; load detune offset
0001C926 135C 000B                  		move.b	(a4)+,cVolEnv(a1)	; load volume envelope ID
0001C92A D2C6                       		adda.w	d6,a1			; go to the next channel
0001C92C 51CF FFD4                  		dbf	d7,.loopPSG		; repeat for all FM channels
0001C930                            
0001C930                            .intSFX
0001C930                            ; ---------------------------------------------------------------------------
0001C930                            ; Now follows initializing FM6 to be ready for PCM streaming,
0001C930                            ; and resetting the PCM filter for Dual PCM. Simply, this just
0001C930                            ; clears some YM registers.
0001C930                            ; ---------------------------------------------------------------------------
0001C930                            
0001C930 7028                       		moveq	#$28,d0			; YM address: Key on/off
0001C932 7206                       		moveq	#6,d1			; FM6, all operators off
0001C934 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to part 2 channel
0001C938                            
0001C938 727F                       		moveq	#$7F,d1			; set total level to $7F (silent)
0001C93A 7042                       		moveq	#$42,d0			; YM address: Total Level Operator 1 (FM3/6)
0001C93C 4EBA 0000                  		jsr	WriteYM_Pt2(pc)		; write to part 2 channel
0001C940 704A                       		moveq	#$4A,d0			; YM address: Total Level Operator 2 (FM3/6)
0001C942 4EBA 0000                  		jsr	WriteYM_Pt2(pc)		; write to part 2 channel
0001C946 7046                       		moveq	#$46,d0			; YM address: Total Level Operator 3 (FM3/6)
0001C948 4EBA 0000                  		jsr	WriteYM_Pt2(pc)		; write to part 2 channel
0001C94C 704E                       		moveq	#$4E,d0			; YM address: Total Level Operator 4 (FM3/6)
0001C94E 4EBA 0000                  		jsr	WriteYM_Pt2(pc)		; write to part 2 channel
0001C952                            
0001C952 72C0                       		moveq	#$FFFFFFC0,d1		; set panning to centre
0001C954 70B6                       		moveq	#$FFFFFFB4+2,d0		; YM address: Panning and LFO (FM3/6)
0001C956 4EBA 0000                  		jsr	WriteYM_Pt2(pc)		; write to part 2 channel
0001C95A                            
0001C95A 303C 0000                  		move.w	#fLog>>$0F,d0		; use linear filter
0001C95E 4EBA 0000                  		jsr	dSetFilter(pc)		; set filter
0001C962                            ; ---------------------------------------------------------------------------
0001C962                            ; This piece of code here handles SFX overriding our newly loaded
0001C962                            ; music channels. Since we did not do this at the initialization
0001C962                            ; step, we will handle it here instead.
0001C962                            ; ---------------------------------------------------------------------------
0001C962                            
0001C962 45FA 0000                  		lea	dSFXoverList(pc),a2	; load quick reference to the SFX override list
0001C966 43F8 C67C                  		lea	mSFXDAC1.w,a1		; start from SFX DAC1 channel
0001C96A 7E06                       		moveq	#SFX_Ch-1,d7		; prepare total number of SFX channels into d7
0001C96C 7C1C                       		moveq	#cSizeSFX,d6		; prepare SFX channel size to d6
0001C96E                            
0001C96E                            .loopSFX
0001C96E 4A11                       		tst.b	(a1)			; check if SFX channel is running a tracker
0001C970 6A00                       		bpl.s	.nextSFX		; if not, skip this channel
0001C972                            
0001C972 7000                       		moveq	#0,d0
0001C974 1029 0001                  		move.b	cType(a1),d0		; load SFX channel type to d0
0001C978 6B00                       		bmi.s	.SFXPSG			; if negative, it is a PSG channel
0001C97A                            
0001C97A 0240 0007                  		and.w	#$07,d0			; get only the necessary bits to d3
0001C97E 5540                       		subq.w	#2,d0			; since FM 1 and 2 are not used, skip over them
0001C980 D040                       		add.w	d0,d0			; double offset (each entry is 1 word in size)
0001C982 6000                       		bra.s	.override
0001C984                            ; ---------------------------------------------------------------------------
0001C984                            
0001C984                            .SFXPSG
0001C984 E808                       		lsr.b	#4,d0			; make it easier to reference the right offset in the table
0001C986                            .override
0001C986 3672 0000                  		move.w	(a2,d0.w),a3		; get music channel RAM address to a3
0001C98A 08D3 0001                  		bset	#cfbInt,(a3)		; set as interrupted
0001C98E                            
0001C98E                            .nextSFX
0001C98E D2C6                       		adda.w	d6,a1			; go to the next channel
0001C990 51CF FFDC                  		dbf	d7,.loopSFX		; repeat for all SFX channels
0001C994                            ; ---------------------------------------------------------------------------
0001C994                            ; Here we mute all non-interrupted FM and PSG channels
0001C994                            ; ---------------------------------------------------------------------------
0001C994                            
0001C994 4BF8 C51C                  		lea	mFM1.w,a5		; start from FM1 channel
0001C998 7804                       		moveq	#Mus_FM-1,d4		; prepare total number of FM channels into d7
0001C99A                            .stopFM
0001C99A 4EBA 0000                  		jsr	dKeyOffFM(pc)		; send key off even if not interrupted
0001C99E DAC6                       		adda.w	d6,a5			; go to the next channel
0001C9A0 51CC FFF8                  		dbf	d4,.stopFM		; repeat for all FM channels
0001C9A4                            
0001C9A4 7802                       		moveq	#Mus_PSG-1,d4		; start from PSG1 channel
0001C9A6                            .mutePSG
0001C9A6 4EBA 0000                  		jsr	dMutePSGmus(pc)		; mute PSG channel if not interrupted
0001C9AA DAC6                       		adda.w	d6,a5			; go to the next channel
0001C9AC 51CC FFF8                  		dbf	d4,.mutePSG		; repeat for all FM channels
0001C9B0 4E75                       		rts
0001C9B2                            
0001C9B2                            ; ===========================================================================
0001C9B2                            ; ---------------------------------------------------------------------------
0001C9B2                            ; Type values for different channels. Used for playing music
0001C9B2                            ; ---------------------------------------------------------------------------
0001C9B2 0B0E                       dDACtypeVals:	dc.b ctDAC1, ctDAC2
0001C9B4 0001 0204 05               dFMtypeVals:	dc.b ctFM1, ctFM2, ctFM3, ctFM4, ctFM5
0001C9B9 80A0 C0                    dPSGtypeVals:	dc.b ctPSG1, ctPSG2, ctPSG3
0001C9BC                            		even
0001C9BC                            ; ===========================================================================
0001C9BC                            ; ---------------------------------------------------------------------------
0001C9BC                            ; Subroutine to play a queued sound effect
0001C9BC                            ; ---------------------------------------------------------------------------
0001C9BC                            
0001C9BC                            dPlaySnd_SFX:
0001C9BC                            ; ---------------------------------------------------------------------------
0001C9BC                            ; This is a little special case with Sonic 1 - 3K, where the ring
0001C9BC                            ; sound effect would change panning each time it is played. AMPS
0001C9BC                            ; emulates this behavior like the original drivers did, by
0001C9BC                            ; playing a different sound effect ID.
0001C9BC                            ; ---------------------------------------------------------------------------
0001C9BC                            
0001C9BC                            		;cmpi.b	#sfx_RingRight,d7	; check if the sound effect was the ring sound effect
0001C9BC                            		;bne.s	.noring			; if not, skip
0001C9BC                            		;bchg	#mfbRing,mFlags.w	; swap flag and check if it was set
0001C9BC                            		;beq.s	.noring			; if was not, do not change sound effect
0001C9BC                            		;move.w	#sfx_RingLeft,d7	; switch to left panned sound effect instead
0001C9BC                            ; ---------------------------------------------------------------------------
0001C9BC                            ; To save few cycles, we don't directly substract the SFX offset from
0001C9BC                            ; the ID, and instead offset the table position. In practice this will
0001C9BC                            ; have the same effect, but saves us 8 cycles overall.
0001C9BC                            ; ---------------------------------------------------------------------------
0001C9BC                            
0001C9BC                            .noring
0001C9BC 43FA 0000                  		lea	SoundIndex-(SFXoff*4)(pc),a1; get sfx pointer table with an offset to a4
0001C9C0 1207                       		move.b	d7,d1			; copy sfx ID to d1 (used later)
0001C9C2 DE47                       		add.w	d7,d7			; quadruple sfx ID
0001C9C4 DE47                       		add.w	d7,d7			; since each entry is 4 bytes in size
0001C9C6 2871 7000                  		movea.l	(a1,d7.w),a4		; get SFX header pointer from the table
0001C9CA                            
0001C9CA                            ; ---------------------------------------------------------------------------
0001C9CA                            ; Continous SFX is a very special type of sound effect. Unlike other
0001C9CA                            ; sound effects, when a continous SFX is played, it will run a loop
0001C9CA                            ; again, until it is no longer queued. This is very useful for sound
0001C9CA                            ; effects that need to be queued very often, but that really do not
0001C9CA                            ; sound good when restarted (plus, it requires more CPU time, anyway).
0001C9CA                            ; Even the Marble Zone block pushing sound effect had similar behavior,
0001C9CA                            ; but the code was not quite as matured as this here. Only one continous
0001C9CA                            ; SFX may be running at once, when other type is loaded, the earlier one
0001C9CA                            ; is stopped and replaced.
0001C9CA                            ; ---------------------------------------------------------------------------
0001C9CA                            
0001C9CA 4A31 7000                  		tst.b	(a1,d7.w)		; check if this sound effect is continously looping
0001C9CE 6A00                       		bpl.s	.nocont			; if not, skip
0001C9D0 11EC 0001 C4C2             		move.b	1(a4),mContCtr.w	; copy the number of channels as the new continous loop counter
0001C9D6 B238 C4C3                  		cmp.b	mContLast.w,d1		; check if the last continous SFX had the same ID
0001C9DA 6600                       		bne.s	.setcont		; if not, play as a new sound effect anyway
0001C9DC 4E75                       		rts
0001C9DE                            
0001C9DE                            .setcont
0001C9DE 11C1 C4C3                  		move.b	d1,mContLast.w		; save new continous SFX ID
0001C9E2                            .nocont
0001C9E2 224C                       		movea.l	a4,a1			; copy tracker header pointer to a1
0001C9E4                            
0001C9E4 7E00                       		moveq	#0,d7
0001C9E6 47FA 0000                  		lea	dSFXoverList(pc),a3	; load quick reference to the SFX override list to a3
0001C9EA 45FA 0000                  		lea	dSFXoffList(pc),a2	; load quick reference to the SFX channel list to a2
0001C9EE 1A19                       		move.b	(a1)+,d5		; load sound effect priority to d5
0001C9F0 1E19                       		move.b	(a1)+,d7		; load number of SFX channels to d7
0001C9F2 7C1C                       		moveq	#cSizeSFX,d6		; prepare SFX channel size to d6
0001C9F4                            ; ---------------------------------------------------------------------------
0001C9F4                            ; The reason why we delay PSG by 1 extra frame, is because of Dual PCM.
0001C9F4                            ; It adds a delay of 1 frame to DAC and FM due to the YMCue, and PCM
0001C9F4                            ; buffering to avoid quality loss from DMA's. This means that, since PSG
0001C9F4                            ; is controlled by the 68000, we would be off by a single frame without
0001C9F4                            ; this fix.
0001C9F4                            ; ---------------------------------------------------------------------------
0001C9F4                            
0001C9F4                            .loopSFX
0001C9F4 7600                       		moveq	#0,d3
0001C9F6 7402                       		moveq	#2,d2			; prepare duration of 1 frames to d5
0001C9F8 1629 0001                  		move.b	1(a1),d3		; load sound effect channel type to d3
0001C9FC 1803                       		move.b	d3,d4			; copy type to d4
0001C9FE 6B00                       		bmi.s	.chPSG			; if channel is a PSG channel, branch
0001CA00                            
0001CA00 0243 0007                  		and.w	#$07,d3			; get only the necessary bits to d3
0001CA04 5543                       		subq.w	#2,d3			; since FM 1 and 2 are not used, skip over them
0001CA06 D643                       		add.w	d3,d3			; double offset (each entry is 1 word in size)
0001CA08                            
0001CA08 3A72 3000                  		move.w	(a2,d3.w),a5		; get the SFX channel we are trying to load to
0001CA0C BA2D 001A                  		cmp.b	cPrio(a5),d5		; check if this sound effect has higher priority
0001CA10 6500                       		blo.s	.skip			; if not, we can not override it
0001CA12                            
0001CA12 3C73 3000                  		move.w	(a3,d3.w),a6		; get the music channel we should override
0001CA16 08D6 0001                  		bset	#cfbInt,(a6)		; override music channel with sound effect
0001CA1A 7401                       		moveq	#1,d2			; prepare duration of 0 frames to d5
0001CA1C 6000                       		bra.s	.clearCh
0001CA1E                            ; ---------------------------------------------------------------------------
0001CA1E                            
0001CA1E                            .skip
0001CA1E 5C89                       		addq.l	#6,a1			; skip this sound effect channel
0001CA20 51CF FFD2                  		dbf	d7,.loopSFX		; repeat for each requested channel
0001CA24 4E75                       		rts
0001CA26                            ; ---------------------------------------------------------------------------
0001CA26                            
0001CA26                            .chPSG
0001CA26 E84B                       		lsr.w	#4,d3			; make it easier to reference the right offset in the table
0001CA28 3A72 3000                  		move.w	(a2,d3.w),a5		; get the SFX channel we are trying to load to
0001CA2C BA2D 001A                  		cmp.b	cPrio(a5),d5		; check if this sound effect has higher priority
0001CA30 65EC                       		blo.s	.skip			; if not, we can not override it
0001CA32                            
0001CA32 3C73 3000                  		move.w	(a3,d3.w),a6		; get the music channel we should override
0001CA36 08D6 0001                  		bset	#cfbInt,(a6)		; override music channel with sound effect
0001CA3A 0004 001F                  		ori.b	#$1F,d4			; add volume update and max volume to channel type
0001CA3E 13C4 00C0 0011             		move.b	d4,dPSG			; send volume mute command to PSG
0001CA44                            
0001CA44 0C04 00DF                  		cmpi.b	#ctPSG3|$1F,d4		; check if we sent command about PSG3
0001CA48 6600                       		bne.s	.clearCh		; if not, skip
0001CA4A 13FC 00FF 00C0 0011        		move.b	#ctPSG4|$1F,dPSG	; send volume mute command for PSG4 to PSG
0001CA52                            
0001CA52                            .clearCh
0001CA52 3C4D                       		move.w	a5,a6			; copy sound effect channel RAM pointer to a6
0001CA54 7006                       		moveq	#cSizeSFX/4-1,d0	; prepare SFX channel size / 4 to d0
0001CA56                            .clear
0001CA56 429E                       		clr.l	(a6)+			; clear 4 bytes of channel data
0001CA58 51C8 FFFC                  		dbf	d0,.clear		; clear the entire channel
0001CA5C                            
0001CA5C                            
0001CA5C 3A99                       		move.w	(a1)+,(a5)		; load channel flags and type
0001CA5E 1B45 001A                  		move.b	d5,cPrio(a5)		; set channel priority
0001CA62 1B42 000C                  		move.b	d2,cDuration(a5)	; reset channel duration
0001CA66                            
0001CA66 7000                       		moveq	#0,d0
0001CA68 3019                       		move.w	(a1)+,d0		; load tracker offset to d0
0001CA6A D08C                       		add.l	a4,d0			; add music header offset to d0
0001CA6C 2B40 0002                  		move.l	d0,cData(a5)		; save as the tracker address of the channel
0001CA70                            
0001CA70 3B59 0008                  		move.w	(a1)+,cPitch(a5)	; load pitch offset and channel volume
0001CA74 4A04                       		tst.b	d4			; check if this channel is a PSG channel
0001CA76 6B00                       		bmi.s	.loop			; if is, skip over this
0001CA78                            
0001CA78 72C0                       		moveq	#$FFFFFFC0,d1		; set panning to centre
0001CA7A 1B41 0006                  		move.b	d1,cPanning(a5)		; save to channel memory too
0001CA7E 70B4                       		moveq	#$FFFFFFB4,d0		; YM address: Panning and LFO
0001CA80 4EBA 0000                  		jsr	WriteChYM(pc)		; write to part 2 channel
0001CA84                            
0001CA84 BAFC C67C                  		cmp.w	#mSFXDAC1,a5		; check if this channel is a DAC channel
0001CA88 6600                       		bne.s	.fm			; if not, branch
0001CA8A 3B7C 0100 000E             		move.w	#$100,cFreq(a5)		; DAC default frequency is $100, NOT $000
0001CA90                            
0001CA90                            .loop
0001CA90 51CF FF62                  		dbf	d7,.loopSFX		; repeat for each requested channel
0001CA94 4E75                       		rts
0001CA96                            ; ---------------------------------------------------------------------------
0001CA96                            ; The instant release for FM channels behavior was not in the Sonic 1
0001CA96                            ; SMPS driver by default, but it has been added since it fixes an
0001CA96                            ; issue with YM2612, where sometimes subsequent sound effect activations
0001CA96                            ; would sound different over time. This fix will help to mitigate that.
0001CA96                            ; ---------------------------------------------------------------------------
0001CA96                            
0001CA96                            .fm
0001CA96 720F                       		moveq	#$F,d1			; set to release note instantly
0001CA98 7080                       		moveq	#$FFFFFF80,d0		; YM address: Release Rate Operator 1
0001CA9A 4EBA 0000                  		jsr	WriteChYM(pc)		; write to YM according to channel
0001CA9E 7088                       		moveq	#$FFFFFF88,d0		; YM address: Release Rate Operator 3
0001CAA0 4EBA 0000                  		jsr	WriteChYM(pc)		; write to YM according to channel
0001CAA4 7084                       		moveq	#$FFFFFF84,d0		; YM address: Release Rate Operator 2
0001CAA6 4EBA 0000                  		jsr	WriteChYM(pc)		; write to YM according to channel
0001CAAA 708C                       		moveq	#$FFFFFF8C,d0		; YM address: Release Rate Operator 4
0001CAAC 4EBA 0000                  		jsr	WriteChYM(pc)		; write to YM according to channel
0001CAB0                            
0001CAB0 7028                       		moveq	#$28,d0			; YM address: Key on/off
0001CAB2 122D 0001                  		move.b	cType(a5),d1		; FM channel, all operators off
0001CAB6 6100 0000                  		bsr.w	WriteYM_Pt1		; write to part 1 or 2 channel
0001CABA                            
0001CABA 51CF FF38                  		dbf	d7,.loopSFX		; repeat for each requested channel
0001CABE 4E75                       		rts
0001CAC0                            ; ===========================================================================
0001CAC0                            ; ---------------------------------------------------------------------------
0001CAC0                            ; pointers for music channels SFX can override and addresses of SFX channels
0001CAC0                            ; ---------------------------------------------------------------------------
0001CAC0                            
0001CAC0 C698                       dSFXoffList:	dc.w mSFXFM3			; FM3
0001CAC2 C67C                       		dc.w mSFXDAC1			; DAC1
0001CAC4 C6B4                       		dc.w mSFXFM4			; FM4
0001CAC6 C6D0                       		dc.w mSFXFM5			; FM5
0001CAC8 C6EC                       		dc.w mSFXPSG1			; PSG1
0001CACA C708                       		dc.w mSFXPSG2			; PSG2
0001CACC C724                       		dc.w mSFXPSG3			; PSG3
0001CACE C724                       		dc.w mSFXPSG3			; PSG4
0001CAD0                            
0001CAD0 C574                       dSFXoverList:	dc.w mFM3			; SFX FM3
0001CAD2 C4C4                       		dc.w mDAC1			; SFX DAC1
0001CAD4 C5A0                       		dc.w mFM4			; SFX FM4
0001CAD6 C5CC                       		dc.w mFM5			; SFX FM5
0001CAD8 C5F8                       		dc.w mPSG1			; SFX PSG1
0001CADA C624                       		dc.w mPSG2			; SFX PSG2
0001CADC C650                       		dc.w mPSG3			; SFX PSG3
0001CADE C650                       		dc.w mPSG3			; SFX PSG4
0001CAE0                            ; ===========================================================================
0001CAE0                            ; ---------------------------------------------------------------------------
0001CAE0                            ; Play queued command
0001CAE0                            ; ---------------------------------------------------------------------------
0001CAE0                            
0001CAE0                            dPlaySnd_Comm:
0001CAE0                            
0001CAE0 DE47                       		add.w	d7,d7			; quadruple ID
0001CAE2 DE47                       		add.w	d7,d7			; because each entry is 1 long word
0001CAE4 4EFB 7000                  		jmp	dSoundCommands-4(pc,d7.w); jump to appropriate command handler
0001CAE8                            
0001CAE8                            ; ---------------------------------------------------------------------------
0001CAE8                            dSoundCommands:
0001CAE8 6000 0000                  		bra.w	dPlaySnd_Reset		; 01 - Reset underwater and speed shoes flags, update volume
0001CAEC 6000 0000                  		bra.w	dPlaySnd_FadeOut	; 02 - Initialize a music fade out
0001CAF0 6000 0000                  		bra.w	dPlaySnd_Stop		; 03 - Stop all music
0001CAF4 6000 0000                  		bra.w	dPlaySnd_ShoesOn	; 04 - Enable speed shoes mode
0001CAF8 6000 0000                  		bra.w	dPlaySnd_ShoesOff	; 05 - Disable speed shoes mode
0001CAFC 6000 0000                  		bra.w	dPlaySnd_ToWater	; 06 - Enable underwater mode
0001CB00 6000 0000                  		bra.w	dPlaySnd_OutWater	; 07 - Disable underwater mode
0001CB04 6000 FC4E                  		bra.w	dPlaySnd_Pause		; 08 - Pause the sound driver
0001CB08 6000 FBEA                  		bra.w	dPlaySnd_Unpause	; 09 - Unpause the sound driver
0001CB0C                            dSoundCommands_End:
0001CB0C                            ; ===========================================================================
0001CB0C                            ; ---------------------------------------------------------------------------
0001CB0C                            ; Commands for what to do after a volume fade
0001CB0C                            ; ---------------------------------------------------------------------------
0001CB0C                            
0001CB0C                            dFadeCommands:
0001CB0C 4E75                       		rts				; 80 - Do nothing
0001CB0E 4E75                       		rts
0001CB10 6000                       .stop		bra.s	dPlaySnd_Stop		; 84 - Stop all music
0001CB12 4E75                       		rts
0001CB14 6000 0000                  .resv		bra.w	dResetVolume		; 88 - Reset volume and update
0001CB18 61FA                       		bsr.s	.resv			; 8C - Stop music playing and reset volume
0001CB1A 60F4                       		bra.s	.stop
0001CB1C                            ; ===========================================================================
0001CB1C                            ; ---------------------------------------------------------------------------
0001CB1C                            ; Stop music and SFX from playing (This code clears SFX RAM also)
0001CB1C                            ; ---------------------------------------------------------------------------
0001CB1C                            
0001CB1C                            dPlaySnd_Stop:
0001CB1C                            ; Not needed,	moveq	#$2B,d0			; YM command: DAC Enable
0001CB1C                            ; Dual PCM does	moveq	#$FFFFFF80,d1		; FM6 acts as DAC
0001CB1C                            ; this for us	jsr	WriteYM_Pt1(pc)		; write to YM global register
0001CB1C                            
0001CB1C 7027                       		moveq	#$27,d0			; YM command: Channel 3 Mode & Timer Control
0001CB1E 7200                       		moveq	#0,d1			; disable timers and channel 3 special mode
0001CB20 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to YM global register
0001CB24                            
0001CB24 43F8 C67C                  		lea	mSFXDAC1.w,a1		; prepare SFX DAC 1 to start clearing fromn
0001CB28                            
0001CB28                            	rept (mSize-mSFXDAC1)/4
0001CB28                            		clr.l	(a1)+			; clear entire SFX RAM (others done below)
0001CB28                            	endr
0001CB28 4299                     M 	clr.l	(a1)+
0001CB2A 4299                     M 	clr.l	(a1)+
0001CB2C 4299                     M 	clr.l	(a1)+
0001CB2E 4299                     M 	clr.l	(a1)+
0001CB30 4299                     M 	clr.l	(a1)+
0001CB32 4299                     M 	clr.l	(a1)+
0001CB34 4299                     M 	clr.l	(a1)+
0001CB36 4299                     M 	clr.l	(a1)+
0001CB38 4299                     M 	clr.l	(a1)+
0001CB3A 4299                     M 	clr.l	(a1)+
0001CB3C 4299                     M 	clr.l	(a1)+
0001CB3E 4299                     M 	clr.l	(a1)+
0001CB40 4299                     M 	clr.l	(a1)+
0001CB42 4299                     M 	clr.l	(a1)+
0001CB44 4299                     M 	clr.l	(a1)+
0001CB46 4299                     M 	clr.l	(a1)+
0001CB48 4299                     M 	clr.l	(a1)+
0001CB4A 4299                     M 	clr.l	(a1)+
0001CB4C 4299                     M 	clr.l	(a1)+
0001CB4E 4299                     M 	clr.l	(a1)+
0001CB50 4299                     M 	clr.l	(a1)+
0001CB52 4299                     M 	clr.l	(a1)+
0001CB54 4299                     M 	clr.l	(a1)+
0001CB56 4299                     M 	clr.l	(a1)+
0001CB58 4299                     M 	clr.l	(a1)+
0001CB5A 4299                     M 	clr.l	(a1)+
0001CB5C 4299                     M 	clr.l	(a1)+
0001CB5E 4299                     M 	clr.l	(a1)+
0001CB60 4299                     M 	clr.l	(a1)+
0001CB62 4299                     M 	clr.l	(a1)+
0001CB64 4299                     M 	clr.l	(a1)+
0001CB66 4299                     M 	clr.l	(a1)+
0001CB68 4299                     M 	clr.l	(a1)+
0001CB6A 4299                     M 	clr.l	(a1)+
0001CB6C 4299                     M 	clr.l	(a1)+
0001CB6E 4299                     M 	clr.l	(a1)+
0001CB70 4299                     M 	clr.l	(a1)+
0001CB72 4299                     M 	clr.l	(a1)+
0001CB74 4299                     M 	clr.l	(a1)+
0001CB76 4299                     M 	clr.l	(a1)+
0001CB78 4299                     M 	clr.l	(a1)+
0001CB7A 4299                     M 	clr.l	(a1)+
0001CB7C 4299                     M 	clr.l	(a1)+
0001CB7E 4299                     M 	clr.l	(a1)+
0001CB80 4299                     M 	clr.l	(a1)+
0001CB82 4299                     M 	clr.l	(a1)+
0001CB84 4299                     M 	clr.l	(a1)+
0001CB86 4299                     M 	clr.l	(a1)+
0001CB88 4299                     M 	clr.l	(a1)+
0001CB8A                            
0001CB8A                            	; continue straight to stopping music
0001CB8A                            ; ===========================================================================
0001CB8A                            ; ---------------------------------------------------------------------------
0001CB8A                            ; Stop music from playing, reset driver memory and mute hardware
0001CB8A                            ; ---------------------------------------------------------------------------
0001CB8A                            
0001CB8A                            dStopMusic:
0001CB8A 43F8 C4A6                  		lea	mFlags.w,a1		; load driver RAM start to a1
0001CB8E 3611                       		move.w	(a1),d3			; load driver flags and PAL counter to d3
0001CB90 1838 C4C0                  		move.b	mMasterVolDAC.w,d4	; load DAC master volume to d4
0001CB94 2A38 C4BC                  		move.l	mQueue.w,d5		; load sound queue and PSG master volume to d5
0001CB98 4CF8 0007 C4AC             		movem.l	mComm.w,d0-d2		; load communications bytes, FM master volume and fade address to d0-d2
0001CB9E                            
0001CB9E                            	rept (mSFXDAC1-mFlags)/4
0001CB9E                            		clr.l	(a1)+			; clear driver and music channel memory
0001CB9E                            	endr
0001CB9E 4299                     M 	clr.l	(a1)+
0001CBA0 4299                     M 	clr.l	(a1)+
0001CBA2 4299                     M 	clr.l	(a1)+
0001CBA4 4299                     M 	clr.l	(a1)+
0001CBA6 4299                     M 	clr.l	(a1)+
0001CBA8 4299                     M 	clr.l	(a1)+
0001CBAA 4299                     M 	clr.l	(a1)+
0001CBAC 4299                     M 	clr.l	(a1)+
0001CBAE 4299                     M 	clr.l	(a1)+
0001CBB0 4299                     M 	clr.l	(a1)+
0001CBB2 4299                     M 	clr.l	(a1)+
0001CBB4 4299                     M 	clr.l	(a1)+
0001CBB6 4299                     M 	clr.l	(a1)+
0001CBB8 4299                     M 	clr.l	(a1)+
0001CBBA 4299                     M 	clr.l	(a1)+
0001CBBC 4299                     M 	clr.l	(a1)+
0001CBBE 4299                     M 	clr.l	(a1)+
0001CBC0 4299                     M 	clr.l	(a1)+
0001CBC2 4299                     M 	clr.l	(a1)+
0001CBC4 4299                     M 	clr.l	(a1)+
0001CBC6 4299                     M 	clr.l	(a1)+
0001CBC8 4299                     M 	clr.l	(a1)+
0001CBCA 4299                     M 	clr.l	(a1)+
0001CBCC 4299                     M 	clr.l	(a1)+
0001CBCE 4299                     M 	clr.l	(a1)+
0001CBD0 4299                     M 	clr.l	(a1)+
0001CBD2 4299                     M 	clr.l	(a1)+
0001CBD4 4299                     M 	clr.l	(a1)+
0001CBD6 4299                     M 	clr.l	(a1)+
0001CBD8 4299                     M 	clr.l	(a1)+
0001CBDA 4299                     M 	clr.l	(a1)+
0001CBDC 4299                     M 	clr.l	(a1)+
0001CBDE 4299                     M 	clr.l	(a1)+
0001CBE0 4299                     M 	clr.l	(a1)+
0001CBE2 4299                     M 	clr.l	(a1)+
0001CBE4 4299                     M 	clr.l	(a1)+
0001CBE6 4299                     M 	clr.l	(a1)+
0001CBE8 4299                     M 	clr.l	(a1)+
0001CBEA 4299                     M 	clr.l	(a1)+
0001CBEC 4299                     M 	clr.l	(a1)+
0001CBEE 4299                     M 	clr.l	(a1)+
0001CBF0 4299                     M 	clr.l	(a1)+
0001CBF2 4299                     M 	clr.l	(a1)+
0001CBF4 4299                     M 	clr.l	(a1)+
0001CBF6 4299                     M 	clr.l	(a1)+
0001CBF8 4299                     M 	clr.l	(a1)+
0001CBFA 4299                     M 	clr.l	(a1)+
0001CBFC 4299                     M 	clr.l	(a1)+
0001CBFE 4299                     M 	clr.l	(a1)+
0001CC00 4299                     M 	clr.l	(a1)+
0001CC02 4299                     M 	clr.l	(a1)+
0001CC04 4299                     M 	clr.l	(a1)+
0001CC06 4299                     M 	clr.l	(a1)+
0001CC08 4299                     M 	clr.l	(a1)+
0001CC0A 4299                     M 	clr.l	(a1)+
0001CC0C 4299                     M 	clr.l	(a1)+
0001CC0E 4299                     M 	clr.l	(a1)+
0001CC10 4299                     M 	clr.l	(a1)+
0001CC12 4299                     M 	clr.l	(a1)+
0001CC14 4299                     M 	clr.l	(a1)+
0001CC16 4299                     M 	clr.l	(a1)+
0001CC18 4299                     M 	clr.l	(a1)+
0001CC1A 4299                     M 	clr.l	(a1)+
0001CC1C 4299                     M 	clr.l	(a1)+
0001CC1E 4299                     M 	clr.l	(a1)+
0001CC20 4299                     M 	clr.l	(a1)+
0001CC22 4299                     M 	clr.l	(a1)+
0001CC24 4299                     M 	clr.l	(a1)+
0001CC26 4299                     M 	clr.l	(a1)+
0001CC28 4299                     M 	clr.l	(a1)+
0001CC2A 4299                     M 	clr.l	(a1)+
0001CC2C 4299                     M 	clr.l	(a1)+
0001CC2E 4299                     M 	clr.l	(a1)+
0001CC30 4299                     M 	clr.l	(a1)+
0001CC32 4299                     M 	clr.l	(a1)+
0001CC34 4299                     M 	clr.l	(a1)+
0001CC36 4299                     M 	clr.l	(a1)+
0001CC38 4299                     M 	clr.l	(a1)+
0001CC3A 4299                     M 	clr.l	(a1)+
0001CC3C 4299                     M 	clr.l	(a1)+
0001CC3E 4299                     M 	clr.l	(a1)+
0001CC40 4299                     M 	clr.l	(a1)+
0001CC42 4299                     M 	clr.l	(a1)+
0001CC44 4299                     M 	clr.l	(a1)+
0001CC46 4299                     M 	clr.l	(a1)+
0001CC48 4299                     M 	clr.l	(a1)+
0001CC4A 4299                     M 	clr.l	(a1)+
0001CC4C 4299                     M 	clr.l	(a1)+
0001CC4E 4299                     M 	clr.l	(a1)+
0001CC50 4299                     M 	clr.l	(a1)+
0001CC52 4299                     M 	clr.l	(a1)+
0001CC54 4299                     M 	clr.l	(a1)+
0001CC56 4299                     M 	clr.l	(a1)+
0001CC58 4299                     M 	clr.l	(a1)+
0001CC5A 4299                     M 	clr.l	(a1)+
0001CC5C 4299                     M 	clr.l	(a1)+
0001CC5E 4299                     M 	clr.l	(a1)+
0001CC60 4299                     M 	clr.l	(a1)+
0001CC62 4299                     M 	clr.l	(a1)+
0001CC64 4299                     M 	clr.l	(a1)+
0001CC66 4299                     M 	clr.l	(a1)+
0001CC68 4299                     M 	clr.l	(a1)+
0001CC6A 4299                     M 	clr.l	(a1)+
0001CC6C 4299                     M 	clr.l	(a1)+
0001CC6E 4299                     M 	clr.l	(a1)+
0001CC70 4299                     M 	clr.l	(a1)+
0001CC72 4299                     M 	clr.l	(a1)+
0001CC74 4299                     M 	clr.l	(a1)+
0001CC76 4299                     M 	clr.l	(a1)+
0001CC78 4299                     M 	clr.l	(a1)+
0001CC7A 4299                     M 	clr.l	(a1)+
0001CC7C 4299                     M 	clr.l	(a1)+
0001CC7E 4299                     M 	clr.l	(a1)+
0001CC80 4299                     M 	clr.l	(a1)+
0001CC82 4299                     M 	clr.l	(a1)+
0001CC84 4299                     M 	clr.l	(a1)+
0001CC86 4299                     M 	clr.l	(a1)+
0001CC88                            
0001CC88 4251                       		clr.w	(a1)			; if there is an extra word, clear it too
0001CC8A                            
0001CC8A 31C3 C4A6                  		move.w	d3,mFlags.w		; save driver flags and PAL counter
0001CC8E 11C4 C4C0                  		move.b	d4,mMasterVolDAC.w	; save DAC master volume
0001CC92 21C5 C4BC                  		move.l	d5,mQueue.w		; save sound queue and PSG master volume
0001CC96 48F8 0007 C4AC             		movem.l	d0-d2,mComm.w		; save communications bytes, FM master volume and fade address
0001CC9C                            
0001CC9C 6100                       		bsr.s	dMutePSG		; hardware mute PSG
0001CC9E 4EBA FAE8                  		jsr	dMuteDAC(pc)		; hardware mute DAC
0001CCA2                            	; continue straight to hardware muting FM
0001CCA2                            ; ===========================================================================
0001CCA2                            ; ---------------------------------------------------------------------------
0001CCA2                            ; Mute all FM channels
0001CCA2                            ; ---------------------------------------------------------------------------
0001CCA2                            
0001CCA2                            dMuteFM:
0001CCA2 7028                       		moveq	#$28,d0			; YM address: Key on/off
0001CCA4 7602                       		moveq	#%00000010,d3		; turn keys off, and start from YM channel 3
0001CCA6                            
0001CCA6                            .noteoff
0001CCA6 1203                       		move.b	d3,d1			; copy value into d1
0001CCA8 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to part 1 channel
0001CCAC 5801                       		addq.b	#4,d1			; set this to part 2 channel
0001CCAE 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to part 2 channel
0001CCB2 51CB FFF2                  		dbf	d3,.noteoff		; loop for all 3 channel groups
0001CCB6                            
0001CCB6 7040                       		moveq	#$40,d0			; YM command: Total Level Operator 1
0001CCB8 727F                       		moveq	#$7F,d1			; set total level to $7F (silent)
0001CCBA 7802                       		moveq	#3-1,d4			; prepare 3 groups of channels to d4
0001CCBC                            
0001CCBC                            .chloop
0001CCBC 7603                       		moveq	#4-1,d3			; prepare 4 operator writes per channel to d3
0001CCBE 7A0F                       		moveq	#$10-1,d5		; prepare the value for going to next channel to d5
0001CCC0                            
0001CCC0                            .oploop
0001CCC0 4EBA 0000                  		jsr	WriteYM_Pt1(pc)		; write to part 1 channel
0001CCC4 4EBA 0000                  		jsr	WriteYM_Pt2(pc)		; write to part 2 channel
0001CCC8 5840                       		addq.w	#4,d0			; go to next operator (1 2 3 4)
0001CCCA 51CB FFF4                  		dbf	d3,.oploop		; repeat for each operator
0001CCCE                            
0001CCCE 9005                       		sub.b	d5,d0			; go to next FM channel
0001CCD0 51CC FFEA                  		dbf	d4,.chloop		; repeat for each channel
0001CCD4 4E75                       		rts
0001CCD6                            ; ===========================================================================
0001CCD6                            ; ---------------------------------------------------------------------------
0001CCD6                            ; Routine for muting all PSG channels
0001CCD6                            ; ---------------------------------------------------------------------------
0001CCD6                            
0001CCD6                            dMutePSG:
0001CCD6 43F9 00C0 0011             		lea	dPSG,a1			; load PSG data port address to a1
0001CCDC 12BC 009F                  		move.b	#ctPSG1|$1F,(a1)	; send volume mute command for PSG1 to PSG
0001CCE0 12BC 00BF                  		move.b	#ctPSG2|$1F,(a1)	; send volume mute command for PSG2 to PSG
0001CCE4 12BC 00DF                  		move.b	#ctPSG3|$1F,(a1)	; send volume mute command for PSG3 to PSG
0001CCE8 12BC 00FF                  		move.b	#ctPSG4|$1F,(a1)	; send volume mute command for PSG4 to PSG
0001CCEC 4E75                       		rts
0001CCEE                            ; ===========================================================================
0001CCEE                            ; ---------------------------------------------------------------------------
0001CCEE                            ; Normal fade out data
0001CCEE                            ; ---------------------------------------------------------------------------
0001CCEE                            
0001CCEE                            dFadeOutDataLog:
0001CCEE 0101 0002 0200 0204 0103+  	dc.b $01, $01, $00,  $02, $02, $00,  $02, $04, $01,  $03, $05, $01
0001CCFA 0405 0104 0602 0507 0206+  	dc.b $04, $05, $01,  $04, $06, $02,  $05, $07, $02,  $06, $08, $02
0001CD06 0709 0309 0B03 0A0C 030C+  	dc.b $07, $09, $03,  $09, $0B, $03,  $0A, $0C, $03,  $0C, $0E, $03
0001CD12 0E10 0410 1104 1113 0414+  	dc.b $0E, $10, $04,  $10, $11, $04,  $11, $13, $04,  $14, $15, $05
0001CD1E 1618 051A 1C05 1C1F 0620+  	dc.b $16, $18, $05,  $1A, $1C, $05,  $1C, $1F, $06,  $20, $24, $06
0001CD2A 2228 0726 2E07 2C34 0830+  	dc.b $22, $28, $07,  $26, $2E, $07,  $2C, $34, $08,  $30, $39, $08
0001CD36 343E 093C 440A 404C 0A46+  	dc.b $34, $3E, $09,  $3C, $44, $0A,  $40, $4C, $0A,  $46, $54, $0B
0001CD42 4C5A 0C54 620D 5C6B 0D60+  	dc.b $4C, $5A, $0C,  $54, $62, $0D,  $5C, $6B, $0D,  $60, $76, $0E
0001CD4E 6C7C 0E74 7F0F 7F7F 0F8C   	dc.b $6C, $7C, $0E,  $74, $7F, $0F,  $7F, $7F, $0F,  fReset
0001CD58                            
0001CD58                            ;dFadeOutDataLinear:
0001CD58                            ;	dc.b $01, $00, $00,  $02, $01, $00,  $02, $01, $01,  $03, $02, $01
0001CD58                            ;	dc.b $04, $02, $01,  $04, $03, $02,  $05, $03, $02,  $06, $04, $02
0001CD58                            ;	dc.b $07, $05, $03,  $09, $06, $03,  $0A, $08, $03,  $0C, $0A, $03
0001CD58                            ;	dc.b $0E, $0D, $04,  $10, $0F, $04,  $11, $10, $04,  $14, $13, $05
0001CD58                            ;	dc.b $16, $16, $05,  $1A, $1A, $05,  $1C, $1E, $06,  $20, $22, $06
0001CD58                            ;	dc.b $22, $27, $07,  $26, $2A, $07,  $2C, $2E, $08,  $30, $34, $08
0001CD58                            ;	dc.b $34, $39, $09,  $3C, $3E, $0A,  $40, $3F, $0A,  $46, $40, $0B
0001CD58                            ;	dc.b $4C, $40, $0C,  $54, $40, $0D,  $5C, $40, $0D,  $60, $40, $0E
0001CD58                            ;	dc.b $6C, $40, $0E,  $74, $40, $0F,  $7F, $40, $0F,  fReset
0001CD58                            	even
0001CD58                            ; ===========================================================================
0001CD58                            ; ---------------------------------------------------------------------------
0001CD58                            ; Subroutine for initializing a fade effect.
0001CD58                            ; Since the driver allows for such an extensive and customizable
0001CD58                            ; fading code, we may hit a snag if we use fades too fast. It is
0001CD58                            ; possible, for example, to fade out, then in the middle of that,
0001CD58                            ; start fading in. This would normally cause a quick jump in the
0001CD58                            ; volume level from maybe half to completely mute. This routine
0001CD58                            ; aims to combat this by actually searching for the closest FM
0001CD58                            ; volume level in the fade program, and to start the new fade from
0001CD58                            ; where that byte appears. This can alter how long a volume fade
0001CD58                            ; lasts however, and if PSG and DAC volume are not correct faded,
0001CD58                            ; it may still cause a jump in their volume (especially if only,
0001CD58                            ; say, DAC fades volume). In the future, there might be a fix for
0001CD58                            ; that.
0001CD58                            ; ---------------------------------------------------------------------------
0001CD58                            
0001CD58                            dPlaySnd_FadeOut:
0001CD58 43FA FF94                  		lea	dFadeOutDataLog(pc),a1	; prepare stock fade out program to a1
0001CD5C                            
0001CD5C                            dLoadFade:
0001CD5C 1038 C4B4                  		move.b	mMasterVolFM.w,d0	; load FM master volume to d0
0001CD60 4A38 C4B5                  		tst.b	mFadeAddr+1.w		; check if a fade program is already executing
0001CD64 6700                       		beq.s	.nofade			; if not, load fade as is
0001CD66                            
0001CD66 2449                       		move.l	a1,a2			; copy fade program address to a2
0001CD68 74FF                       		moveq	#-1,d2			; prepare max byter difference
0001CD6A                            
0001CD6A                            .find
0001CD6A 1212                       		move.b	(a2),d1			; load the next FM volume from fade program
0001CD6C 6A00                       		bpl.s	.search			; branch if this is not a command
0001CD6E                            
0001CD6E                            .nofade
0001CD6E 21C9 C4B4                  		move.l	a1,mFadeAddr.w		; save new fade program address to memory
0001CD72 11C0 C4B4                  		move.b	d0,mMasterVolFM.w	; save new FM master volume
0001CD76 4E75                       		rts
0001CD78                            
0001CD78                            .search
0001CD78 568A                       		addq.l	#3,a2			; skip over the current volume group
0001CD7A 9200                       		sub.b	d0,d1			; sub current FM volume from read volume
0001CD7C 6A00                       		bpl.s	.abs			; if positive, do not negate
0001CD7E 4401                       		neg.b	d1			; negative to positive
0001CD80                            
0001CD80                            .abs
0001CD80 B202                       		cmp.b	d2,d1			; check if volume difference was smaller than before
0001CD82 64E6                       		bhs.s	.find			; if not, read next group
0001CD84                            
0001CD84 1401                       		move.b	d1,d2			; else save the new difference
0001CD86 224A                       		move.l	a2,a1			; also save the fade program address where we found it
0001CD88 60E0                       		bra.s	.find			; loop through each group in the program
0001CD8A                            ; ===========================================================================
0001CD8A                            ; ---------------------------------------------------------------------------
0001CD8A                            ; Routine for loading a volume filter into Dual PCM ROM.
0001CD8A                            ; This routine will actually write the bank number the volume filter
0001CD8A                            ; is in. This requires volume filters are aligned to Z80 banks, and
0001CD8A                            ; just because we can, we write 9 bits (yeah its not necessary, but
0001CD8A                            ; what the hell, you have to have fun sometimes!)
0001CD8A                            ; ---------------------------------------------------------------------------
0001CD8A                            
0001CD8A                            dSetFilter:
0001CD8A 43F9 0000 0000             		lea	dZ80+SV_VolumeBank,a1	; load volume bank instructions address to a1
0001CD90 7274                       		moveq	#$74,d1			; prepare the "ld  (hl),h" instruction to d1
0001CD92 7408                       		moveq	#9-1,d2			; prepare number of instructions to write to d2
0001CD94                            	StopZ80					; wait for Z80 to stop
0001CD94 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001CD9C                          M 	waitz80stop
0001CD9C 0839 0000 00A1 1100      M .wait_324:	btst	#0,z80_bus_req
0001CDA4 66F6                     M 	bne.s	.wait_324
0001CDA6                            ; ---------------------------------------------------------------------------
0001CDA6                            ; addx in Motorola 68000 is much like adc in Z80. It allows us to add
0001CDA6                            ; a register AND the carry to another register. What this means, is if
0001CDA6                            ; we push 1 into carry (so, carry set), we will be loading $75 instead
0001CDA6                            ; of $74 into the carry, making us able to switch between the Z80
0001CDA6                            ; instructions  "ld  (hl),h" and "ld  (hl),l", which in turn allows
0001CDA6                            ; Dual PCM to bank switch into the appropriate bank.
0001CDA6                            ; ---------------------------------------------------------------------------
0001CDA6                            
0001CDA6                            .loop
0001CDA6 7600                       		moveq	#0,d3			; prepare 0 into d3 (because of addx)
0001CDA8 E248                       		lsr.w	#1,d0			; shift lsb into carry
0001CDAA D701                       		addx.b	d1,d3			; add instruction and carry into d3
0001CDAC                            
0001CDAC 12C3                       		move.b	d3,(a1)+		; save instruction into Z80 memory
0001CDAE 51CA FFF6                  		dbf	d2,.loop		; repeat for each bit/instruction
0001CDB2                            	StartZ80				; enable Z80 execution
0001CDB2 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001CDBA 4E75                       		rts
0001CDBC                            
0001CDBC                            ; ===========================================================================
0001CDBC                            ; ---------------------------------------------------------------------------
0001CDBC                            ; Routine for resetting master volumes, filters and disabling fading
0001CDBC                            ; ---------------------------------------------------------------------------
0001CDBC                            
0001CDBC                            dResetVolume:
0001CDBC 42B8 C4B4                  		clr.l	mFadeAddr.w		; stop fading program and reset FM master volume
0001CDC0 4238 C4BF                  		clr.b	mMasterVolPSG.w		; reset PSG master volume
0001CDC4 4238 C4C0                  		clr.b	mMasterVolDAC.w		; reset DAC master volume
0001CDC8 303C 0000                  		move.w	#fLog>>$0F,d0		; load value for linear filter
0001CDCC 61BC                       		bsr.s	dSetFilter		; load filter instructions
0001CDCE                            
0001CDCE                            dUpdateVolumeAll:
0001CDCE 6100                       		bsr.s	dReqVolUpFM		; request FM volume update
0001CDD0 8138 C67C                  		or.b	d0,mSFXDAC1.w		; request update for SFX DAC1 channel
0001CDD4                            
0001CDD4 =FFFFC4C4                  .ch =	mDAC1					; start at DAC1
0001CDD4                            	rept Mus_DAC				; loop through all music DAC channels
0001CDD4                            		or.b	d0,.ch.w		; request channel volume update
0001CDD4                            .ch =		.ch+cSize			; go to next channel
0001CDD4                            	endr
0001CDD4 8138 C4C4                M 	or.b	d0,.ch.w
0001CDD8 =FFFFC4F0                M .ch	=	.ch+csize
0001CDD8 8138 C4F0                M 	or.b	d0,.ch.w
0001CDDC =FFFFC51C                M .ch	=	.ch+csize
0001CDDC                            
0001CDDC =FFFFC5F8                  .ch =	mPSG1					; start at PSG1
0001CDDC                            	rept Mus_PSG				; loop through all music PSG channels
0001CDDC                            		or.b	d0,.ch.w		; request channel volume update
0001CDDC                            .ch =		.ch+cSize			; go to next channel
0001CDDC                            	endr
0001CDDC 8138 C5F8                M 	or.b	d0,.ch.w
0001CDE0 =FFFFC624                M .ch	=	.ch+csize
0001CDE0 8138 C624                M 	or.b	d0,.ch.w
0001CDE4 =FFFFC650                M .ch	=	.ch+csize
0001CDE4 8138 C650                M 	or.b	d0,.ch.w
0001CDE8 =FFFFC67C                M .ch	=	.ch+csize
0001CDE8                            
0001CDE8 =FFFFC6EC                  .ch =	mSFXPSG1				; start at SFX PSG1
0001CDE8                            	rept SFX_PSG				; loop through all SFX PSG channels
0001CDE8                            		or.b	d0,.ch.w		; request channel volume update
0001CDE8                            .ch =		.ch+cSizeSFX			; go to next channel
0001CDE8                            	endr
0001CDE8 8138 C6EC                M 	or.b	d0,.ch.w
0001CDEC =FFFFC708                M .ch	=	.ch+csizesfx
0001CDEC 8138 C708                M 	or.b	d0,.ch.w
0001CDF0 =FFFFC724                M .ch	=	.ch+csizesfx
0001CDF0 8138 C724                M 	or.b	d0,.ch.w
0001CDF4 =FFFFC740                M .ch	=	.ch+csizesfx
0001CDF4 4E75                       		rts
0001CDF6                            ; ===========================================================================
0001CDF6                            ; ---------------------------------------------------------------------------
0001CDF6                            ; Enable speed shoes mode
0001CDF6                            ; ---------------------------------------------------------------------------
0001CDF6                            
0001CDF6                            dPlaySnd_ShoesOn:
0001CDF6 11F8 C4B9 C4BB             		move.b	mTempoSpeed.w,mTempoCur.w; set tempo accumulator/counter to speed shoes one
0001CDFC 11F8 C4B9 C4BA             		move.b	mTempoSpeed.w,mTempo.w	; set main tempor to speed shoes one
0001CE02 08F8 0001 C4A6             		bset	#mfbSpeed,mFlags.w	; enable speed shoes flag
0001CE08 4E75                       		rts
0001CE0A                            ; ===========================================================================
0001CE0A                            ; ---------------------------------------------------------------------------
0001CE0A                            ; Reset music flags (underwater mode and tempo mode)
0001CE0A                            ; ---------------------------------------------------------------------------
0001CE0A                            
0001CE0A                            dPlaySnd_Reset:
0001CE0A 6100                       		bsr.s	dPlaySnd_OutWater	; gp reset underwater flag and request volume update
0001CE0C                            ; ===========================================================================
0001CE0C                            ; ---------------------------------------------------------------------------
0001CE0C                            ; Disable speed shoes mode
0001CE0C                            ; ---------------------------------------------------------------------------
0001CE0C                            
0001CE0C                            dPlaySnd_ShoesOff:
0001CE0C 11F8 C4B8 C4BB             		move.b	mTempoMain.w,mTempoCur.w; set tempo accumulator/counter to normal one
0001CE12 11F8 C4B8 C4BA             		move.b	mTempoMain.w,mTempo.w	; set main tempor to normal one
0001CE18 08B8 0001 C4A6             		bclr	#mfbSpeed,mFlags.w	; disable speed shoes flag
0001CE1E 4E75                       		rts
0001CE20                            ; ===========================================================================
0001CE20                            ; ---------------------------------------------------------------------------
0001CE20                            ; Enable Underwater mode
0001CE20                            ; ---------------------------------------------------------------------------
0001CE20                            
0001CE20                            dPlaySnd_ToWater:
0001CE20 08F8 0002 C4A6             		bset	#mfbWater,mFlags.w	; enable underwater mode
0001CE26 6000                       		bra.s	dReqVolUpFM		; request FM volume update
0001CE28                            ; ===========================================================================
0001CE28                            ; ---------------------------------------------------------------------------
0001CE28                            ; Disable Underwater mode
0001CE28                            ; ---------------------------------------------------------------------------
0001CE28                            
0001CE28                            dPlaySnd_OutWater:
0001CE28 08B8 0002 C4A6             		bclr	#mfbWater,mFlags.w	; disable underwater mode
0001CE2E                            ; ===========================================================================
0001CE2E                            ; ---------------------------------------------------------------------------
0001CE2E                            ; force volume update on all FM channels
0001CE2E                            ; ---------------------------------------------------------------------------
0001CE2E                            
0001CE2E                            dReqVolUpFM;
0001CE2E 7020                       		moveq	#1<<cfbVol,d0		; prepare volume update flag to d0
0001CE30 =FFFFC51C                  .ch =	mFM1					; start at FM1
0001CE30                            	rept Mus_FM				; loop through all music FM channels
0001CE30                            		or.b	d0,.ch.w		; request channel volume update
0001CE30                            .ch =		.ch+cSize			; go to next channel
0001CE30                            	endr
0001CE30 8138 C51C                M 	or.b	d0,.ch.w
0001CE34 =FFFFC548                M .ch	=	.ch+csize
0001CE34 8138 C548                M 	or.b	d0,.ch.w
0001CE38 =FFFFC574                M .ch	=	.ch+csize
0001CE38 8138 C574                M 	or.b	d0,.ch.w
0001CE3C =FFFFC5A0                M .ch	=	.ch+csize
0001CE3C 8138 C5A0                M 	or.b	d0,.ch.w
0001CE40 =FFFFC5CC                M .ch	=	.ch+csize
0001CE40 8138 C5CC                M 	or.b	d0,.ch.w
0001CE44 =FFFFC5F8                M .ch	=	.ch+csize
0001CE44                            
0001CE44 =FFFFC698                  .ch =	mSFXFM3					; start at SFX FM3
0001CE44                            	rept SFX_FM				; loop through all SFX FM channels
0001CE44                            		or.b	d0,.ch.w		; request channel volume update
0001CE44                            .ch =		.ch+cSizeSFX			; go to next channel
0001CE44                            	endr
0001CE44 8138 C698                M 	or.b	d0,.ch.w
0001CE48 =FFFFC6B4                M .ch	=	.ch+csizesfx
0001CE48 8138 C6B4                M 	or.b	d0,.ch.w
0001CE4C =FFFFC6D0                M .ch	=	.ch+csizesfx
0001CE4C 8138 C6D0                M 	or.b	d0,.ch.w
0001CE50 =FFFFC6EC                M .ch	=	.ch+csizesfx
0001CE50 4E75                       		rts
0001CE52                            ; ===========================================================================
0001CE52                            ; ---------------------------------------------------------------------------
0001CE52                            ; Subroutine for updating Total Levels for FM channel
0001CE52                            ; ---------------------------------------------------------------------------
0001CE52                            
0001CE52                            dUpdateVolFM:
0001CE52 0815 0001                  		btst	#cfbInt,(a5)		; is the channel interrupted by SFX?
0001CE56 6600                       		bne.s	locret_VolFM		; if yes, do not update
0001CE58                            
0001CE58 162D 0009                  		move.b	cVolume(a5),d3		; load FM channel volume to d3
0001CE5C D638 C4B4                  		add.b	mMasterVolFM.w,d3	; add master FM volume to d3
0001CE60 6A00                       		bpl.s	.noover			; if volume did not overflow, skio
0001CE62 767F                       		moveq	#$7F,d3			; force FM volume to silence
0001CE64                            
0001CE64                            .noover
0001CE64 7000                       		moveq	#0,d0
0001CE66 102D 000B                  		move.b	cVoice(a5),d0		; load FM voice ID of the channel to d0
0001CE6A 224E                       		move.l	a6,a1			; copy music voice table address to a1
0001CE6C                            
0001CE6C                            	dCALC_VOICE				; get address of the specific voice to a1
0001CE6C EB48                     M 	lsl.w	#5,d0
0001CE6E D2C0                     M 	add.w	d0,a1
0001CE70 1011                       		move.b	(a1),d0			; load algorithm and feedback to d0
0001CE72 7C00                       		moveq	#0,d6			; reset the modulator offset
0001CE74                            
0001CE74 0838 0002 C4A6             		btst	#mfbWater,mFlags.w	; check if underwater mode is enabled
0001CE7A 6700                       		beq.s	.uwdone			; if not, skip
0001CE7C 1C00                       		move.b	d0,d6			; copy algorithm and feedback to d6
0001CE7E 0246 0007                  		and.w	#7,d6			; mask out everything but the algorithm
0001CE82 D606                       		add.b	d6,d3			; add algorithm to Total Level carrier offset
0001CE84 1C00                       		move.b	d0,d6			; set algorithm and feedback to modulator offset
0001CE86                            
0001CE86                            .uwdone
0001CE86 7A03                       		moveq	#4-1,d5			; prepare 4 operators to d5
0001CE88 D2FC 0019                  		add.w	#VoiceTL,a1		; go to the Total Level offset of the voice
0001CE8C 45FA 0000                  		lea	dOpTLFM(pc),a2		; load Total Level address table to a3
0001CE90                            
0001CE90                            .tlloop
0001CE90 101A                       		move.b	(a2)+,d0		; load YM address to write to
0001CE92 1219                       		move.b	(a1)+,d1		; get Total Level value from voice to d1
0001CE94 6A00                       		bpl.s	.noslot			; if slot operator bit was not set, branch
0001CE96                            
0001CE96 D203                       		add.b	d3,d1			; add carrier offset to loaded value
0001CE98 6B00                       		bmi.s	.slot			; if we did not overflow, branch
0001CE9A 727F                       		moveq	#$7F,d1			; cap to silent volume
0001CE9C 6000                       		bra.s	.slot
0001CE9E                            
0001CE9E                            .noslot
0001CE9E D206                       		add.b	d6,d1			; add modulator offset to loaded value
0001CEA0                            .slot
0001CEA0 4EBA 0000                  		jsr	WriteChYM(pc)		; write Total Level to YM according to channel
0001CEA4                            .ignore
0001CEA4 51CD FFEA                  		dbf	d5,.tlloop		; repeat for each Total Level operator
0001CEA8                            
0001CEA8                            
0001CEA8                            locret_VolFM:
0001CEA8 4E75                       		rts
0001CEAA                            ; ===========================================================================
0001CEAA                            ; ---------------------------------------------------------------------------
0001CEAA                            ; YM2612 register update list
0001CEAA                            ; ---------------------------------------------------------------------------
0001CEAA                            
0001CEAA 3038 343C                  dOpListYM:	dc.b $30, $38, $34, $3C		; Detune, Multiple
0001CEAE 5058 545C                  		dc.b $50, $58, $54, $5C		; Rate Scale, Attack Rate
0001CEB2 6068 646C                  dAMSEn_Ops:	dc.b $60, $68, $64, $6C		; Decay 1 Rate
0001CEB6 7078 747C                  		dc.b $70, $78, $74, $7C		; Decay 2 Rate
0001CEBA 8088 848C                  		dc.b $80, $88, $84, $8C		; Decay 1 level, Release Rate
0001CEBE 9098 949C                  		dc.b $90, $98, $94, $9C		; SSG-EG
0001CEC2 4048 444C                  dOpTLFM:	dc.b $40, $48, $44, $4C		; Total Level
0001CEC6                            ; ===========================================================================
0001CEC6                            ; ---------------------------------------------------------------------------
0001CEC6                            ; Process SFX FM channels
0001CEC6                            ; ---------------------------------------------------------------------------
0001CEC6                            
0001CEC6                            dAMPSdoFMSFX:
0001CEC6 4DFA 0000                  		lea	VoiceBankSFX(pc),a6	; load sound effects voice table into a6
0001CECA 7E02                       		moveq	#SFX_FM-1,d7		; get total number of SFX FM channels to d7
0001CECC                            
0001CECC                            dAMPSnextFMSFX:
0001CECC DAFC 001C                  		add.w	#cSizeSFX,a5		; go to the next channel
0001CED0 4A15                       		tst.b	(a5)			; check if channel is running a tracker
0001CED2 6A00 0000                  		bpl.w	.next			; if not, branch
0001CED6 532D 000C                  		subq.b	#1,cDuration(a5)	; decrease note duration
0001CEDA 6700 0000                  		beq.w	.update			; if timed out, update channel
0001CEDE                            
0001CEDE                            	dCalcFreq				; calculate channel base frequency
0001CEDE 1C2D 0007                M 	move.b	cdetune(a5),d6
0001CEE2 4886                     M 	ext.w	d6
0001CEE4 DC6D 000E                M 	add.w	cfreq(a5),d6
0001CEE8                            	dModulate dAMPSdoPSGSFX, dAMPSnextFMSFX, 1; run modulation code
0001CEE8 0815 0003                M 	btst	#cfbmod,(a5)
0001CEEC 6700                     M 	beq.s	.noret
0001CEEE 4A2D 0010                M 	tst.b	cmoddelay(a5)
0001CEF2 6700                     M 	beq.s	.started
0001CEF4 532D 0010                M 	subq.b	#1,cmoddelay(a5)
0001CEF8                          M .noret
0001CEF8 0895 0005                M 	bclr	#cfbvol,(a5)
0001CEFC 6700                     M 	beq.s	.noupdatevol
0001CEFE 4EBA FF52                M 	jsr	dupdatevolfm(pc)
0001CF02                          M 	.noupdatevol:
0001CF02 51CF FFC8                M 	dbf	d7,dampsnextfmsfx
0001CF06 6000 0000                M 	bra.w	dampsdopsgsfx
0001CF0A                          M .started
0001CF0A 532D 0016                M 	subq.b	#1,cmodspeed(a5)
0001CF0E 66E8                     M 	bne.s	.noret
0001CF10 226D 0010                M 	movea.l	cmod(a5),a1
0001CF14 1B69 0001 0016           M 	move.b	1(a1),cmodspeed(a5)
0001CF1A 4A2D 0018                M 	tst.b	cmodcount(a5)
0001CF1E 6600                     M 	bne.s	.norev
0001CF20 1B69 0003 0018           M 	move.b	3(a1),cmodcount(a5)
0001CF26 442D 0017                M 	neg.b	cmodstep(a5)
0001CF2A                          M .norev
0001CF2A 532D 0018                M 	subq.b	#1,cmodcount(a5)
0001CF2E 1A2D 0017                M 	move.b	cmodstep(a5),d5
0001CF32 4885                     M 	ext.w	d5
0001CF34 DA6D 0014                M 	add.w	cmodfreq(a5),d5
0001CF38 3B45 0014                M 	move.w	d5,cmodfreq(a5)
0001CF3C DC45                     M 	add.w	d5,d6
0001CF3E 6100 0000                  		bsr.w	dUpdateFreqFM3		; send FM frequency to hardware
0001CF42                            
0001CF42 0895 0005                  		bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0001CF46 6700                       		beq.s	.next			; if not, skip
0001CF48 4EBA FF08                  		jsr	dUpdateVolFM(pc)	; update FM volume
0001CF4C                            
0001CF4C                            .next
0001CF4C 51CF FF7E                  		dbf	d7,dAMPSnextFMSFX	; make sure to run all the channels
0001CF50 4EFA 0000                  		jmp	dAMPSdoPSGSFX(pc)	; after that, process SFX PSG channels
0001CF54                            
0001CF54                            .update
0001CF54 0215 00FA                  		and.b	#$FF-(1<<cfbHold)-(1<<cfbRest),(a5); clear hold and rest flags
0001CF58                            	dDoTracker				; process tracker
0001CF58 286D 0002                M 	movea.l	cdata(a5),a4
0001CF5C                          M .data
0001CF5C 7A00                     M 	moveq	#0,d5
0001CF5E 1A1C                     M 	move.b	(a4)+,d5
0001CF60 0C05 00E0                M 	cmpi.b	#$e0,d5
0001CF64 6500                     M 	blo.s	.notcomm
0001CF66 4EBA 0000                M 	jsr	dcommands(pc)
0001CF6A 60F0                     M 	bra.s	.data
0001CF6C 60DE                     M 	bra.s	.next
0001CF6E                          M .notcomm
0001CF6E 4EBA 0000                  		jsr	dKeyOffFM2(pc)		; send key-off command to YM
0001CF72 4A05                       		tst.b	d5			; check if note is being played
0001CF74 6A00                       		bpl.s	.timer			; if not, it must be a timer. branch
0001CF76                            
0001CF76 6100 0000                  		bsr.w	dGetFreqFM		; get frequency
0001CF7A 1A1C                       		move.b	(a4)+,d5		; check next byte
0001CF7C 6A00                       		bpl.s	.timer			; if positive, process a tiemr too
0001CF7E 534C                       		subq.w	#1,a4			; if not, then return back
0001CF80 6000                       		bra.s	.pcnote			; do some extra clearing
0001CF82                            
0001CF82                            .timer
0001CF82 4EBA F5EC                  		jsr	dCalcDuration(pc)	; calculate duration
0001CF86                            .pcnote
0001CF86                            	dProcNote 1, 0				; reset necessary channel memory
0001CF86 2B4C 0002                M 	move.l	a4,cdata(a5)
0001CF8A 1B6D 000D 000C           M 	move.b	clastdur(a5),cduration(a5)
0001CF90 0815 0002                M 	btst	#cfbhold,(a5)
0001CF94 6600                     M 	bne.s	.endpn
0001CF96 0815 0003                M 	btst	#cfbmod,(a5)
0001CF9A 6700                     M 	beq.s	.endpn
0001CF9C 226D 0010                M 	movea.l	cmod(a5),a1
0001CFA0 1B59 0010                M 	move.b	(a1)+,cmoddelay(a5)
0001CFA4 1B59 0016                M 	move.b	(a1)+,cmodspeed(a5)
0001CFA8 1B59 0017                M 	move.b	(a1)+,cmodstep(a5)
0001CFAC 1011                     M 	move.b	(a1),d0
0001CFAE E208                     M 	lsr.b	#1,d0
0001CFB0 1B40 0018                M 	move.b	d0,cmodcount(a5)
0001CFB4 426D 0014                M 	clr.w	cmodfreq(a5)
0001CFB8                          M .endpn
0001CFB8 6100 0000                  		bsr.w	dUpdateFreqFM		; send FM frequency to hardware
0001CFBC                            	dKeyOnFM 1				; send key-on command to YM
0001CFBC 0815 0002                M 	btst	#cfbhold,(a5)
0001CFC0 6600                     M 	bne.s	.k
0001CFC2 0815 0000                M 	btst	#cfbrest,(a5)
0001CFC6 6600                     M 	bne.s	.k
0001CFC8 7028                     M 	moveq	#$28,d0
0001CFCA 122D 0001                M 	move.b	ctype(a5),d1
0001CFCE 0001 00F0                M 	ori.b	#$f0,d1
0001CFD2 6100 0000                M 	bsr.w	writeym_pt1
0001CFD6                          M .k
0001CFD6                            
0001CFD6 0895 0005                  		bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0001CFDA 6700                       		beq.s	.noupdate		; if not, branch
0001CFDC 4EBA FE74                  		jsr	dUpdateVolFM(pc)	; update FM volume
0001CFE0                            
0001CFE0 51CF FEEA                  .noupdate	dbf	d7,dAMPSnextFMSFX	; make sure to run all the channels
0001CFE4 4EFA 0000                  		jmp	dAMPSdoPSGSFX(pc)	; after that, process SFX PSG channels
0001CFE8                            ; ===========================================================================
0001CFE8                            ; ---------------------------------------------------------------------------
0001CFE8                            ; Process music FM channels
0001CFE8                            ; ---------------------------------------------------------------------------
0001CFE8                            
0001CFE8                            dAMPSdoFM:
0001CFE8 4DFA 0000                  		lea	VoiceBankMusic(pc),a6	; load music voice table into a6
0001CFEC 7E04                       		moveq	#Mus_FM-1,d7		; get total number of music FM channels to d7
0001CFEE                            
0001CFEE                            dAMPSnextFM:
0001CFEE DAFC 002C                  		add.w	#cSize,a5		; go to the next channel
0001CFF2 4A15                       		tst.b	(a5)			; check if channel is running a tracker
0001CFF4 6A00 0000                  		bpl.w	.next			; if not, branch
0001CFF8 532D 000C                  		subq.b	#1,cDuration(a5)	; decrease note duration
0001CFFC 6700 0000                  		beq.w	.update			; if timed out, update channel
0001D000                            
0001D000                            	dNoteToutFM.w				; handle FM-specific note timeout behavior
0001D000                          M 	dnotetouthandler
0001D000 4A2D 001C                M 	tst.b	cnotetimecur(a5)
0001D004 6700                     M 	beq.s	.endt
0001D006 532D 001C                M 	subq.b	#1,cnotetimecur(a5)
0001D00A 6600                     M 	bne.s	.endt
0001D00C 08D5 0000                M 	bset	#cfbrest,(a5)
0001D010 6100 0000                M 	bsr.w	dkeyofffm
0001D014 6000 0000                M 	bra.w	.next
0001D018                          M .endt
0001D018                            	dCalcFreq				; calculate channel base frequency
0001D018 1C2D 0007                M 	move.b	cdetune(a5),d6
0001D01C 4886                     M 	ext.w	d6
0001D01E DC6D 000E                M 	add.w	cfreq(a5),d6
0001D022                            	dModulate dAMPSdoPSG, dAMPSnextFM, 0	; run modulation code
0001D022 0815 0003                M 	btst	#cfbmod,(a5)
0001D026 6700                     M 	beq.s	.noret
0001D028 4A2D 0010                M 	tst.b	cmoddelay(a5)
0001D02C 6700                     M 	beq.s	.started
0001D02E 532D 0010                M 	subq.b	#1,cmoddelay(a5)
0001D032                          M .noret
0001D032 0895 0005                M 	bclr	#cfbvol,(a5)
0001D036 6700                     M 	beq.s	.noupdatevol
0001D038 4EBA FE18                M 	jsr	dupdatevolfm(pc)
0001D03C                          M 	.noupdatevol:
0001D03C 51CF FFB0                M 	dbf	d7,dampsnextfm
0001D040 6000 0000                M 	bra.w	dampsdopsg
0001D044                          M .started
0001D044 532D 0016                M 	subq.b	#1,cmodspeed(a5)
0001D048 66E8                     M 	bne.s	.noret
0001D04A 226D 0010                M 	movea.l	cmod(a5),a1
0001D04E 1B69 0001 0016           M 	move.b	1(a1),cmodspeed(a5)
0001D054 4A2D 0018                M 	tst.b	cmodcount(a5)
0001D058 6600                     M 	bne.s	.norev
0001D05A 1B69 0003 0018           M 	move.b	3(a1),cmodcount(a5)
0001D060 442D 0017                M 	neg.b	cmodstep(a5)
0001D064                          M .norev
0001D064 532D 0018                M 	subq.b	#1,cmodcount(a5)
0001D068 1A2D 0017                M 	move.b	cmodstep(a5),d5
0001D06C 4885                     M 	ext.w	d5
0001D06E DA6D 0014                M 	add.w	cmodfreq(a5),d5
0001D072 3B45 0014                M 	move.w	d5,cmodfreq(a5)
0001D076 DC45                     M 	add.w	d5,d6
0001D078 6100 0000                  		bsr.w	dUpdateFreqFM2		; send FM frequency to hardware
0001D07C                            
0001D07C 0895 0005                  		bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0001D080 6700                       		beq.s	.next			; if not, skip
0001D082 4EBA FDCE                  		jsr	dUpdateVolFM(pc)	; update FM volume
0001D086                            
0001D086                            .next
0001D086 51CF FF66                  		dbf	d7,dAMPSnextFM		; make sure to run all the channels
0001D08A 4EFA 0000                  		jmp	dAMPSdoPSG(pc)		; after that, process music PSG channels
0001D08E                            
0001D08E                            .update
0001D08E 0215 00FA                  		and.b	#$FF-(1<<cfbHold)-(1<<cfbRest),(a5); clear hold and rest flags
0001D092                            	dDoTracker				; process tracker
0001D092 286D 0002                M 	movea.l	cdata(a5),a4
0001D096                          M .data
0001D096 7A00                     M 	moveq	#0,d5
0001D098 1A1C                     M 	move.b	(a4)+,d5
0001D09A 0C05 00E0                M 	cmpi.b	#$e0,d5
0001D09E 6500                     M 	blo.s	.notcomm
0001D0A0 4EBA 0000                M 	jsr	dcommands(pc)
0001D0A4 60F0                     M 	bra.s	.data
0001D0A6 60DE                     M 	bra.s	.next
0001D0A8                          M .notcomm
0001D0A8 4EBA 0000                  		jsr	dKeyOffFM(pc)		; send key-off command to YM
0001D0AC 4A05                       		tst.b	d5			; check if note is being played
0001D0AE 6A00                       		bpl.s	.timer			; if not, it must be a timer. branch
0001D0B0                            
0001D0B0 6100 0000                  		bsr.w	dGetFreqFM		; get frequency
0001D0B4 1A1C                       		move.b	(a4)+,d5		; check next byte
0001D0B6 6A00                       		bpl.s	.timer			; if positive, process a tiemr too
0001D0B8 534C                       		subq.w	#1,a4			; if not, then return back
0001D0BA 6000                       		bra.s	.pcnote			; do some extra clearing
0001D0BC                            
0001D0BC                            .timer
0001D0BC 4EBA F4B2                  		jsr	dCalcDuration(pc)	; calculate duration
0001D0C0                            .pcnote
0001D0C0                            	dProcNote 0, 0				; reset necessary channel memory
0001D0C0 2B4C 0002                M 	move.l	a4,cdata(a5)
0001D0C4 1B6D 000D 000C           M 	move.b	clastdur(a5),cduration(a5)
0001D0CA 0815 0002                M 	btst	#cfbhold,(a5)
0001D0CE 6600                     M 	bne.s	.endpn
0001D0D0 1B6D 001D 001C           M 	move.b	cnotetimemain(a5),cnotetimecur(a5)
0001D0D6 0815 0003                M 	btst	#cfbmod,(a5)
0001D0DA 6700                     M 	beq.s	.endpn
0001D0DC 226D 0010                M 	movea.l	cmod(a5),a1
0001D0E0 1B59 0010                M 	move.b	(a1)+,cmoddelay(a5)
0001D0E4 1B59 0016                M 	move.b	(a1)+,cmodspeed(a5)
0001D0E8 1B59 0017                M 	move.b	(a1)+,cmodstep(a5)
0001D0EC 1011                     M 	move.b	(a1),d0
0001D0EE E208                     M 	lsr.b	#1,d0
0001D0F0 1B40 0018                M 	move.b	d0,cmodcount(a5)
0001D0F4 426D 0014                M 	clr.w	cmodfreq(a5)
0001D0F8                          M .endpn
0001D0F8 6100                       		bsr.s	dUpdateFreqFM		; send FM frequency to hardware
0001D0FA                            	dKeyOnFM				; send key-on command to YM
0001D0FA 0815 0002                M 	btst	#cfbhold,(a5)
0001D0FE 6600                     M 	bne.s	.k
0001D100 0815 0000                M 	btst	#cfbrest,(a5)
0001D104 6600                     M 	bne.s	.k
0001D106 0815 0001                M 	btst	#cfbint,(a5)
0001D10A 6600                     M 	bne.s	.k
0001D10C 7028                     M 	moveq	#$28,d0
0001D10E 122D 0001                M 	move.b	ctype(a5),d1
0001D112 0001 00F0                M 	ori.b	#$f0,d1
0001D116 6100 0000                M 	bsr.w	writeym_pt1
0001D11A                          M .k
0001D11A                            
0001D11A 0895 0005                  		bclr	#cfbVol,(a5)		; check if volume update is needed and clear bit
0001D11E 6700                       		beq.s	.noupdate		; if not, branch
0001D120 4EBA FD30                  		jsr	dUpdateVolFM(pc)	; update FM volume
0001D124                            
0001D124                            .noupdate
0001D124 51CF FEC8                  		dbf	d7,dAMPSnextFM		; make sure to run all the channels
0001D128 4EFA 0000                  		jmp	dAMPSdoPSG(pc)		; after that, process music PSG channels
0001D12C                            ; ===========================================================================
0001D12C                            ; ---------------------------------------------------------------------------
0001D12C                            ; Write FM frequency to Dual PCM YMCue
0001D12C                            ; ---------------------------------------------------------------------------
0001D12C                            
0001D12C                            dUpdateFreqFM:
0001D12C 0815 0000                  		btst	#cfbRest,(a5)		; is this channel resting
0001D130 6600                       		bne.s	locret_UpdFreqFM	; if is, skip
0001D132 3C2D 000E                  		move.w	cFreq(a5),d6		; load channel base frequency to d6
0001D136 6700                       		beq.s	dUpdFreqFMrest		; if 0, this channel should be resting
0001D138                            
0001D138 102D 0007                  		move.b	cDetune(a5),d0		; load detune value to d0
0001D13C 4880                       		ext.w	d0			; extend to word
0001D13E DC40                       		add.w	d0,d6			; add to channel base frequency to d6
0001D140                            
0001D140 0815 0003                  		btst	#cfbMod,(a5)		; check if channel is modulating
0001D144 6700                       		beq.s	dUpdateFreqFM2		; if not, branch
0001D146 DC6D 0014                  		add.w	cModFreq(a5),d6		; add channel modulation frequency offset to d6
0001D14A                            
0001D14A                            dUpdateFreqFM2:
0001D14A 0815 0001                  		btst	#cfbInt,(a5)		; is the channel interrupted by SFX?
0001D14E 6600                       		bne.s	locret_UpdFreqFM	; if is, do not update frequency anyway
0001D150                            
0001D150                            dUpdateFreqFM3:
0001D150 3206                       		move.w	d6,d1			; copy frequency to d1
0001D152 E049                       		lsr.w	#8,d1			; shift upper byte into lower byte
0001D154 70A4                       		moveq	#$FFFFFFA4,d0		; YM command: Frequency MSB & Octave
0001D156 4EBA 0000                  		jsr	WriteChYM(pc)		; write to YM according to channel
0001D15A                            
0001D15A 1206                       		move.b	d6,d1			; copy lower byte of frequency into d1 (value)
0001D15C 103C 00A0                  		move.b	#$FFFFFFA0,d0		; YM command: Frequency LSB
0001D160 4EFA 0000                  		jmp	WriteChYM(pc)		; write to YM according to channel
0001D164                            
0001D164                            dUpdFreqFMrest:
0001D164 08D5 0000                  		bset	#cfbRest,(a5)		; set channel resting flag
0001D168                            
0001D168                            locret_UpdFreqFM:
0001D168 4E75                       		rts
0001D16A                            ; ===========================================================================
0001D16A                            ; ---------------------------------------------------------------------------
0001D16A                            ; Process a note in FM channel (enable resting or get frequency)
0001D16A                            ; ---------------------------------------------------------------------------
0001D16A                            
0001D16A                            dGetFreqFM:
0001D16A 0405 0080                  		subi.b	#$80,d5			; sub $80 from the note (notes start at $80)
0001D16E 6600                       		bne.s	.norest			; branch if note wasnt $80 (rest)
0001D170 08D5 0000                  		bset	#cfbRest,(a5)		; set channel resting flag
0001D174 426D 000E                  		clr.w	cFreq(a5)		; set base frequency to 0
0001D178 4E75                       		rts
0001D17A                            
0001D17A                            .norest
0001D17A DA2D 0008                  		add.b	cPitch(a5),d5		; add pitch offset to note
0001D17E 0245 007F                  		andi.w	#$7F,d5			; keep within $80 notes
0001D182 DA45                       		add.w	d5,d5			; double offset (each entry is a word)
0001D184                            
0001D184 43FA 0000                  		lea	dFreqFM(pc),a1		; load FM frequency table to a1
0001D188 3B71 5000 000E             		move.w	(a1,d5.w),cFreq(a5)	; load and save the requested frequency
0001D18E                            
0001D18E 4E75                       		rts
0001D190                            ; ===========================================================================
0001D190                            ; ---------------------------------------------------------------------------
0001D190                            ; Subroutine for doing keying-off FM channel
0001D190                            ; ---------------------------------------------------------------------------
0001D190                            
0001D190                            dKeyOffFM:
0001D190 0815 0001                  		btst	#cfbInt,(a5)		; check if overridden by sfx
0001D194 66D2                       		bne.s	locret_UpdFreqFM	; if so, do not note off
0001D196                            
0001D196                            dKeyOffFM2:
0001D196 0815 0002                  		btst	#cfbHold,(a5)		; check if note is held
0001D19A 66CC                       		bne.s	locret_UpdFreqFM	; if so, do not note off
0001D19C                            
0001D19C 7028                       		moveq	#$28,d0			; YM command: Key on
0001D19E 122D 0001                  		move.b	cType(a5),d1		; get channel type bits (and turn all operators off)
0001D1A2 6000                       		bra.s	WriteYM_Pt1		; write to part 1 channel
0001D1A4                            ; ===========================================================================
0001D1A4                            ; ---------------------------------------------------------------------------
0001D1A4                            ; Write to YMCue according to channel and check if interrupted by sfx
0001D1A4                            ; ---------------------------------------------------------------------------
0001D1A4                            
0001D1A4                            dWriteYMchnInt:
0001D1A4 0815 0001                  		btst	#cfbInt,(a5)		; check if interrupted by sfx
0001D1A8 6600                       		bne.s	WriteYM_Pt1_rts		; if was, do not note on
0001D1AA                            ; ===========================================================================
0001D1AA                            ; ---------------------------------------------------------------------------
0001D1AA                            ; Write to YMCue according to channel
0001D1AA                            ; ---------------------------------------------------------------------------
0001D1AA                            
0001D1AA                            WriteChYM:
0001D1AA 082D 0002 0001             		btst	#ctbPt2,cType(a5)	; check if this is a YM part 1 or 2 channel
0001D1B0 6600                       		bne.s	WriteChYM2		; if part 2, branch
0001D1B2 D02D 0001                  		add.b	cType(a5),d0		; add channel type to address
0001D1B6                            ; ===========================================================================
0001D1B6                            ; ---------------------------------------------------------------------------
0001D1B6                            ; Write to YMCue using part 1
0001D1B6                            ; ---------------------------------------------------------------------------
0001D1B6                            
0001D1B6                            WriteYM_Pt1:
0001D1B6                            	StopZ80					; wait for Z80 to stop
0001D1B6 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001D1BE                          M 	waitz80stop
0001D1BE 0839 0000 00A1 1100      M .wait_340:	btst	#0,z80_bus_req
0001D1C6 66F6                     M 	bne.s	.wait_340
0001D1C8 51D8                       		sf	(a0)+			; set YM port address as 0
0001D1CA 10C1                       		move.b	d1,(a0)+		; write data value to cue
0001D1CC 10C0                       		move.b	d0,(a0)+		; write address to cue
0001D1CE                            	;	st	(a0)			; mark as the end of the cue data
0001D1CE                            	StartZ80				; enable Z80 execution
0001D1CE 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001D1D6                            
0001D1D6                            WriteYM_Pt1_rts:
0001D1D6 4E75                       		rts
0001D1D8                            ; ===========================================================================
0001D1D8                            ; ---------------------------------------------------------------------------
0001D1D8                            ; Write to YMCue according to channel in part 2
0001D1D8                            ; ---------------------------------------------------------------------------
0001D1D8                            
0001D1D8                            WriteChYM2:
0001D1D8 142D 0001                  		move.b	cType(a5),d2		; get channel type to d2
0001D1DC 0882 0002                  		bclr	#ctbPt2,d2		; remove part 2 marker from it
0001D1E0 D002                       		add.b	d2,d0			; add to YM address
0001D1E2                            ; ===========================================================================
0001D1E2                            ; ---------------------------------------------------------------------------
0001D1E2                            ; Write to YMCue using part 2
0001D1E2                            ; ---------------------------------------------------------------------------
0001D1E2                            
0001D1E2                            WriteYM_Pt2:
0001D1E2                            	StopZ80					; wait for Z80 to stop
0001D1E2 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001D1EA                          M 	waitz80stop
0001D1EA 0839 0000 00A1 1100      M .wait_343:	btst	#0,z80_bus_req
0001D1F2 66F6                     M 	bne.s	.wait_343
0001D1F4 10FC 0002                  		move.b	#$02,(a0)+		; set YM port address as 2
0001D1F8 10C1                       		move.b	d1,(a0)+		; write data value to cue
0001D1FA 10C0                       		move.b	d0,(a0)+		; write address to cue
0001D1FC                            	;	st	(a0)			; mark as the end of the cue data
0001D1FC                            	StartZ80				; enable Z80 execution
0001D1FC 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001D204 4E75                       		rts
0001D206                            ; ===========================================================================
0001D206                            ; ---------------------------------------------------------------------------
0001D206                            ; Note to FM frequency conversion table
0001D206                            ; ---------------------------------------------------------------------------
0001D206                            ;	dc.w   C     C#    D     Eb    E     F     F#    G     G#    A     Bb    B
0001D206 025E                       dFreqFM:dc.w								       $025E; Octave-1 - (80)
0001D208 0284 02AB 02D3 02FE 032D+  	dc.w $0284,$02AB,$02D3,$02FE,$032D,$035C,$038F,$03C5,$03FF,$043C,$047C,$0A5E; Octave 0 - (81 - 8C)
0001D220 0A84 0AAB 0AD3 0AFE 0B2D+  	dc.w $0A84,$0AAB,$0AD3,$0AFE,$0B2D,$0B5C,$0B8F,$0BC5,$0BFF,$0C3C,$0C7C,$125E; Octave 1 - (8D - 98)
0001D238 1284 12AB 12D3 12FE 132D+  	dc.w $1284,$12AB,$12D3,$12FE,$132D,$135C,$138F,$13C5,$13FF,$143C,$147C,$1A5E; Octave 2 - (99 - A4)
0001D250 1A84 1AAB 1AD3 1AFE 1B2D+  	dc.w $1A84,$1AAB,$1AD3,$1AFE,$1B2D,$1B5C,$1B8F,$1BC5,$1BFF,$1C3C,$1C7C,$225E; Octave 3 - (A5 - B0)
0001D268 2284 22AB 22D3 22FE 232D+  	dc.w $2284,$22AB,$22D3,$22FE,$232D,$235C,$238F,$23C5,$23FF,$243C,$247C,$2A5E; Octave 4 - (B1 - BC)
0001D280 2A84 2AAB 2AD3 2AFE 2B2D+  	dc.w $2A84,$2AAB,$2AD3,$2AFE,$2B2D,$2B5C,$2B8F,$2BC5,$2BFF,$2C3C,$2C7C,$325E; Octave 5 - (BD - C8)
0001D298 3284 32AB 32D3 32FE 332D+  	dc.w $3284,$32AB,$32D3,$32FE,$332D,$335C,$338F,$33C5,$33FF,$343C,$347C,$3A5E; Octave 6 - (c9 - D4)
0001D2B0 3A84 3AAB 3AD3 3AFE 3B2D+  	dc.w $3A84,$3AAB,$3AD3,$3AFE,$3B2D,$3B5C,$3B8F,$3BC5,$3BFF,$3C3C,$3C7C	    ; Octave 7 - (D5 - DF)
0001D2C6                            dFreqFM_:
0001D2C6                            ; ===========================================================================
0001D2C6                            ; ---------------------------------------------------------------------------
0001D2C6                            ; Note to Dual PCM frequency conversion table
0001D2C6                            ; ---------------------------------------------------------------------------
0001D2C6                            ;	dc.w   C     C#    D     Eb    E     F     F#    G     G#    A     Bb    B
0001D2C6 0000                       dFreqDAC:dc.w $0000								    ; Octave NOPE - (80)
0001D2C8 0010 0011 0012 0013 0014+  	dc.w $0010,$0011,$0012,$0013,$0014,$0015,$0017,$0018,$0019,$001B,$001D,$001E; Octave 0 - (81 - 8C)
0001D2E0 0020 0022 0024 0026 0028+  	dc.w $0020,$0022,$0024,$0026,$0028,$002B,$002D,$0030,$0033,$0036,$0039,$003C; Octave 1 - (8D - 98)
0001D2F8 0040 0044 0048 004C 0051+  	dc.w $0040,$0044,$0048,$004C,$0051,$0055,$005B,$0060,$0066,$006C,$0072,$0079; Octave 2 - (99 - A4)
0001D310 0080 0088 0090 0098 00A1+  	dc.w $0080,$0088,$0090,$0098,$00A1,$00AB,$00B5,$00C0,$00CB,$00D7,$00E4,$00F2; Octave 3 - (A5 - B0)
0001D328 0100 010F 011F 0130 0143+  	dc.w $0100,$010F,$011F,$0130,$0143,$0156,$016A,$0180,$0196,$01AF,$01C8,$01E3; Octave 4 - (B1 - BC)
0001D340 0200 021E 023F 0261 0285+  	dc.w $0200,$021E,$023F,$0261,$0285,$02AB,$02D4,$02FF,$032D,$035D,$0390,$03C7; Octave 5 - (BD - C8)
0001D358 0400 043D 047D 04C2 050A+  	dc.w $0400,$043D,$047D,$04C2,$050A,$0557,$05A8,$05FE,$0659,$06BA,$0721,$078D; Octave 6 - (C9 - D4)
0001D370 0800 087A 08FB 0983 0A14+  	dc.w $0800,$087A,$08FB,$0983,$0A14,$0AAE,$0B50,$0BFD,$0CB3,$0D74,$0E41,$0F1A; Octave 7 - (D5 - E0)
0001D388 0FFF 0FFF 0FFF 0FFF 0FFF+  	dc.w $0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF; Octave 8 - (E1 - EC)
0001D3A0 0FFF 0FFF 0FFF 0FFF 0FFF+  	dc.w $0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF; Octave 9 - (ED - F8)
0001D3B8 0FFF 0FFF 0FFF 0FFF 0FFF+  	dc.w $0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF,$0FFF				    ; Octave 10 -(F9 - FF)
0001D3C6                            
0001D3C6 F001 F001 F001 F001 F001+  	dc.w			     -$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF; Octave -10 -(00 - 07)
0001D3D6 F001 F001 F001 F001 F001+  	dc.w -$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF; Octave -9 - (08 - 13)
0001D3EE F001 F001 F001 F001 F001+  	dc.w -$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF,-$FFF; Octave -8 - (14 - 1F)
0001D406 F0E6 F1BF F28C F34D F403+  	dc.w -$F1A,-$E41,-$D74,-$CB3,-$BFD,-$B50,-$AAE,-$A14,-$983,-$8FB,-$87A,-$800; Octave -7 - (20 - 2B)
0001D41E F873 F8DF F946 F9A7 FA02+  	dc.w -$78D,-$721,-$6BA,-$659,-$5FE,-$5A8,-$557,-$50A,-$4C2,-$47D,-$43D,-$400; Octave -6 - (2C - 37)
0001D436 FC39 FC70 FCA3 FCD3 FD01+  	dc.w -$3C7,-$390,-$35D,-$32D,-$2FF,-$2D4,-$2AB,-$285,-$261,-$23F,-$21E,-$200; Octave -5 - (38 - 43)
0001D44E FE1D FE38 FE51 FE6A FE80+  	dc.w -$1E3,-$1C8,-$1AF,-$196,-$180,-$16A,-$156,-$143,-$130,-$11F,-$10F,-$100; Octave -4 - (44 - 4F)
0001D466 FF0E FF1C FF29 FF35 FF40+  	dc.w -$0F2,-$0E4,-$0D7,-$0CB,-$0C0,-$0B5,-$0AB,-$0A1,-$098,-$090,-$088,-$080; Octave -3 - (50 - 5B)
0001D47E FF87 FF8E FF94 FF9A FFA0+  	dc.w -$079,-$072,-$06C,-$066,-$060,-$05B,-$055,-$051,-$04C,-$048,-$044,-$040; Octave -2 - (5C - 67)
0001D496 FFC4 FFC7 FFCA FFCD FFD0+  	dc.w -$03C,-$039,-$036,-$033,-$030,-$02D,-$02B,-$028,-$026,-$024,-$022,-$020; Octave -1 - (68 - 73)
0001D4AE FFE2 FFE3 FFE5 FFE7 FFE8+  	dc.w -$01E,-$01D,-$01B,-$019,-$018,-$017,-$015,-$014,-$013,-$012,-$011,-$010; Octave -0 - (74 - 7F)
0001D4C6                            ; ===========================================================================
0001D4C6                            ; ---------------------------------------------------------------------------
0001D4C6                            ; Note to PSG frequency conversion table
0001D4C6                            ; ---------------------------------------------------------------------------
0001D4C6                            ;	dc.w	C     C#    D     Eb    E     F     F#    G     G#    A     Bb    B
0001D4C6 0356 0326 02F9 02CE 02A5+  dFreqPSG:dc.w $0356,$0326,$02F9,$02CE,$02A5,$0280,$025C,$023A,$021A,$01FB,$01DF,$01C4; Octave 3 - (81 - 8C)
0001D4DE 01AB 0193 017D 0167 0153+  	dc.w  $01AB,$0193,$017D,$0167,$0153,$0140,$012E,$011D,$010D,$00FE,$00EF,$00E2; Octave 4 - (8D - 98)
0001D4F6 00D6 00C9 00BE 00B4 00A9+  	dc.w  $00D6,$00C9,$00BE,$00B4,$00A9,$00A0,$0097,$008F,$0087,$007F,$0078,$0071; Octave 5 - (99 - A4)
0001D50E 006B 0065 005F 005A 0055+  	dc.w  $006B,$0065,$005F,$005A,$0055,$0050,$004B,$0047,$0043,$0040,$003C,$0039; Octave 6 - (A5 - B0)
0001D526 0036 0033 0030 002D 002B+  	dc.w  $0036,$0033,$0030,$002D,$002B,$0028,$0026,$0024,$0022,$0020,$001F,$001D; Octave 7 - (B1 - BC)
0001D53E 001B 001A 0018 0017 0016+  	dc.w  $001B,$001A,$0018,$0017,$0016,$0015,$0013,$0012,$0011		     ; Notes (BD - C5)
0001D550 0000                       	dc.w  $0000								     ; Note (C6)
0001D552                            dFreqPSG_:
0001D552                            ; ===========================================================================
0001D552                            ; ---------------------------------------------------------------------------
0001D552                            ; Process SFX PSG channels
0001D552                            ; ---------------------------------------------------------------------------
0001D552                            
0001D552                            dAMPSdoPSGSFX:
0001D552 7E02                       		moveq	#SFX_PSG-1,d7		; get total number of SFX PSG channels to d7
0001D554 4DFA FF70                  		lea	dFreqPSG(pc),a6		; load PSG frequency table for quick access to a6
0001D558                            
0001D558                            dAMPSnextPSGSFX:
0001D558 DAFC 001C                  		add.w	#cSizeSFX,a5		; go to the next channel
0001D55C 4A15                       		tst.b	(a5)			; check if channel is running a tracker
0001D55E 6A00                       		bpl.s	.next			; if not, branch
0001D560 532D 000C                  		subq.b	#1,cDuration(a5)	; decrease note duration
0001D564 6700 0000                  		beq.w	.update			; if timed out, update channel
0001D568                            
0001D568                            	dCalcFreq				; calculate channel base frequency
0001D568 1C2D 0007                M 	move.b	cdetune(a5),d6
0001D56C 4886                     M 	ext.w	d6
0001D56E DC6D 000E                M 	add.w	cfreq(a5),d6
0001D572                            	dModulate				; run modulation code
0001D572 0815 0003                M 	btst	#cfbmod,(a5)
0001D576 6700                     M 	beq.s	.noret
0001D578 4A2D 0010                M 	tst.b	cmoddelay(a5)
0001D57C 6700                     M 	beq.s	.started
0001D57E 532D 0010                M 	subq.b	#1,cmoddelay(a5)
0001D582                          M .noret
0001D582 6000                     M 	bra.s	.endm
0001D584                          M .started
0001D584 532D 0016                M 	subq.b	#1,cmodspeed(a5)
0001D588 66F8                     M 	bne.s	.noret
0001D58A 226D 0010                M 	movea.l	cmod(a5),a1
0001D58E 1B69 0001 0016           M 	move.b	1(a1),cmodspeed(a5)
0001D594 4A2D 0018                M 	tst.b	cmodcount(a5)
0001D598 6600                     M 	bne.s	.norev
0001D59A 1B69 0003 0018           M 	move.b	3(a1),cmodcount(a5)
0001D5A0 442D 0017                M 	neg.b	cmodstep(a5)
0001D5A4                          M .norev
0001D5A4 532D 0018                M 	subq.b	#1,cmodcount(a5)
0001D5A8 1A2D 0017                M 	move.b	cmodstep(a5),d5
0001D5AC 4885                     M 	ext.w	d5
0001D5AE DA6D 0014                M 	add.w	cmodfreq(a5),d5
0001D5B2 3B45 0014                M 	move.w	d5,cmodfreq(a5)
0001D5B6 DC45                     M 	add.w	d5,d6
0001D5B8 6100 0000                  		bsr.w	dUpdateFreqPSG3		; if frequency needs changing, do it
0001D5BC                            
0001D5BC                            .endm
0001D5BC 6100 0000                  		bsr.w	dEnvelopePSG		; run envelope program
0001D5C0                            .next
0001D5C0 51CF FF96                  		dbf	d7,dAMPSnextPSGSFX	; make sure to run all the channels
0001D5C4 4EFA 0000                  		jmp	dCheckTracker(pc)	; after that, check tracker and end loop
0001D5C8                            
0001D5C8                            .update
0001D5C8 0215 00FA                  		and.b	#$FF-(1<<cfbHold)-(1<<cfbRest),(a5); clear hold and rest flags
0001D5CC                            	dDoTracker				; process tracker
0001D5CC 286D 0002                M 	movea.l	cdata(a5),a4
0001D5D0                          M .data
0001D5D0 7A00                     M 	moveq	#0,d5
0001D5D2 1A1C                     M 	move.b	(a4)+,d5
0001D5D4 0C05 00E0                M 	cmpi.b	#$e0,d5
0001D5D8 6500                     M 	blo.s	.notcomm
0001D5DA 4EBA 0000                M 	jsr	dcommands(pc)
0001D5DE 60F0                     M 	bra.s	.data
0001D5E0 60DE                     M 	bra.s	.next
0001D5E2                          M .notcomm
0001D5E2 4A05                       		tst.b	d5			; check if note is being played
0001D5E4 6A00                       		bpl.s	.timer			; if not, it must be a timer. Branch
0001D5E6                            
0001D5E6                            	dGetFreqPSG				; get PSG frequency
0001D5E6 0405 0081                M 	subi.b	#$81,d5
0001D5EA 6400                     M 	bhs.s	.norest
0001D5EC 08D5 0000                M 	bset	#cfbrest,(a5)
0001D5F0 3B7C FFFF 000E           M 	move.w	#-1,cfreq(a5)
0001D5F6 4EBA 0000                M 	jsr	dmutepsgmus(pc)
0001D5FA 6000                     M 	bra.s	.freqgot
0001D5FC                          M .norest
0001D5FC DA2D 0008                M 	add.b	cpitch(a5),d5
0001D600 0245 007F                M 	andi.w	#$7f,d5
0001D604 DA45                     M 	add.w	d5,d5
0001D606 3B76 5000 000E           M 	move.w	(a6,d5.w),cfreq(a5)
0001D60C                          M .freqgot
0001D60C 1A1C                       		move.b	(a4)+,d5		; check if next note is a timer
0001D60E 6A00                       		bpl.s	.timer			; if yes, handle timer
0001D610 534C                       		subq.w	#1,a4			; else, undo the increment
0001D612 6000                       		bra.s	.pcnote			; do not calculate duration
0001D614                            
0001D614                            .timer
0001D614 4EBA EF5A                  		jsr	dCalcDuration(pc)	; calculate duration
0001D618                            .pcnote
0001D618                            	dProcNote 1, 1				; reset necessary channel memory
0001D618 2B4C 0002                M 	move.l	a4,cdata(a5)
0001D61C 1B6D 000D 000C           M 	move.b	clastdur(a5),cduration(a5)
0001D622 0815 0002                M 	btst	#cfbhold,(a5)
0001D626 6600                     M 	bne.s	.endpn
0001D628 422D 0006                M 	clr.b	cenvpos(a5)
0001D62C 0815 0003                M 	btst	#cfbmod,(a5)
0001D630 6700                     M 	beq.s	.endpn
0001D632 226D 0010                M 	movea.l	cmod(a5),a1
0001D636 1B59 0010                M 	move.b	(a1)+,cmoddelay(a5)
0001D63A 1B59 0016                M 	move.b	(a1)+,cmodspeed(a5)
0001D63E 1B59 0017                M 	move.b	(a1)+,cmodstep(a5)
0001D642 1011                     M 	move.b	(a1),d0
0001D644 E208                     M 	lsr.b	#1,d0
0001D646 1B40 0018                M 	move.b	d0,cmodcount(a5)
0001D64A 426D 0014                M 	clr.w	cmodfreq(a5)
0001D64E                          M .endpn
0001D64E                            
0001D64E 6100 0000                  		bsr.w	dUpdateFreqPSG		; update hardware frequency
0001D652 6100 0000                  		bsr.w	dEnvProgPSG		; run envelope program
0001D656 51CF FF00                  		dbf	d7,dAMPSnextPSGSFX	; make sure to run all the channels
0001D65A                            	; continue to check tracker and end loop
0001D65A                            ; ===========================================================================
0001D65A                            ; ---------------------------------------------------------------------------
0001D65A                            ; End channel loop and check if tracker debugger should be opened
0001D65A                            ; ---------------------------------------------------------------------------
0001D65A                            
0001D65A                            dCheckTracker:
0001D65A                            .rts
0001D65A 4E75                       		rts
0001D65C                            ; ===========================================================================
0001D65C                            ; ---------------------------------------------------------------------------
0001D65C                            ; Music PSG channel loop
0001D65C                            ; ---------------------------------------------------------------------------
0001D65C                            
0001D65C                            dAMPSdoPSG:
0001D65C 7E02                       		moveq	#Mus_PSG-1,d7		; get total number of music PSG channels to d7
0001D65E 4DFA FE66                  		lea	dFreqPSG(pc),a6		; load PSG frequency table for quick access to a6
0001D662                            
0001D662                            dAMPSnextPSG:
0001D662 DAFC 002C                  		add.w	#cSize,a5		; go to the next channe
0001D666 4A15                       		tst.b	(a5)			; check if channel is running a tracker
0001D668 6A00 0000                  		bpl.w	.next			; if not, branch
0001D66C 532D 000C                  		subq.b	#1,cDuration(a5)	; decrease note duration
0001D670 6700 0000                  		beq.w	.update			; if timed out, update channel
0001D674                            
0001D674                            	dNoteToutPSG				; handle PSG-specific note timeout behavior
0001D674                          M 	dnotetouthandler
0001D674 4A2D 001C                M 	tst.b	cnotetimecur(a5)
0001D678 6700                     M 	beq.s	.endt
0001D67A 532D 001C                M 	subq.b	#1,cnotetimecur(a5)
0001D67E 6600                     M 	bne.s	.endt
0001D680 08D5 0000                M 	bset	#cfbrest,(a5)
0001D684 6100 0000                M 	bsr.w	dmutepsgmus
0001D688 6000                     M 	bra.s	.next
0001D68A                          M .endt
0001D68A                            	dCalcFreq				; calculate channel base frequency
0001D68A 1C2D 0007                M 	move.b	cdetune(a5),d6
0001D68E 4886                     M 	ext.w	d6
0001D690 DC6D 000E                M 	add.w	cfreq(a5),d6
0001D694                            	dModulate				; run modulation code
0001D694 0815 0003                M 	btst	#cfbmod,(a5)
0001D698 6700                     M 	beq.s	.noret
0001D69A 4A2D 0010                M 	tst.b	cmoddelay(a5)
0001D69E 6700                     M 	beq.s	.started
0001D6A0 532D 0010                M 	subq.b	#1,cmoddelay(a5)
0001D6A4                          M .noret
0001D6A4 6000                     M 	bra.s	.endm
0001D6A6                          M .started
0001D6A6 532D 0016                M 	subq.b	#1,cmodspeed(a5)
0001D6AA 66F8                     M 	bne.s	.noret
0001D6AC 226D 0010                M 	movea.l	cmod(a5),a1
0001D6B0 1B69 0001 0016           M 	move.b	1(a1),cmodspeed(a5)
0001D6B6 4A2D 0018                M 	tst.b	cmodcount(a5)
0001D6BA 6600                     M 	bne.s	.norev
0001D6BC 1B69 0003 0018           M 	move.b	3(a1),cmodcount(a5)
0001D6C2 442D 0017                M 	neg.b	cmodstep(a5)
0001D6C6                          M .norev
0001D6C6 532D 0018                M 	subq.b	#1,cmodcount(a5)
0001D6CA 1A2D 0017                M 	move.b	cmodstep(a5),d5
0001D6CE 4885                     M 	ext.w	d5
0001D6D0 DA6D 0014                M 	add.w	cmodfreq(a5),d5
0001D6D4 3B45 0014                M 	move.w	d5,cmodfreq(a5)
0001D6D8 DC45                     M 	add.w	d5,d6
0001D6DA 6100 0000                  		bsr.w	dUpdateFreqPSG2		; if frequency needs changing, do it
0001D6DE                            
0001D6DE                            .endm
0001D6DE 6100 0000                  		bsr.w	dEnvelopePSG		; run envelope program
0001D6E2                            .next
0001D6E2 51CF FF7E                  		dbf	d7,dAMPSnextPSG		; make sure to run all the channels
0001D6E6 4EFA EEA0                  		jmp	dAMPSdoDACSFX(pc)	; after that, process SFX DAC channels
0001D6EA                            
0001D6EA                            .update
0001D6EA 0215 00FA                  		and.b	#$FF-(1<<cfbHold)-(1<<cfbRest),(a5); clear hold and rest flags
0001D6EE                            	dDoTracker				; process tracker
0001D6EE 286D 0002                M 	movea.l	cdata(a5),a4
0001D6F2                          M .data
0001D6F2 7A00                     M 	moveq	#0,d5
0001D6F4 1A1C                     M 	move.b	(a4)+,d5
0001D6F6 0C05 00E0                M 	cmpi.b	#$e0,d5
0001D6FA 6500                     M 	blo.s	.notcomm
0001D6FC 4EBA 0000                M 	jsr	dcommands(pc)
0001D700 60F0                     M 	bra.s	.data
0001D702 60DE                     M 	bra.s	.next
0001D704                          M .notcomm
0001D704 4A05                       		tst.b	d5			; check if note is being played
0001D706 6A00                       		bpl.s	.timer			; if not, it must be a timer. branch
0001D708                            
0001D708                            	dGetFreqPSG				; get PSG frequency
0001D708 0405 0081                M 	subi.b	#$81,d5
0001D70C 6400                     M 	bhs.s	.norest
0001D70E 08D5 0000                M 	bset	#cfbrest,(a5)
0001D712 3B7C FFFF 000E           M 	move.w	#-1,cfreq(a5)
0001D718 4EBA 0000                M 	jsr	dmutepsgmus(pc)
0001D71C 6000                     M 	bra.s	.freqgot
0001D71E                          M .norest
0001D71E DA2D 0008                M 	add.b	cpitch(a5),d5
0001D722 0245 007F                M 	andi.w	#$7f,d5
0001D726 DA45                     M 	add.w	d5,d5
0001D728 3B76 5000 000E           M 	move.w	(a6,d5.w),cfreq(a5)
0001D72E                          M .freqgot
0001D72E 1A1C                       		move.b	(a4)+,d5		; check if next note is a timer
0001D730 6A00                       		bpl.s	.timer			; if yes, handle timer
0001D732 534C                       		subq.w	#1,a4			; else, undo the increment
0001D734 6000                       		bra.s	.pcnote			; do not calculate duration
0001D736                            
0001D736                            .timer
0001D736 4EBA EE38                  		jsr	dCalcDuration(pc)	; calculate duration
0001D73A                            .pcnote
0001D73A                            	dProcNote 0, 1				; reset necessary channel memory
0001D73A 2B4C 0002                M 	move.l	a4,cdata(a5)
0001D73E 1B6D 000D 000C           M 	move.b	clastdur(a5),cduration(a5)
0001D744 0815 0002                M 	btst	#cfbhold,(a5)
0001D748 6600                     M 	bne.s	.endpn
0001D74A 1B6D 001D 001C           M 	move.b	cnotetimemain(a5),cnotetimecur(a5)
0001D750 422D 0006                M 	clr.b	cenvpos(a5)
0001D754 0815 0003                M 	btst	#cfbmod,(a5)
0001D758 6700                     M 	beq.s	.endpn
0001D75A 226D 0010                M 	movea.l	cmod(a5),a1
0001D75E 1B59 0010                M 	move.b	(a1)+,cmoddelay(a5)
0001D762 1B59 0016                M 	move.b	(a1)+,cmodspeed(a5)
0001D766 1B59 0017                M 	move.b	(a1)+,cmodstep(a5)
0001D76A 1011                     M 	move.b	(a1),d0
0001D76C E208                     M 	lsr.b	#1,d0
0001D76E 1B40 0018                M 	move.b	d0,cmodcount(a5)
0001D772 426D 0014                M 	clr.w	cmodfreq(a5)
0001D776                          M .endpn
0001D776                            
0001D776 6100                       		bsr.s	dUpdateFreqPSG		; update hardware frequency
0001D778 6100 0000                  		bsr.w	dEnvProgPSG		; run envelope program
0001D77C 51CF FEE4                  		dbf	d7,dAMPSnextPSG		; make sure to run all the channels
0001D780 4EFA EE06                  		jmp	dAMPSdoDACSFX(pc)	; after that, process SFX DAC channels
0001D784                            ; ===========================================================================
0001D784                            ; ---------------------------------------------------------------------------
0001D784                            ; Write PSG frequency to hardware
0001D784                            ; ---------------------------------------------------------------------------
0001D784                            
0001D784                            dUpdateFreqPSG:
0001D784 3C2D 000E                  		move.w	cFreq(a5),d6		; get channel base frequency to d6
0001D788 6A00                       		bpl.s	.detune			; if it was not rest frequency, branch
0001D78A 08D5 0000                  		bset	#cfbRest,(a5)		; set channel resting flag
0001D78E 4E75                       		rts
0001D790                            
0001D790                            .detune
0001D790 102D 0007                  		move.b	cDetune(a5),d0		; load detune value to d0
0001D794 4880                       		ext.w	d0			; extend to word
0001D796 DC40                       		add.w	d0,d6			; add to channel base frequency to d6
0001D798                            
0001D798 0815 0003                  		btst	#cfbMod,(a5)		; check if channel is modulating
0001D79C 6700                       		beq.s	dUpdateFreqPSG2		; if not, branch
0001D79E DC6D 0014                  		add.w	cModFreq(a5),d6		; add modulation frequency offset to d6
0001D7A2                            
0001D7A2                            dUpdateFreqPSG2:
0001D7A2 0815 0001                  		btst	#cfbInt,(a5)		; is channel interrupted by sfx?
0001D7A6 6600                       		bne.s	locret_dUpdateFreqPSG	; if so, skip
0001D7A8                            
0001D7A8                            dUpdateFreqPSG3:
0001D7A8 0815 0000                  		btst	#cfbRest,(a5)		; is this channel resting
0001D7AC 6600                       		bne.s	locret_dUpdateFreqPSG	; if so, skip
0001D7AE                            
0001D7AE 102D 0001                  		move.b	cType(a5),d0		; load channel type value to d0
0001D7B2 0C00 00E0                  		cmpi.b	#ctPSG4,d0		; check if this channel is in PSG4 mode
0001D7B6 6600                       		bne.s	.notPSG4		; if not, branch
0001D7B8 70C0                       		moveq	#$FFFFFF00|ctPSG3,d0	; load PSG3 type value instead
0001D7BA                            
0001D7BA                            .notPSG4
0001D7BA 3206                       		move.w	d6,d1			; copy frequency to d1
0001D7BC 0201 000F                  		andi.b	#$F,d1			; get the low nibble of it
0001D7C0 8001                       		or.b	d1,d0			; combine with channel type
0001D7C2                            ; ---------------------------------------------------------------------------
0001D7C2                            ; Note about the and instruction below: If this instruction is
0001D7C2                            ; not commented out, the instashield SFX will not sound correct.
0001D7C2                            ; This instruction was removed in Sonic 3K because of this, but
0001D7C2                            ; this can cause issues when values overflow the valid range of
0001D7C2                            ; PSG frequency. This may cause erroneous behavior if not anded,
0001D7C2                            ; but will also make the instashield SFX not sound correctly.
0001D7C2                            ; Comment out the instruction with caution, if you are planning
0001D7C2                            ; to port said sound effect to this driver. This has not caused
0001D7C2                            ; any issues for me, and if you are careful you can avoid any
0001D7C2                            ; such case, but beware of this issue!
0001D7C2                            ; ---------------------------------------------------------------------------
0001D7C2                            
0001D7C2 E84E                       		lsr.w	#4,d6			; get the 2 higher nibbles of frequency
0001D7C4 0206 003F                  		andi.b	#$3F,d6			; clear any extra bits that aren't valid
0001D7C8 13C0 00C0 0011             		move.b	d0,dPSG			; write frequency low nibble and latch channel
0001D7CE 13C6 00C0 0011             		move.b	d6,dPSG			; write frequency high nibbles to PSG
0001D7D4                            
0001D7D4                            locret_dUpdateFreqPSG:
0001D7D4 4E75                       		rts
0001D7D6                            ; ===========================================================================
0001D7D6                            ; ---------------------------------------------------------------------------
0001D7D6                            ; Routine for running envelope programs
0001D7D6                            ; ---------------------------------------------------------------------------
0001D7D6                            
0001D7D6                            dEnvProgPSG:
0001D7D6 1A2D 0009                  		move.b	cVolume(a5),d5		; load channel volume to d5
0001D7DA DA38 C4BF                  		add.b	mMasterVolPSG.w,d5	; add PSG master volume to d5
0001D7DE                            
0001D7DE 7800                       		moveq	#0,d4
0001D7E0 182D 000B                  		move.b	cVolEnv(a5),d4		; load volume envelope ID to d4
0001D7E4 6700                       		beq.s	dUpdateVolPSG2		; if 0, update volume only
0001D7E6 6000                       		bra.s	dEnvProgPSG2		; continue to run code below
0001D7E8                            
0001D7E8                            dEnvelopePSG:
0001D7E8 7800                       		moveq	#0,d4
0001D7EA 182D 000B                  		move.b	cVolEnv(a5),d4		; load volume envelope ID to d4
0001D7EE 6700                       		beq.s	locret_UpdVolPSG	; if 0, return
0001D7F0                            
0001D7F0 1A2D 0009                  		move.b	cVolume(a5),d5		; load channel volume to d5
0001D7F4 DA38 C4BF                  		add.b	mMasterVolPSG.w,d5	; add PSG master volume to d5
0001D7F8                            
0001D7F8                            dEnvProgPSG2:
0001D7F8                            
0001D7F8 43FA 0000                  		lea	VolEnvs-4(pc),a1	; load volume envelope data array
0001D7FC D844                       		add.w	d4,d4			; quadruple volume envelope ID
0001D7FE D844                       		add.w	d4,d4			; (each entry is 4 bytes in size)
0001D800 2271 4000                  		move.l	(a1,d4.w),a1		; get pointer to volume envelope data
0001D804                            
0001D804 7200                       		moveq	#0,d1
0001D806 7000                       		moveq	#0,d0
0001D808                            
0001D808                            dEnvProgPSG3:
0001D808 122D 0006                  		move.b	cEnvPos(a5),d1		; get envelope position to d1
0001D80C 1031 1000                  		move.b	(a1,d1.w),d0		; get the date in that position
0001D810 6B00                       		bmi.s	dEnvCommand		; if it is a command, handle it
0001D812                            
0001D812 522D 0006                  		addq.b	#1,cEnvPos(a5)		; increment envelope position
0001D816 DA00                       		add.b	d0,d5			; add envelope volume to d5
0001D818                            	; continue to update PSG volume
0001D818                            ; ===========================================================================
0001D818                            ; ---------------------------------------------------------------------------
0001D818                            ; Routine for updating PSG volume to hardware
0001D818                            ; ---------------------------------------------------------------------------
0001D818                            
0001D818                            dUpdateVolPSG2:
0001D818 0C05 000F                  		cmpi.b	#$F,d5			; check if volume is out of range
0001D81C 6300                       		bls.s	dUpdateVolPSG		; if not, branch
0001D81E 7A0F                       		moveq	#$F,d5			; cap volume to silent
0001D820                            
0001D820                            dUpdateVolPSG:
0001D820 0815 0000                  		btst	#cfbRest,(a5)		; is this channel resting
0001D824 6600                       		bne.s	locret_UpdVolPSG	; if is, do not update
0001D826 0815 0001                  		btst	#cfbInt,(a5)		; is channel interrupted by sfx?
0001D82A 6600                       		bne.s	locret_UpdVolPSG	; if is, do not update
0001D82C                            
0001D82C 0815 0002                  		btst	#cfbHold,(a5)		; check if note is held
0001D830 6700                       		beq.s	dUpdVolPSGset		; if not, update volume
0001D832 BAFC C67C                  		cmp.w	#mSFXDAC1,a5		; check if this is a SFX channel
0001D836 6400                       		bhs.s	dUpdVolPSGset		; if so, update volume
0001D838                            
0001D838 4A2D 001D                  		tst.b	cNoteTimeMain(a5)	; check if note timeout is active
0001D83C 6700                       		beq.s	dUpdVolPSGset		; if not, update volume
0001D83E 4A2D 001C                  		tst.b	cNoteTimeCur(a5)	; is note stopped already?
0001D842 6700                       		beq.s	locret_UpdVolPSG	; if is, do not update
0001D844                            
0001D844                            dUpdVolPSGset:
0001D844 8A2D 0001                  		or.b	cType(a5),d5		; combine channel type value with volume
0001D848 0605 0010                  		addi.b	#$10,d5			; set volume update bit
0001D84C 13C5 00C0 0011             		move.b	d5,dPSG			; write volume command to PSG port
0001D852                            
0001D852                            locret_UpdVolPSG:
0001D852 4E75                       		rts
0001D854                            ; ===========================================================================
0001D854                            ; ---------------------------------------------------------------------------
0001D854                            ; Subroutine for handling volume envelope commands
0001D854                            ; ---------------------------------------------------------------------------
0001D854                            
0001D854                            dEnvCommand:
0001D854                            
0001D854 4EFB 0000                  		jmp	.comm-$80(pc,d0.w)	; jump to command handler
0001D858                            
0001D858                            .comm
0001D858 6000                       		bra.s	.reset			; 80 - Loop back to beginning
0001D85A 6000                       		bra.s	.hold			; 82 - Hold the envelope at current level
0001D85C 6000                       		bra.s	.loop			; 84 - Go to position defined by the next byte
0001D85E                            	;	bra.s	.stop			; 86 - Stop current note and envelope
0001D85E                            ; ---------------------------------------------------------------------------
0001D85E                            
0001D85E                            .stop
0001D85E 08D5 0000                  		bset	#cfbRest,(a5)		; set channel resting bit
0001D862 6000                       		bra.s	dMutePSGmus		; nute the channel
0001D864                            ; ---------------------------------------------------------------------------
0001D864                            
0001D864                            .hold
0001D864 532D 0006                  		subq.b	#1,cEnvPos(a5)		; decrease envelope position
0001D868 4EFA FF9E                  		jmp	dEnvProgPSG3(pc)	; run the program again (make sure volume fades work)
0001D86C                            ; ---------------------------------------------------------------------------
0001D86C                            
0001D86C                            .reset
0001D86C 422D 0006                  		clr.b	cEnvPos(a5)		; set envelope position to 0
0001D870 4EFA FF96                  		jmp	dEnvProgPSG3(pc)	; run the program again
0001D874                            ; ---------------------------------------------------------------------------
0001D874                            
0001D874                            .loop
0001D874 1B71 1001 0006             		move.b	1(a1,d1.w),cEnvPos(a5)	; set envelope position to the next byte
0001D87A 4EFA FF8C                  		jmp	dEnvProgPSG3(pc)	; run the program again
0001D87E                            ; ===========================================================================
0001D87E                            ; ---------------------------------------------------------------------------
0001D87E                            ; Routine for hardware muting a PSG channel
0001D87E                            ; ---------------------------------------------------------------------------
0001D87E                            
0001D87E                            dMutePSGmus:
0001D87E 0815 0001                  		btst	#cfbInt,(a5)		; check if this is a SFX channel
0001D882 6600                       		bne.s	locret_MutePSG		; if yes, do not update
0001D884                            
0001D884                            dMutePSGsfx:
0001D884 701F                       		moveq	#$1F,d0			; prepare volume update to mute value to d0
0001D886 802D 0001                  		or.b	cType(a5),d0		; combine channel type value with d0
0001D88A 13C0 00C0 0011             		move.b	d0,dPSG			; write volume command to PSG port
0001D890                            
0001D890                            locret_MutePSG:
0001D890 4E75                       		rts
0001D892                            
0001D892 414D 5053 2031 2E30        	dc.b "AMPS 1.0"				; not required, just here to make my life easier
0001D89A                            ; ===========================================================================
0001D89A                            ; ---------------------------------------------------------------------------
0001D89A                            ; Routine to execute tracker commands
0001D89A                            ;
0001D89A                            ; The reason we use add.b instead of add.w, is to get rid of some bits that
0001D89A                            ; would make this kind of arbitary jumping way more complex than it needs to be.
0001D89A                            ; What do we win by doing this? Why, 8 cycles per command! Thats... Not a lot,
0001D89A                            ; but it may be helpful with speed anyway.
0001D89A                            ; ---------------------------------------------------------------------------
0001D89A                            
0001D89A                            dCommands:
0001D89A DA05                       		add.b	d5,d5			; quadruple command ID
0001D89C DA05                       		add.b	d5,d5			; since each entry is 4 bytes large
0001D89E                            
0001D89E 0815 0004                  		btst	#cfbCond,(a5)		; check if condition state
0001D8A2 6600 0000                  		bne.w	.falsecomm		; branch if false
0001D8A6 4EFB 5000                  		jmp	.comm-$80(pc,d5.w)	; jump to appropriate handler
0001D8AA                            ; ===========================================================================
0001D8AA                            ; ---------------------------------------------------------------------------
0001D8AA                            ; Command handlers for normal execution
0001D8AA                            ; ---------------------------------------------------------------------------
0001D8AA                            
0001D8AA                            .comm
0001D8AA 6000 0000                  	bra.w	dcPan		; E0 - Panning, AMS, FMS (PANAFMS - PAFMS_PAN)
0001D8AE 6000 0000                  	bra.w	dcsDetune	; E1 - Set channel frequency displacement to xx (DETUNE_SET)
0001D8B2 6000 0000                  	bra.w	dcaDetune	; E2 - Add xx to channel frequency displacement (DETUNE)
0001D8B6 6000 0000                  	bra.w	dcsTransp	; E3 - Set channel pitch to xx (TRANSPOSE - TRNSP_SET)
0001D8BA 6000 0000                  	bra.w	dcaTransp	; E4 - Add xx to channel pitch (TRANSPOSE - TRNSP_ADD)
0001D8BE 6000 0000                  	bra.w	dcsTmulCh	; E5 - Set channel tick multiplier to xx (TICK_MULT - TMULT_CUR)
0001D8C2 6000 0000                  	bra.w	dcsTmul		; E6 - Set global tick multiplier to xx (TICK_MULT - TMULT_ALL)
0001D8C6 6000 0000                  	bra.w	dcHold		; E7 - Do not allow note on/off for next note (HOLD)
0001D8CA 6000 0000                  	bra.w	dcVoice		; E8 - Set Voice/voice/sample to xx (INSTRUMENT - INS_C_FM / INS_C_PSG / INS_C_DAC)
0001D8CE 6000 0000                  	bra.w	dcsTempoShoes	; E9 - Set music speed shoes tempo to xx (TEMPO - TEMPO_SET_SPEED)
0001D8D2 6000 0000                  	bra.w	dcsTempo	; EA - Set music tempo to xx (TEMPO - TEMPO_SET)
0001D8D6 6000 0000                  	bra.w	dcModOn		; EB - Turn on Modulation (MOD_SET - MODS_ON)
0001D8DA 6000 0000                  	bra.w	dcModOff	; EC - Turn off Modulation (MOD_SET - MODS_OFF)
0001D8DE 6000 0000                  	bra.w	dcaVolume	; ED - Add xx to channel volume (VOLUME - VOL_CN_FM / VOL_CN_PSG / VOL_CN_DAC)
0001D8E2 6000 0000                  	bra.w	dcsVolume	; EE - Set channel volume to xx (VOLUME - VOL_CN_ABS)
0001D8E6 6000 0000                  	bra.w	dcsLFO		; EF - Set LFO (SET_LFO - LFO_AMSEN)
0001D8EA 6000 0000                  	bra.w	dcMod68K	; F0 - Modulation (MOD_SETUP)
0001D8EE 6000 0000                  	bra.w	dcSampDAC	; F1 - Use sample DAC mode (DAC_MODE - DACM_SAMP)
0001D8F2 6000 0000                  	bra.w	dcPitchDAC	; F2 - Use pitch DAC mode (DAC_MODE - DACM_NOTE)
0001D8F6 6000 0000                  	bra.w	dcNoisePSG	; F3 - PSG4 mode to xx (PSG_NOISE - PNOIS_AMPS)
0001D8FA 6000 0000                  	bra.w	dcCont		; F4 - Do a continuous SFX loop (CONT_SFX)
0001D8FE 6000 0000                  	bra.w	dcStop		; F5 - End of channel (TRK_END - TEND_STD)
0001D902 6000 0000                  	bra.w	dcJump		; F6 - Jump to xxxx (GOTO)
0001D906 6000 0000                  	bra.w	dcLoop		; F7 - Loop back to zzzz yy times, xx being the loop index (LOOP)
0001D90A 6000 0000                  	bra.w	dcCall		; F8 - Call pattern at xxxx, saving return point (GOSUB)
0001D90E 6000 0000                  	bra.w	dcReturn	; F9 - Return (RETURN)
0001D912 6000 0000                  	bra.w	dcsComm		; FA - Set communications byte yy to xx (SET_COMM - SPECIAL)
0001D916 6000 0000                  	bra.w	dcCond		; FB - Get comms byte y, and compare zz using condition x (COMM_CONDITION)
0001D91A 6000 0000                  	bra.w	dcResetCond	; FC - Reset condition (COMM_RESET)
0001D91E 6000 0000                  	bra.w	dcTimeout	; FD - Stop note after xx frames (NOTE_STOP - NSTOP_NORMAL
0001D922 6000 0000                  	bra.w	dcYM		; FE - YM command (YMCMD)
0001D926                            				; FF - META
0001D926                            ; ===========================================================================
0001D926                            ; ---------------------------------------------------------------------------
0001D926                            ; Routine to execute tracker meta and false condition commands
0001D926                            ; ---------------------------------------------------------------------------
0001D926                            
0001D926                            .metacall
0001D926 1A1C                       		move.b	(a4)+,d5		; get next command byte
0001D928 DA45                       		add.w	d5,d5			; quadruple ID
0001D92A DA45                       		add.w	d5,d5			; since each entry is again 4 bytes large
0001D92C 4EFB 5000                  		jmp	.meta(pc,d5.w)		; jump to appropriate meta handler
0001D930                            
0001D930                            .falsecomm
0001D930 4EFB 5000                  		jmp	.false-$80(pc,d5.w)	; jump to appropriate handler (false command)
0001D934                            ; ===========================================================================
0001D934                            ; ---------------------------------------------------------------------------
0001D934                            ; Command handlers for meta commands
0001D934                            ; ---------------------------------------------------------------------------
0001D934                            
0001D934                            .meta
0001D934 6000 0000                  	bra.w	dcWriteDAC1	; FF 00 - Play sample xx on DAC1 (PLAY_DAC - PLAY_DAC1)
0001D938 6000 0000                  	bra.w	dcWriteDAC2	; FF 01 - Play sample xx on DAC2 (PLAY_DAC - PLAY_DAC2)
0001D93C 6000 0000                  	bra.w	dcsFreq		; FF 02 - Set channel frequency to xxxx (CHFREQ_SET)
0001D940 6000 0000                  	bra.w	dcsFreqNote	; FF 03 - Set channel frequency to note xx (CHFREQ_SET - CHFREQ_NOTE)
0001D944 6000 0000                  	bra.w	dcSpRev		; FF 04 - Increment spindash rev counter (SPINDASH_REV - SDREV_INC)
0001D948 6000 0000                  	bra.w	dcSpReset	; FF 05 - Reset spindash rev counter (SPINDASH_REV - SDREV_RESET)
0001D94C 6000 0000                  	bra.w	dcaTempoShoes	; FF 06 - Add xx to music speed tempo (TEMPO - TEMPO_ADD_SPEED)
0001D950 6000 0000                  	bra.w	dcaTempo	; FF 07 - Add xx to music tempo (TEMPO - TEMPO_ADD)
0001D954 6000 0000                  	bra.w	dcCondReg	; FF 08 - Get RAM table offset by y, and chk zz with cond x (COMM_CONDITION - COMM_SPEC)
0001D958 6000 0000                  	bra.w	dcSound		; FF 09 - Play another music/sfx (SND_CMD)
0001D95C 6000 0000                  	bra.w	dcFreqOn	; FF 0A - Enable raw frequency mode (RAW_FREQ)
0001D960 6000 0000                  	bra.w	dcFreqOff	; FF 0B - Disable raw frequency mode (RAW_FREQ - RAW_FREQ_OFF)
0001D964 6000 0000                  	bra.w	dcSpecFM3	; FF 0C - Enable FM3 special mode (SPC_FM3)
0001D968 6000 0000                  	bra.w	dcFilter	; FF 0D - Set DAC filter bank. (DAC_FILTER)
0001D96C                            
0001D96C                            ; ===========================================================================
0001D96C                            ; ---------------------------------------------------------------------------
0001D96C                            ; Command handlers for false condition execution
0001D96C                            ; ---------------------------------------------------------------------------
0001D96C                            
0001D96C                            .false
0001D96C 524C                       	addq.w	#1,a4
0001D96E 4E75                       	rts			; E0 - Panning, AMS, FMS (PANAFMS - PAFMS_PAN)
0001D970 524C                       	addq.w	#1,a4
0001D972 4E75                       	rts			; E1 - Add xx to channel frequency displacement (DETUNE)
0001D974 524C                       	addq.w	#1,a4
0001D976 4E75                       	rts			; E2 - Add xx to channel frequency displacement (DETUNE)
0001D978 524C                       	addq.w	#1,a4
0001D97A 4E75                       	rts			; E3 - Set channel pitch to xx (TRANSPOSE - TRNSP_SET)
0001D97C 524C                       	addq.w	#1,a4
0001D97E 4E75                       	rts			; E4 - Add xx to channel pitch (TRANSPOSE - TRNSP_ADD)
0001D980 6000 0000                  	bra.w	dcsTmulCh	; E5 - Set channel tick multiplier to xx (TICK_MULT - TMULT_CUR)
0001D984 6000 0000                  	bra.w	dcsTmul		; E6 - Set global tick multiplier to xx (TICK_MULT - TMULT_ALL)
0001D988 6000 0000                  	bra.w	dcHold		; E7 - Do not allow note on/off for next note (HOLD)
0001D98C 524C                       	addq.w	#1,a4
0001D98E 4E75                       	rts			; E8 - Add xx to music tempo (TEMPO - TEMPO_ADD)
0001D990 524C                       	addq.w	#1,a4
0001D992 4E75                       	rts			; E9 - Set music tempo to xx (TEMPO - TEMPO_SET)
0001D994 524C                       	addq.w	#1,a4
0001D996 4E75                       	rts			; EA - Set Voice/voice/sample to xx (INSTRUMENT - INS_C_FM / INS_C_PSG / INS_C_DAC)
0001D998 4E75                       	rts
0001D99A 4E75                       	rts			; EB - Turn on Modulation (MOD_SET - MODS_ON)
0001D99C 4E75                       	rts
0001D99E 4E75                       	rts			; EC - Turn off Modulation (MOD_SET - MODS_OFF)
0001D9A0 524C                       	addq.w	#1,a4
0001D9A2 4E75                       	rts			; ED - Add xx to channel volume (VOLUME - VOL_CN_FM / VOL_CN_PSG / VOL_CN_DAC)
0001D9A4 524C                       	addq.w	#1,a4
0001D9A6 4E75                       	rts			; EE - Set channel volume to xx (VOLUME - VOL_CN_ABS)
0001D9A8 524C                       	addq.w	#1,a4
0001D9AA 4E75                       	rts			; EF - Set LFO (SET_LFO - LFO_AMSEN)
0001D9AC 584C                       	addq.w	#4,a4
0001D9AE 4E75                       	rts			; F0 - Modulation (MOD_SETUP)
0001D9B0 4E75                       	rts
0001D9B2 4E75                       	rts			; F1 - Use sample DAC mode (DAC_MODE - DACM_SAMP)
0001D9B4 4E75                       	rts
0001D9B6 4E75                       	rts			; F2 - Use pitch DAC mode (DAC_MODE - DACM_NOTE)
0001D9B8 524C                       	addq.w	#1,a4
0001D9BA 4E75                       	rts			; F3 - PSG4 mode to xx (PSG_NOISE - PNOIS_SET)
0001D9BC 544C                       	addq.w	#2,a4
0001D9BE 4E75                       	rts			; F4 - Do a continuous SFX loop (CONT_SFX)
0001D9C0 4E75                       	rts
0001D9C2 4E75                       	rts			; F5 - End of channel (TRK_END - TEND_STD)
0001D9C4 544C                       	addq.w	#2,a4
0001D9C6 4E75                       	rts			; F6 - Jump to xxxx (GOTO)
0001D9C8 584C                       	addq.w	#4,a4
0001D9CA 4E75                       	rts			; F7 - Loop back to zzzz yy times, xx being the loop index (LOOP)
0001D9CC 544C                       	addq.w	#2,a4
0001D9CE 4E75                       	rts			; F8 - Call pattern at xxxx, saving return point (GOSUB)
0001D9D0 4E75                       	rts
0001D9D2 4E75                       	rts			; F9 - Return (RETURN)
0001D9D4 6000 0000                  	bra.w	dcsComm		; FA - Set communications byte yy to xx (SET_COMM - SPECIAL)
0001D9D8 6000 0000                  	bra.w	dcCond		; FB - Get comms byte y, and compare zz using condition x (COMM_CONDITION)
0001D9DC 6000 0000                  	bra.w	dcResetCond	; FC - Reset condition (COND_RESET)
0001D9E0 524C                       	addq.w	#1,a4
0001D9E2 4E75                       	rts			; FD - Stop note after xx frames (NOTE_STOP - NSTOP_NORMAL
0001D9E4 524C                       	addq.w	#1,a4
0001D9E6 4E75                       	rts			; FE - YM command (YMCMD)
0001D9E8 6000 FF3C                  	bra.w	.metacall	; FF - META
0001D9EC                            ; ===========================================================================
0001D9EC                            ; ---------------------------------------------------------------------------
0001D9EC                            ; Tracker commands for writing direct DAC samples to Dual PCM.
0001D9EC                            ; Note that this will override any DAC already being played,
0001D9EC                            ; and in turn trackers may override these DAC samples at any
0001D9EC                            ; time. Use with caution!
0001D9EC                            ; ---------------------------------------------------------------------------
0001D9EC                            
0001D9EC                            dcWriteDAC1:
0001D9EC 7000                       		moveq	#0,d0
0001D9EE 101C                       		move.b	(a4)+,d0		; get note to write
0001D9F0 4EFA EA98                  		jmp	dNoteWriteDAC1(pc)	; note-on
0001D9F4                            
0001D9F4                            dcWriteDAC2:
0001D9F4 7000                       		moveq	#0,d0
0001D9F6 101C                       		move.b	(a4)+,d0		; get note to write
0001D9F8 4EFA EA82                  		jmp	dNoteWriteDAC2(pc)	; note-on
0001D9FC                            ; ===========================================================================
0001D9FC                            ; ---------------------------------------------------------------------------
0001D9FC                            ; Tracker commands for handling spindash revving.
0001D9FC                            ; The way spindash revving works, is it actually just
0001D9FC                            ; increments a counter each time, and this counter is
0001D9FC                            ; added into the channel pitch offset.
0001D9FC                            ; ---------------------------------------------------------------------------
0001D9FC                            
0001D9FC                            dcSpRev:
0001D9FC 1038 C4C1                  		move.b	mSpindash.w,d0		; load spindash rev counter to d0
0001DA00 5238 C4C1                  		addq.b	#1,mSpindash.w		; increment spindash rev counter
0001DA04 D12D 0008                  		add.b	d0,cPitch(a5)		; add d0 to channel pitch offset
0001DA08                            
0001DA08 0C00 000B                  		cmp.b	#$C-1,d0		; check if this is the max pitch offset
0001DA0C 6500                       		blo.s	.rts			; if not, skip
0001DA0E 5338 C4C1                  		subq.b	#1,mSpindash.w		; cap at pitch offset $C
0001DA12                            
0001DA12                            .rts
0001DA12 4E75                       		rts
0001DA14                            
0001DA14                            dcSpReset:
0001DA14 4238 C4C1                  		clr.b	mSpindash.w		; reset spindash rev counter
0001DA18 4E75                       		rts
0001DA1A                            ; ===========================================================================
0001DA1A                            ; ---------------------------------------------------------------------------
0001DA1A                            ; Tracker command for changing channel panning
0001DA1A                            ; ---------------------------------------------------------------------------
0001DA1A                            
0001DA1A                            dcPan:
0001DA1A                            
0001DA1A 7237                       		moveq	#$37,d1			; prepare bits to keep
0001DA1C C22D 0006                  		and.b	cPanning(a5),d1		; and with channel LFO settings
0001DA20 821C                       		or.b	(a4)+,d1		; or panning value
0001DA22 1B41 0006                  		move.b	d1,cPanning(a5)		; save as channel panning
0001DA26                            
0001DA26 70B4                       		moveq	#$FFFFFFB4,d0		; YM command: Panning & LFO
0001DA28 082D 0003 0001             		btst	#ctbDAC,cType(a5)	; check if this is a DAC channel
0001DA2E 6700 F774                  		beq.w	dWriteYMchnInt		; if not, write channel-specific YM command
0001DA32                            ; ---------------------------------------------------------------------------
0001DA32                            ; Since the DAC channels have or based panning behavior, we need this
0001DA32                            ; piece of code to update its panning
0001DA32                            ; ---------------------------------------------------------------------------
0001DA32                            
0001DA32 1238 C4CA                  		move.b	mDAC1+cPanning.w,d1	; read panning value from music DAC1
0001DA36 0838 0001 C4C4             		btst	#cfbInt,mDAC1+cFlags.w	; check if music DAC1 is interrupted by SFX
0001DA3C 6700                       		beq.s	.nodacsfx		; if not, use music DAC1 panning
0001DA3E 1238 C682                  		move.b	mSFXDAC1+cPanning.w,d1	; read panning value from SFX DAC1
0001DA42                            
0001DA42                            .nodacsfx
0001DA42 8238 C4F6                  		or.b	mDAC2+cPanning.w,d1	; or the panning value from music DAC2
0001DA46 70B6                       		moveq	#$FFFFFFB4+2,d0		; YM address: Panning and LFO (FM3/6)
0001DA48 4EFA F798                  		jmp	WriteYM_Pt2(pc)		; write to part 2 channel
0001DA4C                            ; ===========================================================================
0001DA4C                            ; ---------------------------------------------------------------------------
0001DA4C                            ; Tracker commands for changing detune offset
0001DA4C                            ; ---------------------------------------------------------------------------
0001DA4C                            
0001DA4C                            dcaDetune:
0001DA4C 101C                       		move.b	(a4)+,d0		; load detune offset from tracker
0001DA4E D12D 0007                  		add.b	d0,cDetune(a5)		; Add to channel detune offset
0001DA52 4E75                       		rts
0001DA54                            
0001DA54                            dcsDetune:
0001DA54 1B5C 0007                  		move.b	(a4)+,cDetune(a5)	; load detune offset from tracker to channel
0001DA58 4E75                       		rts
0001DA5A                            ; ===========================================================================
0001DA5A                            ; ---------------------------------------------------------------------------
0001DA5A                            ; Tracker command for changing channel volume
0001DA5A                            ; ---------------------------------------------------------------------------
0001DA5A                            
0001DA5A                            dcsVolume:
0001DA5A 1B5C 0009                  		move.b	(a4)+,cVolume(a5)	; load volume from tracker to channel
0001DA5E 08D5 0005                  		bset	#cfbVol,(a5)		; set volume update flag
0001DA62 4E75                       		rts
0001DA64                            
0001DA64                            dcaVolume:
0001DA64 101C                       		move.b	(a4)+,d0		; load volume from tracker
0001DA66 D12D 0009                  		add.b	d0,cVolume(a5)		; add to channel volume
0001DA6A 08D5 0005                  		bset	#cfbVol,(a5)		; set volume update flag
0001DA6E 4E75                       		rts
0001DA70                            ; ===========================================================================
0001DA70                            ; ---------------------------------------------------------------------------
0001DA70                            ; Tracker command for setting DAC to sample mode and resetting frequency
0001DA70                            ; ---------------------------------------------------------------------------
0001DA70                            
0001DA70                            dcSampDAC:
0001DA70 3B7C 0100 000E             		move.w	#$100,cFreq(a5)		; reset to defualt base frequency
0001DA76 0895 0000                  		bclr	#cfbMode,(a5)		; enable sample mode
0001DA7A 4E75                       		rts
0001DA7C                            ; ===========================================================================
0001DA7C                            ; ---------------------------------------------------------------------------
0001DA7C                            ; Tracker command for setting DAC to pitch mode
0001DA7C                            ; ---------------------------------------------------------------------------
0001DA7C                            
0001DA7C                            dcPitchDAC:
0001DA7C 08D5 0000                  		bset	#cfbMode,(a5)		; enable pitch mode
0001DA80 4E75                       		rts
0001DA82                            ; ===========================================================================
0001DA82                            ; ---------------------------------------------------------------------------
0001DA82                            ; Tracker commands for changing channel tick multiplier
0001DA82                            ; ---------------------------------------------------------------------------
0001DA82                            
0001DA82                            dcsTmulCh:
0001DA82 1B5C 000A                  		move.b	(a4)+,cTick(a5)		; load tick multiplier from tracker to channel
0001DA86 4E75                       		rts
0001DA88                            
0001DA88                            dcsTmul:
0001DA88 101C                       		move.b	(a4)+,d0		; load tick multiplier from tracker to d0
0001DA8A =FFFFC4C4                  .x =	mDAC1					; start at DAC1
0001DA8A                            	rept Mus_Ch				; do for all music channels
0001DA8A                            		move.b	d0,cTick+.x.w		; set channel tick multiplier
0001DA8A                            .x =		.x+cSize			; go to next channel
0001DA8A                            	endr
0001DA8A 11C0 C4CE                M 	move.b	d0,ctick+.x.w
0001DA8E =FFFFC4F0                M .x	=	.x+csize
0001DA8E 11C0 C4FA                M 	move.b	d0,ctick+.x.w
0001DA92 =FFFFC51C                M .x	=	.x+csize
0001DA92 11C0 C526                M 	move.b	d0,ctick+.x.w
0001DA96 =FFFFC548                M .x	=	.x+csize
0001DA96 11C0 C552                M 	move.b	d0,ctick+.x.w
0001DA9A =FFFFC574                M .x	=	.x+csize
0001DA9A 11C0 C57E                M 	move.b	d0,ctick+.x.w
0001DA9E =FFFFC5A0                M .x	=	.x+csize
0001DA9E 11C0 C5AA                M 	move.b	d0,ctick+.x.w
0001DAA2 =FFFFC5CC                M .x	=	.x+csize
0001DAA2 11C0 C5D6                M 	move.b	d0,ctick+.x.w
0001DAA6 =FFFFC5F8                M .x	=	.x+csize
0001DAA6 11C0 C602                M 	move.b	d0,ctick+.x.w
0001DAAA =FFFFC624                M .x	=	.x+csize
0001DAAA 11C0 C62E                M 	move.b	d0,ctick+.x.w
0001DAAE =FFFFC650                M .x	=	.x+csize
0001DAAE 11C0 C65A                M 	move.b	d0,ctick+.x.w
0001DAB2 =FFFFC67C                M .x	=	.x+csize
0001DAB2 4E75                       		rts
0001DAB4                            ; ===========================================================================
0001DAB4                            ; ---------------------------------------------------------------------------
0001DAB4                            ; Tracker command for enabling or disabling the hold flag
0001DAB4                            ; ---------------------------------------------------------------------------
0001DAB4                            
0001DAB4                            dcHold:
0001DAB4 0855 0002                  		bchg	#cfbHold,(a5)		; flip the channel hold flag
0001DAB8 4E75                       		rts
0001DABA                            ; ===========================================================================
0001DABA                            ; ---------------------------------------------------------------------------
0001DABA                            ; Tracker command for enabling or disabling note timeout
0001DABA                            ; ---------------------------------------------------------------------------
0001DABA                            
0001DABA                            dcTimeout:
0001DABA                            
0001DABA 1B54 001D                  		move.b	(a4),cNoteTimeMain(a5)	; load note timeout from tracker to channel
0001DABE 1B5C 001C                  		move.b	(a4)+,cNoteTimeCur(a5)	; ''
0001DAC2 4E75                       		rts
0001DAC4                            ; ===========================================================================
0001DAC4                            ; ---------------------------------------------------------------------------
0001DAC4                            ; Tracker commands for changing channel pitch
0001DAC4                            ; ---------------------------------------------------------------------------
0001DAC4                            
0001DAC4                            dcaTransp:
0001DAC4 101C                       		move.b	(a4)+,d0		; load pitch offset from tracker
0001DAC6 D12D 0008                  		add.b	d0,cPitch(a5)		; add to channel pitch offset
0001DACA 4E75                       		rts
0001DACC                            
0001DACC                            dcsTransp:
0001DACC 1B5C 0008                  		move.b	(a4)+,cPitch(a5)	; load pitch offset from tracker to channel
0001DAD0 4E75                       		rts
0001DAD2                            ; ===========================================================================
0001DAD2                            ; ---------------------------------------------------------------------------
0001DAD2                            ; Tracker commands for tempo control
0001DAD2                            ; ---------------------------------------------------------------------------
0001DAD2                            
0001DAD2                            dcsTempoShoes:
0001DAD2 101C                       		move.b	(a4)+,d0		; load tempo value from tracker
0001DAD4 11C0 C4B9                  		move.b	d0,mTempoSpeed.w	; save as the speed shoes tempo
0001DAD8 0838 0001 C4A6             		btst	#mfbSpeed,mFlags.w	; check if speed shoes mode is active
0001DADE 6600                       		bne.s	dcsTempoCur		; if is, load as current tempo too
0001DAE0 4E75                       		rts
0001DAE2                            
0001DAE2                            dcsTempo:
0001DAE2 101C                       		move.b	(a4)+,d0		; load tempo value from tracker
0001DAE4 11C0 C4B8                  		move.b	d0,mTempoMain.w		; save as the main tempo
0001DAE8 0838 0001 C4A6             		btst	#mfbSpeed,mFlags.w	; check if speed shoes mode is active
0001DAEE 6600                       		bne.s	locret_Tempo		; if not, load as current tempo too
0001DAF0                            
0001DAF0                            dcsTempoCur:
0001DAF0 11C0 C4BA                  		move.b	d0,mTempo.w		; save as current tempo
0001DAF4                            
0001DAF4                            locret_Tempo:
0001DAF4 4E75                       		rts
0001DAF6                            
0001DAF6                            dcaTempoShoes:
0001DAF6 101C                       		move.b	(a4)+,d0		; load tempo value from tracker
0001DAF8 D138 C4B9                  		add.b	d0,mTempoSpeed.w	; add to the speed shoes tempo
0001DAFC 0838 0001 C4A6             		btst	#mfbSpeed,mFlags.w	; check if speed shoes mode is active
0001DB02 6600                       		bne.s	dcaTempoCur		; if is, add to current tempo too
0001DB04 4E75                       		rts
0001DB06                            
0001DB06                            dcaTempo:
0001DB06 101C                       		move.b	(a4)+,d0		; load tempo value from tracker
0001DB08 D138 C4B8                  		add.b	d0,mTempoMain.w		; add to the main tempo
0001DB0C 0838 0001 C4A6             		btst	#mfbSpeed,mFlags.w	; check if speed shoes mode is active
0001DB12 66E0                       		bne.s	locret_Tempo		; if not, add to current tempo too
0001DB14                            
0001DB14                            dcaTempoCur:
0001DB14 D138 C4BA                  		add.b	d0,mTempo.w		; add to current tempo
0001DB18 4E75                       		rts
0001DB1A                            ; ===========================================================================
0001DB1A                            ; ---------------------------------------------------------------------------
0001DB1A                            ; Tracker command for enabling or disabling PSG4 noise mode
0001DB1A                            ; ---------------------------------------------------------------------------
0001DB1A                            
0001DB1A                            dcNoisePSG:
0001DB1A 1B54 001B                  		move.b	(a4),cStatPSG4(a5)	; load PSG4 status command from tracker to channel
0001DB1E 6700                       		beq.s	.psg3			; if disabling PSG4 mode, branch
0001DB20 1B7C 00E0 0001             		move.b	#ctPSG4,cType(a5)	; make PSG3 act on behalf of PSG4
0001DB26 13DC 00C0 0011             		move.b	(a4)+,dPSG		; send command to PSG port
0001DB2C 4E75                       		rts
0001DB2E                            
0001DB2E                            .psg3
0001DB2E 1B7C 00C0 0001             		move.b	#ctPSG3,cType(a5)	; make PSG3 not act on behalf of PSG4
0001DB34 13FC 00FF 00C0 0011        		move.b	#ctPSG4|$1F,dPSG	; send PSG4 mute command to PSG
0001DB3C 524C                       		addq.w	#1,a4			; skip param
0001DB3E 4E75                       		rts
0001DB40                            ; ===========================================================================
0001DB40                            ; ---------------------------------------------------------------------------
0001DB40                            ; Tracker command for playing another music or SFX
0001DB40                            ; ---------------------------------------------------------------------------
0001DB40                            
0001DB40                            dcSound:
0001DB40 11DC C4BE                  		move.b	(a4)+,mQueue+2.w	; load sound ID from tracker to sound queue
0001DB44                            
0001DB44                            Return_dcSound:
0001DB44 4E75                       		rts
0001DB46                            ; ===========================================================================
0001DB46                            ; ---------------------------------------------------------------------------
0001DB46                            ; Tracker command for setting DAC filter bank
0001DB46                            ; ---------------------------------------------------------------------------
0001DB46                            
0001DB46                            dcFilter:
0001DB46 7000                       		moveq	#0,d0
0001DB48 101C                       		move.b	(a4)+,d0		; load filter bank number from tracker
0001DB4A 4EFA F23E                  		jmp	dSetFilter(pc)		; load filter bank instructions to Z80 RAM
0001DB4E                            ; ===========================================================================
0001DB4E                            ; ---------------------------------------------------------------------------
0001DB4E                            ; Tracker command for writing a YM command to YMCue
0001DB4E                            ; ---------------------------------------------------------------------------
0001DB4E                            
0001DB4E                            dcYM:
0001DB4E 101C                       		move.b	(a4)+,d0		; load YM address from tracker to d0
0001DB50 121C                       		move.b	(a4)+,d1		; get command value from tracker to d1
0001DB52 0815 0001                  		btst	#cfbInt,(a5)		; is this channel overridden by SFX?
0001DB56 66EC                       		bne.s	Return_dcSound		; if so, skip
0001DB58                            
0001DB58 0C00 0030                  		cmp.b	#$30,d0			; is this register 00-2F?
0001DB5C 6500 F658                  		blo.w	WriteYM_Pt1		; if so, write to part 1 always
0001DB60                            
0001DB60 1400                       		move.b	d0,d2			; copy address to d2
0001DB62 0402 00A8                  		sub.b	#$A8,d2			; align $A8 with 0
0001DB66 0C02 0008                  		cmp.b	#$08,d2			; is this egister A8-AF?
0001DB6A 6500 F64A                  		blo.w	WriteYM_Pt1		; if so, write to part 1 always
0001DB6E 4EFA F63A                  		jmp	WriteChYM(pc)		; write to YM according to channel
0001DB72                            ; ===========================================================================
0001DB72                            ; ---------------------------------------------------------------------------
0001DB72                            ; Tracker command for setting channel base frequency
0001DB72                            ; ---------------------------------------------------------------------------
0001DB72                            
0001DB72                            dcsFreq:
0001DB72 1B5C 000E                  		move.b	(a4)+,cFreq(a5)		; load base frequency from tracker to channel
0001DB76 1B5C 000F                  		move.b	(a4)+,cFreq+1(a5)	; ''
0001DB7A                            
0001DB7A                            .rts
0001DB7A 4E75                       		rts
0001DB7C                            ; ===========================================================================
0001DB7C                            ; ---------------------------------------------------------------------------
0001DB7C                            ; Tracker command for setting channel base frequency from the note table
0001DB7C                            ; ---------------------------------------------------------------------------
0001DB7C                            
0001DB7C                            dcsFreqNote:
0001DB7C 7000                       		moveq	#0,d0
0001DB7E 101C                       		move.b	(a4)+,d0		; load note from tracker to d0
0001DB80 D02D 0008                  		add.b	cPitch(a5),d0		; add pitch offset to note
0001DB84 D040                       		add.w	d0,d0			; double offset (each entry is a word)
0001DB86                            
0001DB86 43FA F73E                  		lea	dFreqDAC(pc),a1		; load DAC frequency table to a1
0001DB8A 3B71 0000 000E             		move.w	(a1,d0.w),cFreq(a5)	; load and save the requested frequency
0001DB90                            
0001DB90                            .rts
0001DB90 4E75                       		rts
0001DB92                            ; ===========================================================================
0001DB92                            ; ---------------------------------------------------------------------------
0001DB92                            ; Tracker command for doing a continous SFX loop
0001DB92                            ; ---------------------------------------------------------------------------
0001DB92                            
0001DB92                            dcCont:
0001DB92 5338 C4C2                  		subq.b	#1,mContCtr.w		; decrease continous sfx counter
0001DB96 6A00                       		bpl.s	dcJump			; if positive, jump to routine
0001DB98 4238 C4C3                  		clr.b	mContLast.w		; clear continous SFX ID
0001DB9C 544C                       		addq.w	#2,a4			; skip over jump offset
0001DB9E 4E75                       		rts
0001DBA0                            ; ===========================================================================
0001DBA0                            ; ---------------------------------------------------------------------------
0001DBA0                            ; Tracker command for calling a tracker subroutine
0001DBA0                            ; ---------------------------------------------------------------------------
0001DBA0                            
0001DBA0                            dcCall:
0001DBA0                            
0001DBA0 7000                       		moveq	#0,d0
0001DBA2 102D 001E                  		move.b	cStack(a5),d0		; get channel stack pointer
0001DBA6 5900                       		subq.b	#4,d0			; allocate space for another routine
0001DBA8                            
0001DBA8 2B8C 0000                  		move.l	a4,(a5,d0.w)		; save current address in stack
0001DBAC 1B40 001E                  		move.b	d0,cStack(a5)		; save stack pointer
0001DBB0                            ; ===========================================================================
0001DBB0                            ; ---------------------------------------------------------------------------
0001DBB0                            ; Tracker command for jumping to another tracker location
0001DBB0                            ; ---------------------------------------------------------------------------
0001DBB0                            
0001DBB0                            dcJump:
0001DBB0                            	dREAD_WORD a4, d0			; read a word from tracker to d0
0001DBB0 1E9C                     M 	move.b	(a4)+,(sp)
0001DBB2 3017                     M 	move.w	(sp),d0
0001DBB4 1014                     M 	move.b	(a4),d0
0001DBB6 D8C0                       		adda.w	d0,a4			; offset tracker address by d0
0001DBB8 4E75                       		rts
0001DBBA                            ; ===========================================================================
0001DBBA                            ; ---------------------------------------------------------------------------
0001DBBA                            ; Tracker command for handling loops
0001DBBA                            ; ---------------------------------------------------------------------------
0001DBBA                            
0001DBBA                            dcLoop:
0001DBBA 7000                       		moveq	#0,d0
0001DBBC 101C                       		move.b	(a4)+,d0		; load loop index from tracker to d0
0001DBBE                            
0001DBBE 4A35 0019                  		tst.b	cLoop(a5,d0.w)		; check the loop counter
0001DBC2 6600                       		bne.s	.loopok			; if nonzero, branch
0001DBC4 1BAC 0002 0019             		move.b	2(a4),cLoop(a5,d0.w)	; reload loop counter
0001DBCA                            
0001DBCA                            .loopok
0001DBCA 5335 0019                  		subq.b	#1,cLoop(a5,d0.w)	; decrease loop counter
0001DBCE 66E0                       		bne.s	dcJump			; if not 0, jump to routine
0001DBD0 564C                       		addq.w	#3,a4			; skip over jump offset
0001DBD2 4E75                       		rts
0001DBD4                            ; ===========================================================================
0001DBD4                            ; ---------------------------------------------------------------------------
0001DBD4                            ; Tracker command for initializing modulation
0001DBD4                            ; ---------------------------------------------------------------------------
0001DBD4                            
0001DBD4                            dcMod68K:
0001DBD4 2B4C 0010                  		move.l	a4,cMod(a5)		; set modulation data address
0001DBD8 1B5C 0010                  		move.b	(a4)+,cModDelay(a5)	; load modulation delay from tracker to channel
0001DBDC 1B5C 0016                  		move.b	(a4)+,cModSpeed(a5)	; load modulation speed from tracker to channel
0001DBE0 1B5C 0017                  		move.b	(a4)+,cModStep(a5)	; load modulation step offset from tracker to channel
0001DBE4                            
0001DBE4 101C                       		move.b	(a4)+,d0		; load modulation step count from tracker to d0
0001DBE6 E208                       		lsr.b	#1,d0			; halve it
0001DBE8 1B40 0018                  		move.b	d0,cModCount(a5)	; save as modulation step count to channel
0001DBEC 426D 0014                  		clr.w	cModFreq(a5)		; reset modulation frequency offset to 0
0001DBF0                            	; continue to enabling modulation
0001DBF0                            ; ===========================================================================
0001DBF0                            ; ---------------------------------------------------------------------------
0001DBF0                            ; Tracker commands for enabling and disabling modulation
0001DBF0                            ; ---------------------------------------------------------------------------
0001DBF0                            
0001DBF0                            dcModOn:
0001DBF0 08D5 0003                  		bset	#cfbMod,(a5)		; enable modulation
0001DBF4 4E75                       		rts
0001DBF6                            
0001DBF6                            dcModOff:
0001DBF6 0895 0003                  		bclr	#cfbMod,(a5)		; disable modulation
0001DBFA 4E75                       		rts
0001DBFC                            ; ===========================================================================
0001DBFC                            ; ---------------------------------------------------------------------------
0001DBFC                            ; Tracker command for returning from tracker subroutine
0001DBFC                            ; ---------------------------------------------------------------------------
0001DBFC                            
0001DBFC                            dcReturn:
0001DBFC 7000                       		moveq	#0,d0
0001DBFE 102D 001E                  		move.b	cStack(a5),d0		; get channel stack pointer
0001DC02 2875 0000                  		movea.l	(a5,d0.w),a4		; load the address to return to
0001DC06                            
0001DC06 544C                       		addq.w	#2,a4			; skip the call address parameter
0001DC08 5800                       		addq.b	#4,d0			; deallocate stack space
0001DC0A 1B40 001E                  		move.b	d0,cStack(a5)		; save stack pointer
0001DC0E                            
0001DC0E 4E75                       		rts
0001DC10                            ; ===========================================================================
0001DC10                            ; ---------------------------------------------------------------------------
0001DC10                            ; Tracker command for initializing special FM3 mode
0001DC10                            ; ---------------------------------------------------------------------------
0001DC10                            
0001DC10                            dcSpecFM3:
0001DC10 4E75                       		rts
0001DC12                            ; ===========================================================================
0001DC12                            ; ---------------------------------------------------------------------------
0001DC12                            ; Tracker command for enabling raw frequency mode
0001DC12                            ; ---------------------------------------------------------------------------
0001DC12                            
0001DC12                            dcFreqOn:
0001DC12 4E75                       		rts
0001DC14                            ; ===========================================================================
0001DC14                            ; ---------------------------------------------------------------------------
0001DC14                            ; Tracker command for disabling raw frequency mode
0001DC14                            ; ---------------------------------------------------------------------------
0001DC14                            
0001DC14                            dcFreqOff:
0001DC14                            
0001DC14                            locret_FreqOff:
0001DC14 4E75                       		rts
0001DC16                            ; ===========================================================================
0001DC16                            ; ---------------------------------------------------------------------------
0001DC16                            ; Tracker command for changing voice, volume envelope or sample
0001DC16                            ; ---------------------------------------------------------------------------
0001DC16                            
0001DC16                            dcVoice:
0001DC16 7000                       		moveq	#0,d0
0001DC18 101C                       		move.b	(a4)+,d0		; load voice/sample/volume envelope from tracker to d0
0001DC1A 1B40 000B                  		move.b	d0,cVoice(a5)		; save to channel
0001DC1E                            
0001DC1E 4A2D 0001                  		tst.b	cType(a5)		; check if this is a PSG channel
0001DC22 6BF0                       		bmi.s	locret_FreqOff		; if is, skip
0001DC24 082D 0003 0001             		btst	#ctbDAC,cType(a5)	; check if this is a DAC channel
0001DC2A 66E8                       		bne.s	locret_FreqOff		; if is, skip
0001DC2C                            
0001DC2C 0815 0001                  		btst	#cfbInt,(a5)		; check if channel is interrupted by SFX
0001DC30 66E2                       		bne.s	locret_FreqOff		; if is, skip
0001DC32 224E                       		move.l	a6,a1			; load voice table to a1
0001DC34                            	; continue to send FM voice
0001DC34                            ; ===========================================================================
0001DC34                            ; ---------------------------------------------------------------------------
0001DC34                            ; Subroutine for sending the FM voice to YM2612
0001DC34                            ; This routine is speed optimized in a way that allows Dual PCM
0001DC34                            ; to only be stopped for as long as it must be. This will waste
0001DC34                            ; some cycles for 68000, but it will help improve DAC quality.
0001DC34                            ; ---------------------------------------------------------------------------
0001DC34                            
0001DC34                            dUpdateVoiceFM:
0001DC34                            	dCALC_VOICE				; get address of the specific voice to a1
0001DC34 EB48                     M 	lsl.w	#5,d0
0001DC36 D2C0                     M 	add.w	d0,a1
0001DC38 9EFC 003C                  		sub.w	#(VoiceRegs+1)*2,sp	; prepapre space in the stack
0001DC3C 264F                       		move.l	sp,a3			; copy pointer to the free space to a3
0001DC3E                            
0001DC3E 1819                       		move.b	(a1)+,d4		; load feedback and algorithm to d4
0001DC40 16C4                       		move.b	d4,(a3)+		; save it to free space
0001DC42 16FC 00B0                  		move.b	#$B0,(a3)+		; YM command: Algorithm & FeedBack
0001DC46                            
0001DC46 45FA F262                  		lea	dOpListYM(pc),a2	; load YM2612 operator list into a2
0001DC4A                            	rept VoiceRegs-5
0001DC4A                            		move.b	(a1)+,(a3)+		; copy each value (except Total Level)
0001DC4A                            		move.b	(a2)+,(a3)+		; copy each command
0001DC4A                            	endr
0001DC4A 16D9                     M 	move.b	(a1)+,(a3)+
0001DC4C 16DA                     M 	move.b	(a2)+,(a3)+
0001DC4E 16D9                     M 	move.b	(a1)+,(a3)+
0001DC50 16DA                     M 	move.b	(a2)+,(a3)+
0001DC52 16D9                     M 	move.b	(a1)+,(a3)+
0001DC54 16DA                     M 	move.b	(a2)+,(a3)+
0001DC56 16D9                     M 	move.b	(a1)+,(a3)+
0001DC58 16DA                     M 	move.b	(a2)+,(a3)+
0001DC5A 16D9                     M 	move.b	(a1)+,(a3)+
0001DC5C 16DA                     M 	move.b	(a2)+,(a3)+
0001DC5E 16D9                     M 	move.b	(a1)+,(a3)+
0001DC60 16DA                     M 	move.b	(a2)+,(a3)+
0001DC62 16D9                     M 	move.b	(a1)+,(a3)+
0001DC64 16DA                     M 	move.b	(a2)+,(a3)+
0001DC66 16D9                     M 	move.b	(a1)+,(a3)+
0001DC68 16DA                     M 	move.b	(a2)+,(a3)+
0001DC6A 16D9                     M 	move.b	(a1)+,(a3)+
0001DC6C 16DA                     M 	move.b	(a2)+,(a3)+
0001DC6E 16D9                     M 	move.b	(a1)+,(a3)+
0001DC70 16DA                     M 	move.b	(a2)+,(a3)+
0001DC72 16D9                     M 	move.b	(a1)+,(a3)+
0001DC74 16DA                     M 	move.b	(a2)+,(a3)+
0001DC76 16D9                     M 	move.b	(a1)+,(a3)+
0001DC78 16DA                     M 	move.b	(a2)+,(a3)+
0001DC7A 16D9                     M 	move.b	(a1)+,(a3)+
0001DC7C 16DA                     M 	move.b	(a2)+,(a3)+
0001DC7E 16D9                     M 	move.b	(a1)+,(a3)+
0001DC80 16DA                     M 	move.b	(a2)+,(a3)+
0001DC82 16D9                     M 	move.b	(a1)+,(a3)+
0001DC84 16DA                     M 	move.b	(a2)+,(a3)+
0001DC86 16D9                     M 	move.b	(a1)+,(a3)+
0001DC88 16DA                     M 	move.b	(a2)+,(a3)+
0001DC8A 16D9                     M 	move.b	(a1)+,(a3)+
0001DC8C 16DA                     M 	move.b	(a2)+,(a3)+
0001DC8E 16D9                     M 	move.b	(a1)+,(a3)+
0001DC90 16DA                     M 	move.b	(a2)+,(a3)+
0001DC92 16D9                     M 	move.b	(a1)+,(a3)+
0001DC94 16DA                     M 	move.b	(a2)+,(a3)+
0001DC96 16D9                     M 	move.b	(a1)+,(a3)+
0001DC98 16DA                     M 	move.b	(a2)+,(a3)+
0001DC9A 16D9                     M 	move.b	(a1)+,(a3)+
0001DC9C 16DA                     M 	move.b	(a2)+,(a3)+
0001DC9E 16D9                     M 	move.b	(a1)+,(a3)+
0001DCA0 16DA                     M 	move.b	(a2)+,(a3)+
0001DCA2 16D9                     M 	move.b	(a1)+,(a3)+
0001DCA4 16DA                     M 	move.b	(a2)+,(a3)+
0001DCA6 16D9                     M 	move.b	(a1)+,(a3)+
0001DCA8 16DA                     M 	move.b	(a2)+,(a3)+
0001DCAA                            
0001DCAA 7C00                       		moveq	#0,d6			; reset the modulator offset
0001DCAC 162D 0009                  		move.b	cVolume(a5),d3		; load FM channel volume to d3
0001DCB0 D638 C4B4                  		add.b	mMasterVolFM.w,d3	; add master FM volume to d3
0001DCB4 6A00                       		bpl.s	.noover			; if volume did not overflow, skio
0001DCB6 767F                       		moveq	#$7F,d3			; force FM volume to silence
0001DCB8                            
0001DCB8                            .noover
0001DCB8 0838 0002 C4A6             		btst	#mfbWater,mFlags.w	; check if underwater mode is enabled
0001DCBE 6700                       		beq.s	.uwdone			; if not, skip
0001DCC0 1C04                       		move.b	d4,d6			; copy algorithm and feedback to d6
0001DCC2 0246 0007                  		and.w	#7,d6			; mask out everything but the algorithm
0001DCC6 D606                       		add.b	d6,d3			; add algorithm to Total Level carrier offset
0001DCC8 1C04                       		move.b	d4,d6			; set algorithm and feedback to modulator offset
0001DCCA                            
0001DCCA                            .uwdone
0001DCCA 7A03                       		moveq	#4-1,d5			; prepare 4 operators to d5
0001DCCC                            
0001DCCC                            .tlloop
0001DCCC 1219                       		move.b	(a1)+,d1		; get Total Level value from voice to d1
0001DCCE 6A00                       		bpl.s	.noslot			; if slot operator bit was not set, branch
0001DCD0                            
0001DCD0 D203                       		add.b	d3,d1			; add carrier offset to loaded value
0001DCD2 6B00                       		bmi.s	.slot			; if we did not overflow, branch
0001DCD4 727F                       		moveq	#$7F,d1			; cap to silent volume
0001DCD6 6000                       		bra.s	.slot
0001DCD8                            
0001DCD8                            .noslot
0001DCD8 D206                       		add.b	d6,d1			; add modulator offset to loaded value
0001DCDA                            .slot
0001DCDA 16C1                       		move.b	d1,(a3)+		; save the Total Level value
0001DCDC 16DA                       		move.b	(a2)+,(a3)+		; copy total level command
0001DCDE 51CD FFEC                  		dbf	d5,.tlloop		; repeat for each Total Level operator
0001DCE2                            
0001DCE2                            
0001DCE2 0895 0005                  		bclr	#cfbVol,(a5)		; reset volume update request flag
0001DCE6 16ED 0006                  		move.b	cPanning(a5),(a3)+	; copy panning value to free space
0001DCEA 16FC 00B4                  		move.b	#$B4,(a3)+		; YM command: Panning & LFO
0001DCEE                            
0001DCEE 7400                       		moveq	#0,d2			; prepare part 1 value
0001DCF0 162D 0001                  		move.b	cType(a5),d3		; load FM channel type to d3
0001DCF4 0803 0002                  		btst	#ctbPt2,d3		; check if its part 1
0001DCF8 6700                       		beq.s	.ptok			; if so, branch
0001DCFA 0203 0003                  		and.b	#3,d3			; get channel offset only
0001DCFE 7402                       		moveq	#2,d2			; prepare part 2 value
0001DD00                            
0001DD00                            .ptok
0001DD00 264F                       		move.l	sp,a3			; copy free space pointer to a3 again
0001DD02 721D                       		moveq	#VoiceRegs,d1		; prepare loop point
0001DD04                            	StopZ80					; wait for Z80 to stop
0001DD04 33FC 0100 00A1 1100      M 	move.w	#$100,z80_bus_req
0001DD0C                          M 	waitz80stop
0001DD0C 0839 0000 00A1 1100      M .wait_360:	btst	#0,z80_bus_req
0001DD14 66F6                     M 	bne.s	.wait_360
0001DD16                            
0001DD16                            .write
0001DD16 10C2                       		move.b	d2,(a0)+		; select YM port to access (4000 or 4002)
0001DD18 10DB                       		move.b	(a3)+,(a0)+		; write command values
0001DD1A                            
0001DD1A 101B                       		move.b	(a3)+,d0		; load YM command
0001DD1C 8003                       		or.b	d3,d0			; add the channel offset to command
0001DD1E 10C0                       		move.b	d0,(a0)+		; save to Z80 cue
0001DD20 51C9 FFF4                  		dbf	d1,.write		; write all registers
0001DD24 50D0                       		st	(a0)			; mark as end of the cue
0001DD26                            
0001DD26                            	StartZ80				; enable Z80 execution
0001DD26 33FC 0000 00A1 1100      M 	move.w	#0,z80_bus_req
0001DD2E DEFC 003C                  		add.w	#(VoiceRegs+1)*2,sp	; reset stack pointer
0001DD32 4E75                       		rts
0001DD34                            ; ===========================================================================
0001DD34                            ; ---------------------------------------------------------------------------
0001DD34                            ; Tracker command for stopping the current channel
0001DD34                            ; ---------------------------------------------------------------------------
0001DD34                            
0001DD34                            dcStop:
0001DD34 0215 007B                  		and.b	#$FF-(1<<cfbHold)-(1<<cfbRun),(a5); clear hold and running tracker flags
0001DD38 4A2D 0001                  		tst.b	cType(a5)		; check if this was a PSG channel
0001DD3C 6B00                       		bmi.s	.mutePSG		; if yes, mute it
0001DD3E                            
0001DD3E 082D 0003 0001             		btst	#ctbDAC,cType(a5)	; check if this was a DAC channel
0001DD44 6600                       		bne.s	.cont			; if we are, skip
0001DD46 4EBA F448                  		jsr	dKeyOffFM(pc)		; send key-off command to YM
0001DD4A 6000                       		bra.s	.cont
0001DD4C                            ; ---------------------------------------------------------------------------
0001DD4C                            
0001DD4C                            .mutePSG
0001DD4C 4EBA FB30                  		jsr	dMutePSGmus(pc)		; mute PSG channel
0001DD50                            
0001DD50                            .cont
0001DD50 BAFC C698                  		cmpa.w	#mSFXFM3,a5		; check if this is a SFX channel
0001DD54 6500                       		blo.s	.exit			; if not, skip all this mess
0001DD56 422D 001A                  		clr.b	cPrio(a5)		; clear channel priority
0001DD5A                            
0001DD5A 43FA ED74                  		lea	dSFXoverList(pc),a1	; load quick reference to the SFX override list to a1
0001DD5E 7600                       		moveq	#0,d3
0001DD60 162D 0001                  		move.b	cType(a5),d3		; load channel type to d3
0001DD64 6B00                       		bmi.s	.psg			; if this is a PSG channel, branch
0001DD66 3F0D                       		move.w	a5,-(sp)		; push channel pointer
0001DD68                            
0001DD68 0243 0007                  		and.w	#$07,d3			; get only the necessary bits to d3
0001DD6C 5543                       		subq.w	#2,d3			; since FM 1 and 2 are not used, skip over them
0001DD6E D643                       		add.w	d3,d3			; double offset (each entry is 1 word in size)
0001DD70 3A71 3000                  		move.w	(a1,d3.w),a5		; get the SFX channel we were overriding
0001DD74                            
0001DD74                            .dacdone
0001DD74 4A15                       		tst.b	(a5)			; check if that channel is running a tracker
0001DD76 6A00                       		bpl.s	.fixch			; if not, branch
0001DD78                            
0001DD78 08D5 0005                  		bset	#cfbVol,(a5)		; set update volume flag (cleared by dUpdateVoiceFM)
0001DD7C 0895 0001                  		bclr	#cfbInt,(a5)		; reset sfx override flag
0001DD80 082D 0003 0001             		btst	#ctbDAC,cType(a5)	; check if the channel is a DAC channel
0001DD86 6600                       		bne.s	.fixch			; if yes, skip
0001DD88                            
0001DD88 08D5 0000                  		bset	#cfbRest,(a5)		; Set channel resting flag
0001DD8C 43FA 0000                  		lea	VoiceBankMusic(pc),a1	; load music voice table to a1
0001DD90 102D 000B                  		move.b	cVoice(a5),d0		; load FM voice ID of the channel to d0
0001DD94 4EBA FE9E                  		jsr	dUpdateVoiceFM(pc)	; send FM voice for this channel
0001DD98                            
0001DD98                            .fixch
0001DD98 3A5F                       		move.w	(sp)+,a5		; pop the current channel
0001DD9A                            .exit
0001DD9A 5497                       		addq.l	#2,(sp)			; go to next channel immediately
0001DD9C 4E75                       		rts
0001DD9E                            ; ---------------------------------------------------------------------------
0001DD9E                            ; There is nothing that would break even if the channel is not
0001DD9E                            ; running a tracker, so we do not bother checking
0001DD9E                            ; ---------------------------------------------------------------------------
0001DD9E                            
0001DD9E                            .psg
0001DD9E E80B                       		lsr.b	#4,d3			; make it easier to reference the right offset in the table
0001DDA0 3271 3000                  		movea.w	(a1,d3.w),a1		; get the SFX channel we were overriding
0001DDA4 0891 0001                  		bclr	#cfbInt,(a1)		; channel is not interrupted anymore
0001DDA8 08D1 0000                  		bset	#cfbRest,(a1)		; reset sfx override flag
0001DDAC                            
0001DDAC 0C29 00E0 0001             		cmp.b	#ctPSG4,cType(a1)	; check if this channel is in PSG4 mode
0001DDB2 66E6                       		bne.s	.exit			; if not, skip
0001DDB4 13E9 001B 00C0 0011        		move.b	cStatPSG4(a1),dPSG	; update PSG4 status to PSG port
0001DDBC 60DC                       		bra.s	.exit
0001DDBE                            ; ===========================================================================
0001DDBE                            ; ---------------------------------------------------------------------------
0001DDBE                            ; Tracker command for enabling LFO
0001DDBE                            ; ---------------------------------------------------------------------------
0001DDBE                            
0001DDBE                            dcsLFO:
0001DDBE 7000                       		moveq	#0,d0
0001DDC0 102D 000B                  		move.b	cVoice(a5),d0		; load FM voice ID of the channel to d0
0001DDC4 224E                       		move.l	a6,a1			; load voice table to a1
0001DDC6                            
0001DDC6                            	dCALC_VOICE 9				; get address of the specific voice to a1
0001DDC6 EB48                     M 	lsl.w	#5,d0
0001DDC8 0640 0009                M 	add.w	#9,d0
0001DDCC D2C0                     M 	add.w	d0,a1
0001DDCE 1614                       		move.b	(a4),d3			; load LFO enable operators to d3
0001DDD0 45FA F0E0                  		lea	dAMSEn_Ops(pc),a2	; load Decay 1 Rate address table to a2
0001DDD4 7C03                       		moveq	#4-1,d6			; prepare 4 operators to d5
0001DDD6                            
0001DDD6                            .decayloop
0001DDD6 1219                       		move.b	(a1)+,d1		; get Decay 1 Level value from voice to d1
0001DDD8 101A                       		move.b	(a2)+,d0		; load YM address to write to d0
0001DDDA                            
0001DDDA D603                       		add.b	d3,d3			; check if LFO is enabled for this channeÃ¶
0001DDDC 6400                       		bcc.s	.noLFO			; if not, skip
0001DDDE 0001 0080                  		or.b	#$80,d1			; set enable LFO bit
0001DDE2 4EBA F3C6                  		jsr	WriteChYM(pc)		; write to YM according to channel
0001DDE6                            
0001DDE6                            .noLFO
0001DDE6 51CE FFEE                  		dbf	d6,.decayloop		; repeat for each Decay 1 Level operator
0001DDEA                            
0001DDEA 121C                       		move.b	(a4)+,d1		; load LFO frequency value from tracker
0001DDEC 7022                       		moveq	#$22,d0			; YM command: LFO
0001DDEE 4EBA F3C6                  		jsr	WriteYM_Pt1(pc)		; write to part 1 channel
0001DDF2                            
0001DDF2 121C                       		move.b	(a4)+,d1		; load AMS, FMS & Panning from tracker
0001DDF4 1B41 0006                  		move.b	d1,cPanning(a5)		; save to channel panning
0001DDF8                            
0001DDF8 70B4                       		moveq	#$FFFFFFB4,d0		; YM command: Panning & LFO
0001DDFA 4EFA F3A8                  		jmp	dWriteYMchnInt(pc)	; write to YM according to channel
0001DDFE                            ; ===========================================================================
0001DDFE                            ; ---------------------------------------------------------------------------
0001DDFE                            ; Tracker command for resetting condition
0001DDFE                            ; ---------------------------------------------------------------------------
0001DDFE                            
0001DDFE                            dcResetCond:
0001DDFE 0895 0004                  		bclr	#cfbCond,(a5)		; reset condition flag
0001DE02 4E75                       		rts
0001DE04                            ; ===========================================================================
0001DE04                            ; ---------------------------------------------------------------------------
0001DE04                            ; Tracker command for writing to communications flags
0001DE04                            ; ---------------------------------------------------------------------------
0001DE04                            
0001DE04                            dcsComm:
0001DE04 43F8 C4AC                  		lea	mComm.w,a1		; get communications array to a1
0001DE08 7000                       		moveq	#0,d0
0001DE0A 101C                       		move.b	(a4)+,d0		; load byte number to write from tracker
0001DE0C 139C 0000                  		move.b	(a4)+,(a1,d0.w)		; load vaue from tracker to communications byte
0001DE10 4E75                       		rts
0001DE12                            ; ===========================================================================
0001DE12                            ; ---------------------------------------------------------------------------
0001DE12                            ; RAM addresses for special condition code
0001DE12                            ; ---------------------------------------------------------------------------
0001DE12                            
0001DE12                            dcCondRegTable:
0001DE12 C744 C4A6                  	dc.w rHWVersion, mFlags	; 0
0001DE16 C4B8 C4B9                  	dc.w mTempoMain, mTempoSpeed	; 2
0001DE1A 0000 0000                  	dc.w 0, 0			; 4
0001DE1E 0000 0000                  	dc.w 0, 0			; 6
0001DE22 0000 0000                  	dc.w 0, 0			; 8
0001DE26 0000 0000                  	dc.w 0, 0			; $A
0001DE2A 0000 0000                  	dc.w 0, 0			; $C
0001DE2E 0000 0001                  	dc.w 0, cType			; $E
0001DE32                            ; ===========================================================================
0001DE32                            ; ---------------------------------------------------------------------------
0001DE32                            ; Tracker command for checking special RAM addresses
0001DE32                            ; ---------------------------------------------------------------------------
0001DE32                            
0001DE32                            dcCondReg:
0001DE32 101C                       		move.b	(a4)+,d0		; get value from tracker
0001DE34 1200                       		move.b	d0,d1			; copy to d1
0001DE36                            
0001DE36 0240 000F                  		and.w	#$F,d0			; get RAM table offset to d0
0001DE3A D040                       		add.w	d0,d0			; double it (each entry is 1 word)
0001DE3C 303B 00D4                  		move.w	dcCondRegTable(pc,d0.w),d0; get data to read from
0001DE40 6B00                       		bmi.s	.gotit			; branch if if was a RAM address
0001DE42 D04D                       		add.w	a5,d0			; else it was a channel offset
0001DE44                            
0001DE44                            .gotit
0001DE44 3240                       		move.w	d0,a1			; get the desired address from d0 to a1
0001DE46 1011                       		move.b	(a1),d0			; read byte from it
0001DE48 6000                       		bra.s	dcCondCom
0001DE4A                            ; ===========================================================================
0001DE4A                            ; ---------------------------------------------------------------------------
0001DE4A                            ; Tracker command for checking communications bytes
0001DE4A                            ; ---------------------------------------------------------------------------
0001DE4A                            
0001DE4A                            dcCond:
0001DE4A 43F8 C4AC                  		lea	mComm.w,a1		; get communications array to a1
0001DE4E 101C                       		move.b	(a4)+,d0		; load condition and offset from tracker to d0
0001DE50 1200                       		move.b	d0,d1			; copy to d1
0001DE52 0240 000F                  		and.w	#$F,d0			; get offset only
0001DE56 1031 0000                  		move.b	(a1,d0.w),d0		; load value from communcations byte to d0
0001DE5A                            
0001DE5A                            dcCondCom:
0001DE5A 0895 0004                  		bclr	#cfbCond,(a5)		; set condition to true
0001DE5E 0241 00F0                  		and.w	#$F0,d1			; get condition value only
0001DE62 E449                       		lsr.w	#2,d1			; shift 2 bits down (each entry is 4 bytes large)
0001DE64 B01C                       		cmp.b	(a4)+,d0		; check value against tracker byte
0001DE66 4EFB 1000                  		jmp	.cond(pc,d1.w)		; handle conditional code
0001DE6A                            ; ===========================================================================
0001DE6A                            ; ---------------------------------------------------------------------------
0001DE6A                            ; Code for setting the condition flag
0001DE6A                            ; ---------------------------------------------------------------------------
0001DE6A                            
0001DE6A                            .c	macro x
0001DE6A                            	\x	.false
0001DE6A                            	rts
0001DE6A                                 endm
0001DE6A                            
0001DE6A                            .false
0001DE6A 08D5 0004                  		bset	#cfbCond,(a5)		; set condition to false
0001DE6E                            
0001DE6E 4E75                       .cond	rts		; T
0001DE70 4E75                       	rts
0001DE72                            	.c bra.s	; F
0001DE72 60F6                     M 	bra.s	.false
0001DE74 4E75                     M 	rts
0001DE76                            	.c bls.s	; HI
0001DE76 63F2                     M 	bls.s	.false
0001DE78 4E75                     M 	rts
0001DE7A                            	.c bhi.s	; LS
0001DE7A 62EE                     M 	bhi.s	.false
0001DE7C 4E75                     M 	rts
0001DE7E                            	.c blo.s	; HS/CC
0001DE7E 65EA                     M 	blo.s	.false
0001DE80 4E75                     M 	rts
0001DE82                            	.c bhs.s	; LO/CS
0001DE82 64E6                     M 	bhs.s	.false
0001DE84 4E75                     M 	rts
0001DE86                            	.c beq.s	; NE
0001DE86 67E2                     M 	beq.s	.false
0001DE88 4E75                     M 	rts
0001DE8A                            	.c bne.s	; EQ
0001DE8A 66DE                     M 	bne.s	.false
0001DE8C 4E75                     M 	rts
0001DE8E                            	.c bvs.s	; VC
0001DE8E 69DA                     M 	bvs.s	.false
0001DE90 4E75                     M 	rts
0001DE92                            	.c bvc.s	; VS
0001DE92 68D6                     M 	bvc.s	.false
0001DE94 4E75                     M 	rts
0001DE96                            	.c bmi.s	; PL
0001DE96 6BD2                     M 	bmi.s	.false
0001DE98 4E75                     M 	rts
0001DE9A                            	.c bpl.s	; MI
0001DE9A 6ACE                     M 	bpl.s	.false
0001DE9C 4E75                     M 	rts
0001DE9E                            	.c blt.s	; GE
0001DE9E 6DCA                     M 	blt.s	.false
0001DEA0 4E75                     M 	rts
0001DEA2                            	.c bge.s	; LT
0001DEA2 6CC6                     M 	bge.s	.false
0001DEA4 4E75                     M 	rts
0001DEA6                            	.c ble.s	; GT
0001DEA6 6FC2                     M 	ble.s	.false
0001DEA8 4E75                     M 	rts
0001DEAA                            	.c bgt.s	; LE
0001DEAA 6EBE                     M 	bgt.s	.false
0001DEAC 4E75                     M 	rts
0001DEAE                            ; ===========================================================================
0001DEAE                            ; ---------------------------------------------------------------------------
0001DEAE                            ; Tracker command for freezing the CPU. DEBUG FLAG
0001DEAE                            ; ---------------------------------------------------------------------------
0001DEAE                            
0001DEAE                            ; ===========================================================================
0001DEAE                            ; ---------------------------------------------------------------------------
0001DEAE                            ; Check if a song is playing
0001DEAE                            ; ---------------------------------------------------------------------------
0001DEAE                            
0001DEAE                            dChkSongPlay:
0001DEAE 43F8 C4C4                  	lea	mDAC1.w,a1		; Music track RAM
0001DEB2 7209                       	moveq	#Mus_Ch-1,d1
0001DEB4                            
0001DEB4                            .ChkTracks:
0001DEB4 4A11                       	tst.b	cFlags(a1)		; Is this track playing?
0001DEB6 6B00                       	bmi.s	.Playing		; If so, branch
0001DEB8 43E9 002C                  	lea	cSize(a1),a1		; Next track
0001DEBC 51C9 FFF6                  	dbf	d1,.ChkTracks		; Loop
0001DEC0 7200                       	moveq	#0,d1
0001DEC2 4E75                       	rts
0001DEC4                            
0001DEC4                            .Playing:
0001DEC4 50C1                       	st	d1
0001DEC6 4E75                       	rts
0001DEC8                            ; ===========================================================================
0001DEC8                            ; ---------------------------------------------------------------------------
0001DEC8                            ; Define music and SFX
0001DEC8                            ; ---------------------------------------------------------------------------
0001DEC8                            
0001DEC8                            	opt oz-				; disable zero-offset optimization
000C3988                            	list				; continue source listing
000C3988                            ; ===========================================================================
000C3988                            DualPCM:
000C3988                            		z80prog	0
000C3988                          M 	pusho
000C3988                          M 	opt	ae-
000C3988                          M 	opt	an+
00000000                            		include	"Sound/amps/code/Z80.asm"
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; DUAL-PCM - by MarkeyJester
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_Read		macro
00000000                            		ldi					; 16	; copy from window to buffer, and increment register
00000000                            		zadd	a,b				; 04	; add dividend
00000000                            		adc	hl,sp				; 15	; add quotient
00000000                            		endm					; Total: 35
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_CapPCM	macro
00000000                            		jp	po, .ov\@			; 10	; if the sample hasn't overflown the 7F/80 boundary, branch
00000000                            		sbc	a,a				; 04	; erase sample, and subtract the carry to get either FF or 00, depending on overflow direction
00000000                            		xor	07Fh				; 07	; reverse FF/00 (xor 80 below helps)
00000000                            .ov\@		xor	080h				; 07	; convert to unsigned
00000000                            		endm					; Total: 17/28
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_Flush01	macro
00000000                            		ld	e,(hl)				; 07	; load byte from OUT buffer 1 to volume pointer
00000000                            		ld	a,(de)				; 07	; copy to a
00000000                            		zset	001h,h				; 08	; move forwards to OUT buffer 2
00000000                            		inc	d				; 04	; move forwards to volume pointer 2
00000000                            		ld	e,(hl)				; 07	; load byte from OUT buffer 2 to volume pointer
00000000                            		ex	de,hl				; 04	; swap for hl powers
00000000                            		zadd	a,(hl)				; 07	; add volume 2 to volume 1
00000000                            		ex	de,hl				; 04	; swap back
00000000                            		M_CapPCM					; cap the sample overflow
00000000                            		ld	(bc),a				; 07	; save to the YM2612
00000000                            		inc	l				; 04	; advance OUT buffers
00000000                            		endm					; Total: 59
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_Flush02	macro
00000000                            		ld	e,(hl)				; 07	; load byte from OUT buffer 2 to volume pointer
00000000                            		ld	a,(de)				; 07	; copy to a
00000000                            		res	001h,h				; 08	; move back to OUT buffer 1
00000000                            		dec	d				; 04	; move back to volume pointer 1
00000000                            		ld	e,(hl)				; 07	; load byte from OUT buffer 1 to volume pointer
00000000                            		ex	de,hl				; 04	; swap for hl powers
00000000                            		zadd	a,(hl)				; 07	; add volume 1 to volume 2
00000000                            		ex	de,hl				; 04	; swap back
00000000                            		M_CapPCM					; cap the sample overflow
00000000                            		ld	(bc),a				; 07	; save to the YM2612
00000000                            		inc	l				; 04	; advance OUT buffers
00000000                            		endm					; Total: 59
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_Revert01	macro
00000000                            		res	001h,h				; 08	; move back to OUT buffer 1
00000000                            		dec	d				; 04	; move back to volume pointer 1
00000000                            		dec	l				; 04	; move OUT buffers back
00000000                            		endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_Revert02	macro
00000000                            		zset	001h,h				; 08	; move forwards to OUT buffer 2
00000000                            		inc	d				; 04	; move forwards to volume pointer 2
00000000                            		dec	l				; 04	; move OUT buffers back
00000000                            		endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_Wrap		macro
00000000                            		dec	l				; 04	; check l...
00000000                            		inc	l				; 04	; ''
00000000                            		M_WrapCondition
00000000                            		endm
00000000                            
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            M_WrapCondition	macro
00000000                            		jp	nz, .c\@			; 10	; if it's not 0, branch
00000000                            		inc	h				; 04	; advance OUT buffers
00000000                            		bit	004h,h				; 08	; have the OUT buffer addresses reached 1000 (end of buffer) yet?
00000000                            		jp	z, .c\@				; 10	; if not, branch
00000000                            		ld	hl,PCM_Buffer2			; 10	; reset OUT buffers
00000000                            .c\@
00000000                            		endm
00000000                            
00000000                            ; ===========================================================================
00000000                            ; ---------------------------------------------------------------------------
00000000                            ; Start of Z80 ROM
00000000                            ; ---------------------------------------------------------------------------
00000000                            
00000000                            Z80_Start:
0000000B                            
0000000B 0000 0000 00               		align	MaxPitch/$100
00000010                            
00000010                            	; The space from "Start" until the maximum pitch amount, is the space
00000010                            	; where data could potentially be pushed into, thanks to the sp.
00000010                            
00000010                            	; The sp will likely be from roughly FFEF - 000F for the quotient of
00000010                            	; the pitch.  Now, FFEF - FFFF will be fine, since that points to the
00000010                            	; 68k window, which will be pointing to 68k ROM, so nothing will happen.
00000010                            	; But the address from 0000 - 000F points to the beginning of ROM, so
00000010                            	; this place must be free from use outside of V-blank.
00000010                            
00000010                            Z80_Stack:
00000010                            
00000010                            ; ===========================================================================
00000010                            ; ---------------------------------------------------------------------------
00000010                            ; PCM 1 Resetting
00000010                            ; ---------------------------------------------------------------------------
00000010                            		align	010h
00000010                            ; ---------------------------------------------------------------------------
00000010                            
00000010                            BreakLate:
00000019                            
00000019                            ; ===========================================================================
00000019                            ; ---------------------------------------------------------------------------
00000019                            ; PCM 1 Resetting
00000019                            ; ---------------------------------------------------------------------------
00000019 0000 0000 0000 0000 0000+  		align	028h
00000028                            ; ---------------------------------------------------------------------------
00000028                            
00000028                            PCM1_ResetJmp:
0000002B                            
0000002B                            ; ===========================================================================
0000002B                            ; ---------------------------------------------------------------------------
0000002B                            ; PCM 2 Resetting
0000002B                            ; ---------------------------------------------------------------------------
0000002B 0000 0000 00               		align	030h
00000030                            ; ---------------------------------------------------------------------------
00000030                            
00000030                            PCM2_ResetJmp:
00000033                            
00000033                            ; ===========================================================================
00000033                            ; ---------------------------------------------------------------------------
00000033                            ; Breaking out for V-blank
00000033                            ; ---------------------------------------------------------------------------
00000033 0000 0000 00               		align	038h
00000038                            ; ---------------------------------------------------------------------------
00000038                            
00000038                            BreakVBlank:
0000003C 2F                         		cpl					; 04	; change buffer
00000040                            
00000040                            BVB_Check:
00000046                            
00000046                            ; ---------------------------------------------------------------------------
00000046                            ; Breaking out for V-blank, during non-read
00000046                            ; ---------------------------------------------------------------------------
00000046                            
00000046                            BreakPrep:
00000061                            	;	ei					; 04	; enable interrupts
00000061 ED4D                       		reti					; 14	; return
00000063                            
00000063                            ; ===========================================================================
00000063                            ; ---------------------------------------------------------------------------
00000063                            ; Breaking out for V-blank, during read of window or bank register
00000063                            ; ---------------------------------------------------------------------------
00000063                            
00000063                            BreakDMA:
00000066                            
00000066                            	; --- Finding out which registers we're dealing with ---
00000066                            
00000074 1F                         BDMA_NoExchange:	rra					; 04	; get buffer we're currently reading from
00000083 D9                         BDMA_NoFixFlush:	exx					; 04	; swap to the "read" set of exx registers
00000084                            BDMA_ReadSet:
00000084                            
00000084                            ; ---------------------------------------------------------------------------
00000084                            ; Flush remaining data
00000084                            ; ---------------------------------------------------------------------------
00000084                            
00000084                            BreakBank:
00000084 D9                         			exx					; 04	; switch registers
00000086 D9                         			exx					; 04	; switch registers
00000087 ED44                       		zneg	a				; 08	; reverse position
00000090                            
00000090                            BDMA_NoMax:
0000009A                            
0000009A                            BDMA_FlushLoop:
0000009E                            
0000009E                            BDMA_Flush02:
0000009E D9                         			exx					; 04	; switch registers
000000B2 D9                         			exx					; 04	; switch registers
000000B7                            
000000B7                            BDMA_Flush01:
000000B7 D9                         			exx					; 04	; switch registers
000000CB D9                         			exx					; 04	; switch registers
000000D0                            
000000D0                            ; ---------------------------------------------------------------------------
000000D0                            ; Wrapping OUT buffers
000000D0                            ; ---------------------------------------------------------------------------
000000D0                            
000000D0 D9                         			exx					; 04	; switch registers
000000DF D9                         			exx					; 04	; switch back
000000E0                            
000000E0                            ; ---------------------------------------------------------------------------
000000E0                            ; Restore interrupt instructions
000000E0                            ; ---------------------------------------------------------------------------
000000E0                            
00000107                            
00000107                            BDMA_NoRestore:
00000107                            
00000107                            ; ---------------------------------------------------------------------------
00000107                            ; YM2612 flushing
00000107                            ; ---------------------------------------------------------------------------
00000107                            
0000010A                            
00000116                            
00000116                            YMF_Buff1:
0000011F D9                         			exx					; 04	; switch registers back
00000120                            
00000120                            YM_Flush:
00000123                            
00000123                            YMF_NextByte:
00000136 D9                         			exx					; 04	; switch registers
00000149 D9                         			exx					; 04	; switch registers
0000015D D9                         			exx					; 04	; switch registers
00000170 D9                         			exx					; 04	; switch registers
00000176                            
00000176                            	; --- Advance/Wrap OUT buffers ---
00000176                            
00000189                            
00000189                            YMF_Finish02:
00000192                            
00000192                            YMF_Finish01:
0000019B                            
0000019B                            ; ---------------------------------------------------------------------------
0000019B                            ; Waiting for v-blank to finish
0000019B                            ; ---------------------------------------------------------------------------
0000019B                            
0000019B                            PCM_Flush_exx:
0000019B D9                         			exx
0000019C                            
0000019C                            PCM_Flush:
0000019F                            
0000019F                            PCM_NextByte:
000001B2 D9                         			exx					; 04	; switch registers
000001B7                            
000001B7                            
000001B7 D9                         			exx					; 04	; switch registers
000001CB D9                         			exx					; 04	; switch registers
000001CC                            
000001D0                            
000001D0 D9                         			exx					; 04	; switch registers
000001D6                            
000001D6                            	; --- Advance/Wrap OUT buffers ---
000001D6                            
000001E4                            
000001E9 D9                         		exx					; 04	; switch registers down again...
000001EA                            
000001F6                            
000001F6                            YMF_SetBuff1:
000001F8                            
00000202                            
00000202                            VB_PCM1_VolOK:
0000020C                            
0000020C                            VB_PCM2_VolOK:
0000020C                            
0000020C 37                         		scf					; 04	; set carry flag
0000020D                            
00000222                            
00000222                            PCM_VolChangeNo:
00000222                            
00000222                            
0000022D                            
0000022D                            ; ===========================================================================
0000022D                            ; ---------------------------------------------------------------------------
0000022D                            ; Setup/Init
0000022D                            ; ---------------------------------------------------------------------------
0000022D                            
0000022D                            Z80_Init:
00000230                            
00000230                            	; --- YM2612 DAC Setup ---
00000230                            
0000023F                            
0000023F                            	; --- Setting up channels to be mute ---
0000023F                            
00000251                            
0000025A EDB0                       			ldir					; 21 16	; copy mute sample data over...
00000261 EDB0                       			ldir					; 21 16	; copy mute sample data over...
00000268 EDB0                       			ldir					; 21 16	; copy mute sample data over...
0000026F EDB0                       			ldir					; 21 16	; copy mute sample data over...
00000271                            
00000271                            	; --- Setting up PCM 1 switch ---
00000271                            
0000027A                            
0000027A                            	; --- Setting up PCM 2 switch ---
0000027A                            
00000283                            
00000283                            	; --- Final register setup ---
00000283                            
0000028B                            
00000290                            
00000290 D9                         			exx					; 04	; switch registers
00000291                            
00000291                            ; ===========================================================================
00000291                            ; ---------------------------------------------------------------------------
00000291                            ; The catch up loop
00000291                            ; ---------------------------------------------------------------------------
00000291                            
00000291                            CatchUp:
00000291 D9                         			exx					; 04	; switch registers
00000292                            
00000292                            CatchUp_Exx:
000002A5 D9                         			exx					; 04	; switch registers
000002A6                            
000002A6                            Z80_Int2:	;ei
000002A6 00                         		znop					; 04
000002A7                            
000002A7                            ; ---------------------------------------------------------------------------
000002A7                            ; PCM 1
000002A7                            ; ---------------------------------------------------------------------------
000002A7                            
000002A7                            PCM1_MuteRet:
000002AC 00                         Int1_nop:	znop					; 04	; CANNOT CHANGE "ld  (hl),h" since it's altered by Z80 elsewhere
000002C8 D9                         			exx					; 04	; switch registers
000002DC D9                         			exx					; 04	; switch registers
000002E4                            
000002E4                            PCM1_PrepRet:
000002E4                            
000002F2                            
000002FC EDA0                       PCM1_PreInst03:	ldi					; 16	; copy from window to buffer, and increment register
000002FE D9                         			exx					; 04	; switch registers
00000313 D9                         			exx					; 04	; switch registers
0000032C D9                         			exx					; 04	; switch registers
00000341 D9                         			exx					; 04	; switch registers
00000357 EDA0                       PCM1_PreInst0C:	ldi					; 16	; copy from window to buffer, and increment register
00000359 D9                         			exx					; 04	; switch registers
0000036E D9                         			exx					; 04	; switch registers
00000387 D9                         			exx					; 04	; switch registers
0000039C D9                         			exx					; 04	; switch registers
000003B2 EDA0                       PCM1_PreInst15:	ldi					; 16	; copy from window to buffer, and increment register
000003B4 D9                         			exx					; 04	; switch registers
000003C9 D9                         			exx					; 04	; switch registers
000003E6 D9                         			exx					; 04	; switch registers
000003FB D9                         			exx					; 04	; switch registers
00000403                            
00000403                            ; ---------------------------------------------------------------------------
00000403                            ; PCM 2
00000403                            ; ---------------------------------------------------------------------------
00000403                            
00000403                            PCM2_MuteRet:
00000408 00                         Int2_nop:	znop					; 04	; CANNOT CHANGE "ld  (hl),h" since it's altered by Z80 elsewhere
0000041A D9                         			exx					; 04	; switch registers
0000042E D9                         			exx					; 04	; switch registers
00000440                            
00000440                            PCM2_PrepRet:
00000440                            
0000044E                            
00000453 D9                         			exx					; 04	; switch registers
00000468 D9                         			exx					; 04	; switch registers
0000047E EDA0                       PCM2_PreInst06:	ldi					; 16	; copy from window to buffer, and increment register
00000480 D9                         			exx					; 04	; switch registers
00000495 D9                         			exx					; 04	; switch registers
000004AE D9                         			exx					; 04	; switch registers
000004C3 D9                         			exx					; 04	; switch registers
000004D9 EDA0                       PCM2_PreInst0F:	ldi					; 16	; copy from window to buffer, and increment register
000004DB D9                         			exx					; 04	; switch registers
000004F0 D9                         			exx					; 04	; switch registers
00000509 D9                         			exx					; 04	; switch registers
0000051E D9                         			exx					; 04	; switch registers
00000534 EDA0                       PCM2_PreInst18:	ldi					; 16	; copy from window to buffer, and increment register
00000536 D9                         			exx					; 04	; switch registers
0000054B D9                         			exx					; 04	; switch registers
0000055F                            
00000570                            
00000570                            ; ---------------------------------------------------------------------------
00000570                            ; Wrapping OUT buffers
00000570                            ; ---------------------------------------------------------------------------
00000570                            
00000570 D9                         			exx					; 04	; switch registers
00000590 D9                         			exx					; 04	; switch back
00000591                            
00000591                            ; ---------------------------------------------------------------------------
00000591                            ; Wrap IN buffers
00000591                            ; ---------------------------------------------------------------------------
00000591                            
000005A3                            
000005A3                            PCM_BuffNoReset:
000005A3                            
000005A3                            ; ---------------------------------------------------------------------------
000005A3                            ; Rebank...
000005A3                            ; ---------------------------------------------------------------------------
000005A3                            
000005A3 37                         		scf					; 04	; set carry flag
000005BA 37                         		scf					; 04	; set carry flag
000005BB                            
000005BB                            PCM1_IgnoreBank:
000005D1 37                         		scf					; 04	; set carry flag
000005D2                            
000005D2                            PCM2_IgnoreBank:
000005D2                            
000005D2                            ; ---------------------------------------------------------------------------
000005D2                            ; Pitch control
000005D2                            ; ---------------------------------------------------------------------------
000005D2                            
000005DA                            
00000602 37                         		scf					; 04	; set carry flag
00000603                            
00000603                            PCM1_IgnorePitch:
00000603                            
0000060B                            
00000633 37                         		scf					; 04	; set carry flag
00000634                            
00000634                            PCM2_IgnorePitch:
00000634                            
00000634                            ; ---------------------------------------------------------------------------
00000634                            ; Updating Volume
00000634                            ; ---------------------------------------------------------------------------
00000634                            
0000064B                            	;	scf					; 04	; don't think it's necessary here...
0000064B                            
0000064E                            PCM_VolumeRet:
0000064E                            
0000064E                            
0000064E                            ; ---------------------------------------------------------------------------
0000064E                            ; New samples...
0000064E                            ; ---------------------------------------------------------------------------
0000064E                            
00000654                            
00000654                            ; ---------------------------------------------------------------------------
00000654                            ; Checking for "Flush" mode
00000654                            ; ---------------------------------------------------------------------------
00000654                            
00000654                            PCM_NoUpdate:
00000654 D9                         		exx					; 04	; switch registers
00000656 1F                         			rra					; 04	; get upper bit only into carry
00000658 1F                         			rra					; 04	; shift address down with carry
00000659 D9                         		exx					; 04	; switch registers
0000066A                            
0000066A                            CU_ValidDist:
0000066F                            
0000066F                            ; ---------------------------------------------------------------------------
0000066F                            ; New sample playback
0000066F                            ; ---------------------------------------------------------------------------
0000066F                            
0000066F                            CU_Flush:
0000066F                            
0000066F                            ; ---------------------------------------------------------------------------
0000066F                            ; Main "Flush" loop
0000066F                            ; ---------------------------------------------------------------------------
0000066F                            
0000066F D9                         			exx					; 04	; switch registers back
00000673                            
00000673                            FL_NextByte:
00000686 D9                         			exx					; 04	; switch registers
0000068C D9                         			exx					; 04	; switch registers
000006A0 D9                         			exx					; 04	; switch registers
000006A5 D9                         			exx					; 04	; switch registers
000006A6                            
000006AB                            
000006AB                            	; --- Advance/Wrap OUT buffers ---
000006AB                            
000006BC                            
000006BC                            ; ===========================================================================
000006BC                            ; ---------------------------------------------------------------------------
000006BC                            ; When PCM sample 1 has reached an end marker & needs to loop back
000006BC                            ; ---------------------------------------------------------------------------
000006BC                            
000006BC                            PCM1_Mute:
000006CE                            
000006CE                            PCM1_Normal:
000006D4                            
000006D4                            PCM1_Reverse:
000006E4 D9                         			exx					; 04	; switch registers
000006E9 D9                         			exx					; 04	; switch registers
000006ED                            
000006ED                            ; ===========================================================================
000006ED                            ; ---------------------------------------------------------------------------
000006ED                            ; When PCM sample 1 address has reached the end of a window, just to play the last bit
000006ED                            ; ---------------------------------------------------------------------------
000006ED                            
000006ED                            PCM1_PrepReset:
000006FC                            
000006FC                            PCM1_PrepCount:
00000715 D9                         			exx					; 04	; switch registers
00000729 D9                         			exx					; 04	; switch registers
00000731                            
00000731                            ; ===========================================================================
00000731                            ; ---------------------------------------------------------------------------
00000731                            ; When PCM sample 1 address has gone outside the window, and needs to reset
00000731                            ; ---------------------------------------------------------------------------
00000731                            
00000731                            PCM1_Reset:
0000074B                            
00000755                            
00000758                            
0000075A                            
0000075F                            
0000076B                            
00000771 0F                         		rrca					; 04
00000773 0F                         		rrca					; 04
00000775 0F                         		rrca					; 04
00000777 0F                         		rrca					; 04
00000779 0F                         		rrca					; 04
0000077B 0F                         		rrca					; 04
0000077D 0F                         		rrca					; 04
00000780                            
00000782                            
00000787                            
00000797                            
0000079A                            
0000079A                            ; ===========================================================================
0000079A                            ; ---------------------------------------------------------------------------
0000079A                            ; 68K SET - routine to load a new sample 1
0000079A                            ; ---------------------------------------------------------------------------
0000079A                            
0000079A                            PCM1_NewSample:
000007AA                            
000007AA                            PCM1_NewNormal:
000007B0                            
000007B0                            PCM1_NewReverse:
000007C0                            
000007C5 37                         		scf					; 04	; set C flag (for "JP NC" instruction)
000007C7                            
000007C7                            ; ===========================================================================
000007C7                            ; ---------------------------------------------------------------------------
000007C7                            ; When PCM sample 2 has reached an end marker & needs to loop back
000007C7                            ; ---------------------------------------------------------------------------
000007C7                            
000007C7                            PCM2_Mute:
000007D9                            
000007D9                            PCM2_Normal:
000007DF                            
000007DF                            PCM2_Reverse:
000007EF D9                         			exx					; 04	; switch registers
000007F4 D9                         			exx					; 04	; switch registers
000007F8                            
000007F8                            ; ===========================================================================
000007F8                            ; ---------------------------------------------------------------------------
000007F8                            ; When PCM sample 2 address has reached the end of a window, just to play the last bit
000007F8                            ; ---------------------------------------------------------------------------
000007F8                            
000007F8                            PCM2_PrepReset:
00000807                            
00000807                            PCM2_PrepCount:
00000827                            
00000827                            ; ===========================================================================
00000827                            ; ---------------------------------------------------------------------------
00000827                            ; When PCM sample 2 address has gone outside the window, and needs to reset
00000827                            ; ---------------------------------------------------------------------------
00000827                            
00000827                            PCM2_Reset:
00000841                            
0000084B                            
0000084E                            
00000850                            
00000855                            
00000861                            
00000867 0F                         		rrca					; 04
00000869 0F                         		rrca					; 04
0000086B 0F                         		rrca					; 04
0000086D 0F                         		rrca					; 04
0000086F 0F                         		rrca					; 04
00000871 0F                         		rrca					; 04
00000873 0F                         		rrca					; 04
00000876                            
00000878                            
0000087D                            
0000088D                            
00000890                            
00000890                            ; ===========================================================================
00000890                            ; ---------------------------------------------------------------------------
00000890                            ; 68K SET - routine to load a new sample 2
00000890                            ; ---------------------------------------------------------------------------
00000890                            
00000890                            PCM2_NewSample:
000008A0                            
000008A0                            PCM2_NewNormal:
000008A6                            
000008A6                            PCM2_NewReverse:
000008B6                            
000008BB 37                         		scf					; 04	; set C flag (for "JP NC" instruction)
000008BD                            
000008BD                            ; ===========================================================================
000008BD                            ; ---------------------------------------------------------------------------
000008BD                            ; PCM volume Lists
000008BD                            ; ---------------------------------------------------------------------------
000008BD                            		align	00200h
00000A00                            ; ---------------------------------------------------------------------------
00000A00                            
00000A00 0081 8283 8485 8687 8889+  PCM_Volume1:	db	000h,081h,082h,083h,084h,085h,086h,087h,088h,089h,08Ah,08Bh,08Ch,08Dh,08Eh,08Fh
00000A10 9091 9293 9495 9697 9899+  		db	090h,091h,092h,093h,094h,095h,096h,097h,098h,099h,09Ah,09Bh,09Ch,09Dh,09Eh,09Fh
00000A20 A0A1 A2A3 A4A5 A6A7 A8A9+  		db	0A0h,0A1h,0A2h,0A3h,0A4h,0A5h,0A6h,0A7h,0A8h,0A9h,0AAh,0ABh,0ACh,0ADh,0AEh,0AFh
00000A30 B0B1 B2B3 B4B5 B6B7 B8B9+  		db	0B0h,0B1h,0B2h,0B3h,0B4h,0B5h,0B6h,0B7h,0B8h,0B9h,0BAh,0BBh,0BCh,0BDh,0BEh,0BFh
00000A40 C0C1 C2C3 C4C5 C6C7 C8C9+  		db	0C0h,0C1h,0C2h,0C3h,0C4h,0C5h,0C6h,0C7h,0C8h,0C9h,0CAh,0CBh,0CCh,0CDh,0CEh,0CFh
00000A50 D0D1 D2D3 D4D5 D6D7 D8D9+  		db	0D0h,0D1h,0D2h,0D3h,0D4h,0D5h,0D6h,0D7h,0D8h,0D9h,0DAh,0DBh,0DCh,0DDh,0DEh,0DFh
00000A60 E0E1 E2E3 E4E5 E6E7 E8E9+  		db	0E0h,0E1h,0E2h,0E3h,0E4h,0E5h,0E6h,0E7h,0E8h,0E9h,0EAh,0EBh,0ECh,0EDh,0EEh,0EFh
00000A70 F0F1 F2F3 F4F5 F6F7 F8F9+  		db	0F0h,0F1h,0F2h,0F3h,0F4h,0F5h,0F6h,0F7h,0F8h,0F9h,0FAh,0FBh,0FCh,0FDh,0FEh,0FFh
00000A80 0001 0203 0405 0607 0809+  		db	000h,001h,002h,003h,004h,005h,006h,007h,008h,009h,00Ah,00Bh,00Ch,00Dh,00Eh,00Fh
00000A90 1011 1213 1415 1617 1819+  		db	010h,011h,012h,013h,014h,015h,016h,017h,018h,019h,01Ah,01Bh,01Ch,01Dh,01Eh,01Fh
00000AA0 2021 2223 2425 2627 2829+  		db	020h,021h,022h,023h,024h,025h,026h,027h,028h,029h,02Ah,02Bh,02Ch,02Dh,02Eh,02Fh
00000AB0 3031 3233 3435 3637 3839+  		db	030h,031h,032h,033h,034h,035h,036h,037h,038h,039h,03Ah,03Bh,03Ch,03Dh,03Eh,03Fh
00000AC0 4041 4243 4445 4647 4849+  		db	040h,041h,042h,043h,044h,045h,046h,047h,048h,049h,04Ah,04Bh,04Ch,04Dh,04Eh,04Fh
00000AD0 5051 5253 5455 5657 5859+  		db	050h,051h,052h,053h,054h,055h,056h,057h,058h,059h,05Ah,05Bh,05Ch,05Dh,05Eh,05Fh
00000AE0 6061 6263 6465 6667 6869+  		db	060h,061h,062h,063h,064h,065h,066h,067h,068h,069h,06Ah,06Bh,06Ch,06Dh,06Eh,06Fh
00000AF0 7071 7273 7475 7677 7879+  		db	070h,071h,072h,073h,074h,075h,076h,077h,078h,079h,07Ah,07Bh,07Ch,07Dh,07Eh,07Fh
00000B00                            
00000B00 0081 8283 8485 8687 8889+  PCM_Volume2:	db	000h,081h,082h,083h,084h,085h,086h,087h,088h,089h,08Ah,08Bh,08Ch,08Dh,08Eh,08Fh
00000B10 9091 9293 9495 9697 9899+  		db	090h,091h,092h,093h,094h,095h,096h,097h,098h,099h,09Ah,09Bh,09Ch,09Dh,09Eh,09Fh
00000B20 A0A1 A2A3 A4A5 A6A7 A8A9+  		db	0A0h,0A1h,0A2h,0A3h,0A4h,0A5h,0A6h,0A7h,0A8h,0A9h,0AAh,0ABh,0ACh,0ADh,0AEh,0AFh
00000B30 B0B1 B2B3 B4B5 B6B7 B8B9+  		db	0B0h,0B1h,0B2h,0B3h,0B4h,0B5h,0B6h,0B7h,0B8h,0B9h,0BAh,0BBh,0BCh,0BDh,0BEh,0BFh
00000B40 C0C1 C2C3 C4C5 C6C7 C8C9+  		db	0C0h,0C1h,0C2h,0C3h,0C4h,0C5h,0C6h,0C7h,0C8h,0C9h,0CAh,0CBh,0CCh,0CDh,0CEh,0CFh
00000B50 D0D1 D2D3 D4D5 D6D7 D8D9+  		db	0D0h,0D1h,0D2h,0D3h,0D4h,0D5h,0D6h,0D7h,0D8h,0D9h,0DAh,0DBh,0DCh,0DDh,0DEh,0DFh
00000B60 E0E1 E2E3 E4E5 E6E7 E8E9+  		db	0E0h,0E1h,0E2h,0E3h,0E4h,0E5h,0E6h,0E7h,0E8h,0E9h,0EAh,0EBh,0ECh,0EDh,0EEh,0EFh
00000B70 F0F1 F2F3 F4F5 F6F7 F8F9+  		db	0F0h,0F1h,0F2h,0F3h,0F4h,0F5h,0F6h,0F7h,0F8h,0F9h,0FAh,0FBh,0FCh,0FDh,0FEh,0FFh
00000B80 0001 0203 0405 0607 0809+  		db	000h,001h,002h,003h,004h,005h,006h,007h,008h,009h,00Ah,00Bh,00Ch,00Dh,00Eh,00Fh
00000B90 1011 1213 1415 1617 1819+  		db	010h,011h,012h,013h,014h,015h,016h,017h,018h,019h,01Ah,01Bh,01Ch,01Dh,01Eh,01Fh
00000BA0 2021 2223 2425 2627 2829+  		db	020h,021h,022h,023h,024h,025h,026h,027h,028h,029h,02Ah,02Bh,02Ch,02Dh,02Eh,02Fh
00000BB0 3031 3233 3435 3637 3839+  		db	030h,031h,032h,033h,034h,035h,036h,037h,038h,039h,03Ah,03Bh,03Ch,03Dh,03Eh,03Fh
00000BC0 4041 4243 4445 4647 4849+  		db	040h,041h,042h,043h,044h,045h,046h,047h,048h,049h,04Ah,04Bh,04Ch,04Dh,04Eh,04Fh
00000BD0 5051 5253 5455 5657 5859+  		db	050h,051h,052h,053h,054h,055h,056h,057h,058h,059h,05Ah,05Bh,05Ch,05Dh,05Eh,05Fh
00000BE0 6061 6263 6465 6667 6869+  		db	060h,061h,062h,063h,064h,065h,066h,067h,068h,069h,06Ah,06Bh,06Ch,06Dh,06Eh,06Fh
00000BF0 7071 7273 7475 7677 7879+  		db	070h,071h,072h,073h,074h,075h,076h,077h,078h,079h,07Ah,07Bh,07Ch,07Dh,07Eh,07Fh
00000C00                            
00000C00                            ; ===========================================================================
00000C00                            ; ---------------------------------------------------------------------------
00000C00                            ; Bank interrupt preparation list
00000C00                            ; ---------------------------------------------------------------------------
00000C00                            		align	00080h
00000C00                            ; ---------------------------------------------------------------------------
00000C00                            
00000C00 F202                       PCM1_PrepTable:	dw	PCM1_PreInst01
00000C02 F702                       		dw	PCM1_PreInst02
00000C04 FC02                       		dw	PCM1_PreInst03
00000C06 1803                       		dw	PCM1_PreInst04
00000C08 1D03                       		dw	PCM1_PreInst05
00000C0A 2203                       		dw	PCM1_PreInst06
00000C0C 2703                       		dw	PCM1_PreInst07
00000C0E 4303                       		dw	PCM1_PreInst08
00000C10 4803                       		dw	PCM1_PreInst09
00000C12 4D03                       		dw	PCM1_PreInst0A
00000C14 5203                       		dw	PCM1_PreInst0B
00000C16 5703                       		dw	PCM1_PreInst0C
00000C18 7303                       		dw	PCM1_PreInst0D
00000C1A 7803                       		dw	PCM1_PreInst0E
00000C1C 7D03                       		dw	PCM1_PreInst0F
00000C1E 8203                       		dw	PCM1_PreInst10
00000C20 9E03                       		dw	PCM1_PreInst11
00000C22 A303                       		dw	PCM1_PreInst12
00000C24 A803                       		dw	PCM1_PreInst13
00000C26 AD03                       		dw	PCM1_PreInst14
00000C28 B203                       		dw	PCM1_PreInst15
00000C2A CE03                       		dw	PCM1_PreInst16
00000C2C D303                       		dw	PCM1_PreInst17
00000C2E D803                       		dw	PCM1_PreInst18
00000C30 4E04                       PCM2_PrepTable:	dw	PCM2_PreInst01
00000C32 6A04                       		dw	PCM2_PreInst02
00000C34 6F04                       		dw	PCM2_PreInst03
00000C36 7404                       		dw	PCM2_PreInst04
00000C38 7904                       		dw	PCM2_PreInst05
00000C3A 7E04                       		dw	PCM2_PreInst06
00000C3C 9A04                       		dw	PCM2_PreInst07
00000C3E 9F04                       		dw	PCM2_PreInst08
00000C40 A404                       		dw	PCM2_PreInst09
00000C42 A904                       		dw	PCM2_PreInst0A
00000C44 C504                       		dw	PCM2_PreInst0B
00000C46 CA04                       		dw	PCM2_PreInst0C
00000C48 CF04                       		dw	PCM2_PreInst0D
00000C4A D404                       		dw	PCM2_PreInst0E
00000C4C D904                       		dw	PCM2_PreInst0F
00000C4E F504                       		dw	PCM2_PreInst10
00000C50 FA04                       		dw	PCM2_PreInst11
00000C52 FF04                       		dw	PCM2_PreInst12
00000C54 0405                       		dw	PCM2_PreInst13
00000C56 2005                       		dw	PCM2_PreInst14
00000C58 2505                       		dw	PCM2_PreInst15
00000C5A 2A05                       		dw	PCM2_PreInst16
00000C5C 2F05                       		dw	PCM2_PreInst17
00000C5E 3405                       		dw	PCM2_PreInst18
00000C60                            
00000C60                            ; ===========================================================================
00000C60                            ; ---------------------------------------------------------------------------
00000C60                            ; Specific variable data...
00000C60                            ; ---------------------------------------------------------------------------
00000C60                            
00000C60                            	; --- Current bank address for PCM channels ---
00000C60                            
00000C60 00                         PCM1_BankCur:	db	000h					; The current bank address of PCM 1
00000C61 00                         PCM2_BankCur:	db	000h					; The current bank address of PCM 2
00000C62                            
00000C62                            	; --- "Mute Sample" pointer into 68k memory ---
00000C62                            
00000C62 0000                       MuteSample:	dw	00000h					; sample window address
00000C64 00                         MuteBank:	db	000h					; sample bank address
00000C65 0000                       MuteSample_Rev:	dw	00000h					; sample window address
00000C67 00                         MuteBank_Rev:	db	000h					; sample bank address
00000C68                            
00000C68                            	; --- YM2612 Pointers ---
00000C68                            
00000C68 00                         YM_Buffer:	db	000h					; 00 = Z80 Buffer 1 | 68k Buffer 2 ... FF = Z80 Buffer 2 | 68k Buffer 1
00000C69                            
00000C69                            ; ===========================================================================
00000C69                            ; ---------------------------------------------------------------------------
00000C69                            ; Sample requested by 68k
00000C69                            ; ---------------------------------------------------------------------------
00000C69                            
00000C69                            	; --- PCM 1 start sample ---
00000C69                            
00000C69 0000                       PCM1_Sample:		dw	00000h					; PCM 1 requested sample
00000C6B 00                         PCM1_Bank:		db	000h					; PCM 1 requested bank
00000C6C 0000                       PCM1_Sample_Rev:	dw	00000h					; PCM 1 requested sample (reverse position)
00000C6E 00                         PCM1_Bank_Rev:		db	000h					; PCM 1 requested bank (reverse position)
00000C6F                            
00000C6F                            	; --- PCM 1 next sample ---
00000C6F                            
00000C6F 0000                       PCM1_SampleNext:	dw	00000h					; PCM 1 requested sample
00000C71 00                         PCM1_BankNext:		db	000h					; PCM 1 requested bank
00000C72 0000                       PCM1_SampleNext_Rev:	dw	00000h					; PCM 1 requested sample (reverse position)
00000C74 00                         PCM1_BankNext_Rev:	db	000h					; PCM 1 requested bank (reverse position)
00000C75                            
00000C75                            	; --- PCM 2 start sample ---
00000C75                            
00000C75 0000                       PCM2_Sample:		dw	00000h					; PCM 2 requested sample
00000C77 00                         PCM2_Bank:		db	000h					; PCM 2 requested bank
00000C78 0000                       PCM2_Sample_Rev:	dw	00000h					; PCM 2 requested sample (reverse position)
00000C7A 00                         PCM2_Bank_Rev:		db	000h					; PCM 2 requested bank (reverse position)
00000C7B                            
00000C7B                            	; --- PCM 2 next sample ---
00000C7B                            
00000C7B 0000                       PCM2_SampleNext:	dw	00000h					; PCM 2 requested sample
00000C7D 00                         PCM2_BankNext:		db	000h					; PCM 2 requested bank
00000C7E 0000                       PCM2_SampleNext_Rev:	dw	00000h					; PCM 2 requested sample (reverse position)
00000C80 00                         PCM2_BankNext_Rev:	db	000h					; PCM 2 requested bank (reverse position)
00000C81                            
00000C81                            ; ===========================================================================
00000C81                            ; ---------------------------------------------------------------------------
00000C81                            ; PCM buffer (1000h = start of cue, Make sure both buffers end in a multiple of 100)
00000C81                            ; ---------------------------------------------------------------------------
00000C81                            
00000C81 0000 0000 0000 0000 0000+  		align	(01000h-00200h)-00150h
00000CB0                            PCM_Buffer1:	rept	00150h
00000CB0                            		db	080h
00000CB0 8080 8080 8080 8080 8080+  		endr
00000E00                            
00000E00 0000 0000 0000 0000 0000+  		align	01000h-00150h
00000EB0                            PCM_Buffer2:	rept	00150h
00000EB0                            		db	080h
00000EB0 8080 8080 8080 8080 8080+  		endr
00001000                            
00001000                            ; ===========================================================================
00001000                            ; ---------------------------------------------------------------------------
00001000                            ; The YM2612 operator writing lists (68k writes here, z80 must flush off)
00001000                            ; ---------------------------------------------------------------------------
00001000                            
00001000                            YM_Buffer1:	rept	00400h
00001000                            		db	0FFh
00001000 FFFF FFFF FFFF FFFF FFFF+  		endr
00001400                            
00001400                            YM_Buffer2:	rept	00400h
00001400                            		db	0FFh
00001400 FFFF FFFF FFFF FFFF FFFF+  		endr
00001800                            
00001800                            ; ===========================================================================
00001800                            ; ---------------------------------------------------------------------------
00001800                            ; Overflow calculation multiplication tables
00001800                            ; ---------------------------------------------------------------------------
00001800                            
00001800                            PCM_OverflwCalc:
00001800                            
00001800                            		; --- Lower byte ---
00001800                            
00001800 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
00001810 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
00001820 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
00001830 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
00001840 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
00001850 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
00001860 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
00001870 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
00001880 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
00001890 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
000018A0 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
000018B0 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
000018C0 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
000018D0 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
000018E0 0018 3048 6078 90A8 C0D8+  		db	000h,018h,030h,048h,060h,078h,090h,0A8h,0C0h,0D8h,0F0h,008h,020h,038h,050h,068h
000018F0 8098 B0C8 E0F8 1028 4058+  		db	080h,098h,0B0h,0C8h,0E0h,0F8h,010h,028h,040h,058h,070h,088h,0A0h,0B8h,0D0h,0E8h
00001900                            
00001900                            		; --- Upper byte ---
00001900                            
00001900 0000 0000 0000 0000 0000+  		db	000h,000h,000h,000h,000h,000h,000h,000h,000h,000h,000h,001h,001h,001h,001h,001h
00001910 0101 0101 0101 0202 0202+  		db	001h,001h,001h,001h,001h,001h,002h,002h,002h,002h,002h,002h,002h,002h,002h,002h
00001920 0303 0303 0303 0303 0303+  		db	003h,003h,003h,003h,003h,003h,003h,003h,003h,003h,003h,004h,004h,004h,004h,004h
00001930 0404 0404 0404 0505 0505+  		db	004h,004h,004h,004h,004h,004h,005h,005h,005h,005h,005h,005h,005h,005h,005h,005h
00001940 0606 0606 0606 0606 0606+  		db	006h,006h,006h,006h,006h,006h,006h,006h,006h,006h,006h,007h,007h,007h,007h,007h
00001950 0707 0707 0707 0808 0808+  		db	007h,007h,007h,007h,007h,007h,008h,008h,008h,008h,008h,008h,008h,008h,008h,008h
00001960 0909 0909 0909 0909 0909+  		db	009h,009h,009h,009h,009h,009h,009h,009h,009h,009h,009h,00Ah,00Ah,00Ah,00Ah,00Ah
00001970 0A0A 0A0A 0A0A 0B0B 0B0B+  		db	00Ah,00Ah,00Ah,00Ah,00Ah,00Ah,00Bh,00Bh,00Bh,00Bh,00Bh,00Bh,00Bh,00Bh,00Bh,00Bh
00001980 0C0C 0C0C 0C0C 0C0C 0C0C+  		db	00Ch,00Ch,00Ch,00Ch,00Ch,00Ch,00Ch,00Ch,00Ch,00Ch,00Ch,00Dh,00Dh,00Dh,00Dh,00Dh
00001990 0D0D 0D0D 0D0D 0E0E 0E0E+  		db	00Dh,00Dh,00Dh,00Dh,00Dh,00Dh,00Eh,00Eh,00Eh,00Eh,00Eh,00Eh,00Eh,00Eh,00Eh,00Eh
000019A0 0F0F 0F0F 0F0F 0F0F 0F0F+  		db	00Fh,00Fh,00Fh,00Fh,00Fh,00Fh,00Fh,00Fh,00Fh,00Fh,00Fh,010h,010h,010h,010h,010h
000019B0 1010 1010 1010 1111 1111+  		db	010h,010h,010h,010h,010h,010h,011h,011h,011h,011h,011h,011h,011h,011h,011h,011h
000019C0 1212 1212 1212 1212 1212+  		db	012h,012h,012h,012h,012h,012h,012h,012h,012h,012h,012h,013h,013h,013h,013h,013h
000019D0 1313 1313 1313 1414 1414+  		db	013h,013h,013h,013h,013h,013h,014h,014h,014h,014h,014h,014h,014h,014h,014h,014h
000019E0 1515 1515 1515 1515 1515+  		db	015h,015h,015h,015h,015h,015h,015h,015h,015h,015h,015h,016h,016h,016h,016h,016h
000019F0 1616 1616 1616 1717 1717+  		db	016h,016h,016h,016h,016h,016h,017h,017h,017h,017h,017h,017h,017h,017h,017h,017h
00001A00                            
00001A00                            ; ===========================================================================
00001A00                            ; ---------------------------------------------------------------------------
00001A00                            ; Subroutine to change a channel's volume table
00001A00                            ; ---------------------------------------------------------------------------
00001A00                            
00001A00                            PCM_VolumeControl:
00001A06                            
00001A1B                            
00001A1B                            PCM1_NoVolume:
00001A1B                            
00001A30                            
00001A30                            PCM2_NoVolume:
00001A31 37                         		scf					; 04	; set carry flag
00001A35                            
00001A35                            ; ---------------------------------------------------------------------------
00001A35                            ; The volume changing itself
00001A35                            ; ---------------------------------------------------------------------------
00001A35                            
00001A35                            SwitchVolume:
00001A35                            
00001A35                            ; ---------------------------------------------------------------------------
00001A35                            ; Software version of volume table (This is slower to process but will save
00001A35                            ; 8000 bytes of ROM space).  It'll also cause chopping in the sample playback
00001A35                            ; ---------------------------------------------------------------------------
00001A35                            
00001A35                            ;		ld	b,a				; 04	; store volume
00001A35                            ;		zneg					; 08	; convert volume to 00 - 80 (mute - loud)
00001A35                            ;		zadd	a,080h				; 07	; ''
00001A35                            ;		zadd	a,a				; 04	; shift MSB into carry
00001A35                            ;		ld	(SV_Fraction+001h),a		; 13	; store fraction
00001A35                            ;		sbc	a,a				; 04	; get only the carry (for quotient)
00001A35                            ;		zneg					; 08	; ''
00001A35                            ;		ld	c,a				; 04	; store quotient in c
00001A35                            ;		ld	hl,00000h			; 10	; reset current fraction/dividend
00001A35                            ;		ld	a,b				; 04	; reload volume
00001A35                            ;		zadd	a,080h				; 07	; rotate starting volume
00001A35                            ;SV_Fraction:	ld	b,000h				; 07	; set fraction/dividend
00001A35                            ;
00001A35                            ;SV_SetNormal:
00001A35                            ;		ld	(de),a				; 07	; save to table
00001A35                            ;		zadd	hl,bc 				; 11	; add fraction/dividend
00001A35                            ;		adc	a,c				; 04	; add carry to quotient
00001A35                            ;		inc	e				; 04	; advance table
00001A35                            ;		jp	nz,SV_SetNormal			; 10	; repeat until the table is finished (should reach 100)
00001A35                            ;
00001A35                            ;SV_Return:	jp	00000h				; 10	; return
00001A35                            
00001A35                            ; ---------------------------------------------------------------------------
00001A35                            
00001A46                            
00001A46                            	; --- Non-flush version ---
00001A46                            
00001A55                            
00001A55                            SV_NoMute:
00001A5A                            
00001A5A                            SV_LoadVolume:
00001A5A                            		rept	008h
00001A5A                            		ldi					; 16	; copy volume bytes over
00001A5A EDA0 EDA0 EDA0 EDA0 EDA0+  		endr
00001A6E                            
00001A6E                            	; --- Flush version ---
00001A6E                            
00001A6E                            SV_Flush:
00001A79 D9                         			exx					; 04	; switch registers
00001A8D D9                         			exx					; 04	; switch registers
00001A91                            
00001A91                            SVF_NoMute:
00001A96                            
00001A96                            SVF_LoadVolume:
00001A96 D9                         			exx					; 04	; switch registers
00001AAA D9                         			exx					; 04	; switch registers
00001AAB                            
00001AAB                            SVF_StartVolume:
00001AAB                            		rept	008h
00001AAB                            		ldi					; 16	; copy volume bytes over
00001AAB EDA0 EDA0 EDA0 EDA0 EDA0+  		endr
00001ABB D9                         			exx					; 04	; switch registers
00001ACF D9                         			exx					; 04	; switch registers
00001AD0                            		rept	008h
00001AD0                            		ldi					; 16	; copy volume bytes over
00001AD0 EDA0 EDA0 EDA0 EDA0 EDA0+  		endr
00001AE2 D9                         			exx					; 04	; switch registers
00001AF1 D9                         			exx					; 04	; switch registers
00001AFC                            
00001AFC                            ; ===========================================================================
00001AFC                            ; ---------------------------------------------------------------------------
00001AFC                            ; Switching a channel's bank address
00001AFC                            ; ---------------------------------------------------------------------------
00001AFC                            ;		ld	hl,PCM1_BankCur			; 10	; address of bank ID
00001AFC                            ;		ld	de,PCM1_Switch			; 10	; load PCM switch list to edit
00001AFC                            ;		ld	a,(PCM1_PitchQuo+001h)		; 13	; load pitch quotient
00001AFC                            ;		call	SwitchBank			; 17	; change the bank address
00001AFC                            ; ---------------------------------------------------------------------------
00001AFC                            ;		ld	a,(PCM1_BankCur)		; 13	; load bank ID
00001AFC                            ;		ld	de,PCM1_Switch			; 10	; load PCM switch list to edit
00001AFC                            ;		call	SetBank				; 17	; set bank address
00001AFC                            ; ---------------------------------------------------------------------------
00001AFC                            
00001AFC                            SwitchBank:
00001B03                            
00001B03                            SetBank:
00001B06                            	rept	008h
00001B06                            		xor	a				; 04	; clear a
00001B06                            		rrc	l				; 08	; shift bit into carry
00001B06                            		adc	a,h				; 04	; set instruction bits (with carry register bit)
00001B06                            		ld	(de),a				; 07	; write instruction
00001B06                            		inc	e	; WARNING (see comment)	; 04	; advance to next instruction (ONLY WORKS IF THE INSTRUCTIONS DON'T CROSS A 100 BYTE BOUNDARY, please align)
00001B37                            
00001B37                            ; ===========================================================================
00001B37                            ; ---------------------------------------------------------------------------
00001B37                            ; Warning stuff
00001B37                            ; ---------------------------------------------------------------------------
00001B37                            
00001B37                            
00001B37                            
00001B37                            ; ===========================================================================
00001B37                            ; ===========================================================================
00001B37                            DualPCM_sz:
000C54BF =00000000                M z80prg	=	0
000C54BF                          M 	mexit
000C54BF                            
000C54BF                            ; =========================================================================================================================================================
000C54BF                            ; ---------------------------------------------------------------------------------------------------------------------------------------------------------
000C54BF                            ; Error handler
000C54BF                            ; -------------------------------------------------------------------------------------------------------------------------------------------------------
000C54BF                            		include	"Config/Error/error.asm"
000C54BF                            ; -------------------------------------------------------------------------
000C54BF                            ; Vladikcomper's debugger
000C54BF                            ; -------------------------------------------------------------------------
000C54BF                            
000C54BF                            exBus	EQU	ICD_BLK
000C54BF                            exAddr	EQU	ICD_BLK
000C54BF                            exIll	EQU	ICD_BLK
000C54BF                            exDiv	EQU	ICD_BLK
000C54BF                            exChk	EQU	ICD_BLK
000C54BF                            Trapv	EQU	ICD_BLK
000C54BF                            exPriv	EQU	ICD_BLK
000C54BF                            exTrace	EQU	ICD_BLK
000C54BF                            exLineA	EQU	ICD_BLK
000C54BF                            exLineF	EQU	ICD_BLK
000C54BF                            exMisc	EQU	ICD_BLK
000C54BF                            
000C54BF                            ; -------------------------------------------------------------------------
000C54BF                            ; =========================================================================================================================================================
